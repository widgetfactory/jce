/* eslint-disable */
/* 
 * This file includes original and modified code from various versions of Tinymce. 
 * 
 * Source: https://github.com/widgetfactory/tinymce-muon 
 * Copyright (c) Tiny Technologies, Inc. All rights reserved. 
 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved. 
 * Copyright, Moxiecode Systems AB. All rights reserved. 
 * Copyright (c) 2009 - 2023 Ryan Demmer. All rights reserved. 
 * For a detailed history of modifications, refer to the Git commit history. 
 * Licensed under the GNU/LGPL 2.1 or later: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html 
 */
(function () {
  'use strict';

  /**
   * tinymce.js
   *
   * Copyright, Moxiecode Systems AB
   * Released under LGPL License.
   *
   * License: http://www.tinymce.com/license - Inactive
   * Licence: GNU/LGPL 2.1 or later - http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
   * Contributing: http://www.tinymce.com/contributing - Inactive
   */

  /* global CollectGarbage */

  (function (win) {
    var whiteSpaceRe = /^\s*|\s*$/g,
      undef;

    var slice = [].slice;

    /**
     * Core namespace with core functionality for the TinyMCE API all sub classes will be added to this namespace/object.
     *
     * @static
     * @class tinymce
     * @example
     * // Using each method
     * tinymce.each([1, 2, 3], function(v, i) {
     *   console.log(i + '=' + v);
     * });
     *
     * // Checking for a specific browser
     * if (tinymce.isIE)
     *   console.log("IE");
     */
    var tinymce = {
      /**
       * Initializes the TinyMCE global namespace this will setup browser detection and figure out where TinyMCE is running from.
       */
      _init: function () {
        var self = this,
          doc = document,
          i, nl, n, base, p, v;

        // Get suffix and base
        self.suffix = '';

        // If base element found, add that infront of baseURL
        nl = doc.getElementsByTagName('base');

        for (i = 0; i < nl.length; i++) {
          v = nl[i].href;
          if (v) {
            // Host only value like http://site.com or http://site.com:8008
            if (/^https?:\/\/[^\/]+$/.test(v)) {
              v += '/';
            }

            base = v ? v.match(/.*\//)[0] : ''; // Get only directory
          }
        }

        function getBase(n) {
          if (n.src && /tinymce(|_gzip|_jquery|_prototype|_full)(_dev|_src)?.js/.test(n.src)) {
            if (/_(src|dev)\.js/g.test(n.src)) {
              self.suffix = '_src';
            }

            if ((p = n.src.indexOf('?')) != -1) {
              self.query = n.src.substring(p + 1);
            }

            self.baseURL = n.src.substring(0, n.src.lastIndexOf('/'));

            // If path to script is relative and a base href was found add that one infront
            // the src property will always be an absolute one on non IE browsers and IE 8
            // so this logic will basically only be executed on older IE versions
            if (base && self.baseURL.indexOf('://') == -1 && self.baseURL.indexOf('/') !== 0) {
              self.baseURL = base + self.baseURL;
            }

            return self.baseURL;
          }

          return null;
        }

        // Check document
        nl = doc.getElementsByTagName('script');

        for (i = 0; i < nl.length; i++) {
          if (getBase(nl[i])) {
            return;
          }
        }

        // Check head
        n = doc.getElementsByTagName('head')[0];

        if (n) {
          nl = n.getElementsByTagName('script');
          for (i = 0; i < nl.length; i++) {
            if (getBase(nl[i])) {
              return;
            }
          }
        }

        return;
      },

      /**
       * Checks if a object is of a specific type for example an array.
       *
       * @method is
       * @param {Object} o Object to check type of.
       * @param {string} t Optional type to check for.
       * @return {Boolean} true/false if the object is of the specified type.
       */
      is: function (o, t) {
        if (!t) {
          return o !== undef;
        }

        if (t == 'array' && tinymce.isArray(o)) {
          return true;
        }
        return typeof (o) == t;
      },

      /**
       * Returns true/false if the object is an array or not.
       *
       * @method isArray
       * @param {Object} obj Object to check.
       * @return {boolean} true/false state if the object is an array or not.
       */
      isArray: Array.isArray || function (obj) {
        return Object.prototype.toString.call(obj) === "[object Array]";
      },

      /**
       * Makes a name/object map out of an array with names.
       *
       * @method makeMap
       * @param {Array/String} items Items to make map out of.
       * @param {String} delim Optional delimiter to split string by.
       * @param {Object} map Optional map to add items to.
       * @return {Object} Name/value map of items.
       */
      makeMap: function (items, delim, map) {
        var i;

        items = items || [];
        delim = delim || ',';

        if (typeof (items) == "string") {
          items = items.split(delim);
        }

        map = map || {};

        i = items.length;

        while (i--) {
          map[items[i]] = {};
        }

        return map;
      },

      /**
       * Performs an iteration of all items in a collection such as an object or array. This method will execure the
       * callback function for each item in the collection, if the callback returns false the iteration will terminate.
       * The callback has the following format: cb(value, key_or_index).
       *
       * @method each
       * @param {Object} o Collection to iterate.
       * @param {function} cb Callback function to execute for each item.
       * @param {Object} s Optional scope to execute the callback in.
       * @example
       * // Iterate an array
       * tinymce.each([1,2,3], function(v, i) {
       *     console.debug("Value: " + v + ", Index: " + i);
       * });
       *
       * // Iterate an object
       * tinymce.each({a : 1, b : 2, c: 3], function(v, k) {
       *     console.debug("Value: " + v + ", Key: " + k);
       * });
       */
      each: function (o, cb, s) {
        var n, l;

        if (!o) {
          return 0;
        }

        s = s || o;

        if (o.length !== undef) {
          // Indexed arrays, needed for Safari
          for (n = 0, l = o.length; n < l; n++) {
            if (cb.call(s, o[n], n, o) === false) {
              return 0;
            }
          }
        } else {
          // Hashtables
          for (n in o) {
            // eslint-disable-next-line no-prototype-builtins
            if (o.hasOwnProperty(n)) {
              if (cb.call(s, o[n], n, o) === false) {
                return 0;
              }
            }
          }
        }

        return 1;
      },

      // #ifndef jquery

      /**
       * Creates a new array by the return value of each iteration function call. This enables you to convert
       * one array list into another.
       *
       * @method map
       * @param {Array} a Array of items to iterate.
       * @param {function} f Function to call for each item. It's return value will be the new value.
       * @return {Array} Array with new values based on function return values.
       */
      map: function (a, f) {
        var o = [];

        tinymce.each(a, function (v) {
          o.push(f(v));
        });

        return o;
      },

      /**
       * Filters out items from the input array by calling the specified function for each item.
       * If the function returns false the item will be excluded if it returns true it will be included.
       *
       * @method grep
       * @param {Array} a Array of items to loop though.
       * @param {function} f Function to call for each item. Include/exclude depends on it's return value.
       * @return {Array} New array with values imported and filtered based in input.
       * @example
       * // Filter out some items, this will return an array with 4 and 5
       * var items = tinymce.grep([1,2,3,4,5], function(v) {return v > 3;});
       */
      grep: function (a, f) {
        var o = [];

        tinymce.each(a, function (v) {
          if (!f || f(v)) {
            o.push(v);
          }
        });

        return o;
      },

      /**
       * Returns the index of a value in an array, this method will return -1 if the item wasn't found.
       *
       * @method inArray
       * @param {Array} a Array/Object to search for value in.
       * @param {Object} v Value to check for inside the array.
       * @return {Number/String} Index of item inside the array inside an object. Or -1 if it wasn't found.
       * @example
       * // Get index of value in array this will alert 1 since 2 is at that index
       * alert(tinymce.inArray([1,2,3], 2));
       */
      inArray: function (a, v) {
        var i, l;

        if (a) {
          for (i = 0, l = a.length; i < l; i++) {
            if (a[i] === v) {
              return i;
            }
          }
        }

        return -1;
      },

      toArray: function (obj) {
        var array = obj,
          i, l;

        if (!tinymce.isArray(obj)) {
          array = [];
          for (i = 0, l = obj.length; i < l; i++) {
            array[i] = obj[i];
          }
        }

        return array;
      },

      /**
       * Extends an object with the specified other object(s).
       *
       * @method extend
       * @param {Object} obj Object to extend with new items.
       * @param {Object} ext..n Object(s) to extend the specified object with.
       * @return {Object} o New extended object, same reference as the input object.
       * @example
       * // Extends obj1 with two new fields
       * var obj = tinymce.extend(obj1, {
       *     somefield1 : 'a',
       *     somefield2 : 'a'
       * });
       *
       * // Extends obj with obj2 and obj3
       * tinymce.extend(obj, obj2, obj3);
       */
      extend: function (obj, ext) {
        var i, l, name, args = arguments,
          value;

        for (i = 1, l = args.length; i < l; i++) {
          ext = args[i];
          for (name in ext) {
            // eslint-disable-next-line no-prototype-builtins
            if (ext.hasOwnProperty(name)) {
              value = ext[name];

              if (value !== undef) {
                obj[name] = value;
              }
            }
          }
        }

        return obj;
      },

      // #endif

      /**
       * Removes whitespace from the beginning and end of a string.
       *
       * @method trim
       * @param {String} s String to remove whitespace from.
       * @return {String} New string with removed whitespace.
       */
      trim: function (s) {
        return (s ? '' + s : '').replace(whiteSpaceRe, '');
      },

      /**
       * Creates a class, subclass or static singleton.
       * More details on this method can be found in the Wiki.
       *
       * @method create
       * @param {String} s Class name, inheritage and prefix.
       * @param {Object} p Collection of methods to add to the class.
       * @param {Object} root Optional root object defaults to the global window object.
       * @example
       * // Creates a basic class
       * tinymce.create('tinymce.somepackage.SomeClass', {
       *     SomeClass : function() {
       *         // Class constructor
       *     },
       *
       *     method : function() {
       *         // Some method
       *     }
       * });
       *
       * // Creates a basic subclass class
       * tinymce.create('tinymce.somepackage.SomeSubClass:tinymce.somepackage.SomeClass', {
       *     SomeSubClass: function() {
       *         // Class constructor
       *         this._super(); // Call parent constructor
       *     },
       *
       *     method : function() {
       *         // Some method
       *         this._super(); // Call parent method
       *     },
       *
       *     'static' : {
       *         staticMethod : function() {
       *             // Static method
       *         }
       *     }
       * });
       *
       * // Creates a singleton/static class
       * tinymce.create('static tinymce.somepackage.SomeSingletonClass', {
       *     method : function() {
       *         // Some method
       *     }
       * });
       */
      create: function (s, p, root) {
        var self = this,
          sp, ns, cn, scn, c, de = 0;

        // Parse : <prefix> <class>:<super class>
        s = /^((static) )?([\w.]+)(:([\w.]+))?/.exec(s);
        cn = s[3].match(/(^|\.)(\w+)$/i)[2]; // Class name

        // Create namespace for new class
        ns = self.createNS(s[3].replace(/\.\w+$/, ''), root);

        // Class already exists
        if (ns[cn]) {
          return;
        }

        // Make pure static class
        if (s[2] == 'static') {
          ns[cn] = p;

          if (this.onCreate) {
            this.onCreate(s[2], s[3], ns[cn]);
          }

          return;
        }

        // Create default constructor
        if (!p[cn]) {
          p[cn] = function () { };
          de = 1;
        }

        // Add constructor and methods
        ns[cn] = p[cn];
        self.extend(ns[cn].prototype, p);

        // Extend
        if (s[5]) {
          sp = self.resolve(s[5]).prototype;
          scn = s[5].match(/\.(\w+)$/i)[1]; // Class name

          // Extend constructor
          c = ns[cn];
          if (de) {
            // Add passthrough constructor
            ns[cn] = function () {
              return sp[scn].apply(this, arguments);
            };
          } else {
            // Add inherit constructor
            ns[cn] = function () {
              this._super = sp[scn];
              return c.apply(this, arguments);
            };
          }
          ns[cn].prototype[cn] = ns[cn];

          // Add super methods
          self.each(sp, function (f, n) {
            ns[cn].prototype[n] = sp[n];
          });

          // Add overridden methods
          self.each(p, function (f, n) {
            // Extend methods if needed
            if (sp[n]) {
              ns[cn].prototype[n] = function () {
                this._super = sp[n];
                return f.apply(this, arguments);
              };
            } else {
              if (n != cn) {
                ns[cn].prototype[n] = f;
              }
            }
          });
        }

        // Add static methods
        /*jshint sub:true*/
        /*eslint dot-notation:0*/
        self.each(p['static'], function (f, n) {
          ns[cn][n] = f;
        });
      },

      /**
       * Executed the specified function for each item in a object tree.
       *
       * @method walk
       * @param {Object} o Object tree to walk though.
       * @param {function} f Function to call for each item.
       * @param {String} n Optional name of collection inside the objects to walk for example childNodes.
       * @param {String} s Optional scope to execute the function in.
       */
      walk: function (o, f, n, s) {
        s = s || this;

        if (o) {
          if (n) {
            o = o[n];
          }

          tinymce.each(o, function (o, i) {
            if (f.call(s, o, i, n) === false) {
              return false;
            }

            tinymce.walk(o, f, n, s);
          });
        }
      },

      /**
       * Creates a namespace on a specific object.
       *
       * @method createNS
       * @param {String} n Namespace to create for example a.b.c.doc.
       * @param {Object} o Optional object to add namespace to, defaults to window.
       * @return {Object} New namespace object the last item in path.
       * @example
       * // Create some namespace
       * tinymce.createNS('tinymce.somepackage.subpackage');
       *
       * // Add a singleton
       * var tinymce.somepackage.subpackage.SomeSingleton = {
       *     method : function() {
       *         // Some method
       *     }
       * };
       */
      createNS: function (n, o) {
        var i, v;

        o = o || win;

        n = n.split('.');

        for (i = 0; i < n.length; i++) {
          v = n[i];

          if (!o[v]) {
            o[v] = {};
          }

          o = o[v];
        }

        return o;
      },

      /**
       * Resolves a string and returns the object from a specific structure.
       *
       * @method resolve
       * @param {String} n Path to resolve for example a.b.c.doc.
       * @param {Object} o Optional object to search though, defaults to window.
       * @return {Object} Last object in path or null if it couldn't be resolved.
       * @example
       * // Resolve a path into an object reference
       * var obj = tinymce.resolve('a.b.c.d');
       */
      resolve: function (n, o) {
        var i, l;

        o = o || win;

        n = n.split('.');
        for (i = 0, l = n.length; i < l; i++) {
          o = o[n[i]];

          if (!o) {
            break;
          }
        }

        return o;
      },

      /**
       * Adds an unload handler to the document. This handler will be executed when the document gets unloaded.
       * This method is useful for dealing with browser memory leaks where it might be vital to remove DOM references etc.
       *
       * @method addUnload
       * @param {function} f Function to execute before the document gets unloaded.
       * @param {Object} s Optional scope to execute the function in.
       * @return {function} Returns the specified unload handler function.
       * @example
       * // Fixes a leak with a DOM element that was palces in the someObject
       * tinymce.addUnload(function() {
       *     // Null DOM element to reduce IE memory leak
       *     someObject.someElement = null;
       * });
       */
      addUnload: function (f, s) {
        var unload;

        unload = function () {
          var li = self.unloads,
            o, n;

          if (li) {
            // Call unload handlers
            for (n in li) {
              o = li[n];

              if (o && o.func) {
                o.func.call(o.scope, 1);
              } // Send in one arg to distinct unload and user destroy
            }

            // Detach unload function
            if (win.detachEvent) {
              win.detachEvent('onbeforeunload', fakeUnload);
              win.detachEvent('onunload', unload);
            } else if (win.removeEventListener) {
              win.removeEventListener('unload', unload, false);
            }

            // Destroy references
            self.unloads = o = li = unload = 0;

            // Run garbarge collector on IE
            if (win.CollectGarbage) {
              CollectGarbage();
            }
          }
        };

        function fakeUnload() {
          var doc = document;

          function stop() {
            // Prevent memory leak
            doc.detachEvent('onstop', stop);

            // Call unload handler
            if (unload) {
              unload();
            }

            doc = 0;
          }

          // Is there things still loading, then do some magic
          if (doc.readyState == 'interactive') {
            // Fire unload when the currently loading page is stopped
            if (doc) {
              doc.attachEvent('onstop', stop);
            }

            // Remove onstop listener after a while to prevent the unload function
            // to execute if the user presses cancel in an onbeforeunload
            // confirm dialog and then presses the browser stop button
            win.setTimeout(function () {
              if (doc) {
                doc.detachEvent('onstop', stop);
              }
            }, 0);
          }
        }

        f = {
          func: f,
          scope: s || this
        };

        if (!self.unloads) {
          // Attach unload handler
          if (win.attachEvent) {
            win.attachEvent('onunload', unload);
            win.attachEvent('onbeforeunload', fakeUnload);
          } else if (win.addEventListener) {
            win.addEventListener('unload', unload, false);
          }

          // Setup initial unload handler array
          self.unloads = [f];
        } else {
          self.unloads.push(f);
        }

        return f;
      },

      /**
       * Removes the specified function form the unload handler list.
       *
       * @method removeUnload
       * @param {function} f Function to remove from unload handler list.
       * @return {function} Removed function name or null if it wasn't found.
       */
      removeUnload: function (f) {
        var u = this.unloads,
          r = null;

        tinymce.each(u, function (o, i) {
          if (o && o.func == f) {
            u.splice(i, 1);
            r = f;
            return false;
          }
        });

        return r;
      },

      /**
       * Splits a string but removes the whitespace before and after each value.
       *
       * @method explode
       * @param {string} s String to split.
       * @param {string} d Delimiter to split by.
       * @example
       * // Split a string into an array with a,b,c
       * var arr = tinymce.explode('a, b,   c');
       */
      explode: function (s, d) {
        if (!s || tinymce.is(s, 'array')) {
          return s;
        }

        return tinymce.map(s.split(d || ','), tinymce.trim);
      },

      curry: function (fn) {
        var args = slice.call(arguments);

        if (args.length - 1 >= fn.length) {
          return fn.apply(this, args.slice(1));
        }

        return function () {
          var tempArgs = args.concat([].slice.call(arguments));
          return tinymce.curry.apply(this, tempArgs);
        };
      },

      _addVer: function (u) {
        var v;

        if (!this.query) {
          return u;
        }

        v = (u.indexOf('?') == -1 ? '?' : '&') + this.query;

        if (u.indexOf('#') == -1) {
          return u + v;
        }

        return u.replace('#', v + '#');
      }

      /**#@-*/
    };

    // Initialize the API
    tinymce._init();

    // Expose tinymce namespace to the global namespace (window)
    win.tinymce = win.tinyMCE = tinymce;

    // Describe the different namespaces

    /**
     * Root level namespace this contains classes directly releated to the TinyMCE editor.
     *
     * @namespace tinymce
     */

    /**
     * Contains classes for handling the browsers DOM.
     *
     * @namespace tinymce.dom
     */

    tinymce.dom = {};

    /**
     * Contains various tools for rect/position calculation.
     *
     * @namespace tinymce.geom
     */

    tinymce.geom = {};

    /**
     * Contains various tools for characters and zero width space.
     *
     * @namespace tinymce.text
     */

    tinymce.text = {};

    /**
     * Contains various tools for carets.
     *
     * @namespace tinymce.caret
     */

    tinymce.caret = {};

    /**
     * Contains various tools for the clipboard.
     *
     * @namespace tinymce.clipboard
     */

    tinymce.clipboard = {};

    /**
     * Contains html parser and serializer logic.
     *
     * @namespace tinymce.html
     */

    tinymce.html = {};

    /**
     * Contains the different UI types such as buttons, listboxes etc.
     *
     * @namespace tinymce.ui
     */

    tinymce.ui = {};

    /**
     * Contains various utility classes such as json parser, cookies etc.
     *
     * @namespace tinymce.util
     */

    tinymce.util = {};

    /**
     * Contains various file classes.
     *
     * @namespace tinymce.file
     */

    tinymce.file = {};

    /**
     * Contains plugin classes.
     *
     * @namespace tinymce.plugins
     */

    tinymce.plugins = {};
  })(window);

  /**
   * Env.js
   *
   * Released under LGPL License.
   * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
   *
   * License: http://www.tinymce.com/license
   * Contributing: http://www.tinymce.com/contributing
   */

  /**
   * This class contains various environment constants like browser versions etc.
   * Normally you don't want to sniff specific browser versions but sometimes you have
   * to when it's impossible to feature detect. So use this with care.
   *
   * @class tinymce.Env
   * @static
   */

  var nav = navigator,
    userAgent = nav.userAgent;
  var opera, webkit, ie, gecko, mac, iDevice, android, fileApi, phone, tablet, windowsPhone, isTouchEnabled;

  function matchMediaQuery(query) {
    return "matchMedia" in window ? matchMedia(query).matches : false;
  }

  isTouchEnabled = navigator.maxTouchPoints > 1;

  function isIpad() {
    // Check for iOS 13+ iPad
    var isIOS = /iPad/.test(userAgent);
    // Additional checks for distinguishing iPads from Macs
    var hasMacLikeUserAgent = /Macintosh/.test(userAgent);
    // Combining checks to improve accuracy
    return isIOS || (isTouchEnabled && hasMacLikeUserAgent);
  }

  opera = window.opera && window.opera.buildNumber;
  android = /Android/.test(userAgent);
  webkit = /WebKit/.test(userAgent);
  ie = !webkit && !opera && (/MSIE/gi).test(userAgent) && (/Explorer/gi).test(nav.appName);
  ie = ie && /MSIE (\w+)\./.exec(userAgent)[1];
  ie = ie && !webkit;
  gecko = !webkit && !ie && /Gecko/.test(userAgent);
  mac = userAgent.indexOf('Mac') != -1;
  iDevice = /(iPad|iPhone)/.test(userAgent) || isIpad();
  fileApi = "FormData" in window && "FileReader" in window && "URL" in window && !!URL.createObjectURL;
  phone = matchMediaQuery("only screen and (max-device-width: 480px)") && (android || iDevice);
  tablet = matchMediaQuery("only screen and (min-width: 800px)") && (android || iDevice);
  windowsPhone = userAgent.indexOf('Windows Phone') != -1;

  // Is a iPad/iPhone and not on iOS5 sniff the WebKit version since older iOS WebKit versions
  // says it has contentEditable support but there is no visible caret.
  var contentEditable = !iDevice || fileApi || userAgent.match(/AppleWebKit\/(\d*)/)[1] >= 534;

  tinymce.util.Env = {
    /**
     * Constant that is true if the browser is Opera.
     *
     * @property opera
     * @type Boolean
     * @final
     */
    opera: opera,

    /**
     * Constant that is true if the browser is WebKit (Safari/Chrome).
     *
     * @property webKit
     * @type Boolean
     * @final
     */
    webkit: webkit,

    /**
     * Constant that is more than zero if the browser is IE.
     *
     * @property ie
     * @type Boolean
     * @final
     */
    ie: ie,

    /**
     * Constant that is true if the browser is Gecko.
     *
     * @property gecko
     * @type Boolean
     * @final
     */
    gecko: gecko,

    /**
     * Constant that is true if the os is Mac OS.
     *
     * @property mac
     * @type Boolean
     * @final
     */
    mac: mac,

    /**
     * Constant that is true if the os is iOS.
     *
     * @property iOS
     * @type Boolean
     * @final
     */
    ios: iDevice,

    /**
     * Constant that is true if the os is android.
     *
     * @property android
     * @type Boolean
     * @final
     */
    android: android,

    /**
     * Constant that is true if the browser supports editing.
     *
     * @property contentEditable
     * @type Boolean
     * @final
     */
    contentEditable: contentEditable,

    /**
     * Transparent image data url.
     *
     * @property transparentSrc
     * @type Boolean
     * @final
     */
    transparentSrc: "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7",

    /**
     * Returns true/false if the browser can or can't place the caret after a inline block like an image.
     *
     * @property noCaretAfter
     * @type Boolean
     * @final
     */
    caretAfter: true,

    /**
     * Constant that is true if the browser supports native DOM Ranges. IE 9+.
     *
     * @property range
     * @type Boolean
     */
    range: window.getSelection && "Range" in window,

    /**
     * Constant that is true if the browser has a modern file api.
     *
     * @property fileApi
     * @type Boolean
     */
    fileApi: fileApi,

    /**
     * Constant that is true if the browser supports contentEditable=false regions.
     *
     * @property ceFalse
     * @type Boolean
     */
    ceFalse: true,

    /**
     * Constant if CSP mode is possible or not. Meaning we can't use script urls for the iframe.
     */
    canHaveCSP: true,

    desktop: !phone && !tablet,
    windowsPhone: windowsPhone,

    /**
     * Constant that is true if the browser has touch support.
     */
    touchEnabled: isTouchEnabled
  };

  /**
    * Constant that is true if the browser is Opera.
    *
    * @property isOpera
    * @type Boolean
    * @final
  */
  tinymce.isOpera = opera;

  /**
   * Constant that is true if the browser is WebKit (Safari/Chrome).
   *
   * @property isWebKit
   * @type Boolean
   * @final
   */
  tinymce.isWebKit = webkit;

  /**
   * Constant that is true if the browser is IE.
   *
   * @property isIE
   * @type Boolean
   * @final
   */

  tinymce.isIE = ie;

  // IE 11
  tinymce.isIE11 = ie && /Trident\/7.0/.test(userAgent) && /rv:11.0/.test(userAgent);


  // IE 12 / Edge
  tinymce.isIE12 = (userAgent.indexOf('Edge/') != -1 && !ie) ? 12 : false;

  // Remove webkit flag
  if (tinymce.isIE12) {
    tinymce.isWebKit = false;
  }

  /**
   * Constant that is true if the browser is Gecko.
   *
   * @property isGecko
   * @type Boolean
   * @final
   */
  tinymce.isGecko = gecko;

  /**
   * Constant that is true if the os is Mac OS.
   *
   * @property isMac
   * @type Boolean
   * @final
   */
  tinymce.isMac = mac;

  /**
   * Constant that tells if the current device is an iPhone or iPad.
   *
   * @property isIDevice
   * @type Boolean
   * @final
   */
  tinymce.isIDevice = iDevice;

  /**
   * Constant that tells if the current os is Android.
   *
   * @property isAndroid
   * @type Boolean
   * @final
   */
  tinymce.isAndroid = android;

  /**
   * Constant that is true if the os is iOS.
   *
   * @property iOS
   * @type Boolean
   * @final
   */
  tinymce.isIOS = iDevice;

  /**
   * Constant that is true if the current browser is running on iOS 5 or greater.
   *
   * @property isIOS5
   * @type Boolean
   * @final
   */
  tinymce.isIOS5 = iDevice && userAgent.match(/AppleWebKit\/(\d*)/)[1] >= 534;

  /**
   * Constant that is true if the current browser has touch support.
   * @property touchEnabled
   * @type Boolean
   * @final
   */
  tinymce.touchEnabled = isTouchEnabled;

  /**
   * Uuid.js
   *
   * Released under LGPL License.
   * Copyright (c) 1999-2016 Ephox Corp. All rights reserved
   *
   * License: http://www.tinymce.com/license - Inactive
   * Licence: GNU/LGPL 2.1 or later - http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
   * Contributing: http://www.tinymce.com/contributing - Inactive
   */

  /**
   * Generates unique ids.
   *
   * @class tinymce.util.Uuid
   * @private
   */

  var count = 0;

  var seed = function () {
    var rnd = function () {
      return Math.round(Math.random() * 0xFFFFFFFF).toString(36);
    };

    var now = new Date().getTime();
    return 's' + now.toString(36) + rnd() + rnd() + rnd();
  };

  var uuid = function (prefix) {
    return prefix + (count++) + seed();
  };

  tinymce.util.Uuid = {
    uuid: uuid
  };

  /**
   * Delay.js
   *
   * Released under LGPL License.
   * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
   *
   * License: http://www.tinymce.com/license - Inactive
   * Licence: GNU/LGPL 2.1 or later - http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
   * Contributing: http://www.tinymce.com/contributing - Inactive
   */

  /**
   * Utility class for working with delayed actions like setTimeout.
   *
   * @class tinymce.util.Delay
   */
  (function (tinymce) {
  	var requestAnimationFramePromise;

  	function requestAnimationFrame(callback, element) {
  		var i, requestAnimationFrameFunc = window.requestAnimationFrame,
  			vendors = ['ms', 'moz', 'webkit'];

  		function featurefill(callback) {
  			window.setTimeout(callback, 0);
  		}

  		for (i = 0; i < vendors.length && !requestAnimationFrameFunc; i++) {
  			requestAnimationFrameFunc = window[vendors[i] + 'RequestAnimationFrame'];
  		}

  		if (!requestAnimationFrameFunc) {
  			requestAnimationFrameFunc = featurefill;
  		}

  		requestAnimationFrameFunc(callback, element);
  	}

  	function wrappedSetTimeout(callback, time) {
  		if (typeof time != 'number') {
  			time = 0;
  		}

  		return setTimeout(callback, time);
  	}

  	function wrappedSetInterval(callback, time) {
  		if (typeof time != 'number') {
  			time = 1; // IE 8 needs it to be > 0
  		}

  		return setInterval(callback, time);
  	}

  	function wrappedClearTimeout(id) {
  		return clearTimeout(id);
  	}

  	function wrappedClearInterval(id) {
  		return clearInterval(id);
  	}

  	function debounce(callback, time) {
  		var timer, func;

  		func = function () {
  			var args = arguments;

  			clearTimeout(timer);

  			timer = wrappedSetTimeout(function () {
  				callback.apply(this, args);
  			}, time);
  		};

  		func.stop = function () {
  			clearTimeout(timer);
  		};

  		return func;
  	}

  	tinymce.util.Delay = {
  		/**
  		 * Requests an animation frame and fallbacks to a timeout on older browsers.
  		 *
  		 * @method requestAnimationFrame
  		 * @param {function} callback Callback to execute when a new frame is available.
  		 * @param {DOMElement} element Optional element to scope it to.
  		 */
  		requestAnimationFrame: function (callback, element) {
  			if (requestAnimationFramePromise) {
  				requestAnimationFramePromise.then(callback);
  				return;
  			}

  			requestAnimationFramePromise = new Promise(function (resolve) {
  				if (!element) {
  					element = document.body;
  				}

  				requestAnimationFrame(resolve, element);
  			}).then(callback);
  		},

  		/**
  		 * Sets a timer in ms and executes the specified callback when the timer runs out.
  		 *
  		 * @method setTimeout
  		 * @param {function} callback Callback to execute when timer runs out.
  		 * @param {Number} time Optional time to wait before the callback is executed, defaults to 0.
  		 * @return {Number} Timeout id number.
  		 */
  		setTimeout: wrappedSetTimeout,

  		/**
  		 * Sets an interval timer in ms and executes the specified callback at every interval of that time.
  		 *
  		 * @method setInterval
  		 * @param {function} callback Callback to execute when interval time runs out.
  		 * @param {Number} time Optional time to wait before the callback is executed, defaults to 0.
  		 * @return {Number} Timeout id number.
  		 */
  		setInterval: wrappedSetInterval,

  		/**
  		 * Sets an editor timeout it's similar to setTimeout except that it checks if the editor instance is
  		 * still alive when the callback gets executed.
  		 *
  		 * @method setEditorTimeout
  		 * @param {tinymce.Editor} editor Editor instance to check the removed state on.
  		 * @param {function} callback Callback to execute when timer runs out.
  		 * @param {Number} time Optional time to wait before the callback is executed, defaults to 0.
  		 * @return {Number} Timeout id number.
  		 */
  		setEditorTimeout: function (editor, callback, time) {
  			return wrappedSetTimeout(function () {
  				if (!editor.removed) {
  					callback();
  				}
  			}, time);
  		},

  		/**
  		 * Sets an interval timer it's similar to setInterval except that it checks if the editor instance is
  		 * still alive when the callback gets executed.
  		 *
  		 * @method setEditorInterval
  		 * @param {function} callback Callback to execute when interval time runs out.
  		 * @param {Number} time Optional time to wait before the callback is executed, defaults to 0.
  		 * @return {Number} Timeout id number.
  		 */
  		setEditorInterval: function (editor, callback, time) {
  			var timer;

  			timer = wrappedSetInterval(function () {
  				if (!editor.removed) {
  					callback();
  				} else {
  					clearInterval(timer);
  				}
  			}, time);

  			return timer;
  		},

  		/**
  		 * Creates debounced callback function that only gets executed once within the specified time.
  		 *
  		 * @method debounce
  		 * @param {function} callback Callback to execute when timer finishes.
  		 * @param {Number} time Optional time to wait before the callback is executed, defaults to 0.
  		 * @return {Function} debounced function callback.
  		 */
  		debounce: debounce,

  		// Throttle needs to be debounce due to backwards compatibility.
  		throttle: debounce,

  		/**
  		 * Clears an interval timer so it won't execute.
  		 *
  		 * @method clearInterval
  		 * @param {Number} Interval timer id number.
  		 */
  		clearInterval: wrappedClearInterval,

  		/**
  		 * Clears an timeout timer so it won't execute.
  		 *
  		 * @method clearTimeout
  		 * @param {Number} Timeout timer id number.
  		 */
  		clearTimeout: wrappedClearTimeout
  	};
  })(tinymce);

  /**
   * Dispatcher.js
   *
   * Copyright, Moxiecode Systems AB
   * Released under LGPL License.
   *
   * License: http://www.tinymce.com/license - Inactive
   * Licence: GNU/LGPL 2.1 or later - http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
   * Contributing: http://www.tinymce.com/contributing - Inactive
   */

  /**
   * This class is used to dispatch event to observers/listeners.
   * All internal events inside TinyMCE uses this class.
   *
   * @class tinymce.util.Dispatcher
   * @example
   * // Creates a custom event
   * this.onSomething = new tinymce.util.Dispatcher(this);
   *
   * // Dispatch/fire the event
   * this.onSomething.dispatch('some string');
   */

  tinymce.util.Dispatcher = function (scope) {
    var self = this;

    self.scope = scope || self;
    self.listeners = [];
    self.inDispatch = false;
  };

  tinymce.util.Dispatcher.prototype = {
    /**
       * Add an observer function to be executed when a dispatch call is done.
       *
       * @method add
       * @param {function} callback Callback function to execute when a dispatch event occurs.
       * @param {Object} s Optional execution scope, defaults to the one specified in the class constructor.
       * @return {function} Returns the same function as the one passed on.
       */
    add: function (callback, scope) {
      this.listeners.push({
        cb: callback,
        scope: scope || this.scope
      });

      return callback;
    },

    /**
       * Add an observer function to be executed to the top of the list of observers.
       *
       * @method addToTop
       * @param {function} callback Callback function to execute when a dispatch event occurs.
       * @param {Object} scope Optional execution scope, defaults to the one specified in the class constructor.
       * @return {function} Returns the same function as the one passed on.
       */
    addToTop: function (callback, scope) {
      var self = this,
        listener = {
          cb: callback,
          scope: scope || self.scope
        };

      // Create new listeners if addToTop is executed in a dispatch loop
      if (self.inDispatch) {
        self.listeners = [listener].concat(self.listeners);
      } else {
        self.listeners.unshift(listener);
      }

      return callback;
    },

    /**
       * Removes an observer function.
       *
       * @method remove
       * @param {function} callback Observer function to remove.
       * @return {function} The same function that got passed in or null if it wasn't found.
       */
    remove: function (callback) {
      var listeners = this.listeners,
        output = null;

      tinymce.each(listeners, function (listener, i) {
        if (callback == listener.cb) {
          output = listener;
          listeners.splice(i, 1);
          return false;
        }
      });

      return output;
    },

    /**
       * Dispatches an event to all observers/listeners.
       *
       * @method dispatch
       * @param {Object} .. Any number of arguments to dispatch.
       * @return {Object} Last observer functions return value.
       */
    dispatch: function () {
      var self = this,
        returnValue, args = arguments,
        i, listeners = self.listeners,
        listener;

      self.inDispatch = true;

      // Needs to be a real loop since the listener count might change while looping
      // And this is also more efficient
      for (i = 0; i < listeners.length; i++) {
        listener = listeners[i];
        returnValue = listener.cb.apply(listener.scope, args.length > 0 ? args : [listener.scope]);

        if (returnValue === false) {
          break;
        }
      }

      self.inDispatch = false;

      return returnValue;
    }
  };

  /**
   * URI.js
   *
   * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
   * Released under LGPL License.
   *
   * License: http://www.tinymce.com/license - Inactive
   * Licence: GNU/LGPL 2.1 or later - http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
   * Contributing: http://www.tinymce.com/contributing - Inactive
   * 
   * Include modified and updated code from https://github.com/tinymce/tinymce/blob/release/5.10/modules/tinymce/src/core/main/ts/api/util/URI.ts
   */

  (function (tinymce) {
    var each = tinymce.each,
      trim = tinymce.trim;
    var queryParts = "source protocol authority userInfo user password host port relative path directory file query anchor".split(' ');
    var DEFAULT_PORTS = {
      'ftp': 21,
      'http': 80,
      'https': 443,
      'mailto': 25
    };

    var safeSvgDataUrlElements = [ 'img', 'video' ];

    function isNonNullable(value) {
      return value !== null && value !== undefined;
    }

    /**
     * This class handles parsing, modification and serialization of URI/URL strings.
     * @class tinymce.util.URI
     */
    tinymce.util.URI = function (url, settings) {
      var self = this,
          baseUri, base_url;

        url = trim(url);
        settings = self.settings = settings || {};
        baseUri = settings.base_uri;

        // Strange app protocol that isn't http/https or local anchor
        // For example: mailto,skype,tel etc.
        if (/^([\w\-]+):([^\/]{2})/i.test(url) || /^\s*#/.test(url)) {
          self.source = url;
          return;
        }

        var isProtocolRelative = url.indexOf('//') === 0;

        // Absolute path with no host, fake host and protocol
        if (url.indexOf('/') === 0 && !isProtocolRelative) {
          url = (baseUri ? baseUri.protocol || 'http' : 'http') + '://mce_host' + url;
        }

        // Relative path http:// or protocol relative //path
        if (!/^[\w\-]*:?\/\//.test(url)) {
          base_url = settings.base_uri ? settings.base_uri.path : new tinymce.util.URI(location.href).directory;
          if (settings.base_uri.protocol === "") {
            url = '//mce_host' + self.toAbsPath(base_url, url);
          } else {
            url = /([^#?]*)([#?]?.*)/.exec(url);
            url = ((baseUri && baseUri.protocol) || 'http') + '://mce_host' + self.toAbsPath(base_url, url[1]) + url[2];
          }
        }

        // Parse URL (Credits goes to Steave, http://blog.stevenlevithan.com/archives/parseuri)
        url = url.replace(/@@/g, '(mce_at)'); // Zope 3 workaround, they use @@something

        /*jshint maxlen: 255 */
        /*eslint max-len: 0 */
        url = /^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@\/]*):?([^:@\/]*))?@)?([^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/.exec(url);

        each(queryParts, function (v, i) {
          var part = url[i];

          // Zope 3 workaround, they use @@something
          if (part) {
            part = part.replace(/\(mce_at\)/g, '@@');
          }

          self[v] = part;
        });

        if (baseUri) {
          if (!self.protocol) {
            self.protocol = baseUri.protocol;
          }

          if (!self.userInfo) {
            self.userInfo = baseUri.userInfo;
          }

          if (!self.port && self.host === 'mce_host') {
            self.port = baseUri.port;
          }

          if (!self.host || self.host === 'mce_host') {
            self.host = baseUri.host;
          }

          self.source = '';
        }

        if (isProtocolRelative) {
          self.protocol = '';
        }
    };

    tinymce.util.URI.prototype = {
      /**
       * Sets the internal path part of the URI.
       *
       * @method setPath
       * @param {string} path Path string to set.
       */
      setPath: function (path) {
        var self = this;

        path = /^(.*?)\/?(\w+)?$/.exec(path);

        // Update path parts
        self.path = path[0];
        self.directory = path[1];
        self.file = path[2];

        // Rebuild source
        self.source = '';
        self.getURI();
      },

      /**
       * Converts the specified URI into a relative URI based on the current URI instance location.
       *
       * @method toRelative
       * @param {String} uri URI to convert into a relative path/URI.
       * @return {String} Relative URI from the point specified in the current URI instance.
       * @example
       * // Converts an absolute URL to an relative URL url will be somedir/somefile.htm
       * var url = new tinymce.util.URI('http://www.site.com/dir/').toRelative('http://www.site.com/dir/somedir/somefile.htm');
       */
      toRelative: function (uri) {
        var self = this,
          output;

        if (uri === "./") {
          return uri;
        }

        uri = new tinymce.util.URI(uri, {
          base_uri: self
        });

        // Not on same domain/port or protocol
        if ((uri.host != 'mce_host' && self.host != uri.host && uri.host) || self.port != uri.port ||
          (self.protocol != uri.protocol && uri.protocol !== "")) {
          return uri.getURI();
        }

        var tu = self.getURI(),
          uu = uri.getURI();

        // Allow usage of the base_uri when relative_urls = true
        if (tu == uu || (tu.charAt(tu.length - 1) == "/" && tu.substr(0, tu.length - 1) == uu)) {
          return tu;
        }

        output = self.toRelPath(self.path, uri.path);

        // Add query
        if (uri.query) {
          output += '?' + uri.query;
        }

        // Add anchor
        if (uri.anchor) {
          output += '#' + uri.anchor;
        }

        return output;
      },

      /**
       * Converts the specified URI into a absolute URI based on the current URI instance location.
       *
       * @method toAbsolute
       * @param {String} uri URI to convert into a relative path/URI.
       * @param {Boolean} noHost No host and protocol prefix.
       * @return {String} Absolute URI from the point specified in the current URI instance.
       * @example
       * // Converts an relative URL to an absolute URL url will be http://www.site.com/dir/somedir/somefile.htm
       * var url = new tinymce.util.URI('http://www.site.com/dir/').toAbsolute('somedir/somefile.htm');
       */
      toAbsolute: function (uri, noHost) {
        uri = new tinymce.util.URI(uri, {
          base_uri: this
        });

        return uri.getURI(noHost && this.isSameOrigin(uri));
      },

      /**
       * Determine whether the given URI has the same origin as this URI.  Based on RFC-6454.
       * Supports default ports for protocols listed in DEFAULT_PORTS.  Unsupported protocols will fail safe: they
       * won't match, if the port specifications differ.
       *
       * @method isSameOrigin
       * @param {tinymce.util.URI} uri Uri instance to compare.
       * @returns {Boolean} True if the origins are the same.
       */
      isSameOrigin: function (uri) {
        if (this.host == uri.host && this.protocol == uri.protocol) {
          if (this.port == uri.port) {
            return true;
          }

          var defaultPort = DEFAULT_PORTS[this.protocol];
          if (defaultPort && ((this.port || defaultPort) == (uri.port || defaultPort))) {
            return true;
          }
        }

        return false;
      },

      /**
       * Converts a absolute path into a relative path.
       *
       * @method toRelPath
       * @param {String} base Base point to convert the path from.
       * @param {String} path Absolute path to convert into a relative path.
       */
      toRelPath: function (base, path) {
        var items, breakPoint = 0,
          out = '',
          i, l;

        // Split the paths
        base = base.substring(0, base.lastIndexOf('/'));
        base = base.split('/');
        items = path.split('/');

        if (base.length >= items.length) {
          for (i = 0, l = base.length; i < l; i++) {
            if (i >= items.length || base[i] != items[i]) {
              breakPoint = i + 1;
              break;
            }
          }
        }

        if (base.length < items.length) {
          for (i = 0, l = items.length; i < l; i++) {
            if (i >= base.length || base[i] != items[i]) {
              breakPoint = i + 1;
              break;
            }
          }
        }

        if (breakPoint === 1) {
          return path;
        }

        for (i = 0, l = base.length - (breakPoint - 1); i < l; i++) {
          out += "../";
        }

        for (i = breakPoint - 1, l = items.length; i < l; i++) {
          if (i != breakPoint - 1) {
            out += "/" + items[i];
          } else {
            out += items[i];
          }
        }

        return out;
      },

      /**
       * Converts a relative path into a absolute path.
       *
       * @method toAbsPath
       * @param {String} base Base point to convert the path from.
       * @param {String} path Relative path to convert into an absolute path.
       */
      toAbsPath: function (base, path) {
        var i, nb = 0,
          o = [],
          tr, outPath;

        // Split paths
        tr = /\/$/.test(path) ? '/' : '';
        base = base.split('/');
        path = path.split('/');

        // Remove empty chunks
        each(base, function (k) {
          if (k) {
            o.push(k);
          }
        });

        base = o;

        // Merge relURLParts chunks
        for (i = path.length - 1, o = []; i >= 0; i--) {
          // Ignore empty or .
          if (path[i].length === 0 || path[i] === ".") {
            continue;
          }

          // Is parent
          if (path[i] === '..') {
            nb++;
            continue;
          }

          // Move up
          if (nb > 0) {
            nb--;
            continue;
          }

          o.push(path[i]);
        }

        i = base.length - nb;

        // If /a/b/c or /
        if (i <= 0) {
          outPath = o.reverse().join('/');
        } else {
          outPath = base.slice(0, i).join('/') + '/' + o.reverse().join('/');
        }

        // Add front / if it's needed
        if (outPath.indexOf('/') !== 0) {
          outPath = '/' + outPath;
        }

        // Add traling / if it's needed
        if (tr && outPath.lastIndexOf('/') !== outPath.length - 1) {
          outPath += tr;
        }

        return outPath;
      },

      /**
       * Returns the full URI of the internal structure.
       *
       * @method getURI
       * @param {Boolean} noProtoHost Optional no host and protocol part. Defaults to false.
       */
      getURI: function (noProtoHost) {
        var s, self = this;

        // Rebuild source
        if (!self.source || noProtoHost) {
          s = '';

          if (!noProtoHost) {
            if (self.protocol) {
              s += self.protocol + '://';
            } else {
              s += '//';
            }

            if (self.userInfo) {
              s += self.userInfo + '@';
            }

            if (self.host) {
              s += self.host;
            }

            if (self.port) {
              s += ':' + self.port;
            }
          }

          if (self.path) {
            s += self.path;
          }

          if (self.query) {
            s += '?' + self.query;
          }

          if (self.anchor) {
            s += '#' + self.anchor;
          }

          self.source = s;
        }

        return self.source;
      }
    };

    var blockSvgDataUris = function (allowSvgDataUrls, tagName) {
      if (isNonNullable(allowSvgDataUrls)) {
        return !allowSvgDataUrls;
      } else {
        // Only allow SVGs by default on images/videos since the browser won't execute scripts on those elements
        return isNonNullable(tagName) ? tinymce.inArray(safeSvgDataUrlElements, tagName) == -1 : true;
      }
    };

    var isInvalidUri = function (settings, uri, tagName) {
      if (settings.allow_html_data_urls) {
        return false;
      } else if (/^data:image\//i.test(uri)) {
        return blockSvgDataUris(settings.allow_svg_data_urls, tagName) && /^data:image\/svg\+xml/i.test(uri);
      } else {
        return /^data:/i.test(uri);
      }
    };

    tinymce.util.URI.parseDataUri = function (uri) {
      var type, matches;

      uri = decodeURIComponent(uri).split(',');

      matches = /data:([^;]+)/.exec(uri[0]);
      if (matches) {
        type = matches[1];
      }

      return {
        type: type,
        data: uri[1]
      };
    };

    tinymce.util.URI.getDocumentBaseUrl = function (loc) {
      var baseUrl;

      // Pass applewebdata:// and other non web protocols though
      if (loc.protocol.indexOf('http') !== 0 && loc.protocol !== 'file:') {
        baseUrl = loc.href;
      } else {
        baseUrl = loc.protocol + '//' + loc.host + loc.pathname;
      }

      if (/^[^:]+:\/\/\/?[^\/]+\//.test(baseUrl)) {
        baseUrl = baseUrl.replace(/[\?#].*$/, '').replace(/[\/\\][^\/]+$/, '');

        if (!/[\/\\]$/.test(baseUrl)) {
          baseUrl += '/';
        }
      }

      return baseUrl;
    };

    /**
     * Check to see if a URI is safe to use in the Document Object Model (DOM). This will return
     * true if the URI can be used in the DOM without potentially triggering a security issue.
     *
     * @method isDomSafe
     * @static
     * @param {String} uri The URI to be validated.
     * @param {Object} context An optional HTML tag name where the element is being used.
     * @param {Object} options An optional set of options to use when determining if the URI is safe.
     * @return {Boolean} True if the URI is safe, otherwise false.
     */
    tinymce.util.URI.isDomSafe = function (uri, context, options) {
      if (options.allow_script_urls) {
        return true;
      } else {
        // eslint-disable-next-line no-control-regex
        let decodedUri = tinymce.html.Entities.decode(uri).replace(/[\s\u0000-\u001F]+/g, '');

        try {
          // Might throw malformed URI sequence
          decodedUri = decodeURIComponent(decodedUri);
        } catch (ex) {
          // Fallback to non UTF-8 decoder
          decodedUri = unescape(decodedUri);
        }

        // Ensure we don't have a javascript URI, as that is not safe since it allows arbitrary JavaScript execution
        if (/((java|vb)script|mhtml):/i.test(decodedUri)) {
          return false;
        }

        return !isInvalidUri(options, decodedUri, context);
      }
    };
  })(tinymce);

  /**
   * Cookie.js
   *
   * Copyright, Moxiecode Systems AB
   * Released under LGPL License.
   *
   * License: http://www.tinymce.com/license - Inactive
   * Licence: GNU/LGPL 2.1 or later - http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
   * Contributing: http://www.tinymce.com/contributing - Inactive
   */

  (function (tinymce) {
    /**
       * This class contains simple storage manangement functions.
       *
       * @class tinymce.util.Storage
       * @static
       * @example
       * // Gets a cookie from the browser
       * console.debug(tinymce.util.Storage.get('mycookie'));
       *
       * // Gets a hash table cookie from the browser and takes out the x parameter from it
       * console.debug(tinymce.util.Storage.getHash('mycookie').x);
       *
       * // Sets a hash table cookie to the browser
       * tinymce.util.Storage.setHash({x : '1', y : '2'});
       */
    tinymce.util.Storage = {
      /**
        * Parses the specified query string into an name/value object.
        *
        * @method getHash
        * @param {String} n String to parse into a n Hashtable object.
        * @return {Object} Name/Value object with items parsed from querystring.
        */
      getHash: function (n) {
        var v = this.get(n),
          h;

        if (v) {
          try {
            h = JSON.parse(v);
          } catch (e) {
            /* error */
          }
        }

        return h;
      },

      /**
        * Sets a hashtable name/value object to a sessionStorage item.
        *
        * @method setHash
        * @param {String} n Name of the item.
        * @param {Object} v Hashtable object to set as item.
        */
      setHash: function (n, v) {
        this.set(n, JSON.stringify(v));
      },

      /**
        * Gets the raw data of an item by name.
        *
        * @method get
        * @param {String} n Name of item to retrive.
        * @param {String} s Default value to return.
        * @return {String} Item data string.
        */
      get: function (n, s) {
        if (!window.sessionStorage) {
          return null;
        }

        var val = sessionStorage.getItem(n);

        // return default
        if (!tinymce.is(val) || val == null) {
          return s;
        }

        if (val === "true") {
          return true;
        }

        if (val === "false") {
          return false;
        }

        if (val === "null") {
          return null;
        }

        return val;
      },

      /**
        * Sets a raw cookie string.
        *
        * @method set
        * @param {String} n Name of the cookie.
        * @param {String} v Raw cookie data.
        */
      set: function (n, v) {
        if (!window.sessionStorage) {
          return;
        }

        sessionStorage.setItem(n, v);
      }
    };

    tinymce.util.Cookie = {
      getHash: function (n) {
        return tinymce.util.Storage.getHash(n);
      },

      setHash: function (n, v) {
        return tinymce.util.Storage.setHash(n, v);
      },

      get: function (n, s) {
        return tinymce.util.Storage.get(n, s);
      },

      set: function (n, v) {
        return tinymce.util.Storage.set(n, v);
      }
    };
  })(tinymce);

  /**
   * JSON.js
   *
   * Copyright, Moxiecode Systems AB
   * Released under LGPL License.
   *
   * License: http://www.tinymce.com/license - Inactive
   * Licence: GNU/LGPL 2.1 or later - http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
   * Contributing: http://www.tinymce.com/contributing - Inactive
   */

  (function (tinymce) {
    /**
       * JSON parser and serializer class wrapper for native JSON
       *
       * @class tinymce.util.JSON
       * @static
       * @example
       * // JSON parse a string into an object
       * var obj = tinymce.util.JSON.parse(somestring);
       *
       * // JSON serialize a object into an string
       * var str = tinymce.util.JSON.serialize(obj);
       */
    tinymce.util.JSON = {
      /**
           * Serializes the specified object as a JSON string.
           *
           * @method serialize
           * @param {Object} obj Object to serialize as a JSON string.
           * @param {String} quote Optional quote string defaults to ".
           * @return {string} JSON string serialized from input.
           */
      serialize: function (obj) {
        try {
          return JSON.stringify(obj);
        } catch (ex) {
          // Ignore
        }
      },

      /**
           * Unserializes/parses the specified JSON string into a object.
           *
           * @method parse
           * @param {string} str JSON String to parse into a JavaScript object.
           * @return {Object} Object from input JSON string or undefined if it failed.
           */
      parse: function (str) {
        try {
          return JSON.parse(str);
        } catch (ex) {
          // Ignore
        }
      }
      /**#@-*/
    };
  })(tinymce);

  /**
   * JSONP.js
   *
   * Copyright, Moxiecode Systems AB
   * Released under LGPL License.
   *
   * License: http://www.tinymce.com/license - Inactive
   * Licence: GNU/LGPL 2.1 or later - http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
   * Contributing: http://www.tinymce.com/contributing - Inactive
   */

  tinymce.util.JSOP = {
    callbacks: {},
    count: 0,
    send: function (o) {
      var self = this,
        dom = tinymce.DOM,
        count = o.count !== undefined ? o.count : this.count,
        id = 'tinymce_jsonp_' + count;

      this.callbacks[count] = function (json) {
        dom.remove(id);
        delete self.callbacks[count];
        o.callback(json);
      };

      dom.add(dom.doc.body, 'script', {
        id: id,
        src: o.url,
        type: 'text/javascript'
      });

      this.count++;
    }
  };

  /**
   * XHR.js
   *
   * Copyright, Moxiecode Systems AB
   * Released under LGPL License.
   *
   * License: http://www.tinymce.com/license - Inactive
   * Licence: GNU/LGPL 2.1 or later - http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
   * Contributing: http://www.tinymce.com/contributing - Inactive
   */

  /**
   * This class enables you to send XMLHTTPRequests cross browser.
   * @class tinymce.util.XHR
   * @static
   * @example
   * // Sends a low level Ajax request
   * tinymce.util.XHR.send({
   *    url : 'someurl',
   *    success : function(text) {
   *       console.debug(text);
   *    }
   * });
   */
  tinymce.util.XHR = {
    /**
       * Sends a XMLHTTPRequest.
       * Consult the Wiki for details on what settings this method takes.
       *
       * @method send
       * @param {Object} o Object will target URL, callbacks and other info needed to make the request.
       */
    send: function (o) {
      var xhr, c = 0;

      function ready() {
        if (!o.async || xhr.readyState == 4 || c++ > 10000) {
          if (o.success && c < 10000 && xhr.status == 200) {
            o.success.call(o.success_scope, '' + xhr.responseText, xhr, o);
          } else if (o.error) {
            o.error.call(o.error_scope, c > 10000 ? 'TIMED_OUT' : 'GENERAL', xhr, o);
          }
          xhr = null;
        } else {
          window.setTimeout(ready, 10);
        }
      }

      // Default settings
      o.scope = o.scope || this;
      o.success_scope = o.success_scope || o.scope;
      o.error_scope = o.error_scope || o.scope;
      o.async = o.async === false ? false : true;
      o.data = o.data || '';

      xhr = new XMLHttpRequest();

      if (xhr) {
        if (xhr.overrideMimeType) {
          xhr.overrideMimeType(o.content_type);
        }

        xhr.open(o.type || (o.data ? 'POST' : 'GET'), o.url, o.async);

        if (o.content_type) {
          xhr.setRequestHeader('Content-Type', o.content_type);
        }

        xhr.setRequestHeader('X-Requested-With', 'XMLHttpRequest');

        xhr.send(o.data);

        // Syncronous request
        if (!o.async) {
          return ready();
        }

        // Wait for response, onReadyStateChange can not be used since it leaks memory in IE
        window.setTimeout(ready, 10);
      }
    }
  };

  /**
   * JSONRequest.js
   *
   * Copyright, Moxiecode Systems AB
   * Released under LGPL License.
   *
   * License: http://www.tinymce.com/license - Inactive
   * Licence: GNU/LGPL 2.1 or later - http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
   * Contributing: http://www.tinymce.com/contributing - Inactive
   */

  (function (tinymce) {
    var extend = tinymce.extend,
      JSON = tinymce.util.JSON,
      XHR = tinymce.util.XHR;

    /**
     * This class enables you to use JSON-RPC to call backend methods.
     *
     * @class tinymce.util.JSONRequest
     * @example
     * var json = new tinymce.util.JSONRequest({
     * 		url : 'somebackend.php'
     * });
     *
     * // Send RPC call 1
     * json.send({
     *     method : 'someMethod1',
     *     params : ['a', 'b'],
     *     success : function(result) {
     *         console.dir(result);
     * 	   }
     * });
     *
     * // Send RPC call 2
     * json.send({
     *     method : 'someMethod2',
     *     params : ['a', 'b'],
     *     success : function(result) {
     *         console.dir(result);
     *     }
     * });
     */
    tinymce.util.JSONRequest = function (settings) {
      this.settings = extend({}, settings);
      this.count = 0;
    };

    tinymce.util.JSONRequest.prototype = {
      /**
       * Sends a JSON-RPC call. Consult the Wiki API documentation for more details on what you can pass to this function.
       *
       * @method send
       * @param {Object} o Call object where there are three field id, method and params this object should also contain callbacks etc.
       */
      send: function (o) {
        var ecb = o.error,
          scb = o.success;

        o = extend(this.settings, o);

        o.success = function (c, x) {
          c = JSON.parse(c);

          if (typeof c == 'undefined') {
            c = {
              error: 'JSON Parse error.'
            };
          }

          if (c.error) {
            ecb.call(o.error_scope || o.scope, c.error, x);
          } else {
            scb.call(o.success_scope || o.scope, c.result);
          }
        };

        o.error = function (ty, x) {
          if (ecb) {
            ecb.call(o.error_scope || o.scope, ty, x);
          }
        };

        o.data = JSON.serialize({
          id: o.id || 'c' + (this.count++),
          method: o.method,
          params: o.params
        });

        // JSON content type for Ruby on rails. Bug: #1883287
        o.content_type = 'application/json';

        XHR.send(o);
      }
    };

    /**
         * Simple helper function to send a JSON-RPC request without the need to initialize an object.
         * Consult the Wiki API documentation for more details on what you can pass to this function.
         *
         * @method sendRPC
         * @static
         * @param {Object} o Call object where there are three field id, method and params this object should also contain callbacks etc.
         */
    tinymce.util.JSONRequest.sendRPC = function (o) {
      return new tinymce.util.JSONRequest().send(o);
    };

  })(tinymce);

  /**
   * VK.js
   *
   * Copyright, Moxiecode Systems AB
   * Released under LGPL License.
   *
   * License: http://www.tinymce.com/license - Inactive
   * Licence: GNU/LGPL 2.1 or later - http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
   * Contributing: http://www.tinymce.com/contributing - Inactive
   */

  /**
   * This file exposes a set of the common KeyCodes for use.  Please grow it as needed.
   */

  (function (tinymce) {

    tinymce.VK = {
      BACKSPACE: 8,
      DELETE: 46,
      DOWN: 40,
      ENTER: 13,
      LEFT: 37,
      RIGHT: 39,
      SPACEBAR: 32,
      TAB: 9,
      UP: 38,

      modifierPressed: function (e) {
        return e.shiftKey || e.ctrlKey || e.altKey || this.metaKeyPressed(e);
      },

      metaKeyPressed: function (e) {
        // Check if ctrl or meta key is pressed also check if alt is false for Polish users
        if (tinymce.isMac) {
          return e.metaKey;
        }

        return e.ctrlKey && !e.altKey;
      }
    };
  })(tinymce);

  /**
   * Quirks.js
   *
   * Copyright, Moxiecode Systems AB
   * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
   * Released under LGPL License.
   *
   * License: http://www.tinymce.com/license - Inactive
   * Licence: GNU/LGPL 2.1 or later - http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
   * Contributing: http://www.tinymce.com/contributing - Inactive
   */

  /**
   * This file includes fixes for various browser quirks it's made to make it easy to add/remove browser specific fixes.
   */
  tinymce.util.Quirks = function (editor) {
    var VK = tinymce.VK,
      BACKSPACE = VK.BACKSPACE,
      DELETE = VK.DELETE,
      dom = editor.dom,
      selection = editor.selection,
      settings = editor.settings,
      parser = editor.parser,
      each = tinymce.each,
      RangeUtils = tinymce.dom.RangeUtils,
      TreeWalker = tinymce.dom.TreeWalker;

    var mceInternalUrlPrefix = 'data:text/mce-internal,';
    var mceInternalDataType = tinymce.isIE ? 'Text' : 'URL';

    /**
     * Executes a command with a specific state this can be to enable/disable browser editing features.
     */
    function setEditorCommandState(cmd, state) {
      try {
        editor.getDoc().execCommand(cmd, false, state);
      } catch (ex) {
        // Ignore
      }
    }

    /**
     * Returns true/false if the event is prevented or not.
     *
     * @param {Event} e Event object.
     * @return {Boolean} true/false if the event is prevented or not.
     */
    function isDefaultPrevented(e) {
      return e.isDefaultPrevented();
    }

    /**
     * Sets Text/URL data on the event's dataTransfer object to a special data:text/mce-internal url.
     * This is to workaround the inability to set custom contentType on IE and Safari.
     * The editor's selected content is encoded into this url so drag and drop between editors will work.
     *
     * @private
     * @param {DragEvent} e Event object
     */
    function setMceInternalContent(e) {
      var selectionHtml, internalContent;

      if (e.dataTransfer) {
        if (editor.selection.isCollapsed() && e.target.tagName == 'IMG') {
          selection.select(e.target);
        }

        selectionHtml = editor.selection.getContent();

        // Safari/IE doesn't support custom dataTransfer items so we can only use URL and Text
        if (selectionHtml.length > 0) {
          internalContent = mceInternalUrlPrefix + escape(editor.id) + ',' + escape(selectionHtml);
          e.dataTransfer.setData(mceInternalDataType, internalContent);
        }
      }
    }

    /**
     * Gets content of special data:text/mce-internal url on the event's dataTransfer object.
     * This is to workaround the inability to set custom contentType on IE and Safari.
     * The editor's selected content is encoded into this url so drag and drop between editors will work.
     *
     * @private
     * @param {DragEvent} e Event object
     * @returns {String} mce-internal content
     */
    function getMceInternalContent(e) {
      var internalContent;

      if (e.dataTransfer) {
        internalContent = e.dataTransfer.getData(mceInternalDataType);

        if (internalContent && internalContent.indexOf(mceInternalUrlPrefix) >= 0) {
          internalContent = internalContent.substr(mceInternalUrlPrefix.length).split(',');

          return {
            id: unescape(internalContent[0]),
            html: unescape(internalContent[1])
          };
        }
      }

      return null;
    }

    /**
     * Inserts contents using the paste clipboard command if it's available if it isn't it will fallback
     * to the core command.
     *
     * @private
     * @param {String} content Content to insert at selection.
     */
    function insertClipboardContents(content) {
      if (editor.queryCommandSupported('mceInsertClipboardContent')) {
        editor.execCommand('mceInsertClipboardContent', false, {
          content: content
        });
      } else {
        editor.execCommand('mceInsertContent', false, content);
      }
    }

    /**
     * Fixes a WebKit bug when deleting contents using backspace or delete key.
     * WebKit will produce a span element if you delete across two block elements.
     *
     * Example:
     * <h1>a</h1><p>|b</p>
     *
     * Will produce this on backspace:
     * <h1>a<span style="<all runtime styles>">b</span></p>
     *
     * This fixes the backspace to produce:
     * <h1>a|b</p>
     *
     * See bug: https://bugs.webkit.org/show_bug.cgi?id=45784
     *
     * This fixes the following delete scenarios:
     *  1. Delete by pressing backspace key.
     *  2. Delete by pressing delete key.
     *  3. Delete by pressing backspace key with ctrl/cmd (Word delete).
     *  4. Delete by pressing delete key with ctrl/cmd (Word delete).
     *  5. Delete by drag/dropping contents inside the editor.
     *  6. Delete by using Cut Ctrl+X/Cmd+X.
     *  7. Delete by selecting contents and writing a character.
     *
     * This code is a ugly hack since writing full custom delete logic for just this bug
     * fix seemed like a huge task. I hope we can remove this before the year 2030.
     */
    function cleanupStylesWhenDeleting() {
      var dom = editor.dom,
        selection = editor.selection;
      var MutationObserver = window.MutationObserver;

      function isTrailingBr(node) {
        var blockElements = dom.schema.getBlockElements(),
          rootNode = dom.getRoot();

        if (node.nodeName != 'BR') {
          return false;
        }

        for (; node != rootNode && !blockElements[node.nodeName]; node = node.parentNode) {
          if (node.nextSibling) {
            return false;
          }
        }

        return true;
      }

      function isSiblingsIgnoreWhiteSpace(node1, node2) {
        var node;

        for (node = node1.nextSibling; node && node != node2; node = node.nextSibling) {
          if (node.nodeType == 3 && tinymce.trim(node.data).length === 0) {
            continue;
          }

          if (node !== node2) {
            return false;
          }
        }

        return node === node2;
      }

      function findCaretNode(node, forward, startNode) {
        var walker, current, nonEmptyElements, rootNode = dom.getRoot();

        // Protect against the possibility we are asked to find a caret node relative
        // to a node that is no longer in the DOM tree. In this case attempting to
        // select on any match leads to a scenario where selection is completely removed
        // from the editor. This scenario is met in real world at a minimum on
        // WebKit browsers when selecting all and Cmd-X cutting to delete content.
        if (!dom.isChildOf(node, rootNode)) {
          return;
        }

        nonEmptyElements = dom.schema.getNonEmptyElements();

        walker = new TreeWalker(startNode || node, node);

        while ((current = walker[forward ? 'next' : 'prev']())) {
          if (nonEmptyElements[current.nodeName] && !isTrailingBr(current)) {
            return current;
          }

          if (current.nodeType == 3 && current.data.length > 0) {
            return current;
          }
        }
      }

      function deleteRangeBetweenTextBlocks(rng) {
        var startBlock, endBlock, caretNodeBefore, caretNodeAfter, textBlockElements;

        if (rng.collapsed) {
          return;
        }

        startBlock = dom.getParent(RangeUtils.getNode(rng.startContainer, rng.startOffset), dom.isBlock);
        endBlock = dom.getParent(RangeUtils.getNode(rng.endContainer, rng.endOffset), dom.isBlock);
        textBlockElements = editor.schema.getTextBlockElements();

        if (startBlock == endBlock) {
          return;
        }

        if (!textBlockElements[startBlock.nodeName] || !textBlockElements[endBlock.nodeName]) {
          return;
        }

        if (dom.getContentEditable(startBlock) === "false" || dom.getContentEditable(endBlock) === "false") {
          return;
        }

        rng.deleteContents();

        caretNodeBefore = findCaretNode(startBlock, false);
        caretNodeAfter = findCaretNode(endBlock, true);

        // backspace from the beginning of one block element into the previous block element...
        if (caretNodeBefore && caretNodeAfter) {
          if (!dom.isEmpty(endBlock)) {
            var nodes = tinymce.toArray(endBlock.childNodes);

            each(nodes, function (node) {
              if (node && node.nodeType) {
                startBlock.appendChild(node);
              }
            });
          }

          dom.remove(endBlock);
        }

        // remove block elment only if it is empty
        each([startBlock, endBlock], function (node) {
          if (dom.isEmpty(node)) {
            dom.remove(node);
          }
        });

        if (caretNodeBefore) {
          if (caretNodeBefore.nodeType == 1) {
            if (caretNodeBefore.nodeName == "BR") {
              rng.setStartBefore(caretNodeBefore);
              rng.setEndBefore(caretNodeBefore);
            } else {
              rng.setStartAfter(caretNodeBefore);
              rng.setEndAfter(caretNodeBefore);
            }
          } else {
            rng.setStart(caretNodeBefore, caretNodeBefore.data.length);
            rng.setEnd(caretNodeBefore, caretNodeBefore.data.length);
          }
        } else if (caretNodeAfter) {
          if (caretNodeAfter.nodeType == 1) {
            rng.setStartBefore(caretNodeAfter);
            rng.setEndBefore(caretNodeAfter);
          } else {
            rng.setStart(caretNodeAfter, 0);
            rng.setEnd(caretNodeAfter, 0);
          }
        }

        selection.setRng(rng);

        return true;
      }

      function expandBetweenBlocks(rng, isForward) {
        var caretNode, targetCaretNode, textBlock, targetTextBlock, container, offset;

        if (!rng.collapsed) {
          return rng;
        }

        container = rng.startContainer;
        offset = rng.startOffset;

        if (container.nodeType == 3) {
          if (isForward) {
            if (offset < container.data.length) {
              return rng;
            }
          } else {
            if (offset > 0) {
              return rng;
            }
          }
        }

        caretNode = RangeUtils.getNode(container, offset);
        textBlock = dom.getParent(caretNode, dom.isBlock);
        targetCaretNode = findCaretNode(editor.getBody(), isForward, caretNode);
        targetTextBlock = dom.getParent(targetCaretNode, dom.isBlock);
        var isAfter = container.nodeType === 1 && offset > container.childNodes.length - 1;

        if (!caretNode || !targetCaretNode) {
          return rng;
        }

        if (targetTextBlock && textBlock != targetTextBlock) {
          if (!isForward) {
            if (!isSiblingsIgnoreWhiteSpace(targetTextBlock, textBlock)) {
              return rng;
            }

            if (targetCaretNode.nodeType == 1) {
              if (targetCaretNode.nodeName == "BR") {
                rng.setStartBefore(targetCaretNode);
              } else {
                rng.setStartAfter(targetCaretNode);
              }
            } else {
              rng.setStart(targetCaretNode, targetCaretNode.data.length);
            }

            if (caretNode.nodeType == 1) {
              if (isAfter) {
                rng.setEndAfter(caretNode);
              } else {
                rng.setEndBefore(caretNode);
              }
            } else {
              rng.setEndBefore(caretNode);
            }
          } else {
            if (!isSiblingsIgnoreWhiteSpace(textBlock, targetTextBlock)) {
              return rng;
            }

            if (caretNode.nodeType == 1) {
              if (caretNode.nodeName == "BR") {
                rng.setStartBefore(caretNode);
              } else {
                rng.setStartAfter(caretNode);
              }
            } else {
              rng.setStart(caretNode, caretNode.data.length);
            }

            if (targetCaretNode.nodeType == 1) {
              rng.setEnd(targetCaretNode, 0);
            } else {
              rng.setEndBefore(targetCaretNode);
            }
          }
        }

        return rng;
      }

      function handleTextBlockMergeDelete(isForward) {
        var rng = selection.getRng();

        rng = expandBetweenBlocks(rng, isForward);

        if (deleteRangeBetweenTextBlocks(rng)) {
          return true;
        }
      }

      /**
       * This retains the formatting if the last character is to be deleted.
       *
       * Backspace on this: <p><b><i>a|</i></b></p> would become <p>|</p> in WebKit.
       * With this patch: <p><b><i>|<br></i></b></p>
       */
      function handleLastBlockCharacterDelete(isForward, rng) {
        var path, blockElm, newBlockElm, clonedBlockElm, sibling,
          container, offset, br, currentFormatNodes;

        function cloneTextBlockWithFormats(blockElm, node) {
          currentFormatNodes = dom.getParents(node, function (n) {
            return !!editor.schema.getTextInlineElements()[n.nodeName];
          });

          newBlockElm = blockElm.cloneNode(false);

          currentFormatNodes = tinymce.map(currentFormatNodes, function (formatNode) {
            formatNode = formatNode.cloneNode(false);

            if (newBlockElm.hasChildNodes()) {
              formatNode.appendChild(newBlockElm.firstChild);
              newBlockElm.appendChild(formatNode);
            } else {
              newBlockElm.appendChild(formatNode);
            }

            newBlockElm.appendChild(formatNode);

            return formatNode;
          });

          if (currentFormatNodes.length) {
            br = dom.create('br');
            currentFormatNodes[0].appendChild(br);
            dom.replace(newBlockElm, blockElm);

            rng.setStartBefore(br);
            rng.setEndBefore(br);
            editor.selection.setRng(rng);

            return br;
          }

          return null;
        }

        function isTextBlock(node) {
          return node && editor.schema.getTextBlockElements()[node.tagName];
        }

        function NodePathCreate(rootNode, targetNode, normalized) {
          var path = [];

          for (; targetNode && targetNode != rootNode; targetNode = targetNode.parentNode) {
            path.push(tinymce.DOM.nodeIndex(targetNode, normalized));
          }

          return path;
        }

        function NodePathResolve(rootNode, path) {
          var i, node, children;

          for (node = rootNode, i = path.length - 1; i >= 0; i--) {
            children = node.childNodes;

            if (path[i] > children.length - 1) {
              return null;
            }

            node = children[path[i]];
          }

          return node;
        }

        if (!rng.collapsed) {
          return;
        }

        container = rng.startContainer;
        offset = rng.startOffset;
        blockElm = dom.getParent(container, dom.isBlock);
        if (!isTextBlock(blockElm)) {
          return;
        }

        if (container.nodeType == 1) {
          container = container.childNodes[offset];
          if (container && container.tagName != 'BR') {
            return;
          }

          if (isForward) {
            sibling = blockElm.nextSibling;
          } else {
            sibling = blockElm.previousSibling;
          }

          if (dom.isEmpty(blockElm) && isTextBlock(sibling) && dom.isEmpty(sibling)) {
            if (cloneTextBlockWithFormats(blockElm, container)) {
              dom.remove(sibling);
              return true;
            }
          }
        } else if (container.nodeType == 3) {
          path = NodePathCreate(blockElm, container);
          clonedBlockElm = blockElm.cloneNode(true);
          container = NodePathResolve(clonedBlockElm, path);

          if (isForward) {
            if (offset >= container.data.length) {
              return;
            }

            container.deleteData(offset, 1);
          } else {
            if (offset <= 0) {
              return;
            }

            container.deleteData(offset - 1, 1);
          }

          if (dom.isEmpty(clonedBlockElm)) {
            return cloneTextBlockWithFormats(blockElm, container);
          }
        }
      }

      function customDelete(isForward) {
        var mutationObserver, rng, caretElement, rootNode = editor.dom.getRoot();

        if (handleTextBlockMergeDelete(isForward)) {
          return;
        }

        tinymce.each(rootNode.getElementsByTagName('*'), function (elm) {
          // Mark existing spans
          if (elm.tagName == 'SPAN') {
            elm.setAttribute('data-mce-marked', 1);
          }

          // Make sure all elements has a data-mce-style attribute
          if (!elm.hasAttribute('data-mce-style') && elm.hasAttribute('style')) {
            editor.dom.setAttrib(elm, 'style', editor.dom.getAttrib(elm, 'style'));
          }
        });

        // Observe added nodes and style attribute changes
        mutationObserver = new MutationObserver(function () { });
        mutationObserver.observe(editor.getDoc(), {
          childList: true,
          attributes: true,
          subtree: true,
          attributeFilter: ['style']
        });

        editor.getDoc().execCommand(isForward ? 'ForwardDelete' : 'Delete', false, null);

        rng = editor.selection.getRng();
        caretElement = rng.startContainer.parentNode;

        tinymce.each(mutationObserver.takeRecords(), function (record) {
          if (!dom.isChildOf(record.target, rootNode)) {
            return;
          }

          // Restore style attribute to previous value
          if (record.attributeName == "style") {
            var oldValue = record.target.getAttribute('data-mce-style');

            if (oldValue) {
              record.target.setAttribute("style", oldValue);
            } else {
              record.target.removeAttribute("style");
            }
          }

          // Remove all spans that aren't marked and retain selection
          tinymce.each(record.addedNodes, function (node) {
            if (node.nodeType !== 1) {
              return true;
            }

            // remove new runtime style attributes on addedNodes
            if (node.getAttribute('style') && !node.getAttribute('data-mce-style')) {
              node.removeAttribute("style");
            }

            if (node.nodeName == "SPAN" && !node.getAttribute('data-mce-marked')) {
              var offset, container;

              if (node == caretElement) {
                offset = rng.startOffset;
                container = node.firstChild;
              }

              dom.remove(node, true);

              if (container) {
                rng.setStart(container, offset);
                rng.setEnd(container, offset);
                editor.selection.setRng(rng);
              }
            }
          });
        });

        mutationObserver.disconnect();

        // Remove any left over marks
        tinymce.each(editor.dom.select('span[data-mce-marked]', editor.dom.getRoot()), function (span) {
          span.removeAttribute('data-mce-marked');
        });
      }

      editor.onKeyDown.add(function (editor, e) {
        var isForward = e.keyCode == DELETE,
          isMetaOrCtrl = e.ctrlKey || e.metaKey;

        if (!isDefaultPrevented(e) && (isForward || e.keyCode == BACKSPACE)) {
          var rng = editor.selection.getRng(),
            container = rng.startContainer,
            offset = rng.startOffset;

          // Shift+Delete is cut
          if (isForward && e.shiftKey) {
            return;
          }

          if (handleLastBlockCharacterDelete(isForward, rng)) {
            e.preventDefault();
            return;
          }

          // Ignore non meta delete in the where there is text before/after the caret
          if (!isMetaOrCtrl && rng.collapsed && container.nodeType == 3) {
            if (isForward ? offset < container.data.length : offset > 0) {
              return;
            }
          }

          e.preventDefault();

          if (isMetaOrCtrl) {
            editor.selection.getSel().modify("extend", isForward ? "forward" : "backward", e.metaKey ? "lineboundary" : "word");
          }

          customDelete(isForward);
        }
      });

      // Handle case where text is deleted by typing over
      /*editor.onKeyPress.add(function (editor, e) {
        if (!isDefaultPrevented(e) && !selection.isCollapsed() && e.charCode > 31 && !VK.metaKeyPressed(e)) {
          var rng, currentFormatNodes, fragmentNode, blockParent, caretNode, charText;

          if (editor.settings.forced_root_block === false) {
            return;
          }

          rng = editor.selection.getRng();
          charText = String.fromCharCode(e.charCode);
          e.preventDefault();

          // Keep track of current format nodes
          currentFormatNodes = dom.getParents(rng.startContainer, function (node) {
            return !!editor.schema.getTextInlineElements()[node.nodeName];
          });

          customDelete(true);

          // Check if the browser removed them
          currentFormatNodes = currentFormatNodes.filter(function (idx, node) {
            return !editor.getBody().contains(node);
          });

          // Then re-add them
          if (currentFormatNodes.length) {
            fragmentNode = dom.createFragment();

            currentFormatNodes.each(function (idx, formatNode) {
              formatNode = formatNode.cloneNode(false);

              if (fragmentNode.hasChildNodes()) {
                formatNode.appendChild(fragmentNode.firstChild);
                fragmentNode.appendChild(formatNode);
              } else {
                caretNode = formatNode;
                fragmentNode.appendChild(formatNode);
              }

              fragmentNode.appendChild(formatNode);
            });

            caretNode.appendChild(editor.getDoc().createTextNode(charText));

            // Prevent edge case where older WebKit would add an extra BR element
            blockParent = dom.getParent(rng.startContainer, dom.isBlock);
            if (dom.isEmpty(blockParent)) {
              dom.empty(blockParent);
              dom.add(blockParent, fragmentNode);
            } else {
              rng.insertNode(fragmentNode);
            }

            rng.setStart(caretNode.firstChild, 1);
            rng.setEnd(caretNode.firstChild, 1);
            editor.selection.setRng(rng);
          } else {
            editor.selection.setContent(charText);
          }
        }
      });*/

      editor.addCommand('Delete', function () {
        customDelete();
      });

      editor.addCommand('ForwardDelete', function () {
        customDelete(true);
      });

      /*editor.dom.bind(editor.getBody(), 'dragstart', function (e) {
        dragStartRng = selection.getRng();
        setMceInternalContent(e);
      });

      editor.dom.bind(editor.getBody(), 'drop', function (e) {
        if (!isDefaultPrevented(e)) {
          var internalContent = getMceInternalContent(e);

          if (internalContent) {
            e.preventDefault();

            // Safari has a weird issue where drag/dropping images sometimes
            // produces a green plus icon. When this happens the caretRangeFromPoint
            // will return "null" even though the x, y coordinate is correct.
            // But if we detach the insert from the drop event we will get a proper range
            setTimeout(function () {
              var pointRng = RangeUtils.getCaretRangeFromPoint(e.x, e.y, doc);

              if (dragStartRng) {
                selection.setRng(dragStartRng);
                dragStartRng = null;
                transactCustomDelete();
              }

              selection.setRng(pointRng);
              insertClipboardContents(internalContent.html);
            }, 0);
          }
        }
      });*/
    }

    /**
     * Remove runtime styles from Chrome / Safari, eg: <span style="color: inherit; font-family: inherit; font-size: 1rem;">
     */
    function cleanupRuntimeStyles() {
      function removeRuntimeStyle(node) {
        var style = node.attr('style');

        if (style) {
          style = style.replace(/\s/g, '');

          if (style === 'color:inherit;font-family:inherit;font-size:1rem;') {
            node.unwrap();
          }
        }
      }

      editor.parser.addNodeFilter('span', function (nodes) {
        var i = nodes.length,
          node;
        while (i--) {
          node = nodes[i];
          removeRuntimeStyle(node);
        }
      });

      editor.serializer.addNodeFilter('span', function (nodes) {
        var i = nodes.length,
          node;
        while (i--) {
          node = nodes[i];
          removeRuntimeStyle(node);
        }
      });
    }

    /**
     * Makes sure that the editor body becomes empty when backspace or delete is pressed in empty editors.
     *
     * For example:
     * <p><b>|</b></p>
     *
     * Or:
     * <h1>|</h1>
     *
     * Or:
     * [<h1></h1>]
     */
    function emptyEditorWhenDeleting() {
      function serializeRng(rng) {
        var body = dom.create("body");
        var contents = rng.cloneContents();
        body.appendChild(contents);
        return selection.serializer.serialize(body, {
          format: 'html'
        });
      }

      function allContentsSelected(rng) {
        if (!rng.setStart) {
          if (rng.item) {
            return false;
          }

          var bodyRng = rng.duplicate();
          bodyRng.moveToElementText(editor.getBody());
          return RangeUtils.compareRanges(rng, bodyRng);
        }

        var selection = serializeRng(rng);

        var allRng = dom.createRng();
        allRng.selectNode(editor.getBody());

        var allSelection = serializeRng(allRng);
        return selection === allSelection;
      }

      editor.onKeyDown.add(function (editor, e) {
        var keyCode = e.keyCode,
          isCollapsed, root;

        // Empty the editor if it's needed for example backspace at <p><b>|</b></p>
        if (!isDefaultPrevented(e) && (keyCode == DELETE || keyCode == BACKSPACE)) {
          isCollapsed = editor.selection.isCollapsed();
          root = dom.getRoot();//editor.getBody();

          // Selection is collapsed but the editor isn't empty
          if (isCollapsed && !dom.isEmpty(root)) {
            return;
          }

          // Selection isn't collapsed but not all the contents is selected
          if (!isCollapsed && !allContentsSelected(editor.selection.getRng())) {
            return;
          }

          // Manually empty the editor
          e.preventDefault();
          editor.setContent('');

          if (root.firstChild && dom.isBlock(root.firstChild)) {
            editor.selection.setCursorLocation(root.firstChild, 0);
          } else {
            editor.selection.setCursorLocation(root, 0);
          }

          editor.nodeChanged();
        }
      });
    }

    /**
     * WebKit doesn't select all the nodes in the body when you press Ctrl+A.
     * This selects the whole body so that backspace/delete logic will delete everything
     */
    function selectAll() {
      editor.onKeyDown.add(function (editor, e) {
        if (!isDefaultPrevented(e) && e.keyCode == 65 && VK.metaKeyPressed(e)) {
          e.preventDefault();
          editor.execCommand('SelectAll');
        }
      });
    }

    /**
     * WebKit has a weird issue where it some times fails to properly convert keypresses to input method keystrokes.
     * The IME on Mac doesn't initialize when it doesn't fire a proper focus event.
     *
     * This seems to happen when the user manages to click the documentElement element then the window doesn't get proper focus until
     * you enter a character into the editor.
     *
     * It also happens when the first focus in made to the body.
     *
     * See: https://bugs.webkit.org/show_bug.cgi?id=83566
     */
    function inputMethodFocus() {
      if (!editor.settings.content_editable) {
        // Case 1 IME doesn't initialize if you focus the document
        // Disabled since it was interferring with the cE=false logic
        // Also coultn't reproduce the issue on Safari 9
        /*dom.bind(editor.getDoc(), 'focusin', function() {
          selection.setRng(selection.getRng());
        });*/

        // Case 2 IME doesn't initialize if you click the documentElement it also doesn't properly fire the focusin event
        // Needs to be both down/up due to weird rendering bug on Chrome Windows
        dom.bind(editor.getDoc(), 'mousedown mouseup', function (e) {
          var rng;

          if (e.target == editor.getDoc().documentElement) {
            rng = selection.getRng();
            editor.getBody().focus();

            if (e.type == 'mousedown') {
              /*if (CaretContainer.isCaretContainer(rng.startContainer)) {
                return;
              }*/

              // Edge case for mousedown, drag select and mousedown again within selection on Chrome Windows to render caret
              selection.placeCaretAt(e.clientX, e.clientY);
            } else {
              selection.setRng(rng);
            }
          }
        });
      }
    }

    /**
     * Backspacing in FireFox/IE from a paragraph into a horizontal rule results in a floating text node because the
     * browser just deletes the paragraph - the browser fails to merge the text node with a horizontal rule so it is
     * left there. TinyMCE sees a floating text node and wraps it in a paragraph on the key up event (ForceBlocks.js
     * addRootBlocks), meaning the action does nothing. With this code, FireFox/IE matche the behaviour of other
     * browsers.
     *
     * It also fixes a bug on Firefox where it's impossible to delete HR elements.
     */
    function removeHrOnBackspace() {
      editor.onKeyDown.add(function (editor, e) {
        if (!isDefaultPrevented(e) && e.keyCode === BACKSPACE) {
          // Check if there is any HR elements this is faster since getRng on IE 7 & 8 is slow
          if (!editor.getBody().getElementsByTagName('hr').length) {
            return;
          }

          if (selection.isCollapsed() && selection.getRng(true).startOffset === 0) {
            var node = selection.getNode();
            var previousSibling = node.previousSibling;

            if (node.nodeName == 'HR') {
              dom.remove(node);
              e.preventDefault();
              return;
            }

            if (previousSibling && previousSibling.nodeName && previousSibling.nodeName.toLowerCase() === "hr") {
              dom.remove(previousSibling);
              e.preventDefault();
            }
          }
        }
      });
    }

    /**
     * Fixes a Gecko bug where the style attribute gets added to the wrong element when deleting between two block elements.
     *
     * Fixes do backspace/delete on this:
     * <p>bla[ck</p><p style="color:red">r]ed</p>
     *
     * Would become:
     * <p>bla|ed</p>
     *
     * Instead of:
     * <p style="color:red">bla|ed</p>
     */
    function removeStylesWhenDeletingAcrossBlockElements() {
      function getAttributeApplyFunction() {
        var template = dom.getAttribs(selection.getStart().cloneNode(false));

        return function () {
          var target = selection.getStart();

          if (target !== dom.getRoot()) {
            dom.setAttrib(target, "style", null);

            each(template, function (attr) {
              target.setAttributeNode(attr.cloneNode(true));
            });
          }
        };
      }

      function isSelectionAcrossElements() {
        return !selection.isCollapsed() &&
          dom.getParent(selection.getStart(), dom.isBlock) != dom.getParent(selection.getEnd(), dom.isBlock);
      }

      editor.onKeyPress.add(function (editor, e) {
        var applyAttributes;

        if (!isDefaultPrevented(e) && (e.keyCode == 8 || e.keyCode == 46) && isSelectionAcrossElements()) {
          applyAttributes = getAttributeApplyFunction();
          editor.getDoc().execCommand('delete', false, null);
          applyAttributes();
          e.preventDefault();
          return false;
        }
      });

      dom.bind(editor.getDoc(), 'cut', function (e) {
        var applyAttributes;

        if (!isDefaultPrevented(e) && isSelectionAcrossElements()) {
          applyAttributes = getAttributeApplyFunction();

          setTimeout(function () {
            applyAttributes();
          }, 0);
        }
      });
    }

    /**
     * Fire a nodeChanged when the selection is changed on WebKit this fixes selection issues on iOS5. It only fires the nodeChange
     * event every 50ms since it would other wise update the UI when you type and it hogs the CPU.
     */
    /*function selectionChangeNodeChanged() {
      var lastRng, selectionTimer;

      dom.bind(editor.getDoc(), 'selectionchange', function () {
        if (selectionTimer) {
          clearTimeout(selectionTimer);
          selectionTimer = 0;
        }

        selectionTimer = window.setTimeout(function () {
          var rng = selection.getRng();

          // Compare the ranges to see if it was a real change or not
          if (!lastRng || !tinymce.dom.RangeUtils.compareRanges(rng, lastRng)) {
            editor.nodeChanged();
            lastRng = rng;
          }
        }, 50);
      });
    }*/

    /**
     * Backspacing into a table behaves differently depending upon browser type.
     * Therefore, disable Backspace when cursor immediately follows a table.
     */
    function disableBackspaceIntoATable() {
      editor.onKeyDown.add(function (editor, e) {
        if (!isDefaultPrevented(e) && e.keyCode === BACKSPACE) {
          if (selection.isCollapsed() && selection.getRng(true).startOffset === 0) {
            var previousSibling = selection.getNode().previousSibling;
            if (previousSibling && previousSibling.nodeName && previousSibling.nodeName.toLowerCase() === "table") {
              e.preventDefault();
              return false;
            }
          }
        }
      });
    }

    /**
     * Backspace or delete on WebKit will combine all visual styles in a span if the last character is deleted.
     *
     * For example backspace on:
     * <p><b>x|</b></p>
     *
     * Will produce:
     * <p><span style="font-weight: bold">|<br></span></p>
     *
     * When it should produce:
     * <p><b>|<br></b></p>
     *
     * See: https://bugs.webkit.org/show_bug.cgi?id=81656
     */
    /*function keepInlineElementOnDeleteBackspace() {
      editor.onKeyDown.add(function (editor, e) {
        var isDelete, rng, container, offset, brElm, sibling, collapsed;

        isDelete = e.keyCode == DELETE;
        if (!isDefaultPrevented(e) && (isDelete || e.keyCode == BACKSPACE) && !VK.modifierPressed(e)) {
          rng = selection.getRng();
          container = rng.startContainer;
          offset = rng.startOffset;
          collapsed = rng.collapsed;

          // Override delete if the start container is a text node and is at the beginning of text or
          // just before/after the last character to be deleted in collapsed mode
          if (container.nodeType == 3 && container.nodeValue.length > 0 && ((offset === 0 && !collapsed) || (collapsed && offset === (isDelete ? 0 : 1)))) {
            // Edge case when deleting <p><b><img> |x</b></p>
            sibling = container.previousSibling;
            if (sibling && sibling.nodeName == "IMG") {
              return;
            }

            nonEmptyElements = editor.schema.getNonEmptyElements();

            // Prevent default logic since it's broken
            e.preventDefault();

            // Insert a BR before the text node this will prevent the containing element from being deleted/converted
            brElm = dom.create('br', {
              id: '__tmp'
            });
            container.parentNode.insertBefore(brElm, container);

            // Do the browser delete
            editor.getDoc().execCommand(isDelete ? 'ForwardDelete' : 'Delete', false, null);

            // Check if the previous sibling is empty after deleting for example: <p><b></b>|</p>
            container = selection.getRng().startContainer;
            sibling = container.previousSibling;
            if (sibling && sibling.nodeType == 1 && !dom.isBlock(sibling) && dom.isEmpty(sibling) && !nonEmptyElements[sibling.nodeName.toLowerCase()]) {
              dom.remove(sibling);
            }

            // Remove the temp element we inserted
            dom.remove('__tmp');
          }
        }
      });
    }*/

    /**
     * Removes a blockquote when backspace is pressed at the beginning of it.
     *
     * For example:
     * <blockquote><p>|x</p></blockquote>
     *
     * Becomes:
     * <p>|x</p>
     */
    function removeBlockQuoteOnBackSpace() {
      // Add block quote deletion handler
      editor.onKeyDown.add(function (editor, e) {
        var rng, container, offset, root, parent;

        if (isDefaultPrevented(e) || e.keyCode != VK.BACKSPACE) {
          return;
        }

        rng = selection.getRng();
        container = rng.startContainer;
        offset = rng.startOffset;
        root = dom.getRoot();
        parent = container;

        if (!rng.collapsed || offset !== 0) {
          return;
        }

        while (parent && parent.parentNode && parent.parentNode.firstChild == parent && parent.parentNode != root) {
          parent = parent.parentNode;
        }

        // Is the cursor at the beginning of a blockquote?
        if (parent.tagName === 'BLOCKQUOTE') {
          // Remove the blockquote
          editor.formatter.toggle('blockquote', null, parent);

          // Move the caret to the beginning of container
          rng = dom.createRng();
          rng.setStart(container, 0);
          rng.setEnd(container, 0);
          selection.setRng(rng);
        }
      });
    }

    /**
     * Sets various Gecko editing options on mouse down and before a execCommand to disable inline table editing that is broken etc.
     */
    function setGeckoEditingOptions() {
      function setOpts() {
        setEditorCommandState("StyleWithCSS", false);
        setEditorCommandState("enableInlineTableEditing", false);

        if (!settings.object_resizing) {
          setEditorCommandState("enableObjectResizing", false);
        }
      }

      if (!settings.readonly) {
        editor.onBeforeExecCommand.add(setOpts);
        editor.onMouseDown.add(setOpts);
      }
    }

    /**
     * Fixes a gecko link bug, when a link is placed at the end of block elements there is
     * no way to move the caret behind the link. This fix adds a bogus br element after the link.
     *
     * For example this:
     * <p><b><a href="#">x</a></b></p>
     *
     * Becomes this:
     * <p><b><a href="#">x</a></b><br></p>
     */
    function addBrAfterLastLinks() {
      function fixLinks() {
        each(dom.select('a'), function (node) {
          var parentNode = node.parentNode,
            root = dom.getRoot();

          if (parentNode.lastChild === node) {
            while (parentNode && !dom.isBlock(parentNode)) {
              if (parentNode.parentNode.lastChild !== parentNode || parentNode === root) {
                return;
              }

              parentNode = parentNode.parentNode;
            }

            dom.add(parentNode, 'br', {
              'data-mce-bogus': 1
            });
          }
        });
      }

      editor.onExecCommand.add(function (editor, cmd) {
        if (cmd === 'mceInsertLink') {
          fixLinks();
        }
      });

      editor.onSetContent.add(fixLinks);
    }

    /**
     * WebKit will produce DIV elements here and there by default. But since TinyMCE uses paragraphs by
     * default we want to change that behavior.
     */
    function setDefaultBlockType() {
      if (settings.forced_root_block) {
        editor.onInit.add(function () {
          setEditorCommandState('DefaultParagraphSeparator', settings.forced_root_block);
        });
      }
    }

    /**
     * Forces Gecko to render a broken image icon if it fails to load an image.
     */
    function showBrokenImageIcon() {
      editor.contentStyles.push(
        'img:-moz-broken {' +
        '-moz-force-broken-image-icon:1;' +
        'min-width:24px;' +
        'min-height:24px' +
        '}'
      );
    }

    /**
     * iOS has a bug where it's impossible to type if the document has a touchstart event
     * bound and the user touches the document while having the on screen keyboard visible.
     *
     * The touch event moves the focus to the parent document while having the caret inside the iframe
     * this fix moves the focus back into the iframe document.
     */
    function restoreFocusOnKeyDown() {
      editor.onKeyDown.add(function () {
        if (document.activeElement == document.body) {
          editor.getWin().focus();
        }
      });
    }

    /**
     * IE 11 has an annoying issue where you can't move focus into the editor
     * by clicking on the white area HTML element. We used to be able to to fix this with
     * the fixCaretSelectionOfDocumentElementOnIe fix. But since M$ removed the selection
     * object it's not possible anymore. So we need to hack in a ungly CSS to force the
     * body to be at least 150px. If the user clicks the HTML element out side this 150px region
     * we simply move the focus into the first paragraph. Not ideal since you loose the
     * positioning of the caret but good enough for most cases.
     */
    function bodyHeight() {
      if (!editor.inline) {
        editor.contentStyles.push('body {min-height: 150px}');
        editor.onClick.add(function (editor, e) {
          var rng;

          if (e.target.nodeName == 'HTML') {
            // Edge seems to only need focus if we set the range
            // the caret will become invisible and moved out of the iframe!!
            if (tinymce.isIE12) {
              editor.getBody().focus();
              return;
            }

            // Need to store away non collapsed ranges since the focus call will mess that up see #7382
            rng = editor.selection.getRng();
            editor.getBody().focus();
            editor.selection.setRng(rng);
            editor.selection.normalize();
            editor.nodeChanged();
          }
        });
      }
    }

    /**
     * Firefox on Mac OS will move the browser back to the previous page if you press CMD+Left arrow.
     * You might then loose all your work so we need to block that behavior and replace it with our own.
     */
    function blockCmdArrowNavigation() {
      if (tinymce.isMac) {
        editor.onKeyDown.add(function (editor, e) {
          if (VK.metaKeyPressed(e) && !e.shiftKey && (e.keyCode == 37 || e.keyCode == 39)) {
            e.preventDefault();
            editor.selection.getSel().modify('move', e.keyCode == 37 ? 'backward' : 'forward', 'lineboundary');
          }
        });
      }
    }

    /**
     * Disables the autolinking in IE 9+ this is then re-enabled by the autolink plugin.
     */
    function disableAutoUrlDetect() {
      setEditorCommandState("AutoUrlDetect", false);
    }

    /**
     * iOS 7.1 introduced two new bugs:
     * 1) It's possible to open links within a contentEditable area by clicking on them.
     * 2) If you hold down the finger it will display the link/image touch callout menu.
     */
    function tapLinksAndImages() {
      editor.onClick.add(function (editor, e) {
        var elm = e.target;

        do {
          if (elm.tagName === 'A') {
            e.preventDefault();
            return;
          }
        } while ((elm = elm.parentNode));
      });

      editor.contentStyles.push('.mce-content-body {-webkit-touch-callout: none}');
    }

    /**
     * iOS Safari and possible other browsers have a bug where it won't fire
     * a click event when a contentEditable is focused. This function fakes click events
     * by using touchstart/touchend and measuring the time and distance travelled.
     */
    /*
    function touchClickEvent() {
      editor.on('touchstart', function(e) {
        var elm, time, startTouch, changedTouches;

        elm = e.target;
        time = new Date().getTime();
        changedTouches = e.changedTouches;

        if (!changedTouches || changedTouches.length > 1) {
          return;
        }

        startTouch = changedTouches[0];

        editor.once('touchend', function(e) {
          var endTouch = e.changedTouches[0], args;

          if (new Date().getTime() - time > 500) {
            return;
          }

          if (Math.abs(startTouch.clientX - endTouch.clientX) > 5) {
            return;
          }

          if (Math.abs(startTouch.clientY - endTouch.clientY) > 5) {
            return;
          }

          args = {
            target: elm
          };

          each('pageX pageY clientX clientY screenX screenY'.split(' '), function(key) {
            args[key] = endTouch[key];
          });

          args = editor.fire('click', args);

          if (!args.isDefaultPrevented()) {
            // iOS WebKit can't place the caret properly once
            // you bind touch events so we need to do this manually
            // TODO: Expand to the closest word? Touble tap still works.
            editor.selection.placeCaretAt(endTouch.clientX, endTouch.clientY);
            editor.nodeChanged();
          }
        });
      });
    }
    */

    /**
     * WebKit has a bug where it will allow forms to be submitted if they are inside a contentEditable element.
     * For example this: <form><button></form>
     */
    function blockFormSubmitInsideEditor() {
      editor.onInit.add(function () {
        editor.dom.bind(editor.getBody(), 'submit', function (e) {
          e.preventDefault();
        });
      });
    }

    /**
     * Sometimes WebKit/Blink generates BR elements with the Apple-interchange-newline class.
     *
     * Scenario:
     *  1) Create a table 2x2.
     *  2) Select and copy cells A2-B2.
     *  3) Paste and it will add BR element to table cell.
     */
    function removeAppleInterchangeBrs() {
      parser.addNodeFilter('br', function (nodes) {
        var i = nodes.length;

        while (i--) {
          if (nodes[i].attr('class') == 'Apple-interchange-newline') {
            nodes[i].remove();
          }
        }
      });
    }

    /**
     * IE cannot set custom contentType's on drag events, and also does not properly drag/drop between
     * editors. This uses a special data:text/mce-internal URL to pass data when drag/drop between editors.
     */
    function ieInternalDragAndDrop() {
      editor.dom.bind('dragstart', function (e) {
        setMceInternalContent(e);
      });

      editor.dom.bind('dragstart', function (e) {
        if (!isDefaultPrevented(e)) {
          var internalContent = getMceInternalContent(e);

          if (internalContent && internalContent.id != editor.id) {
            e.preventDefault();

            var rng = RangeUtils.getCaretRangeFromPoint(e.x, e.y, editor.getDoc());
            selection.setRng(rng);
            insertClipboardContents(internalContent.html);
          }
        }
      });
    }

    function imageFloatLinkBug() {
      editor.onBeforeExecCommand.add(function (ed, cmd) {
        // remove img styles
        if (cmd == 'mceInsertLink') {
          var se = ed.selection,
            n = se.getNode();

          // store class and style
          if (n && n.nodeName == 'IMG') {
            ed.dom.setAttrib(n, 'data-mce-style', n.style.cssText);
            n.style.cssText = null;
          }
        }
      });

      editor.onExecCommand.add(function (ed, cmd) {
        // restore img styles
        if (cmd == 'mceInsertLink') {
          var se = ed.selection,
            n = se.getNode();

          tinymce.each(ed.dom.select('img[data-mce-style]', n), function (el) {
            if (el.parentNode.nodeName == 'A' && !el.style.cssText) {
              el.style.cssText = ed.dom.getAttrib(el, 'data-mce-style');
            }
          });
        }
      });
    }

    /**
     * WebKit has a bug where it isn't possible to select image, hr or anchor elements
     * by clicking on them so we need to fake that.
     */
    function selectControlElements() {
      editor.onClick.add(function (editor, e) {
        var target = e.target;

        function selectElm(e) {
          e.preventDefault();
          selection.select(target);
          editor.nodeChanged();
        }

        // Workaround for bug, http://bugs.webkit.org/show_bug.cgi?id=12250
        // WebKit can't even do simple things like selecting an image
        if (/^(IMG|HR)$/.test(target.nodeName)) {
          selectElm(e);
        }

        if (target.nodeName == 'A' && dom.hasClass(target, 'mce-item-anchor')) {
          selectElm(e);
        }
      });
    }

    /**
     * Fixes selection issues where the caret can be placed between two inline elements like <b>a</b>|<b>b</b>
     * this fix will lean the caret right into the closest inline element.
     */
    function normalizeSelection() {
      var normalize = function (e) {
        if (e.keyCode != 65 || !VK.metaKeyPressed(e)) {
          selection.normalize();
        }
      };

      // Normalize selection for example <b>a</b><i>|a</i> becomes <b>a|</b><i>a</i> except for Ctrl+A since it selects everything
      editor.onKeyUp.add(normalize);
      editor.onMouseUp.add(normalize);
    }

    function inlineBoundary() {
      var marker;

      function isBr(node) {
        return node && node.nodeType == 1 && node.nodeName == 'BR';
      }

      function isRootNode(node) {
        return node == editor.dom.getRoot();
      }

      function isLastChild(node) {
        var parent = node.parentNode;

        if (isRootNode(parent)) {
          return true;
        }

        if (node == parent.lastChild) {
          return true;
        }

        if (node.nextSibling && isBr(node.nextSibling) && node.nextSibling == parent.lastChild) {
          return true;
        }

        return false;
      }

      function isEmpty(node) {
        // is linebreak or empty whitespace text node
        return isBr(node) || (node && node.nodeType == 3 && /^[ \t\r\n]*$/.test(node.nodeValue));
      }

      function isChildOf(container, node) {
        if (node.lastChild && node.lastChild.nodeType == 1) {
          node = node.lastChild;
        }

        return dom.isChildOf(container, node);
      }

      function moveCursorToEnd(e) {
        var rng = selection.getRng(), container = rng.startContainer, node = container.parentNode;

        if (!node || node == editor.dom.getRoot()) {
          return;
        }

        node = dom.getParent(node, 'a,span[data-mce-item="font"]');

        if (!node) {
          return;
        }

        if (!isLastChild(node) && !isEmpty(node.nextSibling)) {
          return;
        }

        function moveToMarker() {
          // Move the caret to the end of the marker
          rng = dom.createRng();
          rng.setStart(marker, 0);
          rng.setEnd(marker, 0);
          rng.collapse();
          selection.setRng(rng);
        }

        if (container.nodeType == 3 && isChildOf(container, node)) {
          var text = container.data;

          if (text && text.length && rng.startOffset == text.length) {
            marker = dom.create('span', { 'data-mce-type': "caret" }, '\uFEFF');

            if (dom.isBlock(node.parentNode) && isLastChild(node)) {
              node.parentNode.appendChild(marker);

              moveToMarker();
              dom.remove(marker);

            } else {
              // edge case for - some text <a href="link.html">link</a><br />
              if (isBr(node.nextSibling) && node.nextSibling == node.parentNode.lastChild) {
                node = node.nextSibling;
              }
              node.insertAdjacentElement('afterend', marker);

              moveToMarker();
            }

            e.preventDefault();
            editor.nodeChanged();
          }
        }
      }

      // Attempt to move caret after a container element like <a> or <code> (use addToTop to remove marker before EnterKey)
      editor.onKeyDown.addToTop(function (editor, e) {
        dom.remove(marker);

        if (e.keyCode == VK.RIGHT) {
          moveCursorToEnd(e);
        }
      });

      editor.onMouseDown.add(function (editor, e) {
        dom.remove(marker);

        moveCursorToEnd(e);
      });
    }

    // All browsers
    normalizeSelection();

    removeBlockQuoteOnBackSpace();
    emptyEditorWhenDeleting();

    inlineBoundary();

    // WebKit
    if (tinymce.isWebKit) {
      cleanupStylesWhenDeleting();
      inputMethodFocus();
      setDefaultBlockType();
      blockFormSubmitInsideEditor();
      disableBackspaceIntoATable();
      removeAppleInterchangeBrs();
      imageFloatLinkBug();
      selectControlElements();
      //touchClickEvent();

      cleanupRuntimeStyles();

      // iOS
      if (tinymce.isIOS) {
        restoreFocusOnKeyDown();
        bodyHeight();
        tapLinksAndImages();
      } else {
        selectAll();
      }
    }

    if (tinymce.isIE) {
      bodyHeight();
      selectAll();
      disableAutoUrlDetect();
      ieInternalDragAndDrop();
    }

    if (tinymce.isIE >= 11) {
      disableBackspaceIntoATable();
    }

    // Gecko
    if (tinymce.isGecko) {
      removeHrOnBackspace();
      removeStylesWhenDeletingAcrossBlockElements();
      setGeckoEditingOptions();
      addBrAfterLastLinks();
      showBrokenImageIcon();
      blockCmdArrowNavigation();
      disableBackspaceIntoATable();
      // added for gecko selection bug on images with a style of display:block
      selectControlElements();
    }
  };

  /**
   * @package   	JCE
   * @copyright 	Copyright (c) 2009-2019 Ryan Demmer. All rights reserved.
   * @license   	GNU/GPL 2 or later - http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
   * JCE is free software. This version may have been modified pursuant
   * to the GNU General Public License, and as distributed it includes or
   * is derivative of works licensed under the GNU General Public License or
   * other free or open source software licenses.
   */

  (function (tinymce) {
    var each = tinymce.each, extend = tinymce.extend;

    var rgba = {}, luma = {}, white = 'rgb(255, 255, 255)';

    var previewElm;

    function getRGBA(val) {
      if (!rgba[val]) {
        var r = 0, b = 0, g = 0, a = 1, values, match;

        if (val.indexOf('#') !== -1) {
          val = val.substr(1);

          // fff -> ffffff
          if (val.length === 3) {
            val += val;
          }

          r = parseInt(val.substring(0, 2), 16);
          g = parseInt(val.substring(2, 4), 16);
          b = parseInt(val.substring(4, 6), 16);

          if (val.length > 6) {
            a = parseInt(val.substring(6, 8), 16);
            a = +(a / 255).toFixed(2);
          }

        } else {
          // remove spaces
          val = val.replace(/\s/g, '');
          match = /^(?:rgb|rgba)\(([^\)]*)\)$/.exec(val);

          if (match) {
            values = match[1].split(',').map(function (x) {
              return parseFloat(x);
            });
          }

          if (values) {
            r = values[0];
            g = values[1];
            b = values[2];

            if (values.length === 4) {
              a = values[3] || 1;
            }
          }
        }

        rgba[val] = { r: r, g: g, b: b, a: a };
      }

      return rgba[val];
    }
    // https://github.com/bgrins/TinyColor/blob/master/tinycolor.js#L75
    function getLuminance(val) {
      if (!luma[val]) {
        var col = getRGBA(val);

        // opacity is set
        /*if (col.a < 1 && color2) {
                  var col2 = getRGBA(color2);

                  col = {
                      r: ((col2.r - col.r) * col.a) + col.r,
                      g: ((col2.g - col.g) * col.a) + col.g,
                      b: ((col2.b - col.b) * col.a) + col.b
                  };
              }*/

        var RsRGB, GsRGB, BsRGB, R, G, B;

        RsRGB = col.r / 255;
        GsRGB = col.g / 255;
        BsRGB = col.b / 255;

        if (RsRGB <= 0.03928) {
          R = RsRGB / 12.92;
        } else {
          R = Math.pow(((RsRGB + 0.055) / 1.055), 2.4);
        }
        if (GsRGB <= 0.03928) {
          G = GsRGB / 12.92;
        } else {
          G = Math.pow(((GsRGB + 0.055) / 1.055), 2.4);
        }
        if (BsRGB <= 0.03928) {
          B = BsRGB / 12.92;
        } else {
          B = Math.pow(((BsRGB + 0.055) / 1.055), 2.4);
        }

        luma[val] = (0.2126 * R) + (0.7152 * G) + (0.0722 * B);

        //luma[val] = 0.2126 * col.r + 0.7152 * col.g + 0.0722 * col.b; // per ITU-R BT.709
      }

      return luma[val];
    }

    // https://github.com/bgrins/TinyColor/blob/master/tinycolor.js#L726
    function isReadable(color1, color2) {
      var l1 = getLuminance(color1);
      var l2 = getLuminance(color2);

      var lvl = (Math.max(l1, l2) + 0.05) / (Math.min(l1, l2) + 0.05);

      return lvl >= 2;
    }

    var resetElm = function () {
      if (previewElm && previewElm.parentNode) {
        previewElm.parentNode.removeChild(previewElm);

        previewElm = null;
      }
    };

    var getCssText = function (ed, fmt, reset) {
      var name, dom = ed.dom,
        previewCss = {};

      fmt = extend({ styles: [], attributes: [], classes: '' }, fmt);

      var previewStyles = ed.settings.preview_styles;

      // No preview forced
      if (previewStyles === false) {
        return '';
      }

      // Default preview
      if (!previewStyles) {
        previewStyles = 'font-family font-size font-weight text-decoration text-transform background-color color';
      }

      // Removes any variables since these can't be previewed
      function removeVars(val) {
        if (val && typeof (val) === "string") {
          val = val.replace(/%(\w+)/g, '');
        }

        return val;
      }

      // Create block/inline element to use for preview
      name = fmt.block || fmt.inline || 'div';

      if (!previewElm || previewElm.nodeName != name.toUpperCase()) {
        previewElm = dom.create(name);
        ed.getBody().appendChild(previewElm);
      }

      // clear preview element
      dom.removeAllAttribs(previewElm);

      // Add format styles to preview element
      each(fmt.styles, function (value, name) {
        value = removeVars(value);

        if (value) {
          dom.setStyle(previewElm, name, value);
        }
      });

      // Add attributes to preview element
      each(fmt.attributes, function (value, name) {
        value = removeVars(value);

        if (value) {
          dom.setAttrib(previewElm, name, value);
        }
      });

      // Add classes to preview element
      each(fmt.classes, function (value) {
        value = removeVars(value);

        dom.addClass(previewElm, value);
      });

      // Add the previewElm outside the visual area
      dom.setStyles(previewElm, {
        position: 'absolute',
        left: -0xFFFF
      });

      previewElm.setAttribute('data-mce-type', 'temp');

      // get body background color and element background color
      var bodybg = dom.getStyle(ed.getBody(), 'background-color', true), elmbg = dom.getStyle(previewElm, 'background-color', true);

      var styles = previewStyles.split(' ');

      var css = '';

      for (var i = 0, len = styles.length; i < len; i++) {
        var key = styles[i], value = dom.getStyle(previewElm, key, true);

        // skip if already added
        if (previewCss[key]) {
          continue;
        }

        // If text color is white and the background color is white or transparent, override with default color
        if (key == 'color') {
          // default to white if transparent
          if (/transparent|rgba\s*\([^)]+,\s*0\)/.test(elmbg)) {
            elmbg = white;
          }

          // if background color produces unreadable text, try body background color
          if (!isReadable(value, elmbg)) {
            // use body background color
            if (value && isReadable(value, bodybg)) {
              value = bodybg;
            } else {
              value = 'inherit';
            }
          }
        }

        // default to inherit
        if (!value) {
          value = 'inherit';
        }

        // set to default if value is 0
        if (key == 'font-size' && parseInt(value, 10) === 0) {
          value = 'inherit';
        }

        previewCss[key] = value;

        css += key + ':' + value + ';';
      }

      if (reset) {
        resetElm();
      }

      return css;
    };

    tinymce.util.PreviewCss = {
      getCssText: getCssText,
      reset: resetElm
    };
  })(tinymce);

  /**
   * Arr.js
   *
   * Released under LGPL License.
   * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
   *
   * License: http://www.tinymce.com/license - Inactive
   * Licence: GNU/LGPL 2.1 or later - http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
   * Contributing: http://www.tinymce.com/contributing - Inactive
   */

  /**
   * Array utility class.
   *
   * @private
   * @class tinymce.util.Arr
   */
  (function (tinymce) {
    var isArray = Array.isArray || function (obj) {
      return Object.prototype.toString.call(obj) === "[object Array]";
    };

    function toArray(obj) {
      var array = obj,
        i, l;

      if (!isArray(obj)) {
        array = [];
        for (i = 0, l = obj.length; i < l; i++) {
          array[i] = obj[i];
        }
      }

      return array;
    }

    function each(o, cb, s) {
      var n, l;

      if (!o) {
        return 0;
      }

      s = s || o;

      if (o.length !== undefined) {
        // Indexed arrays, needed for Safari
        for (n = 0, l = o.length; n < l; n++) {
          if (cb.call(s, o[n], n, o) === false) {
            return 0;
          }
        }
      } else {
        // Hashtables
        for (n in o) {
          if (o.hasOwnProperty(n)) {
            if (cb.call(s, o[n], n, o) === false) {
              return 0;
            }
          }
        }
      }

      return 1;
    }

    function map(array, callback) {
      var out = [];

      each(array, function (item, index) {
        out.push(callback(item, index, array));
      });

      return out;
    }

    function filter(a, f) {
      var o = [];

      each(a, function (v, index) {
        if (!f || f(v, index, a)) {
          o.push(v);
        }
      });

      return o;
    }

    function indexOf(a, v) {
      var i, l;

      if (a) {
        for (i = 0, l = a.length; i < l; i++) {
          if (a[i] === v) {
            return i;
          }
        }
      }

      return -1;
    }

    function contains(a, v) {
      return indexOf(a, v) > -1;
    }

    function forall(xs, pred) {
      for (var i = 0, len = xs.length; i < len; ++i) {
        var x = xs[i];
        if (pred(x, i) !== true) {
          return false;
        }
      }
      return true;
    }

    function reduce(collection, iteratee, accumulator, thisArg) {
      var i = 0;

      if (arguments.length < 3) {
        accumulator = collection[0];
      }

      for (; i < collection.length; i++) {
        accumulator = iteratee.call(thisArg, accumulator, collection[i], i);
      }

      return accumulator;
    }

    function findIndex(array, predicate, thisArg) {
      var i, l;

      for (i = 0, l = array.length; i < l; i++) {
        if (predicate.call(thisArg, array[i], i, array)) {
          return i;
        }
      }

      return -1;
    }

    function find(array, predicate, thisArg) {
      var idx = findIndex(array, predicate, thisArg);

      if (idx !== -1) {
        return array[idx];
      }

      return undefined;
    }

    function last(collection) {
      return collection[collection.length - 1];
    }

    function toObject(array, callback) {
      var i, l, object = {};

      for (i = 0, l = array.length; i < l; i++) {
        var x = array[i];
        object[x] = callback(x, i);
      }

      return object;
    }

    function flat(arr) {
      var i, l, out = [];

      for (i = 0, l = arr.length; i < l; i++) {
        if (isArray(arr[i])) {
          Array.prototype.push.apply(out, arr[i]);
        }
      }

      return out;
    }

    function flatMap(array, callback) {
      var output = map(array, callback);
      return flat(output);
    }

    tinymce.util.Arr = {
      isArray: isArray,
      toArray: toArray,
      each: each,
      map: map,
      filter: filter,
      indexOf: indexOf,
      reduce: reduce,
      findIndex: findIndex,
      find: find,
      last: last,
      toObject: toObject,
      flat: flat,
      flatMap: flatMap,
      bind: flatMap,
      contains: contains,
      forall: forall
    };
  })(tinymce);

  /**
   * Fun.js
   *
   * Released under LGPL License.
   * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
   *
   * License: http://www.tinymce.com/license - Inactive
   * Licence: GNU/LGPL 2.1 or later - http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
   * Contributing: http://www.tinymce.com/contributing - Inactive
   */

  /**
   * Functional utility class.
   *
   * @private
   * @class tinymce.util.Fun
   */
  (function (tinymce) {
    var slice = [].slice;

    function constant(value) {
      return function () {
        return value;
      };
    }

    function negate(predicate) {
      return function (x) {
        return !predicate(x);
      };
    }

    function compose(f, g) {
      return function (x) {
        return f(g(x));
      };
    }

    function or() {
      var args = slice.call(arguments);

      return function (x) {
        for (var i = 0; i < args.length; i++) {
          if (args[i](x)) {
            return true;
          }
        }

        return false;
      };
    }

    function and() {
      var args = slice.call(arguments);

      return function (x) {
        for (var i = 0; i < args.length; i++) {
          if (!args[i](x)) {
            return false;
          }
        }

        return true;
      };
    }

    var curry = function (fn) {
      var args = slice.call(arguments);

      if (args.length - 1 >= fn.length) {
        return fn.apply(this, args.slice(1));
      }

      return function () {
        var tempArgs = args.concat([].slice.call(arguments));
        return curry.apply(this, tempArgs);
      };
    };

    function noop() { }

    tinymce.util.Fun = {
      constant: constant,
      negate: negate,
      and: and,
      or: or,
      curry: curry,
      compose: compose,
      noop: noop
    };
  })(tinymce);

  /**
   * BlobCache.js
   *
   * Released under LGPL License.
   * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
   *
   * License: http://www.tinymce.com/license - Inactive
   * Licence: GNU/LGPL 2.1 or later - http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
   * Contributing: http://www.tinymce.com/contributing - Inactive
   */

  /**
   * Hold blob info objects where a blob has extra internal information.
   *
   * @private
   * @class tinymce.file.BlobCache
   */


  var Arr = tinymce.util.Arr, Fun = tinymce.util.Fun, Uuid = tinymce.util.Uuid;

  var cache = [],
    constant = Fun.constant;

  function mimeToExt(mime) {
    var mimes = {
      'image/jpeg': 'jpg',
      'image/jpg': 'jpg',
      'image/gif': 'gif',
      'image/png': 'png'
    };

    return mimes[mime.toLowerCase()] || 'dat';
  }

  function create$1(o, blob, base64, filename) {
    return typeof o === 'object' ? toBlobInfo(o) : toBlobInfo({
      id: o,
      name: filename,
      blob: blob,
      base64: base64
    });
  }

  function toBlobInfo(o) {
    var id, name;

    if (!o.blob || !o.base64) {
      throw "blob and base64 representations of the image are required for BlobInfo to be created";
    }

    id = o.id || Uuid.uuid('blobid');
    name = o.name || id;

    return {
      id: constant(id),
      name: constant(name),
      filename: constant(name + '.' + mimeToExt(o.blob.type)),
      blob: constant(o.blob),
      base64: constant(o.base64),
      blobUri: constant(o.blobUri || URL.createObjectURL(o.blob)),
      uri: constant(o.uri)
    };
  }

  function add(blobInfo) {
    if (!get(blobInfo.id())) {
      cache.push(blobInfo);
    }
  }

  function get(id) {
    return findFirst(function (cachedBlobInfo) {
      return cachedBlobInfo.id() === id;
    });
  }

  function findFirst(predicate) {
    return Arr.filter(cache, predicate)[0];
  }

  function getByUri(blobUri) {
    return findFirst(function (blobInfo) {
      return blobInfo.blobUri() == blobUri;
    });
  }

  function removeByUri(blobUri) {
    cache = Arr.filter(cache, function (blobInfo) {
      if (blobInfo.blobUri() === blobUri) {
        URL.revokeObjectURL(blobInfo.blobUri());
        return false;
      }

      return true;
    });
  }

  function destroy() {
    Arr.each(cache, function (cachedBlobInfo) {
      URL.revokeObjectURL(cachedBlobInfo.blobUri());
    });

    cache = [];
  }

  tinymce.file.BlobCache = {
    create: create$1,
    add: add,
    get: get,
    getByUri: getByUri,
    findFirst: findFirst,
    removeByUri: removeByUri,
    destroy: destroy
  };

  /**
   * Conversions.js
   *
   * Released under LGPL License.
   * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
   *
   * License: http://www.tinymce.com/license - Inactive
   * Licence: GNU/LGPL 2.1 or later - http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
   * Contributing: http://www.tinymce.com/contributing - Inactive
   */

  /**
   * Converts blob/uris back and forth.
   *
   * @private
   * @class tinymce.file.Conversions
   */

  function blobUriToBlob(url) {
    return new Promise(function (resolve, reject) {

      var rejectWithError = function () {
        reject("Cannot convert " + url + " to Blob. Resource might not exist or is inaccessible.");
      };

      try {
        var xhr = new XMLHttpRequest();

        xhr.open('GET', url, true);
        xhr.responseType = 'blob';

        xhr.onload = function () {
          if (this.status == 200) {
            resolve(this.response);
          } else {
            // IE11 makes it into onload but responds with status 500
            rejectWithError();
          }
        };

        // Chrome fires an error event instead of the exception
        // Also there seems to be no way to intercept the message that is logged to the console
        xhr.onerror = rejectWithError;

        xhr.send();
      } catch (ex) {
        rejectWithError();
      }
    });
  }

  function parseDataUri(uri) {
    var type, matches;

    uri = decodeURIComponent(uri).split(',');

    matches = /data:([^;]+)/.exec(uri[0]);
    if (matches) {
      type = matches[1];
    }

    return {
      type: type,
      data: uri[1]
    };
  }

  function dataUriToBlob(uri) {
    return new Promise(function (resolve) {
      var str, arr, i;

      uri = parseDataUri(uri);

      // Might throw error if data isn't proper base64
      try {
        str = atob(uri.data);
      } catch (e) {
        resolve(new Blob([]));
        return;
      }

      arr = new Uint8Array(str.length);

      for (i = 0; i < arr.length; i++) {
        arr[i] = str.charCodeAt(i);
      }

      resolve(new Blob([arr], {
        type: uri.type
      }));
    });
  }

  function uriToBlob(url) {
    if (url.indexOf('blob:') === 0) {
      return blobUriToBlob(url);
    }

    if (url.indexOf('data:') === 0) {
      return dataUriToBlob(url);
    }

    return null;
  }

  function blobToDataUri(blob) {
    return new Promise(function (resolve) {
      var reader = new FileReader();

      reader.onloadend = function () {
        resolve(reader.result);
      };

      reader.readAsDataURL(blob);
    });
  }

  tinymce.file.Conversions = {
    uriToBlob: uriToBlob,
    blobToDataUri: blobToDataUri,
    parseDataUri: parseDataUri
  };

  /**
   * Entities.js
   *
   * Copyright, Moxiecode Systems AB
   * Released under LGPL License.
   *
   * License: http://www.tinymce.com/license - Inactive
   * Licence: GNU/LGPL 2.1 or later - http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
   * Contributing: http://www.tinymce.com/contributing - Inactive
   */

  /*jshint bitwise:false */
  /*eslint no-bitwise:0 */

  (function (tinymce) {
    var namedEntities, baseEntities, reverseEntities,
      attrsCharsRegExp = /[&<>\"\u0060\u007E-\uD7FF\uE000-\uFFEF]|[\uD800-\uDBFF][\uDC00-\uDFFF]/g,
      textCharsRegExp = /[<>&\u007E-\uD7FF\uE000-\uFFEF]|[\uD800-\uDBFF][\uDC00-\uDFFF]/g,
      rawCharsRegExp = /[<>&\"\']/g,
      entityRegExp = /&#([a-z0-9]+);?|&([a-z0-9]+);/gi,
      asciiMap = {
        128: "\u20AC",
        130: "\u201A",
        131: "\u0192",
        132: "\u201E",
        133: "\u2026",
        134: "\u2020",
        135: "\u2021",
        136: "\u02C6",
        137: "\u2030",
        138: "\u0160",
        139: "\u2039",
        140: "\u0152",
        142: "\u017D",
        145: "\u2018",
        146: "\u2019",
        147: "\u201C",
        148: "\u201D",
        149: "\u2022",
        150: "\u2013",
        151: "\u2014",
        152: "\u02DC",
        153: "\u2122",
        154: "\u0161",
        155: "\u203A",
        156: "\u0153",
        158: "\u017E",
        159: "\u0178"
      };

    // Raw entities
    baseEntities = {
      '\"': '&quot;', // Needs to be escaped since the YUI compressor would otherwise break the code
      "'": '&#39;',
      '<': '&lt;',
      '>': '&gt;',
      '&': '&amp;',
      '\u0060': '&#96;'
    };

    // Reverse lookup table for raw entities
    reverseEntities = {
      '&lt;': '<',
      '&gt;': '>',
      '&amp;': '&',
      '&quot;': '"',
      '&apos;': "'"
    };

    // Decodes text by using the browser
    function nativeDecode(text) {
      var elm;

      elm = document.createElement("div");
      elm.innerHTML = text;

      return elm.textContent || elm.innerText || text;
    }

    // Build a two way lookup table for the entities
    function buildEntitiesLookup(items, radix) {
      var i, chr, entity, lookup = {};

      if (items) {
        items = items.split(',');
        radix = radix || 10;

        // Build entities lookup table
        for (i = 0; i < items.length; i += 2) {
          chr = String.fromCharCode(parseInt(items[i], radix));

          // Only add non base entities
          if (!baseEntities[chr]) {
            entity = '&' + items[i + 1] + ';';
            lookup[chr] = entity;
            lookup[entity] = chr;
          }
        }

        return lookup;
      }
    }

    // Unpack entities lookup where the numbers are in radix 32 to reduce the size
    namedEntities = buildEntitiesLookup(
      '50,nbsp,51,iexcl,52,cent,53,pound,54,curren,55,yen,56,brvbar,57,sect,58,uml,59,copy,' +
          '5a,ordf,5b,laquo,5c,not,5d,shy,5e,reg,5f,macr,5g,deg,5h,plusmn,5i,sup2,5j,sup3,5k,acute,' +
          '5l,micro,5m,para,5n,middot,5o,cedil,5p,sup1,5q,ordm,5r,raquo,5s,frac14,5t,frac12,5u,frac34,' +
          '5v,iquest,60,Agrave,61,Aacute,62,Acirc,63,Atilde,64,Auml,65,Aring,66,AElig,67,Ccedil,' +
          '68,Egrave,69,Eacute,6a,Ecirc,6b,Euml,6c,Igrave,6d,Iacute,6e,Icirc,6f,Iuml,6g,ETH,6h,Ntilde,' +
          '6i,Ograve,6j,Oacute,6k,Ocirc,6l,Otilde,6m,Ouml,6n,times,6o,Oslash,6p,Ugrave,6q,Uacute,' +
          '6r,Ucirc,6s,Uuml,6t,Yacute,6u,THORN,6v,szlig,70,agrave,71,aacute,72,acirc,73,atilde,74,auml,' +
          '75,aring,76,aelig,77,ccedil,78,egrave,79,eacute,7a,ecirc,7b,euml,7c,igrave,7d,iacute,7e,icirc,' +
          '7f,iuml,7g,eth,7h,ntilde,7i,ograve,7j,oacute,7k,ocirc,7l,otilde,7m,ouml,7n,divide,7o,oslash,' +
          '7p,ugrave,7q,uacute,7r,ucirc,7s,uuml,7t,yacute,7u,thorn,7v,yuml,ci,fnof,sh,Alpha,si,Beta,' +
          'sj,Gamma,sk,Delta,sl,Epsilon,sm,Zeta,sn,Eta,so,Theta,sp,Iota,sq,Kappa,sr,Lambda,ss,Mu,' +
          'st,Nu,su,Xi,sv,Omicron,t0,Pi,t1,Rho,t3,Sigma,t4,Tau,t5,Upsilon,t6,Phi,t7,Chi,t8,Psi,' +
          't9,Omega,th,alpha,ti,beta,tj,gamma,tk,delta,tl,epsilon,tm,zeta,tn,eta,to,theta,tp,iota,' +
          'tq,kappa,tr,lambda,ts,mu,tt,nu,tu,xi,tv,omicron,u0,pi,u1,rho,u2,sigmaf,u3,sigma,u4,tau,' +
          'u5,upsilon,u6,phi,u7,chi,u8,psi,u9,omega,uh,thetasym,ui,upsih,um,piv,812,bull,816,hellip,' +
          '81i,prime,81j,Prime,81u,oline,824,frasl,88o,weierp,88h,image,88s,real,892,trade,89l,alefsym,' +
          '8cg,larr,8ch,uarr,8ci,rarr,8cj,darr,8ck,harr,8dl,crarr,8eg,lArr,8eh,uArr,8ei,rArr,8ej,dArr,' +
          '8ek,hArr,8g0,forall,8g2,part,8g3,exist,8g5,empty,8g7,nabla,8g8,isin,8g9,notin,8gb,ni,8gf,prod,' +
          '8gh,sum,8gi,minus,8gn,lowast,8gq,radic,8gt,prop,8gu,infin,8h0,ang,8h7,and,8h8,or,8h9,cap,8ha,cup,' +
          '8hb,int,8hk,there4,8hs,sim,8i5,cong,8i8,asymp,8j0,ne,8j1,equiv,8j4,le,8j5,ge,8k2,sub,8k3,sup,8k4,' +
          'nsub,8k6,sube,8k7,supe,8kl,oplus,8kn,otimes,8l5,perp,8m5,sdot,8o8,lceil,8o9,rceil,8oa,lfloor,8ob,' +
          'rfloor,8p9,lang,8pa,rang,9ea,loz,9j0,spades,9j3,clubs,9j5,hearts,9j6,diams,ai,OElig,aj,oelig,b0,' +
          'Scaron,b1,scaron,bo,Yuml,m6,circ,ms,tilde,802,ensp,803,emsp,809,thinsp,80c,zwnj,80d,zwj,80e,lrm,' +
          '80f,rlm,80j,ndash,80k,mdash,80o,lsquo,80p,rsquo,80q,sbquo,80s,ldquo,80t,rdquo,80u,bdquo,810,dagger,' +
          '811,Dagger,81g,permil,81p,lsaquo,81q,rsaquo,85c,euro', 32);

    tinymce.html = tinymce.html || {};

    /**
       * Entity encoder class.
       *
       * @class tinymce.html.SaxParser
       * @static
       * @version 3.4
       */
    tinymce.html.Entities = {
      /**
           * Encodes the specified string using raw entities. This means only the required XML base entities will be encoded.
           *
           * @method encodeRaw
           * @param {String} text Text to encode.
           * @param {Boolean} attr Optional flag to specify if the text is attribute contents.
           * @return {String} Entity encoded text.
           */
      encodeRaw: function (text, attr) {
        return text.replace(attr ? attrsCharsRegExp : textCharsRegExp, function (chr) {
          return baseEntities[chr] || chr;
        });
      },

      /**
           * Encoded the specified text with both the attributes and text entities. This function will produce larger text contents
           * since it doesn't know if the context is within a attribute or text node. This was added for compatibility
           * and is exposed as the DOMUtils.encode function.
           *
           * @method encodeAllRaw
           * @param {String} text Text to encode.
           * @return {String} Entity encoded text.
           */
      encodeAllRaw: function (text) {
        return ('' + text).replace(rawCharsRegExp, function (chr) {
          return baseEntities[chr] || chr;
        });
      },

      /**
           * Encodes the specified string using numeric entities. The core entities will be
           * encoded as named ones but all non lower ascii characters will be encoded into numeric entities.
           *
           * @method encodeNumeric
           * @param {String} text Text to encode.
           * @param {Boolean} attr Optional flag to specify if the text is attribute contents.
           * @return {String} Entity encoded text.
           */
      encodeNumeric: function (text, attr) {
        return text.replace(attr ? attrsCharsRegExp : textCharsRegExp, function (chr) {
          // Multi byte sequence convert it to a single entity
          if (chr.length > 1) {
            return '&#' + (((chr.charCodeAt(0) - 0xD800) * 0x400) + (chr.charCodeAt(1) - 0xDC00) + 0x10000) + ';';
          }

          return baseEntities[chr] || '&#' + chr.charCodeAt(0) + ';';
        });
      },

      /**
           * Encodes the specified string using named entities. The core entities will be encoded
           * as named ones but all non lower ascii characters will be encoded into named entities.
           *
           * @method encodeNamed
           * @param {String} text Text to encode.
           * @param {Boolean} attr Optional flag to specify if the text is attribute contents.
           * @param {Object} entities Optional parameter with entities to use.
           * @return {String} Entity encoded text.
           */
      encodeNamed: function (text, attr, entities) {
        entities = entities || namedEntities;

        return text.replace(attr ? attrsCharsRegExp : textCharsRegExp, function (chr) {
          return baseEntities[chr] || entities[chr] || chr;
        });
      },

      /**
           * Returns an encode function based on the name(s) and it's optional entities.
           *
           * @method getEncodeFunc
           * @param {String} name Comma separated list of encoders for example named,numeric.
           * @param {String} entities Optional parameter with entities to use instead of the built in set.
           * @return {function} Encode function to be used.
           */
      getEncodeFunc: function (name, entities) {
        var Entities = tinymce.html.Entities;

        entities = buildEntitiesLookup(entities) || namedEntities;

        function encodeNamedAndNumeric(text, attr) {
          return text.replace(attr ? attrsCharsRegExp : textCharsRegExp, function (chr) {
            return baseEntities[chr] || entities[chr] || '&#' + chr.charCodeAt(0) + ';' || chr;
          });
        }

        function encodeCustomNamed(text, attr) {
          return Entities.encodeNamed(text, attr, entities);
        }

        // Replace + with , to be compatible with previous TinyMCE versions
        name = tinymce.makeMap(name.replace(/\+/g, ','));

        // Named and numeric encoder
        if (name.named && name.numeric) {
          return encodeNamedAndNumeric;
        }

        // Named encoder
        if (name.named) {
          // Custom names
          if (entities) {
            return encodeCustomNamed;
          }

          return Entities.encodeNamed;
        }

        // Numeric
        if (name.numeric) {
          return Entities.encodeNumeric;
        }

        // Raw encoder
        return Entities.encodeRaw;
      },

      /**
           * Decodes the specified string, this will replace entities with raw UTF characters.
           *
           * @method decode
           * @param {String} text Text to entity decode.
           * @return {String} Entity decoded string.
           */
      decode: function (text) {
        return text.replace(entityRegExp, function (all, numeric) {
          if (numeric) {
            if (numeric.charAt(0).toLowerCase() === 'x') {
              numeric = parseInt(numeric.substr(1), 16);
            } else {
              numeric = parseInt(numeric, 10);
            }

            // Support upper UTF
            if (numeric > 0xFFFF) {
              numeric -= 0x10000;

              return String.fromCharCode(0xD800 + (numeric >> 10), 0xDC00 + (numeric & 0x3FF));
            }

            return asciiMap[numeric] || String.fromCharCode(numeric);
          }

          return reverseEntities[all] || namedEntities[all] || nativeDecode(all);
        });
      }
    };
  })(tinymce);

  /**
   * Styles.js
   *
   * Copyright, Moxiecode Systems AB
   * Released under LGPL License.
   *
   * License: http://www.tinymce.com/license - Inactive
   * Licence: GNU/LGPL 2.1 or later - http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
   * Contributing: http://www.tinymce.com/contributing - Inactive
   */

  /**
   * This class is used to parse CSS styles it also compresses styles to reduce the output size.
   *
   * @example
   * var Styles = new tinymce.html.Styles({
   *    url_converter: function(url) {
   *       return url;
   *    }
   * });
   *
   * styles = Styles.parse('border: 1px solid red');
   * styles.color = 'red';
   *
   * console.log(new tinymce.html.StyleSerializer().serialize(styles));
   *
   * @class tinymce.html.Styles
   * @version 3.4
   */
  tinymce.html.Styles = function (settings, schema) {
  	/*jshint maxlen:255 */
  	/*eslint max-len:0 */
  	var rgbRegExp = /rgb\s*\(\s*([0-9]+)\s*,\s*([0-9]+)\s*,\s*([0-9]+)\s*\)/gi,
  		urlOrStrRegExp = /(?:url(?:(?:\(\s*\"([^\"]+)\"\s*\))|(?:\(\s*\'([^\']+)\'\s*\))|(?:\(\s*([^)\s]+)\s*\))))|(?:\'([^\']+)\')|(?:\"([^\"]+)\")/gi,
  		styleRegExp = /\s*([^:]+):\s*([^;]+);?/g,
  		trimRightRegExp = /\s+$/,
  		undef, i, encodingLookup = {},
  		encodingItems, validStyles, invalidStyles, invisibleChar = '\uFEFF';

  	settings = settings || {};

  	if (schema) {
  		validStyles = schema.getValidStyles();
  		invalidStyles = schema.getInvalidStyles();
  	}

  	encodingItems = ('\\" \\\' \\; \\: ; : ' + invisibleChar).split(' ');
  	for (i = 0; i < encodingItems.length; i++) {
  		encodingLookup[encodingItems[i]] = invisibleChar + i;
  		encodingLookup[invisibleChar + i] = encodingItems[i];
  	}

  	function toHex(match, r, g, b) {
  		function hex(val) {
  			val = parseInt(val, 10).toString(16);

  			return val.length > 1 ? val : '0' + val; // 0 -> 00
  		}

  		return '#' + hex(r) + hex(g) + hex(b);
  	}

  	return {
  		/**
  		 * Parses the specified RGB color value and returns a hex version of that color.
  		 *
  		 * @method toHex
  		 * @param {String} color RGB string value like rgb(1,2,3)
  		 * @return {String} Hex version of that RGB value like #FF00FF.
  		 */
  		toHex: function (color) {
  			return color.replace(rgbRegExp, toHex);
  		},

  		/**
  		 * Parses the specified style value into an object collection. This parser will also
  		 * merge and remove any redundant items that browsers might have added. It will also convert non hex
  		 * colors to hex values. Urls inside the styles will also be converted to absolute/relative based on settings.
  		 *
  		 * @method parse
  		 * @param {String} css Style value to parse for example: border:1px solid red;.
  		 * @return {Object} Object representation of that style like {border: '1px solid red'}
  		 */
  		parse: function (css) {
  			var styles = {},
  				matches, name, value, isEncoded, urlConverter = settings.url_converter;
  			var urlConverterScope = settings.url_converter_scope || this;

  			function compress(prefix, suffix, noJoin) {
  				var top, right, bottom, left;

  				top = styles[prefix + '-top' + suffix];
  				if (!top) {
  					return;
  				}

  				right = styles[prefix + '-right' + suffix];
  				if (!right) {
  					return;
  				}

  				bottom = styles[prefix + '-bottom' + suffix];
  				if (!bottom) {
  					return;
  				}

  				left = styles[prefix + '-left' + suffix];
  				if (!left) {
  					return;
  				}

  				var box = [top, right, bottom, left];
  				i = box.length - 1;
  				while (i--) {
  					if (box[i] !== box[i + 1]) {
  						break;
  					}
  				}

  				if (i > -1 && noJoin) {
  					return;
  				}

  				styles[prefix + suffix] = i == -1 ? box[0] : box.join(' ');
  				delete styles[prefix + '-top' + suffix];
  				delete styles[prefix + '-right' + suffix];
  				delete styles[prefix + '-bottom' + suffix];
  				delete styles[prefix + '-left' + suffix];
  			}

  			/**
  			 * Checks if the specific style can be compressed in other words if all border-width are equal.
  			 */
  			function canCompress(key) {
  				var value = styles[key],
  					i;

  				if (!value) {
  					return;
  				}

  				value = value.split(' ');
  				i = value.length;
  				while (i--) {
  					if (value[i] !== value[0]) {
  						return false;
  					}
  				}

  				styles[key] = value[0];

  				return true;
  			}

  			/**
  			 * Compresses multiple styles into one style.
  			 */
  			function compress2(target, a, b, c) {
  				if (!canCompress(a)) {
  					return;
  				}

  				if (!canCompress(b)) {
  					return;
  				}

  				if (!canCompress(c)) {
  					return;
  				}

  				// Compress
  				styles[target] = styles[a] + ' ' + styles[b] + ' ' + styles[c];
  				delete styles[a];
  				delete styles[b];
  				delete styles[c];
  			}

  			// Encodes the specified string by replacing all \" \' ; : with _<num>
  			function encode(str) {
  				isEncoded = true;

  				return encodingLookup[str];
  			}

  			// Decodes the specified string by replacing all _<num> with it's original value \" \' etc
  			// It will also decode the \" \' if keep_slashes is set to fale or omitted
  			function decode(str, keep_slashes) {
  				if (isEncoded) {
  					str = str.replace(/\uFEFF[0-9]/g, function (str) {
  						return encodingLookup[str];
  					});
  				}

  				if (!keep_slashes) {
  					str = str.replace(/\\([\'\";:])/g, "$1");
  				}

  				return str;
  			}

  			function processUrl(match, url, url2, url3, str, str2) {
  				str = str || str2;

  				if (str) {
  					str = decode(str);

  					// Force strings into single quote format
  					return "'" + str.replace(/\'/g, "\\'") + "'";
  				}

  				url = decode(url || url2 || url3);

  				if (!settings.allow_script_urls) {
  					var scriptUrl = url.replace(/[\s\r\n]+/, '');

  					if (/(java|vb)script:/i.test(scriptUrl)) {
  						return "";
  					}

  					if (!settings.allow_svg_data_urls && /^data:image\/svg/i.test(scriptUrl)) {
  						return "";
  					}
  				}

  				// Convert the URL to relative/absolute depending on config
  				if (urlConverter) {
  					url = urlConverter.call(urlConverterScope, url, 'style');
  				}

  				// Output new URL format
  				return "url('" + url.replace(/\'/g, "\\'") + "')";
  			}

  			if (css) {
  				css = css.replace(/[\u0000-\u001F]/g, '');

  				// Encode \" \' % and ; and : inside strings so they don't interfere with the style parsing
  				css = css.replace(/\\[\"\';:\uFEFF]/g, encode).replace(/\"[^\"]+\"|\'[^\']+\'/g, function (str) {
  					return str.replace(/[;:]/g, encode);
  				});

  				// Parse styles
  				while ((matches = styleRegExp.exec(css))) {
  					name = matches[1].replace(trimRightRegExp, '').toLowerCase();
  					value = matches[2].replace(trimRightRegExp, '');

  					// Decode escaped sequences like \65 -> e
  					/*jshint loopfunc:true*/
  					/*eslint no-loop-func:0 */
  					value = value.replace(/\\[0-9a-f]+/g, function (e) {
  						return String.fromCharCode(parseInt(e.substr(1), 16));
  					});

  					if (name && value.length > 0) {
  						// Don't allow behavior name or expression/comments within the values
  						if (!settings.allow_script_urls && (name == "behavior" || /expression\s*\(|\/\*|\*\//.test(value))) {
  							continue;
  						}

  						// Opera will produce 700 instead of bold in their style values
  						if (name === 'font-weight' && value === '700') {
  							value = 'bold';
  						} else if (name === 'color' || name === 'background-color') { // Lowercase colors like RED
  							value = value.toLowerCase();
  						}

  						// Convert RGB colors to HEX
  						value = value.replace(rgbRegExp, toHex);

  						// Convert URLs and force them into url('value') format
  						value = value.replace(urlOrStrRegExp, processUrl);
  						styles[name] = isEncoded ? decode(value, true) : value;
  					}

  					styleRegExp.lastIndex = matches.index + matches[0].length;
  				}
  				// Compress the styles to reduce it's size for example IE will expand styles
  				compress("border", "", true);
  				compress("border", "-width");
  				compress("border", "-color");
  				compress("border", "-style");
  				compress("padding", "");
  				compress("margin", "");
  				compress2('border', 'border-width', 'border-style', 'border-color');

  				// Remove pointless border, IE produces these
  				if (styles.border === 'medium none') {
  					delete styles.border;
  				}

  				// IE 11 will produce a border-image: none when getting the style attribute from <p style="border: 1px solid red"></p>
  				// So lets asume it shouldn't be there
  				if (styles['border-image'] === 'none') {
  					delete styles['border-image'];
  				}
  			}

  			return styles;
  		},

  		/**
  		 * Serializes the specified style object into a string.
  		 *
  		 * @method serialize
  		 * @param {Object} styles Object to serialize as string for example: {border: '1px solid red'}
  		 * @param {String} elementName Optional element name, if specified only the styles that matches the schema will be serialized.
  		 * @return {String} String representation of the style object for example: border: 1px solid red.
  		 */
  		serialize: function (styles, elementName) {
  			var css = '',
  				name, value;

  			function serializeStyles(name) {
  				var styleList, i, l, value;

  				styleList = validStyles[name];
  				if (styleList) {
  					for (i = 0, l = styleList.length; i < l; i++) {
  						name = styleList[i];
  						value = styles[name];

  						if (value !== undef && value.length > 0) {
  							css += (css.length > 0 ? ' ' : '') + name + ': ' + value + ';';
  						}
  					}
  				}
  			}

  			function isValid(name, elementName) {
  				var styleMap;

  				styleMap = invalidStyles['*'];
  				if (styleMap && styleMap[name]) {
  					return false;
  				}

  				styleMap = invalidStyles[elementName];
  				if (styleMap && styleMap[name]) {
  					return false;
  				}

  				return true;
  			}

  			// Serialize styles according to schema
  			if (elementName && validStyles) {
  				// Serialize global styles and element specific styles
  				serializeStyles('*');
  				serializeStyles(elementName);
  			} else {
  				// Output the styles in the order they are inside the object
  				for (name in styles) {
  					value = styles[name];

  					if (value !== undef && value.length > 0) {
  						if (!invalidStyles || isValid(name, elementName)) {
  							css += (css.length > 0 ? ' ' : '') + name + ': ' + value + ';';
  						}
  					}
  				}
  			}

  			return css;
  		}
  	};
  };

  /**
   * Schema.js
   *
   * Copyright, Moxiecode Systems AB
   * Released under LGPL License.
   *
   * License: http://www.tinymce.com/license - Inactive
   * Licence: GNU/LGPL 2.1 or later - http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
   * Contributing: http://www.tinymce.com/contributing - Inactive
   */

  (function (tinymce) {
    var mapCache = {},
      dummyObj = {};
    var makeMap = tinymce.makeMap,
      each = tinymce.each,
      extend = tinymce.extend,
      explode = tinymce.explode,
      inArray = tinymce.inArray;

    function split(items, delim) {
      return items ? items.split(delim || ' ') : [];
    }

    /**
     * Builds a schema lookup table
     *
     * @private
     * @param {String} type html4, html5 or html5-strict schema type.
     * @return {Object} Schema lookup table.
     */
    function compileSchema(type) {
      var schema = {},
        globalAttributes, blockContent;
      var phrasingContent, flowContent, html4BlockContent, html4PhrasingContent, eventAttributes, microdataAttributes;

      function add(name, attributes, children) {
        var ni, i, attributesOrder, args = arguments;

        function arrayToMap(array, obj) {
          var map = {},
            i, l;

          for (i = 0, l = array.length; i < l; i++) {
            map[array[i]] = obj || {};
          }

          return map;
        }

        children = children || [];
        attributes = attributes || "";

        if (typeof children === "string") {
          children = split(children);
        }

        // Split string children
        for (i = 3; i < args.length; i++) {
          if (typeof args[i] === "string") {
            args[i] = split(args[i]);
          }

          children.push.apply(children, args[i]);
        }

        name = split(name);
        ni = name.length;
        while (ni--) {
          attributesOrder = [].concat(split(attributes), globalAttributes);

          schema[name[ni]] = {
            attributes: arrayToMap(attributesOrder),
            attributesOrder: attributesOrder,
            children: arrayToMap(children, dummyObj)
          };
        }
      }

      function addAttrs(name, attributes) {
        var ni, schemaItem, i, l;

        name = split(name);
        ni = name.length;
        attributes = split(attributes);
        while (ni--) {
          schemaItem = schema[name[ni]];
          for (i = 0, l = attributes.length; i < l; i++) {

            // avoid duplicates
            if (schemaItem.attributes[attributes[i]]) {
              continue;
            }

            schemaItem.attributes[attributes[i]] = {};
            schemaItem.attributesOrder.push(attributes[i]);
          }
        }
      }

      // Use cached schema
      if (mapCache[type]) {
        return mapCache[type];
      }

      // Attributes present on all elements
      globalAttributes = split("id accesskey class dir lang style tabindex title");

      microdataAttributes = split("itemprop itemscope itemtype itemid itemref");

      // microdata attributes
      globalAttributes.push.apply(globalAttributes, microdataAttributes);

      // global event attributes
      eventAttributes = split("onclick ondblclick onmousedown " +
        "onmouseup onmouseover onmousemove onmouseout onkeypress onkeydown onkeyup");

      // html5 mouse events
      if (type != "html4") {
        eventAttributes.push.apply(eventAttributes, split("onabort onblur oncancel oncanplay oncanplaythrough onchange onclose oncontextmenu oncuechange " +
          "ondrag ondragend ondragenter ondragleave ondragover ondragstart ondrop ondurationchange onemptied onended " +
          "onerror onfocus oninput oninvalid onload onloadeddata onloadedmetadata onloadstart " +
          "onmouseenter onmouseleave onmousewheel onpause onplay onplaying onprogress onratechange " +
          "onreset onscroll onseeked onseeking onseeking onselect onshow onstalled onsubmit onsuspend ontimeupdate onvolumechange " +
          "onwaiting onwheel"));
      }

      // Event attributes can be opt-in/opt-out
      globalAttributes.push.apply(globalAttributes, eventAttributes);

      // schema.org attributes
      globalAttributes.push.apply(globalAttributes, split("itemscope itemtype itemid itemprop itemref"));

      // aria attributes
      globalAttributes.push.apply(globalAttributes, split("role"));

      // Block content elements
      blockContent = split(
        "address blockquote div dl fieldset form h1 h2 h3 h4 h5 h6 hr menu ol p pre table ul"
      );

      // Phrasing content elements from the HTML5 spec (inline)
      phrasingContent = split(
        "a abbr b bdo br button cite code del dfn em embed i iframe img input ins kbd " +
        "label map noscript object q s samp script select small span strong sub sup " +
        "textarea u var link style #text #comment"
      );

      // Add HTML5 items to globalAttributes, blockContent, phrasingContent
      if (type != "html4") {
        globalAttributes.push.apply(globalAttributes, split("contenteditable contextmenu draggable dropzone " +
          "hidden spellcheck translate"));
        blockContent.push.apply(blockContent, split("article aside details dialog figure header footer hgroup section nav"));
        phrasingContent.push.apply(phrasingContent, split("audio canvas command datalist mark meter output picture " +
          "progress time wbr video ruby bdi keygen"));
      }

      // Add HTML4 elements unless it's html5-strict
      if (type != "html5-strict") {
        globalAttributes.push("xml:lang");

        html4PhrasingContent = split("acronym applet basefont big font strike tt");
        phrasingContent.push.apply(phrasingContent, html4PhrasingContent);

        each(html4PhrasingContent, function (name) {
          add(name, "", phrasingContent);
        });

        html4BlockContent = split("center dir isindex noframes");
        blockContent.push.apply(blockContent, html4BlockContent);

        // Flow content elements from the HTML5 spec (block+inline)
        flowContent = [].concat(blockContent, phrasingContent);

        each(html4BlockContent, function (name) {
          add(name, "", flowContent);
        });
      }

      // Flow content elements from the HTML5 spec (block+inline)
      flowContent = flowContent || [].concat(blockContent, phrasingContent);

      // HTML4 base schema TODO: Move HTML5 specific attributes to HTML5 specific if statement
      // Schema items <element name>, <specific attributes>, <children ..>
      add("html", "manifest", "head body");
      add("head", "", "base command link meta noscript script style title");
      add("title hr noscript br");
      add("base", "href target");
      add("link", "href rel media hreflang type sizes");
      add("meta", "name http-equiv content charset");
      add("style", "media type scoped");
      add("script", "src async defer type charset");
      add("body", "onafterprint onbeforeprint onbeforeunload onblur onerror onfocus " +
        "onhashchange onload onmessage onoffline ononline onpagehide onpageshow " +
        "onpopstate onresize onscroll onstorage onunload", flowContent);
      add("address dt dd div caption", "", flowContent);
      add("h1 h2 h3 h4 h5 h6 pre p abbr code var samp kbd sub sup i b u bdo span legend em strong small s cite dfn", "", phrasingContent);
      add("blockquote", "cite", flowContent);
      add("ol", "reversed start type", "li");
      add("ul", "", "li");
      add("li", "value", flowContent);
      add("dl", "", "dt dd");
      add("a", "href target rel media hreflang type", phrasingContent);
      add("q", "cite", phrasingContent);
      add("ins del", "cite datetime", flowContent);
      add("img", "src sizes srcset alt usemap ismap width height");
      add("iframe", "src name width height", flowContent);
      add("embed", "src type width height");
      add("object", "data type typemustmatch name usemap form width height", flowContent, "param");
      add("param", "name value");
      add("map", "name", flowContent, "area");
      add("area", "alt coords shape href target rel media hreflang type");
      add("table", "border", "caption colgroup thead tfoot tbody tr" + (type == "html4" ? " col" : ""));
      add("colgroup", "span", "col");
      add("col", "span");
      add("tbody thead tfoot", "", "tr");
      add("tr", "", "td th");
      add("td", "colspan rowspan headers", flowContent);
      add("th", "colspan rowspan headers scope abbr", flowContent);
      add("form", "accept-charset action autocomplete enctype method name novalidate target", flowContent);
      add("fieldset", "disabled form name", flowContent, "legend");
      add("label", "form for", phrasingContent);
      add("input", "accept alt autocomplete checked dirname disabled form formaction formenctype formmethod formnovalidate " +
        "formtarget height list max maxlength min multiple name pattern readonly required size src step type value width"
      );
      add("button", "disabled form formaction formenctype formmethod formnovalidate formtarget name type value",
        type == "html4" ? flowContent : phrasingContent);
      add("select", "disabled form multiple name required size", "option optgroup");
      add("optgroup", "disabled label", "option");
      add("option", "disabled label selected value");
      add("textarea", "cols dirname disabled form maxlength name readonly required rows wrap");
      add("menu", "type label", flowContent, "li");
      add("noscript", "", flowContent);

      add("code", "", phrasingContent);

      // Extend with HTML5 elements
      if (type != "html4") {
        add("wbr");
        add("ruby", "", phrasingContent, "rt rp");
        add("figcaption", "", flowContent);
        add("mark rt rp summary bdi", "", phrasingContent);
        add("canvas", "width height", flowContent);
        add("video", "src crossorigin poster preload autoplay mediagroup loop " +
          "muted controls width height buffered controlslist playsinline", flowContent, "track source");
        add("audio", "src crossorigin preload autoplay mediagroup loop muted controls buffered volume controlslist", flowContent, "track source");
        add("picture", "", "img source");
        add("source", "src srcset type media sizes");
        add("track", "kind src srclang label default");
        add("datalist", "", phrasingContent, "option");
        add("article section nav aside header footer", "", flowContent);
        add("hgroup", "", "h1 h2 h3 h4 h5 h6");
        add("figure", "", flowContent, "figcaption");
        add("time", "datetime", phrasingContent);
        add("dialog", "open", flowContent);
        add("command", "type label icon disabled checked radiogroup command");
        add("output", "for form name", phrasingContent);
        add("progress", "value max", phrasingContent);
        add("meter", "value min max low high optimum", phrasingContent);
        add("details", "open", flowContent, "summary");
        add("keygen", "autofocus challenge disabled form keytype name");

        // update with flowContent
        add("a", "href target rel media hreflang type", flowContent);
      }

      // form events
      addAttrs("form", "onblur onchange onfocus onselect onsubmit");

      // Extend with HTML4 attributes unless it's html5-strict
      if (type != "html5-strict") {
        addAttrs("script", "language xml:space");
        addAttrs("style", "xml:space");
        addAttrs("object", "declare classid code codebase codetype archive standby align border hspace vspace");
        addAttrs("embed", "align name hspace vspace");
        addAttrs("param", "valuetype type");
        addAttrs("a", "charset name rev shape coords");
        addAttrs("br", "clear");
        addAttrs("applet", "codebase archive code object alt name width height align hspace vspace");
        addAttrs("img", "name longdesc align border hspace vspace");
        addAttrs("iframe", "longdesc frameborder marginwidth marginheight scrolling align");
        addAttrs("font basefont", "size color face");
        addAttrs("input", "usemap align");
        addAttrs("select", "onchange");
        addAttrs("textarea");
        addAttrs("h1 h2 h3 h4 h5 h6 div p legend caption", "align");
        addAttrs("ul", "type compact");
        addAttrs("li", "type");
        addAttrs("ol dl menu dir", "compact");
        addAttrs("pre", "width xml:space");
        addAttrs("hr", "align noshade size width");
        addAttrs("isindex", "prompt");
        addAttrs("table", "summary width frame rules cellspacing cellpadding align bgcolor");
        addAttrs("col", "width align char charoff valign");
        addAttrs("colgroup", "width align char charoff valign");
        addAttrs("thead", "align char charoff valign");
        addAttrs("tr", "align char charoff valign bgcolor");
        addAttrs("th", "axis align char charoff valign nowrap bgcolor width height");
        addAttrs("form", "accept");
        addAttrs("td", "abbr axis scope align char charoff valign nowrap bgcolor width height");
        addAttrs("tfoot", "align char charoff valign");
        addAttrs("tbody", "align char charoff valign");
        addAttrs("area", "nohref");
        addAttrs("body", "background bgcolor text link vlink alink");

        // form events
        addAttrs("form", "onreset");
      }

      // Extend with HTML5 attributes unless it's html4
      if (type != "html4") {
        addAttrs("input button select textarea", "autofocus");
        addAttrs("input textarea", "placeholder");
        addAttrs("a", "download");
        addAttrs("link script img", "crossorigin");
        addAttrs("iframe", "sandbox seamless allowfullscreen allow referrerpolicy loading"); // Excluded: srcdoc

        addAttrs("img", "loading decoding");

        addAttrs("link", "as disabled imagesizes imagesrcset title");

        // form events
        addAttrs("form", "oncontextmenu onformchange onforminput oninput oninvalid");

        // media events
        addAttrs("video audio", "onabort oncanplay oncanplaythrough ondurationchange onemptied onended " +
          "onerror onloadeddata onloadedmetadata onloadstart onpause onplay onplaying onprogress " +
          "onratechange onreadystatechange onseeked onseeking onstalled onsuspend ontimeupdate " +
          "onvolumechange onwaiting");
      }

      // Special: iframe, ruby, video, audio, label

      // Delete children of the same name from it's parent
      // For example: form can't have a child of the name form
      each(split('a form meter progress dfn'), function (name) {
        if (schema[name]) {
          delete schema[name].children[name];
        }
      });

      // Delete header, footer, sectioning and heading content descendants
      /*each('dt th address', function(name) {
           delete schema[name].children[name];
           });*/

      // Caption can't have tables
      delete schema.caption.children.table;

      // TODO: LI:s can only have value if parent is OL

      // TODO: Handle transparent elements
      // a ins del canvas map

      mapCache[type] = schema;

      return schema;
    }

    function compileElementMap(value, mode) {
      var styles;

      if (value) {
        styles = {};

        if (typeof value == 'string') {
          value = {
            '*': value
          };
        }

        // Convert styles into a rule list
        each(value, function (value, key) {
          styles[key] = styles[key.toUpperCase()] = mode == 'map' ? makeMap(value, /[, ]/) : explode(value, /[, ]/);
        });
      }

      return styles;
    }

    /**
     * Constructs a new Schema instance.
     *
     * @constructor
     * @method Schema
     * @param {Object} settings Name/value settings object.
     */
    tinymce.html.Schema = function (settings) {
      var self = this,
        elements = {},
        children = {},
        patternElements = [],
        validStyles, invalidStyles, schemaItems;
      var whiteSpaceElementsMap, selfClosingElementsMap, shortEndedElementsMap, boolAttrMap, validClasses;
      var blockElementsMap, nonEmptyElementsMap, moveCaretBeforeOnEnterElementsMap, textBlockElementsMap, textInlineElementsMap;
      var customElementsMap = {},
        specialElements = {};

      // Creates an lookup table map object for the specified option or the default value
      function createLookupTable(option, default_value, extendWith) {
        var value = settings[option];

        if (!value) {
          // Get cached default map or make it if needed
          value = mapCache[option];

          if (!value) {
            value = makeMap(default_value, ' ', makeMap(default_value.toUpperCase(), ' '));
            value = extend(value, extendWith);

            mapCache[option] = value;
          }
        } else {
          // Create custom map
          value = makeMap(value, /[, ]/, makeMap(value.toUpperCase(), /[, ]/));
        }

        return value;
      }

      settings = settings || {};
      schemaItems = compileSchema(settings.schema);

      // Allow all elements and attributes if verify_html is set to false
      if (settings.verify_html === false) {
        settings.valid_elements = '*[*]';
      }

      validStyles = compileElementMap(settings.valid_styles);
      invalidStyles = compileElementMap(settings.invalid_styles, 'map');
      validClasses = compileElementMap(settings.valid_classes, 'map');

      // Setup map objects
      whiteSpaceElementsMap = createLookupTable('whitespace_elements', 'pre script noscript style textarea video audio iframe object');

      selfClosingElementsMap = createLookupTable('self_closing_elements', 'colgroup dd dt li option p td tfoot th thead tr');

      shortEndedElementsMap = createLookupTable('short_ended_elements', 'area base basefont br col frame hr img input isindex link ' +
        'meta param embed source wbr track');

      boolAttrMap = createLookupTable('boolean_attributes', 'async checked compact declare defer disabled ismap multiple nohref noresize ' +
        'noshade nowrap readonly selected autoplay loop controls itemscope playsinline spellcheck contextmenu draggable hidden allowfullscreen muted');

      nonEmptyElementsMap = createLookupTable('non_empty_elements', 'td th iframe video audio object script pre code', shortEndedElementsMap);
      moveCaretBeforeOnEnterElementsMap = createLookupTable('move_caret_before_on_enter_elements', 'table', nonEmptyElementsMap);

      textBlockElementsMap = createLookupTable('text_block_elements', 'h1 h2 h3 h4 h5 h6 p div address pre form ' +
        'blockquote center dir fieldset header footer article section hgroup aside main nav figure');

      blockElementsMap = createLookupTable('block_elements', 'hr table tbody thead tfoot ' +
        'th tr td li ol ul caption dl dt dd noscript menu isindex option ' +
        'datalist select optgroup figcaption details summary', textBlockElementsMap);

      textInlineElementsMap = createLookupTable('text_inline_elements', 'span strong b em i font strike u var cite ' +
        'dfn code mark q sup sub samp');

      each((settings.special || 'script noscript iframe noframes noembed title style textarea xmp').split(' '), function (name) {
        specialElements[name] = new RegExp('<\/' + name + '[^>]*>', 'gi');
      });

      // Converts a wildcard expression string to a regexp for example *a will become /.*a/.
      function patternToRegExp(str) {
        return new RegExp('^' + str.replace(/([?+*])/g, '.$1') + '$');
      }

      /*
      * The `valid_elements` option specifies which HTML elements are preserved during the editor's save process, allowing for the restriction of HTML to a specified subset.
      * This option utilizes a comma-separated list of "element conversion chunks" to detail the treatment of specific elements and their attributes. The default rules are based on either a combination of the full HTML5 and HTML4 specifications or solely one of these, depending on the schema configuration.
      * To modify or extend behavior for particular elements, the `extended_valid_elements` option should be used.
      * 
      * Control Characters:
      * @ : Applies the following rules to all subsequent elements, enabling specified attributes globally unless scoped to specific elements in the `extended_valid_elements`.
      * , : Delimits individual element definition chunks.
      * / : Distinguishes element synonyms, with the first named element being the output.
      * | : Separates attributes within an element's definition.
      * [ : Begins an attribute list for an element.
      * ] : Closes an attribute list for an element.
      * ! : Marks attributes as required, removing the element if these attributes are absent.
      * = : Assigns a default value to an attribute.
      * : : Forces an attribute to take a specified value.
      * < : Restricts attribute values to a specified list.
      * ? : Separates possible values within attribute value verification.
      * + : Opens an element if it has no child nodes.
      * - : Allows for the removal of empty elements.
      * # : Pads empty elements with a non-breaking space if they are empty.
      * ! (second usage): Removes elements that lack attributes but may contain content.
      * 
      * Wildcards such as *, +, and ? are permissible for matching element or attribute names.
      */

      // Parses the specified valid_elements string and adds to the current rules
      // This function is a bit hard to read since it's heavily optimized for speed
      function addValidElements(validElements) {
        var ei, el, ai, al, matches, element, attr, attrData, elementName, attrName, attrType, attributes, attributesOrder,
          prefix, outputName, globalAttributes, globalAttributesOrder, key, value,
          elementRuleRegExp = /^([#+\-])?([^\[!\/]+)(?:\/([^\[!]+))?(?:(!?)\[([^\]]+)\])?$/,
          attrRuleRegExp = /^([!\-])?(\w+::\w+|[^=:<]+)?(?:([=:<])(.*))?$/,
          hasPatternsRegExp = /[*?+]/;

        if (validElements) {
          // Split valid elements into an array with rules
          validElements = split(validElements, ',');

          if (elements['@']) {
            globalAttributes = elements['@'].attributes;
            globalAttributesOrder = elements['@'].attributesOrder;
          }

          // Loop all rules
          for (ei = 0, el = validElements.length; ei < el; ei++) {
            // Parse element rule
            matches = elementRuleRegExp.exec(validElements[ei]);
            if (matches) {
              // Setup local names for matches
              prefix = matches[1];
              elementName = matches[2];
              outputName = matches[3];
              attrData = matches[5];

              // Create new attributes and attributesOrder
              attributes = {};
              attributesOrder = [];

              // Create the new element
              element = {
                attributes: attributes,
                attributesOrder: attributesOrder
              };

              // Padd empty elements prefix
              if (prefix === '#') {
                element.paddEmpty = true;
              }

              // Remove empty elements prefix
              if (prefix === '-') {
                element.removeEmpty = true;
              }

              if (matches[4] === '!') {
                element.removeEmptyAttrs = true;
              }

              // Copy attributes from global rule into current rule
              if (globalAttributes) {
                for (key in globalAttributes) {
                  attributes[key] = globalAttributes[key];
                }

                attributesOrder.push.apply(attributesOrder, globalAttributesOrder);
              }

              // Attributes defined
              if (attrData) {
                attrData = split(attrData, '|');
                for (ai = 0, al = attrData.length; ai < al; ai++) {
                  matches = attrRuleRegExp.exec(attrData[ai]);
                  if (matches) {
                    attr = {};
                    attrType = matches[1];
                    attrName = matches[2].replace(/::/g, ':');
                    prefix = matches[3];
                    value = matches[4];

                    // Required
                    if (attrType === '!') {
                      element.attributesRequired = element.attributesRequired || [];
                      element.attributesRequired.push(attrName);
                      attr.required = true;
                    }

                    // Denied from global
                    if (attrType === '-') {
                      delete attributes[attrName];
                      attributesOrder.splice(inArray(attributesOrder, attrName), 1);
                      continue;
                    }

                    // Default value
                    if (prefix) {
                      // Default value
                      if (prefix === '=') {
                        element.attributesDefault = element.attributesDefault || [];
                        element.attributesDefault.push({
                          name: attrName,
                          value: value
                        });
                        attr.defaultValue = value;
                      }

                      // Forced value
                      if (prefix === ':') {
                        element.attributesForced = element.attributesForced || [];
                        element.attributesForced.push({
                          name: attrName,
                          value: value
                        });
                        attr.forcedValue = value;
                      }

                      // Required values
                      if (prefix === '<') {
                        attr.validValues = makeMap(value, '?');
                      }
                    }

                    // Check for attribute patterns
                    if (hasPatternsRegExp.test(attrName)) {
                      element.attributePatterns = element.attributePatterns || [];
                      attr.pattern = patternToRegExp(attrName);
                      element.attributePatterns.push(attr);
                    } else {
                      // Add attribute to order list if it doesn't already exist
                      if (!attributes[attrName]) {
                        attributesOrder.push(attrName);
                      }

                      attributes[attrName] = attr;
                    }
                  }
                }
              }

              // Global rule, store away these for later usage
              if (!globalAttributes && elementName == '@') {
                globalAttributes = attributes;
                globalAttributesOrder = attributesOrder;
              }

              // Handle substitute elements such as b/strong
              if (outputName) {
                element.outputName = elementName;
                elements[outputName] = element;
              }

              // Add pattern or exact element
              if (hasPatternsRegExp.test(elementName)) {
                element.pattern = patternToRegExp(elementName);
                patternElements.push(element);
              } else {
                elements[elementName] = element;
              }
            }
          }
        }
      }

      function setValidElements(validElements) {
        elements = {};
        patternElements = [];

        addValidElements(validElements);

        each(schemaItems, function (element, name) {
          children[name] = element.children;
        });
      }

      // Adds custom non HTML elements to the schema
      function addCustomElements(customElements) {
        var customElementRegExp = /^(~)?(.+)$/;

        if (customElements) {
          // Flush cached items since we are altering the default maps
          mapCache.text_block_elements = mapCache.block_elements = null;

          each(split(customElements, ','), function (rule) {
            var matches = customElementRegExp.exec(rule),
              inline = matches[1] === '~',
              cloneName = inline ? 'span' : 'div',
              name = matches[2];

            children[name] = children[cloneName];
            customElementsMap[name] = cloneName;

            // If it's not marked as inline then add it to valid block elements
            if (!inline) {
              blockElementsMap[name.toUpperCase()] = {};
              blockElementsMap[name] = {};
            }

            // Add elements clone if needed
            if (!elements[name]) {
              var customRule = elements[cloneName];

              customRule = extend({}, customRule);
              delete customRule.removeEmptyAttrs;
              delete customRule.removeEmpty;

              elements[name] = customRule;
            }

            // Add custom elements at span/div positions
            each(children, function (element, elmName) {
              if (element[cloneName]) {
                children[elmName] = element = extend({}, children[elmName]);
                element[name] = element[cloneName];
              }
            });
          });
        }
      }

      // Adds valid children to the schema object
      function addValidChildren(validChildren) {
        var childRuleRegExp = /^([+\-]?)(\w+)\[([^\]]+)\]$/;

        if (validChildren) {
          each(split(validChildren, ','), function (rule) {
            var matches = childRuleRegExp.exec(rule),
              parent, prefix;

            if (matches) {
              prefix = matches[1];

              // Add/remove items from default
              if (prefix) {
                parent = children[matches[2]];
              } else {
                parent = children[matches[2]] = {
                  '#comment': {}
                };
              }

              parent = children[matches[2]];

              each(split(matches[3], '|'), function (child) {
                if (prefix === '-') {
                  // Clone the element before we delete
                  // things in it to not mess up default schemas
                  children[matches[2]] = parent = extend({}, children[matches[2]]);

                  delete parent[child];
                } else {
                  parent[child] = {};
                }
              });
            }
          });
        }
      }

      function getElementRule(name) {
        var element = elements[name],
          i;

        // Exact match found
        if (element) {
          return element;
        }

        // No exact match then try the patterns
        i = patternElements.length;
        while (i--) {
          element = patternElements[i];

          if (element.pattern.test(name)) {
            return element;
          }
        }
      }

      if (!settings.valid_elements) {
        // No valid elements defined then clone the elements from the schema spec
        each(schemaItems, function (element, name) {
          elements[name] = {
            attributes: element.attributes,
            attributesOrder: element.attributesOrder
          };

          children[name] = element.children;
        });

        // Switch these on HTML4
        if (settings.schema === "html4") {
          each(split('strong/b em/i'), function (item) {
            item = split(item, '/');
            elements[item[1]].outputName = item[0];
          });
        }

        // Add default alt attribute for images
        elements.img.attributesDefault = [{
          name: 'alt',
          value: ''
        }];

        // Remove these if they are empty by default
        each(split('ol ul sub sup blockquote font table tbody tr strong b'), function (name) {
          if (elements[name]) {
            elements[name].removeEmpty = true;
          }
        });

        // Padd these by default
        each(split('p h1 h2 h3 h4 h5 h6 th td pre div address caption'), function (name) {
          elements[name].paddEmpty = true;
        });

        // Remove these if they have no attributes
        if (settings.allow_empty_spans === false) {
          each(split('span'), function (name) {
            elements[name].removeEmptyAttrs = true;
          });
        }

        // Remove these by default
        // TODO: Reenable in 4.1
        /*each(split('script style'), function(name) {
               delete elements[name];
               });*/
      } else {
        setValidElements(settings.valid_elements);
      }

      addCustomElements(settings.custom_elements);
      addValidChildren(settings.valid_children);
      addValidElements(settings.extended_valid_elements);

      // Todo: Remove this when we fix list handling to be valid
      addValidChildren('+ol[ul|ol],+ul[ul|ol]');

      // Delete invalid elements
      if (settings.invalid_elements) {
        each(explode(settings.invalid_elements), function (item) {
          if (elements[item]) {
            delete elements[item];
          }
        });
      }

      // If the user didn't allow span only allow internal spans
      if (!getElementRule('span')) {
        //addValidElements('span[!data-mce-type|*]');
        addValidElements('span[*]');
      }

      /**
       * Name/value map object with valid parents and children to those parents.
       *
       * @example
       * children = {
       *    div:{p:{}, h1:{}}
       * };
       * @field children
       * @type Object
       */
      self.children = children;

      /**
       * Name/value map object with valid styles for each element.
       *
       * @method getValidStyles
       * @type Object
       */
      self.getValidStyles = function () {
        return validStyles;
      };

      /**
       * Name/value map object with valid styles for each element.
       *
       * @method getInvalidStyles
       * @type Object
       */
      self.getInvalidStyles = function () {
        return invalidStyles;
      };

      /**
       * Name/value map object with valid classes for each element.
       *
       * @method getValidClasses
       * @type Object
       */
      self.getValidClasses = function () {
        return validClasses;
      };

      /**
       * Returns a map with boolean attributes.
       *
       * @method getBoolAttrs
       * @return {Object} Name/value lookup map for boolean attributes.
       */
      self.getBoolAttrs = function () {
        return boolAttrMap;
      };

      /**
       * Returns a map with block elements.
       *
       * @method getBlockElements
       * @return {Object} Name/value lookup map for block elements.
       */
      self.getBlockElements = function () {
        return blockElementsMap;
      };

      /**
       * Returns a map with text block elements. Such as: p,h1-h6,div,address
       *
       * @method getTextBlockElements
       * @return {Object} Name/value lookup map for block elements.
       */
      self.getTextBlockElements = function () {
        return textBlockElementsMap;
      };

      /**
       * Returns a map with text block root elements.
       *
       * @method getTextRootBlockElements
       * @return {Object} Name/value lookup map for block elements.
       */
      self.getTextRootBlockElements = function () {
        return makeMap(
          'td th li dt dd figcaption caption details summary',
          textBlockElementsMap
        );
      };

      /**
       * Returns a map of inline text format nodes for example strong/span or ins.
       *
       * @method getTextInlineElements
       * @return {Object} Name/value lookup map for text format elements.
       */
      self.getTextInlineElements = function () {
        return textInlineElementsMap;
      };

      /**
       * Returns a map with short ended elements such as BR or IMG.
       *
       * @method getShortEndedElements
       * @return {Object} Name/value lookup map for short ended elements.
       */
      self.getShortEndedElements = function () {
        return shortEndedElementsMap;
      };

      /**
       * Returns a map with self closing tags such as <li>.
       *
       * @method getSelfClosingElements
       * @return {Object} Name/value lookup map for self closing tags elements.
       */
      self.getSelfClosingElements = function () {
        return selfClosingElementsMap;
      };

      /**
       * Returns a map with elements that should be treated as contents regardless if it has text
       * content in them or not such as TD, VIDEO or IMG.
       *
       * @method getNonEmptyElements
       * @return {Object} Name/value lookup map for non empty elements.
       */
      self.getNonEmptyElements = function () {
        return nonEmptyElementsMap;
      };

      /**
       * Returns a map with elements that the caret should be moved in front of after enter is
       * pressed
       *
       * @method getMoveCaretBeforeOnEnterElements
       * @return {Object} Name/value lookup map for elements to place the caret in front of.
       */
      self.getMoveCaretBeforeOnEnterElements = function () {
        return moveCaretBeforeOnEnterElementsMap;
      };

      /**
       * Returns a map with elements where white space is to be preserved like PRE or SCRIPT.
       *
       * @method getWhiteSpaceElements
       * @return {Object} Name/value lookup map for white space elements.
       */
      self.getWhiteSpaceElements = function () {
        return whiteSpaceElementsMap;
      };

      /**
       * Returns a map with special elements. These are elements that needs to be parsed
       * in a special way such as script, style, textarea etc. The map object values
       * are regexps used to find the end of the element.
       *
       * @method getSpecialElements
       * @return {Object} Name/value lookup map for special elements.
       */
      self.getSpecialElements = function () {
        return specialElements;
      };

      /**
       * Returns true/false if the specified element and it's child is valid or not
       * according to the schema.
       *
       * @method isValidChild
       * @param {String} name Element name to check for.
       * @param {String} child Element child to verify.
       * @return {Boolean} True/false if the element is a valid child of the specified parent.
       */
      self.isValidChild = function (name, child) {
        var parent = children[name];

        return !!(parent && parent[child]);
      };

      /**
       * Returns true/false if the specified element name and optional attribute is
       * valid according to the schema.
       *
       * @method isValid
       * @param {String} name Name of element to check.
       * @param {String} attr Optional attribute name to check for.
       * @return {Boolean} True/false if the element and attribute is valid.
       */
      self.isValid = function (name, attr) {
        var attrPatterns, i, rule = getElementRule(name);

        // Check if it's a valid element
        if (rule) {
          if (attr) {
            // Check if attribute name exists
            if (rule.attributes[attr]) {
              return true;
            }

            // Check if attribute matches a regexp pattern
            attrPatterns = rule.attributePatterns;
            if (attrPatterns) {
              i = attrPatterns.length;
              while (i--) {
                if (attrPatterns[i].pattern.test(name)) {
                  return true;
                }
              }
            }
          } else {
            return true;
          }
        }

        // No match
        return false;
      };

      /**
       * Returns true/false if the specified element is valid or not
       * according to the schema.
       *
       * @method getElementRule
       * @param {String} name Element name to check for.
       * @return {Object} Element object or undefined if the element isn't valid.
       */
      self.getElementRule = getElementRule;

      /**
       * Returns an map object of all custom elements.
       *
       * @method getCustomElements
       * @return {Object} Name/value map object of all custom elements.
       */
      self.getCustomElements = function () {
        return customElementsMap;
      };

      /**
       * Parses a valid elements string and adds it to the schema. The valid elements
       * format is for example "element[attr=default|otherattr]".
       * Existing rules will be replaced with the ones specified, so this extends the schema.
       *
       * @method addValidElements
       * @param {String} valid_elements String in the valid elements format to be parsed.
       */
      self.addValidElements = addValidElements;

      /**
       * Parses a valid elements string and sets it to the schema. The valid elements
       * format is for example "element[attr=default|otherattr]".
       * Existing rules will be replaced with the ones specified, so this extends the schema.
       *
       * @method setValidElements
       * @param {String} valid_elements String in the valid elements format to be parsed.
       */
      self.setValidElements = setValidElements;

      /**
       * Adds custom non HTML elements to the schema.
       *
       * @method addCustomElements
       * @param {String} custom_elements Comma separated list of custom elements to add.
       */
      self.addCustomElements = addCustomElements;

      /**
       * Parses a valid children string and adds them to the schema structure. The valid children
       * format is for example: "element[child1|child2]".
       *
       * @method addValidChildren
       * @param {String} valid_children Valid children elements string to parse
       */
      self.addValidChildren = addValidChildren;

      self.elements = elements;
    };
  })(tinymce);

  /**
   * SaxParser.js
   *
   * Copyright, Moxiecode Systems AB
   * Released under LGPL License.
   *
   * License: http://www.tinymce.com/license - Inactive
   * Licence: GNU/LGPL 2.1 or later - http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
   * Contributing: http://www.tinymce.com/contributing - Inactive
   */

  (function (tinymce) {
    /**
     * This class parses HTML code using pure JavaScript and executes various events for each item it finds. It will
     * always execute the events in the right order for tag soup code like <b><p></b></p>. It will also remove elements
     * and attributes that doesn't fit the schema if the validate setting is enabled.
     *
     * @example
     * var parser = new tinymce.html.SaxParser({
     *     validate: true,
     *
     *     comment: function(text) {
     *         console.log('Comment:', text);
     *     },
     *
     *     cdata: function(text) {
     *         console.log('CDATA:', text);
     *     },
     *
     *     text: function(text, raw) {
     *         console.log('Text:', text, 'Raw:', raw);
     *     },
     *
     *     start: function(name, attrs, empty) {
     *         console.log('Start:', name, attrs, empty);
     *     },
     *
     *     end: function(name) {
     *         console.log('End:', name);
     *     },
     *
     *     pi: function(name, text) {
     *         console.log('PI:', name, text);
     *     },
     *
     *     doctype: function(text) {
     *         console.log('DocType:', text);
     *     }
     * }, schema);
     * @class tinymce.html.SaxParser
     * @version 3.4
     */

    var each = tinymce.each,
      Entities = tinymce.html.Entities;

    // A list of form control or other elements whereby a name/id would override a form or document property
    // https://developer.mozilla.org/en-US/docs/Web/API/HTMLFormElement/elements#value
    // https://portswigger.net/research/dom-clobbering-strikes-back
    var filteredClobberElements = tinymce.makeMap('button,fieldset,form,iframe,img,image,input,object,output,select,textarea');

    // Create a temp document and return a cached version of it in subsequent calls
    var getTempDocument = (function () {
      var cachedDocument = null;

      return function () {

        if (!cachedDocument) {
          cachedDocument = document.implementation.createHTMLDocument('parser');
        }

        return cachedDocument;
      };
    })();
    
    /**
     * Constructs a new SaxParser instance.
     *
     * @constructor
     * @method SaxParser
     * @param {Object} settings Name/value collection of settings. comment, cdata, text, start and end are callbacks.
     * @param {tinymce.html.Schema} schema HTML Schema class to use when parsing.
     */
    tinymce.html.SaxParser = function (settings, schema) {
      var self = this;

      var doc = getTempDocument(), form = doc.createElement('form');

      function noop() { }

      settings = settings || {};
      self.schema = schema = schema || new tinymce.html.Schema();

      if (settings.fix_self_closing !== false) {
        settings.fix_self_closing = true;
      }

      if (settings.allow_event_attributes !== true) {
        settings.allow_event_attributes = false;
      }

      if (settings.preserve_cdata !== false) {
        settings.preserve_cdata = true;
      }

      // Add handler functions from settings and setup default handlers
      each('comment cdata text start end pi doctype'.split(' '), function (name) {
        if (name) {
          self[name] = settings[name] || noop;
        }
      });

      /**
       * Returns the index of the end tag for a specific start tag. This can be
       * used to skip all children of a parent element from being processed.
       *
       * @private
       * @method findEndTag
       * @param {tinymce.html.Schema} schema Schema instance to use to match short ended elements.
       * @param {String} html HTML string to find the end tag in.
       * @param {Number} startIndex Indext to start searching at should be after the start tag.
       * @return {Number} Index of the end tag.
       */
      self.findEndTag = function (schema, html, startIndex) {
        var count = 1,
          index, matches, tokenRegExp, shortEndedElements;

        shortEndedElements = schema.getShortEndedElements();
        tokenRegExp = /<([!?\/])?([A-Za-z0-9\-_\:\.]+)((?:\s+[^"\'>]+(?:(?:"[^"]*")|(?:\'[^\']*\')|[^>]*))*|\/|\s+)>/g;
        tokenRegExp.lastIndex = index = startIndex;

        while ((matches = tokenRegExp.exec(html))) {
          index = tokenRegExp.lastIndex;

          if (matches[1] === '/') { // End element
            count--;
          } else if (!matches[1]) { // Start element
            if (matches[2] in shortEndedElements) {
              continue;
            }

            count++;
          }

          if (count === 0) {
            break;
          }
        }

        return index;
      };

      /**
       * Parses the specified HTML string and executes the callbacks for each item it finds.
       *
       * @example
       * new SaxParser({...}).parse('<b>text</b>');
       * @method parse
       * @param {String} html Html string to sax parse.
       */
      self.parse = function (html, format) {
        var self = this,
          matches, index = 0,
          value, endRegExp, stack = [],
          attrList, i, text, name;
        var isInternalElement, removeInternalElements, shortEndedElements, fillAttrsMap, isShortEnded;
        var validate, elementRule, isValidElement, attr, attribsValue, validAttributesMap, validAttributePatterns;
        var attributesRequired, attributesDefault, attributesForced;
        var anyAttributesRequired, selfClosing, tokenRegExp, attrRegExp, specialElements, attrValue, idCount = 0;
        var decode = Entities.decode,
          fixSelfClosing, filteredUrlAttrs = tinymce.makeMap('src,href,data,background,formaction,poster,xlink:href');
        //var scriptUriRegExp = /((java|vb)script|mhtml):/i;
        var processHtml;

        // parser format - html, xml
        format = format || 'html';

        function processEndTag(name) {
          var pos, i;

          // Find position of parent of the same type
          pos = stack.length;
          while (pos--) {
            if (stack[pos].name === name) {
              break;
            }
          }

          // Found parent
          if (pos >= 0) {
            // Close all the open elements
            for (i = stack.length - 1; i >= pos; i--) {
              name = stack[i];

              if (name.valid) {
                self.end(name.name);
              }
            }

            // Remove the open elements from the stack
            stack.length = pos;
          }
        }

        /*function isInvalidUri(settings, uri) {
          if (settings.allow_html_data_urls) {
            return false;
          } else if (/^data:image\//i.test(uri)) {
            return settings.allow_svg_data_urls === false && /^data:image\/svg\+xml/i.test(uri);
          } else {
            return /^data:/i.test(uri);
          }
        }*/

        // a data attribute is any attribute with a hyphen, eg: data- or ng- or v-
        function isDataAttribute(name) {
          return name.indexOf('-') > 0;
        }

        // an aria attribute is any attribute that starts with aria-
        function isAriaAttribute(name) {
          return name.indexOf('aria-') === 0;
        }

        function isEventAttribute(name) {
          return name.indexOf('on') == 0;
        }

        function isFilterdUrlAttribute(name) {
          return name in filteredUrlAttrs;
        }

        function processComment(value) {
          // Ignore empty comments
          if (value === '') {
            return value;
          }

          // Padd comment value to avoid browsers from parsing invalid comments as HTML
          if (value.charAt(0) === '>') {
            value = ' ' + value;
          }

          if (!settings.allow_conditional_comments && value.substr(0, 3).toLowerCase() === '[if') {
            value = ' ' + value;
          }

          return value;
        }

        function processMalformedComment(value, startIndex) {
          var startTag = value || '';
          var isBogus = startTag.indexOf('--') !== 0;

          // Find the end of the malformed/bogus comment
          var endIndex = findCommentEndIndex(value, isBogus, startIndex);
          value = value.substr(startIndex, endIndex - startIndex);

          value = processComment(isBogus ? startTag + value : value);

          return endIndex + 1;
        }

        function isConditionalComment(html, startIndex) {
          return /^\s*\[if [\w\W]+\]>.*<!\[endif\](--!?)?>/.test(html.substr(startIndex));
        }

        function findCommentEndIndex(html, isBogus, startIndex) {
          var lcHtml = html.toLowerCase();
          if (lcHtml.indexOf('[if ', startIndex) !== -1 && isConditionalComment(lcHtml, startIndex)) {
            var endIfIndex = lcHtml.indexOf('[endif]', startIndex);
            return lcHtml.indexOf('>', endIfIndex);
          } else {
            if (isBogus) {
              var endIndex = lcHtml.indexOf('>', startIndex);
              return endIndex !== -1 ? endIndex : lcHtml.length;
            } else {
              var endCommentRegexp = /--!?>/;
              endCommentRegexp.lastIndex = startIndex;
              var match = endCommentRegexp.exec(html);
              return match ? match.index + match[0].length : lcHtml.length;
            }
          }
        }

        function trimComments(text) {
          var sanitizedText = text;

          while (/<!--|--!?>/g.test(sanitizedText)) {
            sanitizedText = sanitizedText.replace(/<!--|--!?>/g, '');
          }

          return sanitizedText;
        }

        function checkBogusAttribute(regExp, attrString) {
          var matches = regExp.exec(attrString);

          if (matches) {
            var name = matches[1];
            var value = matches[2];

            return typeof name === 'string' && name.toLowerCase() === 'data-mce-bogus' ? value : null;
          } else {
            return null;
          }
        }

        function parseAttribute(tagName, name, value, val2, val3) {
          var attrRule, i;// trimRegExp = /[\s\u0000-\u001F]+/g;

          name = name.toLowerCase();
          value = name in fillAttrsMap ? name : decode(value || val2 || val3 || ''); // Handle boolean attribute than value attribute

          // Validate name and value pass through all data- attributes
          if (validate && !isInternalElement && !isDataAttribute(name) && !isAriaAttribute(name)) {

            // block event attributes, eg: onload
            if (!settings.allow_event_attributes && isEventAttribute(name)) {
              return;
            }

            attrRule = validAttributesMap[name];

            // Find rule by pattern matching
            if (!attrRule && validAttributePatterns) {
              i = validAttributePatterns.length;
              while (i--) {
                attrRule = validAttributePatterns[i];
                if (attrRule.pattern.test(name)) {
                  break;
                }
              }

              // No rule matched
              if (i === -1) {
                attrRule = null;
              }
            }

            // No attribute rule found
            if (!attrRule) {
              return;
            }

            // Validate value
            if (attrRule.validValues && !(value in attrRule.validValues)) {
              return;
            }
          }

          // Attempt to block any dom clobbering on document or forms
          // See https://www.slideshare.net/x00mario/in-the-dom-no-one-will-hear-you-scream
          var isNameOrId = name === 'name' || name === 'id';

          if (isNameOrId && tagName in filteredClobberElements && (value in doc || value in form)) {
            return;
          }

          // Block any javascript: urls or non image data uris
          if (isFilterdUrlAttribute(name) && !tinymce.util.URI.isDomSafe(value, tagName, settings)) {
            return;
          }

          // Block any javascript: urls or non image data uris
          /*if (filteredUrlAttrs[name] && !settings.allow_script_urls) {
            var uri = value.replace(trimRegExp, '');

            try {
              // Might throw malformed URI sequence
              uri = decodeURIComponent(uri);
            } catch (ex) {
              // Fallback to non UTF-8 decoder
              uri = unescape(uri);
            }

            if (scriptUriRegExp.test(uri)) {
              return;
            }

            if (isInvalidUri(settings, uri)) {
              return;
            }
          }*/

          // Block data or event attributes on elements marked as internal
          if (isInternalElement) {
            if (isFilterdUrlAttribute(name)) {
              return;
            }
            // only allow event attributes if enabled
            if (isEventAttribute(name) && !settings.allow_event_attributes) {
              return;
            }
          }

          // Add attribute to list and map
          attrList.map[name] = value;
          attrList.push({
            name: name,
            value: value
          });
        }

        // Precompile RegExps and map objects
        tokenRegExp = new RegExp('<(?:' +
          '(?:!--([\\w\\W]*?)--!?>)|' + // Comment
          '(?:!\\[CDATA\\[([\\w\\W]*?)\\]\\]>)|' + // CDATA
          '(?:![Dd][Oo][Cc][Tt][Yy][Pp][Ee]([\\w\\W]*?)>)|' + // DOCTYPE (case insensitive)
          '(?:\\?([^\\s\\/<>]+) ?([\\w\\W]*?)[?/]>)|' + // PI
          '(?:\\/([A-Za-z][A-Za-z0-9\\-_\\:\\.]*)>)|' + // End element
          '(?:([A-Za-z][A-Za-z0-9\\-_\\:\\.]*)((?:\\s+[^"\'>]+(?:(?:"[^"]*")|(?:\'[^\']*\')|[^>]*))*|\\/|\\s+)>)' + // Start element
          ')', 'g');

        attrRegExp = /([\w:\-]+)(?:\s*=\s*(?:(?:\"((?:[^\"])*)\")|(?:\'((?:[^\'])*)\')|([^>\s]+)))?/g;

        // Setup lookup tables for empty elements and boolean attributes
        shortEndedElements = schema.getShortEndedElements();
        selfClosing = settings.self_closing_elements || schema.getSelfClosingElements();
        fillAttrsMap = schema.getBoolAttrs();
        validate = settings.validate;
        removeInternalElements = settings.remove_internals;
        fixSelfClosing = settings.fix_self_closing;
        specialElements = schema.getSpecialElements();
        processHtml = html + '>';

        while ((matches = tokenRegExp.exec(processHtml))) {
          // Text
          if (index < matches.index) {
            self.text(decode(html.substr(index, matches.index - index)));
          }

          if ((value = matches[6])) { // End element
            value = value.toLowerCase();

            // IE will add a ":" in front of elements it doesn't understand like custom elements or HTML5 elements
            if (value.charAt(0) === ':') {
              value = value.substr(1);
            }

            processEndTag(value);
          } else if ((value = matches[7])) { // Start element
            // Did we consume the extra character then treat it as text
            // This handles the case with html like this: "text a<b text"
            if (matches.index + matches[0].length > html.length) {
              self.text(decode(html.substr(matches.index)));
              index = matches.index + matches[0].length;
              continue;
            }

            value = value.toLowerCase();

            // IE will add a ":" in front of elements it doesn't understand like custom elements or HTML5 elements
            if (value.charAt(0) === ':') {
              value = value.substr(1);
            }

            isShortEnded = value in shortEndedElements;

            // Is self closing tag for example an <li> after an open <li>
            if (fixSelfClosing && selfClosing[value] && stack.length > 0 && stack[stack.length - 1].name === value) {
              processEndTag(value);
            }

            // Always invalidate element if it's marked as bogus
            var bogusValue = checkBogusAttribute(attrRegExp, matches[8]);
            if (bogusValue !== null) {
              if (bogusValue === 'all') {
                index = self.findEndTag(schema, html, tokenRegExp.lastIndex);
                tokenRegExp.lastIndex = index;
                continue;
              }

              isValidElement = false;
            }

            // Validate element
            if (!validate || (elementRule = schema.getElementRule(value))) {
              isValidElement = true;

              // Grab attributes map and patters when validation is enabled
              if (validate) {
                validAttributesMap = elementRule.attributes;
                validAttributePatterns = elementRule.attributePatterns;
              }

              // Parse attributes
              if ((attribsValue = matches[8])) {
                isInternalElement = attribsValue.indexOf('data-mce-type') !== -1; // Check if the element is an internal element

                // If the element has internal attributes then remove it if we are told to do so
                if (isInternalElement && removeInternalElements) {
                  isValidElement = false;
                }

                attrList = [];
                attrList.map = {};

                //attribsValue.replace(attrRegExp, parseAttribute);
                // eslint-disable-next-line no-loop-func
                attribsValue.replace(attrRegExp, (match, name, val, val2, val3) => {
                  parseAttribute(value, name, val, val2, val3);
                  return '';
                });
              } else {
                attrList = [];
                attrList.map = {};
              }

              // Process attributes if validation is enabled
              if (validate && !isInternalElement) {
                attributesRequired = elementRule.attributesRequired;
                attributesDefault = elementRule.attributesDefault;
                attributesForced = elementRule.attributesForced;
                anyAttributesRequired = elementRule.removeEmptyAttrs;

                // Check if any attribute exists
                if (anyAttributesRequired && !attrList.length) {
                  isValidElement = false;
                }

                // Handle forced attributes
                if (attributesForced) {
                  i = attributesForced.length;
                  while (i--) {
                    attr = attributesForced[i];
                    name = attr.name;
                    attrValue = attr.value;

                    if (attrValue === '{$uid}') {
                      attrValue = 'mce_' + idCount++;
                    }

                    attrList.map[name] = attrValue;
                    attrList.push({
                      name: name,
                      value: attrValue
                    });
                  }
                }

                // Handle default attributes
                if (attributesDefault) {
                  i = attributesDefault.length;
                  while (i--) {
                    attr = attributesDefault[i];
                    name = attr.name;

                    if (!(name in attrList.map)) {
                      attrValue = attr.value;

                      if (attrValue === '{$uid}') {
                        attrValue = 'mce_' + idCount++;
                      }

                      attrList.map[name] = attrValue;
                      attrList.push({
                        name: name,
                        value: attrValue
                      });
                    }
                  }
                }

                // Handle required attributes
                if (attributesRequired) {
                  i = attributesRequired.length;
                  while (i--) {
                    if (attributesRequired[i] in attrList.map) {
                      break;
                    }
                  }

                  // None of the required attributes where found
                  if (i === -1) {
                    isValidElement = false;
                  }
                }

                // Invalidate element if it's marked as bogus
                if ((attr = attrList.map['data-mce-bogus'])) {
                  if (attr === 'all') {
                    index = self.findEndTag(schema, html, tokenRegExp.lastIndex);
                    tokenRegExp.lastIndex = index;
                    continue;
                  }

                  isValidElement = false;
                }
              }

              if (isValidElement) {
                self.start(value, attrList, isShortEnded);
              }
            } else {
              isValidElement = false;
            }

            // Treat script, noscript and style a bit different since they may include code that looks like elements
            if ((endRegExp = specialElements[value]) && value != 'title' && value != 'textarea') {
              endRegExp.lastIndex = index = matches.index + matches[0].length;

              if ((matches = endRegExp.exec(html))) {
                if (isValidElement) {
                  text = html.substr(index, matches.index - index);
                }

                index = matches.index + matches[0].length;
              } else {
                text = html.substr(index);
                index = html.length;
              }

              if (isValidElement) {
                if (text.length > 0) {
                  self.text(text, true);
                }

                self.end(value);
              }

              tokenRegExp.lastIndex = index;
              continue;
            }

            // Push value on to stack
            if (!isShortEnded) {
              if (!attribsValue || attribsValue.indexOf('/') != attribsValue.length - 1) {
                stack.push({
                  name: value,
                  valid: isValidElement
                });
              } else if (isValidElement) {
                self.end(value);
              }
            }
          } else if ((value = matches[1])) { // Comment
            self.comment(trimComments(processComment(value)));
          } else if ((value = matches[2])) { // CDATA

            // Ensure we are in a valid CDATA context (eg child of svg or mathml). If we aren't in a valid context then the cdata should
            // be treated as a bogus comment. See https://html.spec.whatwg.org/multipage/parsing.html#markup-declaration-open-state
            var isValidCdataSection = format === 'xml' || settings.preserve_cdata || stack.length > 0 && schema.isValidChild(stack[stack.length - 1].name, '#cdata');

            if (isValidCdataSection) {
              self.cdata(trimComments(value));
            } else {
              index = processMalformedComment('', matches.index + 2);
              tokenRegExp.lastIndex = index;
              continue;
            }
          } else if ((value = matches[3])) { // DOCTYPE
            self.doctype(value);
          } else if ((value = matches[4])) { // PI
            self.pi(value, matches[5]);

            /*if (format === 'xml') {
              self.pi(value, matches[5]);
            } else {
              // Processing Instructions aren't valid in HTML so it should be treated as a bogus comment.
              // See https://html.spec.whatwg.org/multipage/parsing.html#tag-open-state
              index = processMalformedComment('?', matches.index + 2); // <? === 2 chars

              tokenRegExp.lastIndex = index;
              continue;
            }*/
          }

          index = matches.index + matches[0].length;
        }

        // Text
        if (index < html.length) {
          self.text(decode(html.substr(index)));
        }

        // Close any open elements
        for (i = stack.length - 1; i >= 0; i--) {
          value = stack[i];

          if (value.valid) {
            self.end(value.name);
          }
        }
      };
    };
  })(tinymce);

  /**
   * Node.js
   *
   * Copyright, Moxiecode Systems AB
   * Released under LGPL License.
   *
   * License: http://www.tinymce.com/license - Inactive
   * Licence: GNU/LGPL 2.1 or later - http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
   * Contributing: http://www.tinymce.com/contributing - Inactive
   */

  (function (tinymce) {
    var whiteSpaceRegExp = /^[ \t\r\n]*$/,
      typeLookup = {
        '#text': 3,
        '#comment': 8,
        '#cdata': 4,
        '#pi': 7,
        '#doctype': 10,
        '#document-fragment': 11
      };

    // Walks the tree left/right
    function walk(node, root_node, prev) {
      var sibling, parent, startName = prev ? 'lastChild' : 'firstChild',
        siblingName = prev ? 'prev' : 'next';

      // Walk into nodes if it has a start
      if (node[startName]) {
        return node[startName];
      }

      // Return the sibling if it has one
      if (node !== root_node) {
        sibling = node[siblingName];

        if (sibling) {
          return sibling;
        }

        // Walk up the parents to look for siblings
        for (parent = node.parent; parent && parent !== root_node; parent = parent.parent) {
          sibling = parent[siblingName];

          if (sibling) {
            return sibling;
          }
        }
      }
    }

    /**
     * This class is a minimalistic implementation of a DOM like node used by the DomParser class.
     *
     * @example
     * var node = new tinymce.html.Node('strong', 1);
     * someRoot.append(node);
     *
     * @class tinymce.html.Node
     * @version 3.4
     */

    /**
     * Constructs a new Node instance.
     *
     * @constructor
     * @method Node
     * @param {String} name Name of the node type.
     * @param {Number} type Numeric type representing the node.
     */
    function Node(name, type) {
      this.name = name;
      this.type = type;

      if (type === 1) {
        this.attributes = [];
        this.attributes.map = {};
      }
    }

    tinymce.extend(Node.prototype, {
      /**
       * Replaces the current node with the specified one.
       *
       * @example
       * someNode.replace(someNewNode);
       *
       * @method replace
       * @param {tinymce.html.Node} node Node to replace the current node with.
       * @return {tinymce.html.Node} The old node that got replaced.
       */
      replace: function (node) {
        var self = this;

        if (node.parent) {
          node.remove();
        }

        self.insert(node, self);
        self.remove();

        return self;
      },

      /**
       * Gets/sets or removes an attribute by name.
       *
       * @example
       * someNode.attr("name", "value"); // Sets an attribute
       * console.log(someNode.attr("name")); // Gets an attribute
       * someNode.attr("name", null); // Removes an attribute
       *
       * @method attr
       * @param {String} name Attribute name to set or get.
       * @param {String} value Optional value to set.
       * @return {String/tinymce.html.Node} String or undefined on a get operation or the current node on a set operation.
       */
      attr: function (name, value) {
        var self = this,
          attrs, i, undef;

        if (typeof name !== "string") {
          for (i in name) {
            self.attr(i, name[i]);
          }

          return self;
        }

        if ((attrs = self.attributes)) {
          if (value !== undef) {
            // Remove attribute
            if (value === null) {
              if (name in attrs.map) {
                delete attrs.map[name];

                i = attrs.length;
                while (i--) {
                  if (attrs[i].name === name) {
                    attrs = attrs.splice(i, 1);
                    return self;
                  }
                }
              }

              return self;
            }

            // Set attribute
            if (name in attrs.map) {
              // stringify value
              value = '' + value;

              // Set attribute
              i = attrs.length;
              while (i--) {
                if (attrs[i].name === name) {
                  attrs[i].value = value;
                  break;
                }
              }
            } else {
              attrs.push({
                name: name,
                value: value
              });
            }

            attrs.map[name] = value;

            return self;
          } else {
            return attrs.map[name];
          }
        }
      },

      addClass: function (str) {
        var self = this;

        var cls = self.attr('class') || '';

        if (!str) {
          return cls;
        }

        if (str.indexOf(' ') !== -1) {

          tinymce.each(str.split(' '), function (val) {
            self.addClass(val);
          });

        } else {
          if (self.hasClass(str)) {
            return cls;
          }

          cls = tinymce.trim(cls + ' ' + str);

          self.attr('class', cls);

          return cls;
        }
      },

      hasClass: function (str) {
        var cls = this.attr('class') || '';
        return (' ' + cls + ' ').indexOf(' ' + str + ' ') !== -1;
      },

      removeClass: function (str) {
        var self = this, cls = self.attr('class') || '';

        if (!str) {
          return cls;
        }

        if (str.indexOf(' ') !== -1) {
          tinymce.each(str.split(' '), function (val) {
            self.removeClass(val);
          });
        } else {
          if (self.hasClass(str)) {
            cls = tinymce.trim((" " + cls + " ").replace(' ' + str + ' ', ' '));

            // remove the attribute if the value is empty
            if (!cls) {
              self.attr('class', null);
            } else {
              self.attr('class', cls);
            }
          }

          return cls;
        }
      },

      /**
       * Does a shallow clones the node into a new node. It will also exclude id attributes since
       * there should only be one id per document.
       *
       * @example
       * var clonedNode = node.clone();
       *
       * @method clone
       * @return {tinymce.html.Node} New copy of the original node.
       */
      clone: function (deep) {
        var self = this,
          clone = new Node(self.name, self.type),
          i, l, selfAttrs, selfAttr, cloneAttrs, node, next;

        // Clone element attributes
        if ((selfAttrs = self.attributes)) {
          cloneAttrs = [];
          cloneAttrs.map = {};

          for (i = 0, l = selfAttrs.length; i < l; i++) {
            selfAttr = selfAttrs[i];

            // Clone everything except id
            if (selfAttr.name !== 'id') {
              cloneAttrs[cloneAttrs.length] = {
                name: selfAttr.name,
                value: selfAttr.value
              };
              cloneAttrs.map[selfAttr.name] = selfAttr.value;
            }
          }

          clone.attributes = cloneAttrs;
        }

        clone.value = self.value;
        clone.shortEnded = self.shortEnded;

        if (deep) {
          // append all the children
          for (node = self.firstChild; node;) {
            next = node.next;
            clone.append(node);
            node = next;
          }
        }

        return clone;
      },

      /**
       * Wraps the node in in another node.
       *
       * @example
       * node.wrap(wrapperNode);
       *
       * @method wrap
       */
      wrap: function (wrapper) {
        var self = this;

        self.parent.insert(wrapper, self);
        wrapper.append(self);

        return self;
      },

      /**
       * Unwraps the node in other words it removes the node but keeps the children.
       *
       * @example
       * node.unwrap();
       *
       * @method unwrap
       */
      unwrap: function () {
        var self = this,
          node, next;

        for (node = self.firstChild; node;) {
          next = node.next;
          self.insert(node, self, true);
          node = next;
        }

        self.remove();
      },

      /**
       * Removes the node from it's parent.
       *
       * @example
       * node.remove();
       *
       * @method remove
       * @return {tinymce.html.Node} Current node that got removed.
       */
      remove: function () {
        var self = this,
          parent = self.parent,
          next = self.next,
          prev = self.prev;

        if (parent) {
          if (parent.firstChild === self) {
            parent.firstChild = next;

            if (next) {
              next.prev = null;
            }
          } else {
            prev.next = next;
          }

          if (parent.lastChild === self) {
            parent.lastChild = prev;

            if (prev) {
              prev.next = null;
            }
          } else {
            next.prev = prev;
          }

          self.parent = self.next = self.prev = null;
        }

        return self;
      },

      /**
       * Appends a new node as a child of the current node.
       *
       * @example
       * node.append(someNode);
       *
       * @method append
       * @param {tinymce.html.Node} node Node to append as a child of the current one.
       * @return {tinymce.html.Node} The node that got appended.
       */
      append: function (node) {
        var self = this,
          last;

        if (node.parent) {
          node.remove();
        }

        last = self.lastChild;
        if (last) {
          last.next = node;
          node.prev = last;
          self.lastChild = node;
        } else {
          self.lastChild = self.firstChild = node;
        }

        node.parent = self;

        return node;
      },

      /**
       * Inserts a node at a specific position as a child of the current node.
       *
       * @example
       * parentNode.insert(newChildNode, oldChildNode);
       *
       * @method insert
       * @param {tinymce.html.Node} node Node to insert as a child of the current node.
       * @param {tinymce.html.Node} ref_node Reference node to set node before/after.
       * @param {Boolean} before Optional state to insert the node before the reference node.
       * @return {tinymce.html.Node} The node that got inserted.
       */
      insert: function (node, ref_node, before) {
        var parent;

        if (node.parent) {
          node.remove();
        }

        parent = ref_node.parent || this;

        if (before) {
          if (ref_node === parent.firstChild) {
            parent.firstChild = node;
          } else {
            ref_node.prev.next = node;
          }

          node.prev = ref_node.prev;
          node.next = ref_node;
          ref_node.prev = node;
        } else {
          if (ref_node === parent.lastChild) {
            parent.lastChild = node;
          } else {
            ref_node.next.prev = node;
          }

          node.next = ref_node.next;
          node.prev = ref_node;
          ref_node.next = node;
        }

        node.parent = parent;

        return node;
      },

      /**
       * Get all children by name.
       *
       * @method getAll
       * @param {String} name Name of the child nodes to collect.
       * @return {Array} Array with child nodes matchin the specified name.
       */
      getAll: function (name) {
        var self = this,
          node, collection = [];

        for (node = self.firstChild; node; node = walk(node, self)) {
          if (node.name === name) {
            collection.push(node);
          }
        }

        return collection;
      },

      /**
       * Get all children of this node.
       *
       * @method children
       * @return {Array} Array containing child nodes.
     */
      children: function () {
        var self = this,
          node, collection = [];

        for (node = self.firstChild; node; node = node.next) {
          collection.push(node);
        }

        return collection;
      },

      /**
  		 * Removes all children of the current node.
  		 *
  		 * @method empty
  		 * @return {tinymce.html.Node} The current node that got cleared.
  		 */
      empty: function () {
        var self = this,
          nodes, i, node;

        // Remove all children
        if (self.firstChild) {
          nodes = [];

          // Collect the children
          for (node = self.firstChild; node; node = walk(node, self)) {
            nodes.push(node);
          }

          // Remove the children
          i = nodes.length;
          while (i--) {
            node = nodes[i];
            node.parent = node.firstChild = node.lastChild = node.next = node.prev = null;
          }
        }

        self.firstChild = self.lastChild = null;

        return self;
      },

      /**
       * Returns true/false if the node is to be considered empty or not.
       *
       * @example
       * node.isEmpty({img : true});
       * @method isEmpty
       * @param {Object} elements Name/value object with elements that are automatically treated as non empty elements.
       * @return {Boolean} true/false if the node is empty or not.
       */
      isEmpty: function (elements) {
        var self = this,
          node = self.firstChild,
          i, name;

        function isValidAttribute(name) {
          // allow for anchors and html templating
          if (name == "name" || name == "id" || name == "class") {
            return true;
          }

          // allow some system and generic data- attributes
          if (name.indexOf('-') != -1) {
            if (name == 'data-mce-bookmark') {
              return true;
            }

            if (name.indexOf('data-mce-') != -1) {
              return false;
            }

            return true;
          }

          return false;
        }

        if (node) {
          do {
            if (node.type === 1) {
              // Ignore bogus elements
              if (node.attributes.map['data-mce-bogus']) {
                continue;
              }

              // Keep empty elements like <img />
              if (elements[node.name]) {
                return false;
              }

              // Keep elements with data attributes or name attribute like <a name="1"></a>
              i = node.attributes.length;

              while (i--) {
                name = node.attributes[i].name;

                if (isValidAttribute(name)) {
                  return false;
                }
              }

              // Keep elements with attributes
              /*if (node.attributes.length) {
                return false;
              }*/
            }

            // Keep comments
            if (node.type === 8) {
              return false;
            }

            // Keep non whitespace text nodes
            if ((node.type === 3 && !whiteSpaceRegExp.test(node.value))) {
              return false;
            }
          } while ((node = walk(node, self)));
        }

        return true;
      },

      /**
       * Walks to the next or previous node and returns that node or null if it wasn't found.
       *
       * @method walk
       * @param {Boolean} prev Optional previous node state defaults to false.
       * @return {tinymce.html.Node} Node that is next to or previous of the current node.
       */
      walk: function (prev) {
        return walk(this, null, prev);
      }
    });

    tinymce.extend(Node, {
      /**
       * Creates a node of a specific type.
       *
       * @static
       * @method create
       * @param {String} name Name of the node type to create for example "b" or "#text".
       * @param {Object} attrs Name/value collection of attributes that will be applied to elements.
       */
      create: function (name, attrs) {
        var node, attrName;

        // Create node
        node = new Node(name, typeLookup[name] || 1);

        // Add attributes if needed
        if (attrs) {
          for (attrName in attrs) {
            node.attr(attrName, attrs[attrName]);
          }

          return node;
        }
      }
    });

    tinymce.html.Node = Node;
  })(tinymce);

  /**
   * DomParser.js
   *
   * Copyright, Moxiecode Systems AB
   * Released under LGPL License.
   *
   * License: http://www.tinymce.com/license - Inactive
   * Licence: GNU/LGPL 2.1 or later - http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
   * Contributing: http://www.tinymce.com/contributing - Inactive
   */

  (function (tinymce) {
    var Node = tinymce.html.Node,
      each = tinymce.each,
      explode = tinymce.explode,
      extend = tinymce.extend,
      makeMap = tinymce.makeMap;

    /**
     * This class parses HTML code into a DOM like structure of nodes it will remove redundant whitespace and make
     * sure that the node tree is valid according to the specified schema. So for example: <p>a<p>b</p>c</p> will become <p>a</p><p>b</p><p>c</p>
     *
     * @example
     * var parser = new tinymce.html.DomParser({validate: true}, schema);
     * var rootNode = parser.parse('<h1>content</h1>');
     *
     * @class tinymce.html.DomParser
     * @version 3.4
     */

    /**
     * Constructs a new DomParser instance.
     *
     * @constructor
     * @method DomParser
     * @param {Object} settings Name/value collection of settings. comment, cdata, text, start and end are callbacks.
     * @param {tinymce.html.Schema} schema HTML Schema class to use when parsing.
     */
    tinymce.html.DomParser = function (settings, schema) {
      var self = this,
        nodeFilters = {},
        attributeFilters = [],
        matchedNodes = {},
        matchedAttributes = {};

      settings = settings || {};
      settings.validate = "validate" in settings ? settings.validate : true;
      settings.root_name = settings.root_name || 'body';
      self.schema = schema = schema || new tinymce.html.Schema();

      function fixInvalidChildren(nodes) {
        var ni, node, parent, parents, newParent, currentNode, tempNode, childNode, i;
        var nonEmptyElements, nonSplitableElements, textBlockElements, specialElements, sibling, nextNode;

        nonSplitableElements = makeMap('tr,td,th,tbody,thead,tfoot,table');
        nonEmptyElements = schema.getNonEmptyElements();
        textBlockElements = schema.getTextBlockElements();
        specialElements = schema.getSpecialElements();

        var removeOrUnwrapInvalidNode = function (node, originalNodeParent) {
          if (specialElements[node.name]) {
            node.empty().remove();
          } else {
            // are the children of `node` valid children of the top level parent?
            // if not, remove or unwrap them too
            var children = node.children();

            for (var childNode of children) {
              if (!schema.isValidChild(originalNodeParent.name, childNode.name)) {
                removeOrUnwrapInvalidNode(childNode, originalNodeParent);
              }
            }

            node.unwrap();
          }
        };

        for (ni = 0; ni < nodes.length; ni++) {
          node = nodes[ni];

          // Already removed or fixed
          if (!node.parent || node.fixed) {
            continue;
          }

          // If the invalid element is a text block and the text block is within a parent LI element
          // Then unwrap the first text block and convert other sibling text blocks to LI elements similar to Word/Open Office
          if (textBlockElements[node.name] && node.parent.name == 'li') {
            // Move sibling text blocks after LI element
            sibling = node.next;
            while (sibling) {
              if (textBlockElements[sibling.name]) {
                sibling.name = 'li';
                sibling.fixed = true;
                node.parent.insert(sibling, node.parent);
              } else {
                break;
              }

              sibling = sibling.next;
            }

            // Unwrap current text block
            node.unwrap(node);
            continue;
          }

          // Get list of all parent nodes until we find a valid parent to stick the child into
          parents = [node];

          for (parent = node.parent; parent && !schema.isValidChild(parent.name, node.name) &&
            !nonSplitableElements[parent.name]; parent = parent.parent) {
            parents.push(parent);
          }

          // Found a suitable parent
          if (parent && parents.length > 1) {
            // If the node is a valid child of the parent, then try to move it. Otherwise unwrap it
            if (schema.isValidChild(parent.name, node.name)) {
              // Reverse the array since it makes looping easier
              parents.reverse();

              // Clone the related parent and insert that after the moved node
              newParent = currentNode = self.filterNode(parents[0].clone());

              // Start cloning and moving children on the left side of the target node
              for (i = 0; i < parents.length - 1; i++) {
                if (schema.isValidChild(currentNode.name, parents[i].name)) {
                  tempNode = self.filterNode(parents[i].clone());
                  currentNode.append(tempNode);
                } else {
                  tempNode = currentNode;
                }

                for (childNode = parents[i].firstChild; childNode && childNode != parents[i + 1];) {
                  nextNode = childNode.next;
                  tempNode.append(childNode);
                  childNode = nextNode;
                }

                currentNode = tempNode;
              }

              if (!newParent.isEmpty(nonEmptyElements)) {
                parent.insert(newParent, parents[0], true);
                parent.insert(node, newParent);
              } else {
                parent.insert(node, parents[0], true);
              }

              // Check if the element is empty by looking through it's contents and special treatment for <p><br /></p>
              parent = parents[0];

              if (parent.isEmpty(nonEmptyElements) || parent.firstChild === parent.lastChild && parent.firstChild.name === 'br') {
                parent.empty().remove();
              }
            } else {
              removeOrUnwrapInvalidNode(node, node.parent);
            }
          } else if (node.parent) {
            // If it's an LI try to find a UL/OL for it or wrap it
            if (node.name === 'li') {
              sibling = node.prev;
              if (sibling && (sibling.name === 'ul' || sibling.name === 'ul')) {
                sibling.append(node);
                continue;
              }

              sibling = node.next;
              if (sibling && (sibling.name === 'ul' || sibling.name === 'ul')) {
                sibling.insert(node, sibling.firstChild, true);
                continue;
              }

              node.wrap(self.filterNode(new Node('ul', 1)));
              continue;
            }

            // Try wrapping the element in a DIV
            if (schema.isValidChild(node.parent.name, 'div') && schema.isValidChild('div', node.name)) {
              node.wrap(self.filterNode(new Node('div', 1)));
            } else {
              // We failed wrapping it, remove or unwrap it
              removeOrUnwrapInvalidNode(node, node.parent);
            }
          }
        }
      }

      /**
       * Runs the specified node though the element and attributes filters.
       *
       * @method filterNode
       * @param {tinymce.html.Node} Node the node to run filters on.
       * @return {tinymce.html.Node} The passed in node.
       */
      self.filterNode = function (node) {
        var i, name, list;

        // Run element filters
        if (name in nodeFilters) {
          list = matchedNodes[name];

          if (list) {
            list.push(node);
          } else {
            matchedNodes[name] = [node];
          }
        }

        // Run attribute filters
        i = attributeFilters.length;
        while (i--) {
          name = attributeFilters[i].name;

          if (name in node.attributes.map) {
            list = matchedAttributes[name];

            if (list) {
              list.push(node);
            } else {
              matchedAttributes[name] = [node];
            }
          }
        }

        return node;
      };

      /**
       * Adds a node filter function to the parser, the parser will collect the specified nodes by name
       * and then execute the callback ones it has finished parsing the document.
       *
       * @example
       * parser.addNodeFilter('p,h1', function(nodes, name) {
       *		for (var i = 0; i < nodes.length; i++) {
       *			console.log(nodes[i].name);
       *		}
       * });
       * @method addNodeFilter
       * @method {String} name Comma separated list of nodes to collect.
       * @param {function} callback Callback function to execute once it has collected nodes.
       */
      self.addNodeFilter = function (name, callback) {
        each(explode(name), function (name) {
          var list = nodeFilters[name];

          if (!list) {
            nodeFilters[name] = list = [];
          }

          list.push(callback);
        });
      };

      /**
       * Adds a attribute filter function to the parser, the parser will collect nodes that has the specified attributes
       * and then execute the callback ones it has finished parsing the document.
       *
       * @example
       * parser.addAttributeFilter('src,href', function(nodes, name) {
       *		for (var i = 0; i < nodes.length; i++) {
       *			console.log(nodes[i].name);
       *		}
       * });
       * @method addAttributeFilter
       * @method {String} name Comma separated list of nodes to collect.
       * @param {function} callback Callback function to execute once it has collected nodes.
       */
      self.addAttributeFilter = function (name, callback) {
        each(explode(name), function (name) {
          var i;

          for (i = 0; i < attributeFilters.length; i++) {
            if (attributeFilters[i].name === name) {
              attributeFilters[i].callbacks.push(callback);
              return;
            }
          }

          attributeFilters.push({
            name: name,
            callbacks: [callback]
          });
        });
      };

      /**
       * Parses the specified HTML string into a DOM like node tree and returns the result.
       *
       * @example
       * var rootNode = new DomParser({...}).parse('<b>text</b>');
       * @method parse
       * @param {String} html Html string to sax parse.
       * @param {Object} args Optional args object that gets passed to all filter functions.
       * @return {tinymce.html.Node} Root node containing the tree.
       */
      self.parse = function (html, args) {
        var parser, rootNode, node, nodes, i, l, fi, fl, list, name, validate;
        var blockElements, startWhiteSpaceRegExp, invalidChildren = [],
          isInWhiteSpacePreservedElement;
        var endWhiteSpaceRegExp, allWhiteSpaceRegExp, isAllWhiteSpaceRegExp, whiteSpaceElements;
        var children, nonEmptyElements, rootBlockName;

        args = args || {};
        matchedNodes = {};
        matchedAttributes = {};
        blockElements = extend(makeMap('script,style,head,html,body,title,meta,param'), schema.getBlockElements());
        nonEmptyElements = schema.getNonEmptyElements();
        children = schema.children;
        validate = settings.validate;
        rootBlockName = "forced_root_block" in args ? args.forced_root_block : settings.forced_root_block;

        whiteSpaceElements = schema.getWhiteSpaceElements();
        startWhiteSpaceRegExp = /^[ \t\r\n]+/;
        endWhiteSpaceRegExp = /[ \t\r\n]+$/;
        allWhiteSpaceRegExp = /[ \t\r\n]+/g;
        isAllWhiteSpaceRegExp = /^[ \t\r\n]+$/;

        function addRootBlocks() {
          var node = rootNode.firstChild,
            next, rootBlockNode;

          // Removes whitespace at beginning and end of block so:
          // <p> x </p> -> <p>x</p>
          function trim(rootBlockNode) {
            if (rootBlockNode) {
              node = rootBlockNode.firstChild;
              if (node && node.type == 3) {
                node.value = node.value.replace(startWhiteSpaceRegExp, '');
              }

              node = rootBlockNode.lastChild;
              if (node && node.type == 3) {
                node.value = node.value.replace(endWhiteSpaceRegExp, '');
              }
            }
          }

          // Check if rootBlock is valid within rootNode for example if P is valid in H1 if H1 is the contentEditabe root
          if (!schema.isValidChild(rootNode.name, rootBlockName.toLowerCase())) {
            return;
          }

          while (node) {
            next = node.next;

            if ((node.type == 3 && tinymce.trim(node.value)) || (node.type == 1 && node.name !== 'p' && !blockElements[node.name] && !node.attr('data-mce-type'))) {
              if (!rootBlockNode) {
                // Create a new root block element
                rootBlockNode = createNode(rootBlockName, 1);
                rootBlockNode.attr(settings.forced_root_block_attrs);
                rootNode.insert(rootBlockNode, node);
                rootBlockNode.append(node);
              } else {
                rootBlockNode.append(node);
              }
            } else {
              trim(rootBlockNode);
              rootBlockNode = null;
            }

            node = next;
          }

          trim(rootBlockNode);
        }

        function createNode(name, type) {
          var node = new Node(name, type),
            list;

          if (name in nodeFilters) {
            list = matchedNodes[name];

            if (list) {
              list.push(node);
            } else {
              matchedNodes[name] = [node];
            }
          }

          return node;
        }

        function removeWhitespaceBefore(node) {
          var textNode, textNodeNext, textVal, sibling, blockElements = schema.getBlockElements();

          for (textNode = node.prev; textNode && textNode.type === 3;) {
            textVal = textNode.value.replace(endWhiteSpaceRegExp, '');

            // Found a text node with non whitespace then trim that and break
            if (textVal.length > 0) {
              textNode.value = textVal;
              return;
            }

            textNodeNext = textNode.next;

            // Fix for bug #7543 where bogus nodes would produce empty
            // text nodes and these would be removed if a nested list was before it
            if (textNodeNext) {
              if (textNodeNext.type == 3 && textNodeNext.value.length) {
                textNode = textNode.prev;
                continue;
              }

              if (!blockElements[textNodeNext.name] && textNodeNext.name != 'script' && textNodeNext.name != 'style') {
                textNode = textNode.prev;
                continue;
              }
            }

            sibling = textNode.prev;
            textNode.remove();
            textNode = sibling;
          }
        }

        function cloneAndExcludeBlocks(input) {
          var name, output = {};

          for (name in input) {
            if (name !== 'li' && name != 'p') {
              output[name] = input[name];
            }
          }

          return output;
        }

        parser = new tinymce.html.SaxParser({
          validate: validate,
          allow_script_urls: settings.allow_script_urls,
          allow_conditional_comments: settings.allow_conditional_comments,
          allow_event_attributes: settings.allow_event_attributes,

          // Exclude P and LI from DOM parsing since it's treated better by the DOM parser
          self_closing_elements: cloneAndExcludeBlocks(schema.getSelfClosingElements()),

          cdata: function (text) {
            node.append(createNode('#cdata', 4)).value = text;
          },

          text: function (text, raw) {
            var textNode;

            // Trim all redundant whitespace on non white space elements
            if (!isInWhiteSpacePreservedElement) {
              text = text.replace(allWhiteSpaceRegExp, ' ');

              if (node.lastChild && blockElements[node.lastChild.name]) {
                text = text.replace(startWhiteSpaceRegExp, '');
              }
            }

            // Do we need to create the node
            if (text.length !== 0) {
              textNode = createNode('#text', 3);
              textNode.raw = !!raw;
              node.append(textNode).value = text;
            }
          },

          comment: function (text) {
            node.append(createNode('#comment', 8)).value = text;
          },

          pi: function (name, text) {
            node.append(createNode(name, 7)).value = text;
            removeWhitespaceBefore(node);
          },

          doctype: function (text) {
            var newNode;

            newNode = node.append(createNode('#doctype', 10));
            newNode.value = text;
            removeWhitespaceBefore(node);
          },

          start: function (name, attrs, empty) {
            var newNode, attrFiltersLen, elementRule, attrName, parent;

            elementRule = validate ? schema.getElementRule(name) : {};

            if (elementRule) {
              newNode = createNode(elementRule.outputName || name, 1);
              newNode.attributes = attrs;
              newNode.shortEnded = empty;

              node.append(newNode);

              // Check if node is valid child of the parent node is the child is
              // unknown we don't collect it since it's probably a custom element
              parent = children[node.name];
              if (parent && children[newNode.name] && !parent[newNode.name]) {
                invalidChildren.push(newNode);
              }

              attrFiltersLen = attributeFilters.length;

              while (attrFiltersLen--) {
                attrName = attributeFilters[attrFiltersLen].name;

                if (attrName in attrs.map) {
                  list = matchedAttributes[attrName];

                  if (list) {
                    list.push(newNode);
                  } else {
                    matchedAttributes[attrName] = [newNode];
                  }
                }
              }

              // Trim whitespace before block
              if (blockElements[name]) {
                removeWhitespaceBefore(newNode);
              }

              // Change current node if the element wasn't empty i.e not <br /> or <img />
              if (!empty) {
                node = newNode;
              }

              // Check if we are inside a whitespace preserved element
              if (!isInWhiteSpacePreservedElement && whiteSpaceElements[name]) {
                isInWhiteSpacePreservedElement = true;
              }
            }
          },

          end: function (name) {
            var textNode, elementRule, text, sibling, tempNode;

            elementRule = validate ? schema.getElementRule(name) : {};

            if (elementRule) {
              if (blockElements[name]) {
                if (!isInWhiteSpacePreservedElement) {
                  // Trim whitespace of the first node in a block
                  textNode = node.firstChild;
                  if (textNode && textNode.type === 3) {
                    text = textNode.value.replace(startWhiteSpaceRegExp, '');

                    // Any characters left after trim or should we remove it
                    if (text.length > 0) {
                      textNode.value = text;
                      textNode = textNode.next;
                    } else {
                      sibling = textNode.next;
                      textNode.remove();
                      textNode = sibling;

                      // Remove any pure whitespace siblings
                      while (textNode && textNode.type === 3) {
                        text = textNode.value;
                        sibling = textNode.next;

                        if (text.length === 0 || isAllWhiteSpaceRegExp.test(text)) {
                          textNode.remove();
                          textNode = sibling;
                        }

                        textNode = sibling;
                      }
                    }
                  }

                  // Trim whitespace of the last node in a block
                  textNode = node.lastChild;
                  if (textNode && textNode.type === 3) {
                    text = textNode.value.replace(endWhiteSpaceRegExp, '');

                    // Any characters left after trim or should we remove it
                    if (text.length > 0) {
                      textNode.value = text;
                      textNode = textNode.prev;
                    } else {
                      sibling = textNode.prev;
                      textNode.remove();
                      textNode = sibling;

                      // Remove any pure whitespace siblings
                      while (textNode && textNode.type === 3) {
                        text = textNode.value;
                        sibling = textNode.prev;

                        if (text.length === 0 || isAllWhiteSpaceRegExp.test(text)) {
                          textNode.remove();
                          textNode = sibling;
                        }

                        textNode = sibling;
                      }
                    }
                  }
                }

                // Trim start white space
                // Removed due to: #5424
                /*textNode = node.prev;
                if (textNode && textNode.type === 3) {
                  text = textNode.value.replace(startWhiteSpaceRegExp, '');

                  if (text.length > 0)
                    textNode.value = text;
                  else
                    textNode.remove();
                }*/
              }

              // Check if we exited a whitespace preserved element
              if (isInWhiteSpacePreservedElement && whiteSpaceElements[name]) {
                isInWhiteSpacePreservedElement = false;
              }

              // Handle empty nodes
              if (elementRule.removeEmpty || elementRule.paddEmpty) {
                if (node.isEmpty(nonEmptyElements)) {
                  if (elementRule.paddEmpty) {
                    node.empty().append(new Node('#text', '3')).value = '\u00a0';
                  } else {
                    // Leave nodes that have a name like <a name="name">
                    if (!node.attributes.map.name && !node.attributes.map.id) {
                      tempNode = node.parent;

                      if (blockElements[node.name]) {
                        node.empty().remove();
                      } else {
                        node.unwrap();
                      }

                      node = tempNode;
                      return;
                    }
                  }
                }
              }

              node = node.parent;
            }
          }
        }, schema);

        rootNode = node = new Node(args.context || settings.root_name, 11);

        parser.parse(html);

        // Fix invalid children or report invalid children in a contextual parsing
        if (validate && invalidChildren.length) {
          if (!args.context) {
            fixInvalidChildren(invalidChildren);
          } else {
            args.invalid = true;
          }
        }

        // Wrap nodes in the root into block elements if the root is body
        if (rootBlockName && (rootNode.name == 'body' || args.isRootContent)) {
          addRootBlocks();
        }

        // Run filters only when the contents is valid
        if (!args.invalid) {
          // Run node filters
          for (name in matchedNodes) {
            list = nodeFilters[name];
            nodes = matchedNodes[name];

            // Remove already removed children
            fi = nodes.length;
            while (fi--) {
              if (!nodes[fi].parent) {
                nodes.splice(fi, 1);
              }
            }

            for (i = 0, l = list.length; i < l; i++) {
              list[i](nodes, name, args);
            }
          }

          // Run attribute filters
          for (i = 0, l = attributeFilters.length; i < l; i++) {
            list = attributeFilters[i];

            if (list.name in matchedAttributes) {
              nodes = matchedAttributes[list.name];

              // Remove already removed children
              fi = nodes.length;
              while (fi--) {
                if (!nodes[fi].parent) {
                  nodes.splice(fi, 1);
                }
              }

              for (fi = 0, fl = list.callbacks.length; fi < fl; fi++) {
                list.callbacks[fi](nodes, list.name, args);
              }
            }
          }
        }

        return rootNode;
      };

      // Remove <br> at end of block elements Gecko and WebKit injects BR elements to
      // make it possible to place the caret inside empty blocks. This logic tries to remove
      // these elements and keep br elements that where intended to be there intact
      if (settings.remove_trailing_brs) {
        self.addNodeFilter('br', function (nodes) {
          var i, l = nodes.length,
            node, blockElements = extend({}, schema.getBlockElements());
          var nonEmptyElements = schema.getNonEmptyElements(),
            parent, lastParent, prev, prevName;
          var textNode, elementRule;

          // Remove brs from body element as well
          blockElements.body = 1;

          // Must loop forwards since it will otherwise remove all brs in <p>a<br><br><br></p>
          for (i = 0; i < l; i++) {
            node = nodes[i];
            parent = node.parent;

            if (blockElements[node.parent.name] && node === parent.lastChild) {
              // Loop all nodes to the left of the current node and check for other BR elements
              // excluding bookmarks since they are invisible
              prev = node.prev;
              while (prev) {
                prevName = prev.name;

                // Ignore bookmarks
                if (prevName !== "span" || prev.attr('data-mce-type') !== 'bookmark') {
                  // Found a non BR element
                  if (prevName !== "br") {
                    break;
                  }

                  // Found another br it's a <br><br> structure then don't remove anything
                  if (prevName === 'br') {
                    node = null;
                    break;
                  }
                }

                prev = prev.prev;
              }

              if (node) {

                // skip breaks with attributes
                if (node.attributes.length && node.attributes[0].name !== 'data-mce-bogus') {
                  continue;
                }

                node.remove();

                // Is the parent to be considered empty after we removed the BR
                if (parent.isEmpty(nonEmptyElements)) {
                  elementRule = schema.getElementRule(parent.name);

                  // Remove or padd the element depending on schema rule
                  if (elementRule) {
                    if (elementRule.removeEmpty) {
                      parent.remove();
                    } else if (elementRule.paddEmpty) {
                      parent.empty().append(new Node('#text', 3)).value = '\u00a0';
                    }
                  }
                }
              }
            } else {
              // Replaces BR elements inside inline elements like <p><b><i><br></i></b></p>
              // so they become <p><b><i>&nbsp;</i></b></p>
              lastParent = node;
              while (parent && parent.firstChild === lastParent && parent.lastChild === lastParent) {
                lastParent = parent;

                if (blockElements[parent.name]) {
                  break;
                }

                parent = parent.parent;
              }

              if (lastParent === parent) {
                textNode = new Node('#text', 3);
                textNode.value = '\u00a0';
                node.replace(textNode);
              }
            }
          }
        });
      }

      self.addAttributeFilter('href', function (nodes) {
        var i = nodes.length,
          node;

        var appendRel = function (rel) {
          var parts = rel.split(' ').filter(function (p) {
            return p.length > 0;
          });
          return parts.concat(['noopener']).sort().join(' ');
        };

        var addNoOpener = function (rel) {
          var newRel = rel ? tinymce.trim(rel) : '';
          if (!/\b(noopener)\b/g.test(newRel)) {
            return appendRel(newRel);
          } else {
            return newRel;
          }
        };

        if (!settings.allow_unsafe_link_target) {
          while (i--) {
            node = nodes[i];
            if (node.name === 'a' && node.attr('target') === '_blank' && /:\/\//.test(node.attr('href'))) {
              node.attr('rel', addNoOpener(node.attr('rel')));
            }
          }
        }
      });

      // Force anchor names closed, unless the setting "allow_html_in_named_anchor" is explicitly included.
      if (!settings.allow_html_in_named_anchor) {
        self.addAttributeFilter('id,name', function (nodes) {
          var i = nodes.length,
            sibling, prevSibling, parent, node;

          while (i--) {
            node = nodes[i];
            if (node.name === 'a' && node.firstChild && !node.attr('href')) {
              parent = node.parent;

              // Move children after current node
              sibling = node.lastChild;
              do {
                prevSibling = sibling.prev;
                parent.insert(sibling, node);
                sibling = prevSibling;
              } while (sibling);
            }
          }
        });
      }

      if (settings.validate && schema.getValidClasses()) {
        self.addAttributeFilter('class', function (nodes) {
          var i = nodes.length,
            node, classList, ci, className, classValue;
          var validClasses = schema.getValidClasses(),
            validClassesMap, valid;

          while (i--) {
            node = nodes[i];
            classList = node.attr('class').split(' ');
            classValue = '';

            for (ci = 0; ci < classList.length; ci++) {
              className = classList[ci];
              valid = false;

              validClassesMap = validClasses['*'];
              if (validClassesMap && validClassesMap[className]) {
                valid = true;
              }

              validClassesMap = validClasses[node.name];
              if (!valid && validClassesMap && validClassesMap[className]) {
                valid = true;
              }

              if (valid) {
                if (classValue) {
                  classValue += ' ';
                }

                classValue += className;
              }
            }

            if (!classValue.length) {
              classValue = null;
            }

            node.attr('class', classValue);
          }
        });
      }
    };
  })(tinymce);

  /**
   * Serializer.js
   *
   * Copyright, Moxiecode Systems AB
   * Released under LGPL License.
   *
   * License: http://www.tinymce.com/license - Inactive
   * Licence: GNU/LGPL 2.1 or later - http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
   * Contributing: http://www.tinymce.com/contributing - Inactive
   */

  (function (tinymce) {
    /**
  	 * This class is used to serialize down the DOM tree into a string using a Writer instance.
  	 *
  	 *
  	 * @example
  	 * new tinymce.html.Serializer().serialize(new tinymce.html.DomParser().parse('<p>text</p>'));
  	 * @class tinymce.html.Serializer
  	 * @version 3.4
  	 */

    /**
  	 * Constructs a new Serializer instance.
  	 *
  	 * @constructor
  	 * @method Serializer
  	 * @param {Object} settings Name/value settings object.
  	 * @param {tinymce.html.Schema} schema Schema instance to use.
  	 */
    tinymce.html.Serializer = function (settings, schema) {
      var self = this,
        writer = new tinymce.html.Writer(settings, schema);

      settings = settings || {};
      settings.validate = "validate" in settings ? settings.validate : true;

      self.schema = schema = schema || new tinymce.html.Schema();
      self.writer = writer;

      var boolAttrMap = schema.getBoolAttrs();
      /**
  		 * Serializes the specified node into a string.
  		 *
  		 * @example
  		 * new tinymce.html.Serializer().serialize(new tinymce.html.DomParser().parse('<p>text</p>'));
  		 * @method serialize
  		 * @param {tinymce.html.Node} node Node instance to serialize.
  		 * @return {String} String with HTML based on DOM tree.
  		 */
      self.serialize = function (node) {
        var handlers, validate;

        validate = settings.validate;

        handlers = {
          // #text
          3: function (node) {
            writer.text(node.value, node.raw);
          },

          // #comment
          8: function (node) {
            writer.comment(node.value);
          },

          // Processing instruction
          7: function (node) {
            writer.pi(node.name, node.value);
          },

          // Doctype
          10: function (node) {
            writer.doctype(node.value);
          },

          // CDATA
          4: function (node) {
            writer.cdata(node.value);
          },

          // Document fragment
          11: function (node) {
            if ((node = node.firstChild)) {
              do {
                walk(node);
              } while ((node = node.next));
            }
          }
        };

        writer.reset();

        function walk(node) {
          var handler = handlers[node.type],
            name, isEmpty, attrs, attrName, attrValue, sortedAttrs, i, l, elementRule;

          if (!handler) {
            name = node.name;
            isEmpty = node.shortEnded;
            attrs = node.attributes;

            // Sort attributes
            if (validate && attrs && attrs.length > 1) {
              sortedAttrs = [];
              sortedAttrs.map = {};

              elementRule = schema.getElementRule(node.name);

              if (!elementRule) {
                return;
              }

              for (i = 0, l = elementRule.attributesOrder.length; i < l; i++) {
                attrName = elementRule.attributesOrder[i];

                if (attrName in attrs.map) {
                  attrValue = attrs.map[attrName];
                  sortedAttrs.map[attrName] = attrValue;

                  sortedAttrs.push({
                    name: attrName,
                    value: attrValue,
                    "boolean": boolAttrMap[attrName] ? true : false
                  });
                }
              }

              for (i = 0, l = attrs.length; i < l; i++) {
                attrName = attrs[i].name;

                if (!(attrName in sortedAttrs.map)) {
                  attrValue = attrs.map[attrName];
                  sortedAttrs.map[attrName] = attrValue;

                  sortedAttrs.push({
                    name: attrName,
                    value: attrValue,
                    "boolean": boolAttrMap[attrName] ? true : false
                  });
                }
              }

              attrs = sortedAttrs;
            }

            writer.start(node.name, attrs, isEmpty);

            if (!isEmpty) {
              if ((node = node.firstChild)) {
                do {
                  walk(node);
                } while ((node = node.next));
              }

              writer.end(name);
            }
          } else {
            handler(node);
          }
        }

        // Serialize element and treat all non elements as fragments
        if (node.type == 1 && !settings.inner) {
          walk(node);
        } else {
          handlers[11](node);
        }

        return writer.getContent();
      };
    };
  })(tinymce);

  /**
   * Writer.js
   *
   * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
   * Released under LGPL License.
   *
   * License: http://www.tinymce.com/license - Inactive
   * Licence: GNU/LGPL 2.1 or later - http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
   * Contributing: http://www.tinymce.com/contributing - Inactive
   */

  /**
   * This class is used to write HTML tags out it can be used with the Serializer or the SaxParser.
   *
   * @class tinymce.html.Writer
   * @example
   * var writer = new tinymce.html.Writer({indent : true});
   * var parser = new tinymce.html.SaxParser(writer).parse('<p><br></p>');
   * console.log(writer.getContent());
   *
   * @class tinymce.html.Writer
   * @version 3.4
   */

  /**
   * Constructs a new Writer instance.
   *
   * @constructor
   * @method Writer
   * @param {Object} settings Name/value settings object.
   */
  tinymce.html.Writer = function (settings, schema) {
    var html = [],
      indent, indentBefore, indentAfter, encode, htmlOutput;

    var makeMap = tinymce.makeMap,
      Entities = tinymce.html.Entities;

    settings = settings || {};
    indent = settings.indent;
    indentBefore = makeMap(settings.indent_before || '');
    indentAfter = makeMap(settings.indent_after || '');
    encode = Entities.getEncodeFunc(settings.entity_encoding || 'raw', settings.entities);
    htmlOutput = settings.element_format == "html";

    return {
      /**
         * Writes the a start element such as <p id="a">.
         *
         * @method start
         * @param {String} name Name of the element.
         * @param {Array} attrs Optional attribute array or undefined if it hasn't any.
         * @param {Boolean} empty Optional empty state if the tag should end like <br />.
         */
      start: function (name, attrs, empty) {
        var i, l, attr, value;

        if (indent && indentBefore[name] && html.length > 0) {
          value = html[html.length - 1];

          if (value.length > 0 && value !== '\n') {
            html.push('\n');
          }
        }

        html.push('<', name);

        if (attrs) {
          var bool = [];

          for (i = 0, l = attrs.length; i < l; i++) {
            attr = attrs[i];

            if (attr["boolean"]) {
              if (settings.schema != 'html4') {
                // boolean attributes in HTML5 are written without a value
                bool.push(' ', attr.name);
              } else {
                bool.push(' ', attr.name, '="', encode('' + attr.name, true), '"');
              }
            } else {
              // treat as a boolean
              if (attr.name == attr.value) {
                bool.push(' ', attr.name);
              } else {
                html.push(' ', attr.name, '="', encode('' + attr.value, true), '"');
              }
            }
          }
          // add boolean attributes at the end. This is primarily for readability and because the Joomla Text Filter will remove boolean attributes if they are not at the end of the tag.
          html = html.concat(bool);
        }

        if (!empty || htmlOutput) {
          html[html.length] = '>';
        } else {
          // use void tag
          if (settings.schema == 'html5-strict') {
            html[html.length] = '>';
            // use self-closing tag
          } else {
            html[html.length] = ' />';
          }
        }

        if (empty && indent && indentAfter[name] && html.length > 0) {
          value = html[html.length - 1];

          if (value.length > 0 && value !== '\n') {
            html.push('\n');
          }
        }
      },

      /**
       * Writes the a end element such as </p>.
       *
       * @method end
       * @param {String} name Name of the element.
       */
      end: function (name) {
        var value;

        /*if (indent && indentBefore[name] && html.length > 0) {
          value = html[html.length - 1];

          if (value.length > 0 && value !== '\n')
            html.push('\n');
        }*/

        html.push('</', name, '>');

        if (indent && indentAfter[name] && html.length > 0) {
          value = html[html.length - 1];

          if (value.length > 0 && value !== '\n') {
            html.push('\n');
          }
        }
      },

      /**
       * Writes a text node.
       *
       * @method text
       * @param {String} text String to write out.
       * @param {Boolean} raw Optional raw state if true the contents wont get encoded.
       */
      text: function (text, raw) {
        if (text.length > 0) {
          html[html.length] = raw ? text : encode(text);
        }
      },

      /**
       * Writes a cdata node such as <![CDATA[data]]>.
       *
       * @method cdata
       * @param {String} text String to write out inside the cdata.
       */
      cdata: function (text) {
        html.push('<![CDATA[', text, ']]>');
      },

      /**
       * Writes a comment node such as <!-- Comment -->.
       *
       * @method cdata
       * @param {String} text String to write out inside the comment.
       */
      comment: function (text) {
        html.push('<!--', text, '-->');
      },

      /**
       * Writes a PI node such as <?xml attr="value" ?>.
       *
       * @method pi
       * @param {String} name Name of the pi.
       * @param {String} text String to write out inside the pi.
       */
      pi: function (name, text) {
        if (text) {
          html.push('<?', name, ' ', encode(text), '?>');
        } else {
          html.push('<?', name, '?>');
        }

        if (indent) {
          html.push('\n');
        }
      },

      /**
       * Writes a doctype node such as <!DOCTYPE data>.
       *
       * @method doctype
       * @param {String} text String to write out inside the doctype.
       */
      doctype: function (text) {
        html.push('<!DOCTYPE', text, '>', indent ? '\n' : '');
      },

      /**
       * Resets the internal buffer if one wants to reuse the writer.
       *
       * @method reset
       */
      reset: function () {
        html.length = 0;
      },

      /**
       * Returns the contents that got serialized.
       *
       * @method getContent
       * @return {String} HTML contents that got written down.
       */
      getContent: function () {
        return html.join('').replace(/\n$/, '');
      }
    };
  };

  /**
   * ClientRect.js
   *
   * Released under LGPL License.
   * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
   *
   * License: http://www.tinymce.com/license - Inactive
   * Licence: GNU/LGPL 2.1 or later - http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
   * Contributing: http://www.tinymce.com/contributing - Inactive
   */

  /**
   * Utility functions for working with client rects.
   *
   * @private
   * @class tinymce.geom.ClientRect
   */
  (function (tinymce) {
    var round = Math.round;

    var clone = function (rect) {
      if (!rect) {
        return {
          left: 0,
          top: 0,
          bottom: 0,
          right: 0,
          width: 0,
          height: 0
        };
      }

      return {
        left: round(rect.left),
        top: round(rect.top),
        bottom: round(rect.bottom),
        right: round(rect.right),
        width: round(rect.width),
        height: round(rect.height)
      };
    };

    var collapse = function (clientRect, toStart) {
      clientRect = clone(clientRect);

      if (toStart) {
        clientRect.right = clientRect.left;
      } else {
        clientRect.left = clientRect.left + clientRect.width;
        clientRect.right = clientRect.left;
      }

      clientRect.width = 0;

      return clientRect;
    };

    var isEqual = function (rect1, rect2) {
      return (
        rect1.left === rect2.left &&
        rect1.top === rect2.top &&
        rect1.bottom === rect2.bottom &&
        rect1.right === rect2.right
      );
    };

    var isValidOverflow = function (overflowY, clientRect1, clientRect2) {
      return overflowY >= 0 && overflowY <= Math.min(clientRect1.height, clientRect2.height) / 2;

    };

    var isAbove = function (clientRect1, clientRect2) {
      if ((clientRect1.bottom - clientRect1.height / 2) < clientRect2.top) {
        return true;
      }

      if (clientRect1.top > clientRect2.bottom) {
        return false;
      }

      return isValidOverflow(clientRect2.top - clientRect1.bottom, clientRect1, clientRect2);
    };

    var isBelow = function (clientRect1, clientRect2) {
      if (clientRect1.top > clientRect2.bottom) {
        return true;
      }

      if (clientRect1.bottom < clientRect2.top) {
        return false;
      }

      return isValidOverflow(clientRect2.bottom - clientRect1.top, clientRect1, clientRect2);
    };

    var isLeft = function (clientRect1, clientRect2) {
      return clientRect1.left < clientRect2.left;
    };

    var isRight = function (clientRect1, clientRect2) {
      return clientRect1.right > clientRect2.right;
    };

    var compare = function (clientRect1, clientRect2) {
      if (isAbove(clientRect1, clientRect2)) {
        return -1;
      }

      if (isBelow(clientRect1, clientRect2)) {
        return 1;
      }

      if (isLeft(clientRect1, clientRect2)) {
        return -1;
      }

      if (isRight(clientRect1, clientRect2)) {
        return 1;
      }

      return 0;
    };

    var containsXY = function (clientRect, clientX, clientY) {
      return (
        clientX >= clientRect.left &&
        clientX <= clientRect.right &&
        clientY >= clientRect.top &&
        clientY <= clientRect.bottom
      );
    };

    tinymce.geom.ClientRect = {
      clone: clone,
      collapse: collapse,
      isEqual: isEqual,
      isAbove: isAbove,
      isBelow: isBelow,
      isLeft: isLeft,
      isRight: isRight,
      compare: compare,
      containsXY: containsXY
    };

  })(tinymce);

  /**
   * Rect.js
   *
   * Released under LGPL License.
   * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
   *
   * License: http://www.tinymce.com/license - Inactive
   * Licence: GNU/LGPL 2.1 or later - http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
   * Contributing: http://www.tinymce.com/contributing - Inactive
   */

  /**
   * Contains various tools for rect/position calculation.
   *
   * @class tinymce.geom.Rect
   */

  (function (tinymce) {
    var min = Math.min,
      max = Math.max,
      round = Math.round;

    /**
     * Returns the rect positioned based on the relative position name
     * to the target rect.
     *
     * @method relativePosition
     * @param {Rect} rect Source rect to modify into a new rect.
     * @param {Rect} targetRect Rect to move relative to based on the rel option.
     * @param {String} rel Relative position. For example: tr-bl.
     */
    var relativePosition = function (rect, targetRect, rel) {
      var x, y, w, h, targetW, targetH;

      x = targetRect.x;
      y = targetRect.y;
      w = rect.w;
      h = rect.h;
      targetW = targetRect.w;
      targetH = targetRect.h;

      rel = (rel || '').split('');

      if (rel[0] === 'b') {
        y += targetH;
      }

      if (rel[1] === 'r') {
        x += targetW;
      }

      if (rel[0] === 'c') {
        y += round(targetH / 2);
      }

      if (rel[1] === 'c') {
        x += round(targetW / 2);
      }

      if (rel[3] === 'b') {
        y -= h;
      }

      if (rel[4] === 'r') {
        x -= w;
      }

      if (rel[3] === 'c') {
        y -= round(h / 2);
      }

      if (rel[4] === 'c') {
        x -= round(w / 2);
      }

      return create(x, y, w, h);
    };

    /**
     * Tests various positions to get the most suitable one.
     *
     * @method findBestRelativePosition
     * @param {Rect} rect Rect to use as source.
     * @param {Rect} targetRect Rect to move relative to.
     * @param {Rect} constrainRect Rect to constrain within.
     * @param {Array} rels Array of relative positions to test against.
     */
    var findBestRelativePosition = function (rect, targetRect, constrainRect, rels) {
      var pos, i;

      for (i = 0; i < rels.length; i++) {
        pos = relativePosition(rect, targetRect, rels[i]);

        if (pos.x >= constrainRect.x && pos.x + pos.w <= constrainRect.w + constrainRect.x &&
          pos.y >= constrainRect.y && pos.y + pos.h <= constrainRect.h + constrainRect.y) {
          return rels[i];
        }
      }

      return null;
    };

    /**
     * Inflates the rect in all directions.
     *
     * @method inflate
     * @param {Rect} rect Rect to expand.
     * @param {Number} w Relative width to expand by.
     * @param {Number} h Relative height to expand by.
     * @return {Rect} New expanded rect.
     */
    var inflate = function (rect, w, h) {
      return create(rect.x - w, rect.y - h, rect.w + w * 2, rect.h + h * 2);
    };

    /**
     * Returns the intersection of the specified rectangles.
     *
     * @method intersect
     * @param {Rect} rect The first rectangle to compare.
     * @param {Rect} cropRect The second rectangle to compare.
     * @return {Rect} The intersection of the two rectangles or null if they don't intersect.
     */
    var intersect = function (rect, cropRect) {
      var x1, y1, x2, y2;

      x1 = max(rect.x, cropRect.x);
      y1 = max(rect.y, cropRect.y);
      x2 = min(rect.x + rect.w, cropRect.x + cropRect.w);
      y2 = min(rect.y + rect.h, cropRect.y + cropRect.h);

      if (x2 - x1 < 0 || y2 - y1 < 0) {
        return null;
      }

      return create(x1, y1, x2 - x1, y2 - y1);
    };

    /**
     * Returns a rect clamped within the specified clamp rect. This forces the
     * rect to be inside the clamp rect.
     *
     * @method clamp
     * @param {Rect} rect Rectangle to force within clamp rect.
     * @param {Rect} clampRect Rectable to force within.
     * @param {Boolean} fixedSize True/false if size should be fixed.
     * @return {Rect} Clamped rect.
     */
    var clamp = function (rect, clampRect, fixedSize) {
      var underflowX1, underflowY1, overflowX2, overflowY2,
        x1, y1, x2, y2, cx2, cy2;

      x1 = rect.x;
      y1 = rect.y;
      x2 = rect.x + rect.w;
      y2 = rect.y + rect.h;
      cx2 = clampRect.x + clampRect.w;
      cy2 = clampRect.y + clampRect.h;

      underflowX1 = max(0, clampRect.x - x1);
      underflowY1 = max(0, clampRect.y - y1);
      overflowX2 = max(0, x2 - cx2);
      overflowY2 = max(0, y2 - cy2);

      x1 += underflowX1;
      y1 += underflowY1;

      if (fixedSize) {
        x2 += underflowX1;
        y2 += underflowY1;
        x1 -= overflowX2;
        y1 -= overflowY2;
      }

      x2 -= overflowX2;
      y2 -= overflowY2;

      return create(x1, y1, x2 - x1, y2 - y1);
    };

    /**
     * Creates a new rectangle object.
     *
     * @method create
     * @param {Number} x Rectangle x location.
     * @param {Number} y Rectangle y location.
     * @param {Number} w Rectangle width.
     * @param {Number} h Rectangle height.
     * @return {Rect} New rectangle object.
     */
    var create = function (x, y, w, h) {
      return {
        x: x,
        y: y,
        w: w,
        h: h
      };
    };

    /**
     * Creates a new rectangle object form a clientRects object.
     *
     * @method fromClientRect
     * @param {ClientRect} clientRect DOM ClientRect object.
     * @return {Rect} New rectangle object.
     */
    var fromClientRect = function (clientRect) {
      return create(clientRect.left, clientRect.top, clientRect.width, clientRect.height);
    };

    tinymce.geom.Rect = {
      inflate: inflate,
      relativePosition: relativePosition,
      findBestRelativePosition: findBestRelativePosition,
      intersect: intersect,
      clamp: clamp,
      create: create,
      fromClientRect: fromClientRect
    };

  })(tinymce);

  /**
   * EventUtils.js
   *
   * Copyright, Moxiecode Systems AB
   * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
   * Released under LGPL License.
   *
   * License: http://www.tinymce.com/license - Inactive
   * Licence: GNU/LGPL 2.1 or later - http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
   * Contributing: http://www.tinymce.com/contributing - Inactive
   */

  // JSLint defined globals
  /*global tinymce:false, window:false */

  tinymce.dom = {};

  (function (namespace) {
    var eventExpandoPrefix = "mce-data-";
    var mouseEventRe = /^(?:mouse|contextmenu)|click/;
    var deprecated = {
      keyLocation: 1,
      layerX: 1,
      layerY: 1,
      returnValue: 1,
      webkitMovementX: 1,
      webkitMovementY: 1,
      keyIdentifier: 1,
      mozPressure: 1,
      path: 1
    };

    /**
       * Binds a native event to a callback on the speified target.
       */
    function addEvent(target, name, callback, capture) {
      target.addEventListener(name, callback, capture || false);
    }

    /**
       * Unbinds a native event callback on the specified target.
       */
    function removeEvent(target, name, callback, capture) {
      target.removeEventListener(name, callback, capture || false);
    }

    /**
       * Normalizes a native event object or just adds the event specific methods on a custom event.
       */
    function fix(originalEvent, data) {
      var name, event = data || {},
        undef;

      // Dummy function that gets replaced on the delegation state functions
      function returnFalse() {
        return false;
      }

      // Dummy function that gets replaced on the delegation state functions
      function returnTrue() {
        return true;
      }

      // Copy all properties from the original event
      for (name in originalEvent) {
        // layerX/layerY is deprecated in Chrome and produces a warning
        if (!deprecated[name]) {
          event[name] = originalEvent[name];
        }
      }

      // Normalize target IE uses srcElement
      if (!event.target) {
        event.target = event.srcElement || document;
      }

      // Calculate pageX/Y if missing and clientX/Y available
      if (originalEvent && mouseEventRe.test(originalEvent.type) && originalEvent.pageX === undef && originalEvent.clientX !== undef) {
        var eventDoc = event.target.ownerDocument || document;
        var doc = eventDoc.documentElement;
        var body = eventDoc.body;

        event.pageX = originalEvent.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) -
          (doc && doc.clientLeft || body && body.clientLeft || 0);

        event.pageY = originalEvent.clientY + (doc && doc.scrollTop || body && body.scrollTop || 0) -
          (doc && doc.clientTop || body && body.clientTop || 0);
      }

      // Add preventDefault method
      event.preventDefault = function () {
        event.isDefaultPrevented = returnTrue;

        // Execute preventDefault on the original event object
        if (originalEvent) {
          originalEvent.preventDefault();
        }
      };

      // Add stopPropagation
      event.stopPropagation = function () {
        event.isPropagationStopped = returnTrue;

        // Execute stopPropagation on the original event object
        if (originalEvent) {
          originalEvent.stopPropagation();
        }
      };

      // Add stopImmediatePropagation
      event.stopImmediatePropagation = function () {
        event.isImmediatePropagationStopped = returnTrue;
        event.stopPropagation();
      };

      // Add event delegation states
      if (!event.isDefaultPrevented) {
        event.isDefaultPrevented = returnFalse;
        event.isPropagationStopped = returnFalse;
        event.isImmediatePropagationStopped = returnFalse;
      }

      return event;
    }

    /**
       * Bind a DOMContentLoaded event across browsers and executes the callback once the page DOM is initialized.
       * It will also set/check the domLoaded state of the event_utils instance so ready isn't called multiple times.
       */
    function bindOnReady(win, callback, eventUtils) {
      var doc = win.document,
        event = {
          type: 'ready'
        };

      if (eventUtils.domLoaded) {
        callback(event);
        return;
      }

      // Gets called when the DOM is ready
      function readyHandler() {
        if (!eventUtils.domLoaded) {
          eventUtils.domLoaded = true;
          callback(event);
        }
      }

      // Use W3C method
      if (doc.readyState === "complete") {
        readyHandler();
      } else {
        addEvent(win, 'DOMContentLoaded', readyHandler);
      }

      // Fallback if any of the above methods should fail for some odd reason
      addEvent(win, 'load', readyHandler);
    }

    /**
       * This class enables you to bind/unbind native events to elements and normalize it's behavior across browsers.
       */
    function EventUtils() {
      var self = this,
        events = {},
        count, expando, hasFocusIn, hasMouseEnterLeave, mouseEnterLeave;

      expando = eventExpandoPrefix + (+new Date()).toString(32);
      hasMouseEnterLeave = "onmouseenter" in document.documentElement;
      hasFocusIn = "onfocusin" in document.documentElement;
      mouseEnterLeave = {
        mouseenter: 'mouseover',
        mouseleave: 'mouseout'
      };
      count = 1;

      // State if the DOMContentLoaded was executed or not
      self.domLoaded = false;
      self.events = events;

      /**
           * Executes all event handler callbacks for a specific event.
           *
           * @private
           * @param {Event} evt Event object.
           * @param {String} id Expando id value to look for.
           */
      function executeHandlers(evt, id) {
        var callbackList, i, l, callback, container = events[id];

        callbackList = container && container[evt.type];
        if (callbackList) {
          for (i = 0, l = callbackList.length; i < l; i++) {
            callback = callbackList[i];

            // Check if callback exists might be removed if a unbind is called inside the callback
            if (callback && callback.func.call(callback.scope, evt) === false) {
              evt.preventDefault();
            }

            // Should we stop propagation to immediate listeners
            if (evt.isImmediatePropagationStopped()) {
              return;
            }
          }
        }
      }

      /**
           * Binds a callback to an event on the specified target.
           *
           * @method bind
           * @param {Object} target Target node/window or custom object.
           * @param {String} names Name of the event to bind.
           * @param {function} callback Callback function to execute when the event occurs.
           * @param {Object} scope Scope to call the callback function on, defaults to target.
           * @return {function} Callback function that got bound.
           */
      self.bind = function (target, names, callback, scope) {
        var id, callbackList, i, name, fakeName, nativeHandler, capture, win = window;

        // Native event handler function patches the event and executes the callbacks for the expando
        function defaultNativeHandler(evt) {
          executeHandlers(fix(evt || win.event), id);
        }

        // Don't bind to text nodes or comments
        if (!target || target.nodeType === 3 || target.nodeType === 8) {
          return;
        }

        // Create or get events id for the target
        if (!target[expando]) {
          id = count++;
          target[expando] = id;
          events[id] = {};
        } else {
          id = target[expando];
        }

        // Setup the specified scope or use the target as a default
        scope = scope || target;

        // Split names and bind each event, enables you to bind multiple events with one call
        names = names.split(' ');
        i = names.length;
        while (i--) {
          name = names[i];
          nativeHandler = defaultNativeHandler;
          fakeName = capture = false;

          // Use ready instead of DOMContentLoaded
          if (name === "DOMContentLoaded") {
            name = "ready";
          }

          // DOM is already ready
          if (self.domLoaded && name === "ready" && target.readyState == 'complete') {
            callback.call(scope, fix({
              type: name
            }));
            continue;
          }

          // Handle mouseenter/mouseleaver
          if (!hasMouseEnterLeave) {
            fakeName = mouseEnterLeave[name];

            if (fakeName) {
              nativeHandler = function (evt) {
                var current, related;

                current = evt.currentTarget;
                related = evt.relatedTarget;

                // Check if related is inside the current target if it's not then the event should
                // be ignored since it's a mouseover/mouseout inside the element
                if (related && current.contains) {
                  // Use contains for performance
                  related = current.contains(related);
                } else {
                  while (related && related !== current) {
                    related = related.parentNode;
                  }
                }

                // Fire fake event
                if (!related) {
                  evt = fix(evt || win.event);
                  evt.type = evt.type === 'mouseout' ? 'mouseleave' : 'mouseenter';
                  evt.target = current;
                  executeHandlers(evt, id);
                }
              };
            }
          }

          // Fake bubbling of focusin/focusout
          if (!hasFocusIn && (name === "focusin" || name === "focusout")) {
            capture = true;
            fakeName = name === "focusin" ? "focus" : "blur";
            nativeHandler = function (evt) {
              evt = fix(evt || win.event);
              evt.type = evt.type === 'focus' ? 'focusin' : 'focusout';
              executeHandlers(evt, id);
            };
          }

          // Setup callback list and bind native event
          callbackList = events[id][name];
          if (!callbackList) {
            events[id][name] = callbackList = [{
              func: callback,
              scope: scope
            }];
            callbackList.fakeName = fakeName;
            callbackList.capture = capture;
            //callbackList.callback = callback;

            // Add the nativeHandler to the callback list so that we can later unbind it
            callbackList.nativeHandler = nativeHandler;

            // Check if the target has native events support

            if (name === "ready") {
              bindOnReady(target, nativeHandler, self);
            } else {
              addEvent(target, fakeName || name, nativeHandler, capture);
            }
          } else {
            if (name === "ready" && self.domLoaded) {
              callback({
                type: name
              });
            } else {
              // If it already has an native handler then just push the callback
              callbackList.push({
                func: callback,
                scope: scope
              });
            }
          }
        }

        target = callbackList = 0; // Clean memory for IE

        return callback;
      };

      /**
           * Unbinds the specified event by name, name and callback or all events on the target.
           *
           * @method unbind
           * @param {Object} target Target node/window or custom object.
           * @param {String} names Optional event name to unbind.
           * @param {function} callback Optional callback function to unbind.
           * @return {EventUtils} Event utils instance.
           */
      self.unbind = function (target, names, callback) {
        var id, callbackList, i, ci, name, eventMap;

        // Don't bind to text nodes or comments
        if (!target || target.nodeType === 3 || target.nodeType === 8) {
          return self;
        }

        // Unbind event or events if the target has the expando
        id = target[expando];
        if (id) {
          eventMap = events[id];

          // Specific callback
          if (names) {
            names = names.split(' ');
            i = names.length;
            while (i--) {
              name = names[i];
              callbackList = eventMap[name];

              // Unbind the event if it exists in the map
              if (callbackList) {
                // Remove specified callback
                if (callback) {
                  ci = callbackList.length;
                  while (ci--) {
                    if (callbackList[ci].func === callback) {
                      var nativeHandler = callbackList.nativeHandler;
                      var fakeName = callbackList.fakeName,
                        capture = callbackList.capture;

                      // Clone callbackList since unbind inside a callback would otherwise break the handlers loop
                      callbackList = callbackList.slice(0, ci).concat(callbackList.slice(ci + 1));
                      callbackList.nativeHandler = nativeHandler;
                      callbackList.fakeName = fakeName;
                      callbackList.capture = capture;

                      eventMap[name] = callbackList;
                    }
                  }
                }

                // Remove all callbacks if there isn't a specified callback or there is no callbacks left
                if (!callback || callbackList.length === 0) {
                  delete eventMap[name];
                  removeEvent(target, callbackList.fakeName || name, callbackList.nativeHandler, callbackList.capture);
                }
              }
            }
          } else {
            // All events for a specific element
            for (name in eventMap) {
              callbackList = eventMap[name];
              removeEvent(target, callbackList.fakeName || name, callbackList.nativeHandler, callbackList.capture);
            }

            eventMap = {};
          }

          // Check if object is empty, if it isn't then we won't remove the expando map
          for (name in eventMap) {
            return self;
          }

          // Delete event object
          delete events[id];

          // Remove expando from target
          try {
            // IE will fail here since it can't delete properties from window
            delete target[expando];
          } catch (ex) {
            // IE will set it to null
            target[expando] = null;
          }
        }

        return self;
      };

      /**
       * Fires the specified event on the specified target.
       *
       * @method fire
       * @param {Object} target Target node/window or custom object.
       * @param {String} name Event name to fire.
       * @param {Object} args Optional arguments to send to the observers.
       * @return {EventUtils} Event utils instance.    
       */
      self.fire = function (target, name, args) {
        var id;

        // Don't bind to text nodes or comments
        if (!target || target.nodeType === 3 || target.nodeType === 8) {
          return self;
        }

        // Build event object by patching the args
        args = fix(null, args);
        args.type = name;
        args.target = target;

        do {
          // Found an expando that means there is listeners to execute
          id = target[expando];
          if (id) {
            executeHandlers(args, id);
          }

          // Walk up the DOM
          target = target.parentNode || target.ownerDocument || target.defaultView || target.parentWindow;
        } while (target && !args.isPropagationStopped());

        self.args = args;

        return self;
      };

      /**
        * Removes all bound event listeners for the specified target. This will also remove any bound
        * listeners to child nodes within that target.
        *
        * @method clean
        * @param {Object} target Target node/window object.
        * @return {EventUtils} Event utils instance.
        */
      self.clean = function (target) {
        var i, children, unbind = self.unbind;

        // Don't bind to text nodes or comments
        if (!target || target.nodeType === 3 || target.nodeType === 8) {
          return self;
        }

        // Unbind any element on the specified target
        if (target[expando]) {
          unbind(target);
        }

        // Target doesn't have getElementsByTagName it's probably a window object then use it's document to find the children
        if (!target.getElementsByTagName) {
          target = target.document;
        }

        // Remove events from each child element
        if (target && target.getElementsByTagName) {
          unbind(target);

          children = target.getElementsByTagName('*');
          i = children.length;
          while (i--) {
            target = children[i];

            if (target[expando]) {
              unbind(target);
            }
          }
        }

        return self;
      };

      /**
           * Destroys the event object. Call this on IE to remove memory leaks.
           */
      self.destroy = function () {
        events = {};
      };

      // Legacy function for canceling events
      self.cancel = function (e) {
        if (e) {
          e.preventDefault();
          e.stopImmediatePropagation();
        }

        return false;
      };

      self.add = function (target, events, func, scope) {
        // Old API supported direct ID assignment
        if (typeof (target) === "string") {
          target = document.getElementById(target);
        }

        // Old API supported multiple targets
        if (target && target instanceof Array) {
          var i = target.length;

          while (i--) {
            self.add(target[i], events, func, scope);
          }

          return;
        }

        // Old API called ready init
        if (events === "init") {
          events = "ready";
        }

        return self.bind(target, events instanceof Array ? events.join(' ') : events, func, scope);
      };

      self.remove = function (target, events, func, scope) {
        if (!target) {
          return self;
        }

        // Old API supported direct ID assignment
        if (typeof (target) === "string") {
          target = document.getElementById(target);
        }

        // Old API supported multiple targets
        if (target instanceof Array) {
          var i = target.length;

          while (i--) {
            self.remove(target[i], events, func, scope);
          }

          return self;
        }

        return self.unbind(target, events instanceof Array ? events.join(' ') : events, func);
      };

      self.clear = function (target) {
        // Old API supported direct ID assignment
        if (typeof (target) === "string") {
          target = document.getElementById(target);
        }

        return self.clean(target);
      };

      self.preventDefault = function (e) {
        if (e) {
          e.preventDefault();
        }
      };

      self.isDefaultPrevented = function (e) {
        return e.isDefaultPrevented();
      };
    }

    namespace.EventUtils = EventUtils;

    namespace.Event = new EventUtils();

    // Bind ready event when tinymce script is loaded
    namespace.Event.bind(window, 'ready', function () { });

    namespace = 0;
  })(tinymce.dom); // Namespace and expando

  /**
   * TreeWalker.js
   *
   * Copyright, Moxiecode Systems AB
   * Released under LGPL License.
   *
   * License: http://www.tinymce.com/license - Inactive
   * Licence: GNU/LGPL 2.1 or later - http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
   * Contributing: http://www.tinymce.com/contributing - Inactive
   */

  tinymce.dom.TreeWalker = function (startNode, rootNode) {
  	var node = startNode;

  	function findSibling(node, startName, siblingName, shallow) {
  		var sibling, parent;

  		if (node) {
  			// Walk into nodes if it has a start
  			if (!shallow && node[startName]) {
  				return node[startName];
  			}

  			// Return the sibling if it has one
  			if (node != rootNode) {
  				sibling = node[siblingName];
  				if (sibling) {
  					return sibling;
  				}

  				// Walk up the parents to look for siblings
  				for (parent = node.parentNode; parent && parent != rootNode; parent = parent.parentNode) {
  					sibling = parent[siblingName];
  					if (sibling) {
  						return sibling;
  					}
  				}
  			}
  		}
  	}

  	function findPreviousNode(node, startName, siblingName, shallow) {
  		var sibling, parent, child;

  		if (node) {
  			sibling = node[siblingName];
  			if (rootNode && sibling === rootNode) {
  				return;
  			}

  			if (sibling) {
  				if (!shallow) {
  					// Walk up the parents to look for siblings
  					for (child = sibling[startName]; child; child = child[startName]) {
  						if (!child[startName]) {
  							return child;
  						}
  					}
  				}

  				return sibling;
  			}

  			parent = node.parentNode;
  			if (parent && parent !== rootNode) {
  				return parent;
  			}
  		}
  	}

  	/**
  	 * Returns the current node.
  	 *
  	 * @return {Node} Current node where the walker is.
  	 */
  	this.current = function () {
  		return node;
  	};

  	/**
  	 * Walks to the next node in tree.
  	 *
  	 * @return {Node} Current node where the walker is after moving to the next node.
  	 */
  	this.next = function (shallow) {
  		return (node = findSibling(node, 'firstChild', 'nextSibling', shallow));
  	};

  	/**
  	 * Walks to the previous node in tree.
  	 *
  	 * @return {Node} Current node where the walker is after moving to the previous node.
  	 */
  	this.prev = function (shallow) {
  		return (node = findSibling(node, 'lastChild', 'previousSibling', shallow));
  	};

  	this.prev2 = function (shallow) {
  		node = findPreviousNode(node, 'lastChild', 'previousSibling', shallow);
  		return node;
  	};
  };

  /**
   * DOMUtils.js
   *
   * Copyright, Moxiecode Systems AB
   * Released under LGPL License.
   *
   * License: http://www.tinymce.com/license - Inactive
   * Licence: GNU/LGPL 2.1 or later - http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
   * Contributing: http://www.tinymce.com/contributing - Inactive
   */

  (function (tinymce) {
    // Shorten names
    var each = tinymce.each,
      is = tinymce.is,
      isWebKit = tinymce.isWebKit,
      isIE = tinymce.isIE,
      Entities = tinymce.html.Entities,
      simpleSelectorRe = /^([a-z0-9],?)+$/i,
      whiteSpaceRegExp = /^[ \t\r\n]*$/;

    function stringToArray(value) {
      if (Array.isArray(value)) {
        return value;
      }

      if (typeof value === "string") {
        return value.split(' ');
      }

      return [];
    }

    /**
     * Utility class for various DOM manipulation and retrival functions.
     *
     * @class tinymce.dom.DOMUtils
     * @example
     * // Add a class to an element by id in the page
     * tinymce.DOM.addClass('someid', 'someclass');
     *
     * // Add a class to an element by id inside the editor
     * tinymce.activeEditor.dom.addClass('someid', 'someclass');
     */
    /**
       * Constructs a new DOMUtils instance. Consult the Wiki for more details on settings etc for this class.
       *
       * @constructor
       * @method DOMUtils
       * @param {Document} d Document reference to bind the utility class to.
       * @param {settings} s Optional settings collection.
       */
    tinymce.dom.DOMUtils = function (d, s) {
      var self = this,
        blockElementsMap;

      self.doc = d;
      self.win = window;
      self.files = {};
      self.cssFlicker = false;
      self.counter = 0;
      self.stdMode = !tinymce.isIE || d.documentMode >= 8;
      self.boxModel = !tinymce.isIE || d.compatMode == "CSS1Compat" || self.stdMode;
      self.hasOuterHTML = "outerHTML" in d.createElement("a");

      self.settings = s = tinymce.extend({
        keep_values: false,
        hex_colors: 1
      }, s);

      self.schema = s.schema;
      self.styles = new tinymce.html.Styles({
        url_converter: s.url_converter,
        url_converter_scope: s.url_converter_scope
      }, s.schema);

      self.events = s.ownEvents ? new tinymce.dom.EventUtils(s.proxy) : tinymce.dom.Event;
      tinymce.addUnload(self.destroy, this);
      blockElementsMap = s.schema ? s.schema.getBlockElements() : {};

      /**
       * Returns true/false if the specified element is a block element or not.
       *
       * @method isBlock
       * @param {Node/String} node Element/Node to check.
       * @return {Boolean} True/False state if the node is a block element or not.
       */
      self.isBlock = function (node) {
        // Fix for #5446
        if (!node) {
          return false;
        }

        // This function is called in module pattern style since it might be executed with the wrong this scope
        var type = node.nodeType;

        // If it's a node then check the type and use the nodeName
        if (type) {
          return !!(type === 1 && blockElementsMap[node.nodeName]);
        }

        return !!blockElementsMap[node];
      };
    };

    tinymce.dom.DOMUtils.prototype = {

      doc: null,
      root: null,
      files: null,
      pixelStyles: /^(top|left|bottom|right|width|height|maxWidth|maxHeight|minWidth|minHeight|borderWidth)$/,
      props: {
        "for": "htmlFor",
        "class": "className",
        className: "className",
        checked: "checked",
        disabled: "disabled",
        maxlength: "maxLength",
        readonly: "readOnly",
        selected: "selected",
        value: "value",
        id: "id",
        name: "name",
        type: "type"
      },

      clone: function (node, deep) {
        var self = this,
          clone, doc;

        // TODO: Add feature detection here in the future
        if (!isIE || tinymce.isIE11 || node.nodeType !== 1 || deep) {
          return node.cloneNode(deep);
        }

        doc = self.doc;

        // Make a HTML5 safe shallow copy
        if (!deep) {
          clone = doc.createElement(node.nodeName);

          // Copy attribs
          each(self.getAttribs(node), function (attr) {
            self.setAttrib(clone, attr.nodeName, self.getAttrib(node, attr.nodeName));
          });

          return clone;
        }
        /*
              // Setup HTML5 patched document fragment
              if (!self.frag) {
                self.frag = doc.createDocumentFragment();
                self.fixDoc(self.frag);
              }

              // Make a deep copy by adding it to the document fragment then removing it this removed the :section
              clone = doc.createElement('div');
              self.frag.appendChild(clone);
              clone.innerHTML = node.outerHTML;
              self.frag.removeChild(clone);
        */
        return clone.firstChild;
      },

      /**
       * Returns the root node of the document this is normally the body but might be a DIV. Parents like getParent will not
       * go above the point of this root node.
       *
       * @method getRoot
       * @return {Element} Root element for the utility class.
       */
      getRoot: function () {
        var self = this,
          s = self.settings;

        return (s && self.get(s.root_element)) || self.doc.body;
      },

      /**
       * Returns the viewport of the window.
       *
       * @method getViewPort
       * @param {Window} w Optional window to get viewport of.
       * @return {Object} Viewport object with fields x, y, w and h.
       */
      getViewPort: function (w) {
        var d, b;

        w = !w ? this.win : w;
        d = w.document;
        b = this.boxModel ? d.documentElement : d.body;

        // Returns viewport size excluding scrollbars
        return {
          x: w.pageXOffset || b.scrollLeft,
          y: w.pageYOffset || b.scrollTop,
          w: w.innerWidth || b.clientWidth,
          h: w.innerHeight || b.clientHeight
        };
      },

      /**
       * Returns the rectangle for a specific element.
       *
       * @method getRect
       * @param {Element/String} e Element object or element ID to get rectange from.
       * @return {object} Rectange for specified element object with x, y, w, h fields.
       */
      getRect: function (e) {
        var p, self = this,
          sr;

        e = self.get(e);
        p = self.getPos(e);
        sr = self.getSize(e);

        return {
          x: p.x,
          y: p.y,
          w: sr.w,
          h: sr.h
        };
      },

      /**
       * Returns the size dimensions of the specified element.
       *
       * @method getSize
       * @param {Element/String} e Element object or element ID to get rectange from.
       * @return {object} Rectange for specified element object with w, h fields.
       */
      getSize: function (e) {
        var self = this,
          w, h;

        e = self.get(e);
        w = self.getStyle(e, 'width');
        h = self.getStyle(e, 'height');

        // Non pixel value, then force offset/clientWidth
        if (w.indexOf('px') === -1) {
          w = 0;
        }

        // Non pixel value, then force offset/clientWidth
        if (h.indexOf('px') === -1) {
          h = 0;
        }

        return {
          w: parseInt(w, 10) || e.offsetWidth || e.clientWidth,
          h: parseInt(h, 10) || e.offsetHeight || e.clientHeight
        };
      },

      /**
       * Returns a node by the specified selector function. This function will
       * loop through all parent nodes and call the specified function for each node.
       * If the function then returns true indicating that it has found what it was looking for, the loop execution will then end
       * and the node it found will be returned.
       *
       * @method getParent
       * @param {Node/String} n DOM node to search parents on or ID string.
       * @param {function} f Selection function to execute on each node or CSS pattern.
       * @param {Node} r Optional root element, never go below this point.
       * @return {Node} DOM Node or null if it wasn't found.
       */
      getParent: function (n, f, r) {
        return this.getParents(n, f, r, false);
      },

      /**
       * Returns a node list of all parents matching the specified selector function or pattern.
       * If the function then returns true indicating that it has found what it was looking for and that node will be collected.
       *
       * @method getParents
       * @param {Node/String} n DOM node to search parents on or ID string.
       * @param {function} f Selection function to execute on each node or CSS pattern.
       * @param {Node} r Optional root element, never go below this point.
       * @return {Array} Array of nodes or null if it wasn't found.
       */
      getParents: function (n, f, r, c) {
        var self = this,
          na, se = self.settings,
          o = [];

        n = self.get(n);
        c = c === undefined;

        if (se.strict_root) {
          r = r || self.getRoot();
        }

        // Wrap node name as func
        if (is(f, 'string')) {
          na = f;

          if (f === '*') {
            f = function (n) {
              return n.nodeType == 1;
            };
          } else {
            f = function (n) {
              return self.is(n, na);
            };
          }
        }

        while (n) {
          if (n == r || !n.nodeType || n.nodeType === 9) {
            break;
          }

          if (!f || f(n)) {
            if (c) {
              o.push(n);
            } else {
              return n;
            }
          }

          n = n.parentNode;
        }

        return c ? o : null;
      },

      /**
       * Returns the specified element by ID or the input element if it isn't a string.
       *
       * @method get
       * @param {String/Element} n Element id to look for or element to just pass though.
       * @return {Element} Element matching the specified id or null if it wasn't found.
       */
      get: function (e) {
        var n;

        if (e && this.doc && typeof (e) == 'string') {
          n = e;
          e = this.doc.getElementById(e);

          // IE and Opera returns meta elements when they match the specified input ID, but getElementsByName seems to do the trick
          if (e && e.id !== n) {
            return this.doc.getElementsByName(n)[1];
          }
        }

        return e;
      },

      /**
       * Returns the next node that matches selector or function
       *
       * @method getNext
       * @param {Node} node Node to find siblings from.
       * @param {String/function} selector Selector CSS expression or function.
       * @return {Node} Next node item matching the selector or null if it wasn't found.
       */
      getNext: function (node, selector) {
        return this._findSib(node, selector, 'nextSibling');
      },

      /**
       * Returns the previous node that matches selector or function
       *
       * @method getPrev
       * @param {Node} node Node to find siblings from.
       * @param {String/function} selector Selector CSS expression or function.
       * @return {Node} Previous node item matching the selector or null if it wasn't found.
       */
      getPrev: function (node, selector) {
        return this._findSib(node, selector, 'previousSibling');
      },

      // #ifndef jquery

      /**
       * Selects specific elements by a CSS level 3 pattern. For example "div#a1 p.test".
       * This function is optimized for the most common patterns needed in TinyMCE but it also performes good enough
       * on more complex patterns.
       *
       * @method select
       * @param {String} selector CSS level 1 pattern to select/find elements by.
       * @param {Object} scope Optional root element/scope element to search in.
       * @return {Array} Array with all matched elements.
       * @example
       * // Adds a class to all paragraphs in the currently active editor
       * tinymce.activeEditor.dom.addClass(tinymce.activeEditor.dom.select('p'), 'someclass');
       *
       * // Adds a class to all spans that has the test class in the currently active editor
       * tinymce.activeEditor.dom.addClass(tinymce.activeEditor.dom.select('span.test'), 'someclass');
       */
      select: function (selector, scope) {
        var self = this;

        /*eslint new-cap:0 */
        return tinymce.dom.Sizzle(selector, self.get(scope) || self.get(self.settings.root_element) || self.doc, []);
      },

      unique: function (arr) {
        return tinymce.dom.Sizzle.uniqueSort(arr);
      },

      /**
       * Returns true/false if the specified element matches the specified css pattern.
       *
       * @method is
       * @param {Node/NodeList} elm DOM node to match or an array of nodes to match.
       * @param {String} selector CSS pattern to match the element agains.
       */
      is: function (elm, selector) {
        var i;

        // If it isn't an array then try to do some simple selectors instead of Sizzle for to boost performance
        if (elm.length === undefined) {
          // Simple all selector
          if (selector === '*') {
            return elm.nodeType == 1;
          }

          // Simple selector just elements
          if (simpleSelectorRe.test(selector)) {
            selector = selector.toLowerCase().split(/,/);
            elm = elm.nodeName.toLowerCase();

            for (i = selector.length - 1; i >= 0; i--) {
              if (selector[i] == elm) {
                return true;
              }
            }

            return false;
          }
        }

        // Is non element
        if (elm.nodeType && elm.nodeType != 1) {
          return false;
        }

        var elms = elm.nodeType ? [elm] : elm;

        /*eslint new-cap:0 */
        return tinymce.dom.Sizzle(selector, elms[0].ownerDocument || elms[0], null, elms).length > 0;
      },

      closest: function (n, selector) {
        var self = this,
          result = [];

        while (n) {
          if (typeof selector === 'string' && self.is(n, selector)) {
            result.push(n);
            break;
          } else if (n === selector) {
            result.push(n);
            break;
          }

          n = n.parentNode;
        }

        return result;
      },

      contains: function (context, elm) {
        return tinymce.dom.Sizzle.contains(context, elm);
      },

      // #endif

      /**
       * Adds the specified element to another element or elements.
       *
       * @method add
       * @param {String/Element/Array} Element id string, DOM node element or array of id's or elements to add to.
       * @param {String/Element} n Name of new element to add or existing element to add.
       * @param {Object} a Optional object collection with arguments to add to the new element(s).
       * @param {String} h Optional inner HTML contents to add for each element.
       * @param {Boolean} c Optional internal state to indicate if it should create or add.
       * @return {Element/Array} Element that got created or array with elements if multiple elements where passed.
       * @example
       * // Adds a new paragraph to the end of the active editor
       * tinymce.activeEditor.dom.add(tinymce.activeEditor.getBody(), 'p', {title : 'my title'}, 'Some content');
       */
      add: function (p, n, a, h, c) {
        var self = this;

        return this.run(p, function (p) {
          var e;

          e = is(n, 'string') ? self.doc.createElement(n) : n;
          self.setAttribs(e, a);

          if (h) {
            if (h.nodeType) {
              e.appendChild(h);
            } else {
              self.setHTML(e, h);
            }
          }

          return !c ? p.appendChild(e) : e;
        });
      },

      /**
       * Creates a new element.
       *
       * @method create
       * @param {String} n Name of new element.
       * @param {Object} a Optional object name/value collection with element attributes.
       * @param {String} h Optional HTML string to set as inner HTML of the element.
       * @return {Element} HTML DOM node element that got created.
       * @example
       * // Adds an element where the caret/selection is in the active editor
       * var el = tinymce.activeEditor.dom.create('div', {id : 'test', 'class' : 'myclass'}, 'some content');
       * tinymce.activeEditor.selection.setNode(el);
       */
      create: function (n, a, h) {
        return this.add(this.doc.createElement(n), n, a, h, 1);
      },

      wrap: function (elements, wrapper, all) {
        var lastParent, newWrapper;

        wrapper = this.get(wrapper);

        return this.run(elements, function (elm) {
          if (!all || lastParent != elm.parentNode) {
            lastParent = elm.parentNode;
            newWrapper = wrapper.cloneNode(false);
            elm.parentNode.insertBefore(newWrapper, elm);
            newWrapper.appendChild(elm);
          } else {
            newWrapper.appendChild(elm);
          }
        });
      },

      /**
       * Create HTML string for element. The element will be closed unless an empty inner HTML string is passed.
       *
       * @method createHTML
       * @param {String} n Name of new element.
       * @param {Object} a Optional object name/value collection with element attributes.
       * @param {String} h Optional HTML string to set as inner HTML of the element.
       * @return {String} String with new HTML element like for example: <a href="#">test</a>.
       * @example
       * // Creates a html chunk and inserts it at the current selection/caret location
       * tinymce.activeEditor.selection.setContent(tinymce.activeEditor.dom.createHTML('a', {href : 'test.html'}, 'some line'));
       */
      createHTML: function (n, a, h) {
        var o = '',
          self = this,
          k;

        o += '<' + n;

        for (k in a) {
          // eslint-disable-next-line no-prototype-builtins
          if (a.hasOwnProperty(k) && a[k] != '') {
            o += ' ' + k + '="' + self.encode(a[k]) + '"';
          }
        }

        // A call to tinymce.is doesn't work for some odd reason on IE9 possible bug inside their JS runtime
        if (typeof (h) != "undefined") {
          return o + '>' + h + '</' + n + '>';
        }

        return o + ' />';
      },

      /**
       * Creates a document fragment out of the specified HTML string.
       *
       * @method createFragment
       * @param {String} html Html string to create fragment from.
       * @return {DocumentFragment} Document fragment node.
       */
      createFragment: function (html) {
        var frag, node, doc = this.doc,
          container;

        container = doc.createElement("div");
        frag = doc.createDocumentFragment();

        // Append the container to the fragment so as to remove it from
        // the current document context
        frag.appendChild(container);

        if (html) {
          container.innerHTML = html;
        }

        while ((node = container.firstChild)) {
          frag.appendChild(node);
        }

        // Remove the container now that all the children have been transferred
        frag.removeChild(container);

        return frag;
      },

      /**
       * Removes/deletes the specified element(s) from the DOM.
       *
       * @method remove
       * @param {String/Element/Array} node ID of element or DOM element object or array containing multiple elements/ids.
       * @param {Boolean} keep_children Optional state to keep children or not. If set to true all children will be placed at the location of the removed element.
       * @return {Element/Array} HTML DOM element that got removed or array of elements depending on input.
       * @example
       * // Removes all paragraphs in the active editor
       * tinymce.activeEditor.dom.remove(tinymce.activeEditor.dom.select('p'));
       *
       * // Removes a element by id in the document
       * tinymce.DOM.remove('mydiv');
       */
      remove: function (node, keep_children) {
        return this.run(node, function (node) {
          var child, parent = node.parentNode;

          if (!parent) {
            return null;
          }

          if (keep_children) {
            while ((child = node.firstChild)) {
              // IE 8 will crash if you don't remove completely empty text nodes
              if (!tinymce.isIE || child.nodeType !== 3 || child.nodeValue) {
                parent.insertBefore(child, node);
              } else {
                node.removeChild(child);
              }
            }
          }

          return parent.removeChild(node);
        });
      },

      /**
       * Empties all elements in set.
       *
       * @param {String/Element/Array} n HTML element/Element ID or Array of elements/ids to empty.
       * @method empty
       * @return {Boolean}
       */
      empty: function (node) {
        return this.run(node, function (node) {
          var n, i = node.length;

          while (i--) {
            n = node[i];
            while (n.firstChild) {
              n.removeChild(n.firstChild);
            }
          }

          return true;
        });
      },

      /**
       * Sets the CSS style value on a HTML element. The name can be a camelcase string
       * or the CSS style name like background-color.
       *
       * @method setStyle
       * @param {String/Element/Array} n HTML element/Element ID or Array of elements/ids to set CSS style value on.
       * @param {String} na Name of the style value to set.
       * @param {String} v Value to set on the style.
       * @example
       * // Sets a style value on all paragraphs in the currently active editor
       * tinymce.activeEditor.dom.setStyle(tinymce.activeEditor.dom.select('p'), 'background-color', 'red');
       *
       * // Sets a style value to an element by id in the current document
       * tinymce.DOM.setStyle('mydiv', 'background-color', 'red');
       */
      setStyle: function (n, na, v) {
        var self = this;

        return self.run(n, function (e) {
          var s;

          s = e.style;

          // Camelcase it, if needed
          na = na.replace(/-(\D)/g, function (a, b) {
            return b.toUpperCase();
          });

          // Default px suffix on these
          if (self.pixelStyles.test(na) && (tinymce.is(v, 'number') || /^[\-0-9\.]+$/.test(v))) {
            v += 'px';
          }

          if (na == 'float') {
            na = tinymce.isIE && tinymce.isIE < 12 ? 'styleFloat' : 'cssFloat';
          }

          s[na] = v || '';

          // Force update of the style data
          if (self.settings.update_styles) {
            v = self.serializeStyle(self.parseStyle(e.style.cssText), e.nodeName);
            self.setAttrib(e, 'data-mce-style', v);
          }
        });
      },

      /**
       * Returns the current style or runtime/computed value of a element.
       *
       * @method getStyle
       * @param {String/Element} n HTML element or element id string to get style from.
       * @param {String} na Style name to return.
       * @param {Boolean} c Computed style.
       * @return {String} Current style or computed style value of a element.
       */
      getStyle: function (n, na, c) {
        n = this.get(n);

        if (!n) {
          return;
        }

        // Gecko
        if (this.doc.defaultView && c) {
          // Remove camelcase
          na = na.replace(/[A-Z]/g, function (a) {
            return '-' + a;
          });

          try {
            return this.doc.defaultView.getComputedStyle(n, null).getPropertyValue(na);
          } catch (ex) {
            // Old safari might fail
            return null;
          }
        }

        // Camelcase it, if needed
        na = na.replace(/-(\D)/g, function (a, b) {
          return b.toUpperCase();
        });

        if (na == 'float') {
          na = 'cssFloat';
        }

        // IE & Opera
        if (n.currentStyle && c) {
          return n.currentStyle[na];
        }

        return n.style ? n.style[na] : undefined;
      },

      /**
       * Sets multiple styles on the specified element(s).
       *
       * @method setStyles
       * @param {Element/String/Array} e DOM element, element id string or array of elements/ids to set styles on.
       * @param {Object} o Name/Value collection of style items to add to the element(s).
       * @example
       * // Sets styles on all paragraphs in the currently active editor
       * tinymce.activeEditor.dom.setStyles(tinymce.activeEditor.dom.select('p'), {'background-color' : 'red', 'color' : 'green'});
       *
       * // Sets styles to an element by id in the current document
       * tinymce.DOM.setStyles('mydiv', {'background-color' : 'red', 'color' : 'green'});
       */
      setStyles: function (e, o) {
        var self = this,
          s = self.settings,
          ol, v;

        ol = s.update_styles;
        s.update_styles = 0;

        this.run(e, function (e) {
          each(o, function (v, n) {
            self.setStyle(e, n, v);
          });

          if (ol) {
            // Force update of the style data
            v = self.serializeStyle(self.parseStyle(e.style.cssText), e.nodeName);
            self.setAttrib(e, 'data-mce-style', v);
          }
        });

        s.update_styles = ol;
      },

      /**
       * Removes all attributes from an element or elements.
       *
       * @param {Element/String/Array} e DOM element, element id string or array of elements/ids to remove attributes from.
       */
      removeAllAttribs: function (e) {
        return this.run(e, function (e) {
          var i, attrs = e.attributes;
          for (i = attrs.length - 1; i >= 0; i--) {
            e.removeAttributeNode(attrs.item(i));
          }
        });
      },

      removeAttrib: function (e, n) {
        var self = this;

        // Whats the point
        if (!e || !n) {
          return;
        }

        // Strict XML mode
        if (self.settings.strict) {
          n = n.toLowerCase();
        }

        return this.run(e, function (e) {
          e.removeAttribute(n, 2);
        });
      },

      /**
       * Sets the specified attributes value of a element or elements.
       *
       * @method setAttrib
       * @param {Element/String/Array} e DOM element, element id string or array of elements/ids to set attribute on.
       * @param {String} n Name of attribute to set.
       * @param {String} v Value to set on the attribute of this value is falsy like null 0 or '' it will remove the attribute instead.
       * @example
       * // Sets an attribute to all paragraphs in the active editor
       * tinymce.activeEditor.dom.setAttrib(tinymce.activeEditor.dom.select('p'), 'class', 'myclass');
       *
       * // Sets an attribute to a specific element in the current page
       * tinymce.dom.setAttrib('mydiv', 'class', 'myclass');
       */
      setAttrib: function (e, n, v) {
        var self = this;

        // Whats the point
        if (!e || !n) {
          return;
        }

        // Strict XML mode
        if (self.settings.strict) {
          n = n.toLowerCase();
        }

        return this.run(e, function (e) {
          var s = self.settings;
          var originalValue = e.getAttribute(n);
          if (v !== null) {
            switch (n) {
              case "style":
                if (!is(v, 'string')) {
                  each(v, function (v, n) {
                    self.setStyle(e, n, v);
                  });

                  return;
                }

                // No mce_style for elements with these since they might get resized by the user
                if (s.keep_values) {
                  if (v && !self._isRes(v)) {
                    e.setAttribute('data-mce-style', v, 2);
                  } else {
                    e.removeAttribute('data-mce-style', 2);
                  }
                }

                e.style.cssText = v;
                break;

              case "class":
                e.className = v || ''; // Fix IE null bug
                break;

              case "src":
              case "href":
                if (s.keep_values) {
                  if (s.url_converter) {
                    v = s.url_converter.call(s.url_converter_scope || self, v, n, e);
                  }

                  self.setAttrib(e, 'data-mce-' + n, v, 2);
                }

                break;

              case "shape":
                e.setAttribute('data-mce-style', v);
                break;
            }
          }
          if (is(v) && v !== null && v.length !== 0) {
            e.setAttribute(n, '' + v, 2);
          } else {
            e.removeAttribute(n, 2);
          }

          // fire onChangeAttrib event for attributes that have changed
          if (tinymce.activeEditor && originalValue != v) {
            var ed = tinymce.activeEditor;
            ed.onSetAttrib.dispatch(ed, e, n, v);
          }
        });
      },

      /**
       * Sets the specified attributes of a element or elements.
       *
       * @method setAttribs
       * @param {Element/String/Array} e DOM element, element id string or array of elements/ids to set attributes on.
       * @param {Object} o Name/Value collection of attribute items to add to the element(s).
       * @example
       * // Sets some attributes to all paragraphs in the active editor
       * tinymce.activeEditor.dom.setAttribs(tinymce.activeEditor.dom.select('p'), {'class' : 'myclass', title : 'some title'});
       *
       * // Sets some attributes to a specific element in the current page
       * tinymce.DOM.setAttribs('mydiv', {'class' : 'myclass', title : 'some title'});
       */
      setAttribs: function (e, o) {
        var self = this;

        return this.run(e, function (e) {
          each(o, function (v, n) {
            self.setAttrib(e, n, v);
          });
        });
      },

      /**
       * Returns the specified attribute by name.
       *
       * @method getAttrib
       * @param {String/Element} e Element string id or DOM element to get attribute from.
       * @param {String} n Name of attribute to get.
       * @param {String} dv Optional default value to return if the attribute didn't exist.
       * @return {String} Attribute value string, default value or null if the attribute wasn't found.
       */
      getAttrib: function (e, n, dv) {
        var v, self = this,
          undef;

        e = self.get(e);

        if (!e || e.nodeType !== 1) {
          return dv === undef ? false : dv;
        }

        if (!is(dv)) {
          dv = '';
        }
        // Try the mce variant for these
        if (/^(src|href|style|coords|shape)$/.test(n)) {
          v = e.getAttribute("data-mce-" + n);

          if (v) {
            return v;
          }
        }

        if (isIE && self.props[n]) {
          v = e[self.props[n]];
          v = v && v.nodeValue ? v.nodeValue : v;
        }

        if (!v) {
          v = e.getAttribute(n, 2);
        }

        // Check boolean attribs
        if (/^(checked|compact|declare|defer|disabled|ismap|multiple|nohref|noshade|nowrap|readonly|selected)$/.test(n)) {
          if (e[self.props[n]] === true && v === '') {
            return n;
          }

          return v ? n : '';
        }

        // Inner input elements will override attributes on form elements
        if (e.nodeName === "FORM" && e.getAttributeNode(n)) {
          return e.getAttributeNode(n).nodeValue;
        }

        if (n === 'style') {
          v = v || e.style.cssText;

          if (v) {
            v = self.serializeStyle(self.parseStyle(v), e.nodeName);

            if (self.settings.keep_values && !self._isRes(v)) {
              e.setAttribute('data-mce-style', v);
            }
          }
        }

        // Remove Apple and WebKit stuff
        if (isWebKit && n === "class" && v) {
          v = v.replace(/(apple|webkit)\-[a-z\-]+/gi, '');
        }

        // Handle IE issues
        if (isIE) {
          switch (n) {
            case 'rowspan':
            case 'colspan':
              // IE returns 1 as default value
              if (v === 1) {
                v = '';
              }

              break;

            case 'size':
              // IE returns +0 as default value for size
              if (v === '+0' || v === 20 || v === 0) {
                v = '';
              }

              break;

            case 'width':
            case 'height':
            case 'vspace':
            case 'checked':
            case 'disabled':
            case 'readonly':
              if (v === 0) {
                v = '';
              }

              break;

            case 'hspace':
              // IE returns -1 as default value
              if (v === -1) {
                v = '';
              }

              break;

            case 'maxlength':
            case 'tabindex':
              // IE returns default value
              if (v === 32768 || v === 2147483647 || v === '32768') {
                v = '';
              }

              break;

            case 'multiple':
            case 'compact':
            case 'noshade':
            case 'nowrap':
              if (v === 65535) {
                return n;
              }

              return dv;

            case 'shape':
              v = v.toLowerCase();
              break;

            default:
              // IE has odd anonymous function for event attributes
              if (n.indexOf('on') === 0 && v) {
                v = '' + v;
                v = v.replace(/^function\s+\w+\(\)\s+\{\s+(.*)\s+\}$/, '$1');
              }
          }
        }

        return (v !== undef && v !== null && v !== '') ? '' + v : dv;
      },

      setValue: function (n, value) {
        n = this.get(n);

        if (!n || n.nodeType !== 1) {
          return null;
        }

        if (n.nodeName === "SELECT") {
          each(this.select('option[value="' + value + '"]', n), function (elm) {
            elm.selected = true;
          });
        } else {
          n.value = value;
        }
      },

      getValue: function (n) {
        n = this.get(n);

        if (!n || n.nodeType !== 1) {
          return null;
        }

        if (n.nodeName === "SELECT") {
          if (n.options == null || n.selectedIndex === -1) {
            return "";
          }

          return n.options[n.selectedIndex].value;
        }

        return n.value;
      },

      /**
       * Returns the absolute x, y position of a node. The position will be returned in a object with x, y fields.
       *
       * @method getPos
       * @param {Element/String} n HTML element or element id to get x, y position from.
       * @param {Element} ro Optional root element to stop calculations at.
       * @return {object} Absolute position of the specified element object with x, y fields.
       */
      getPos: function (n, ro) {
        var self = this,
          x = 0,
          y = 0,
          e, d = self.doc,
          r, body = d.body;

        n = self.get(n);
        ro = ro || body;

        if (n) {

          // Use getBoundingClientRect if it exists since it's faster than looping offset nodes
          if (ro === body && n.getBoundingClientRect && self.getStyle(body, 'position') === 'static') {
            n = n.getBoundingClientRect();
            e = self.boxModel ? d.documentElement : d.body;

            // Add scroll offsets from documentElement or body since IE with the wrong box model will use d.body and so do WebKit
            // Also remove the body/documentelement clientTop/clientLeft on IE 6, 7 since they offset the position
            x = n.left + (d.documentElement.scrollLeft || d.body.scrollLeft) - e.clientTop;
            y = n.top + (d.documentElement.scrollTop || d.body.scrollTop) - e.clientLeft;

            return {
              x: x,
              y: y
            };
          }

          r = n;
          while (r && r != ro && r.nodeType) {
            x += r.offsetLeft || 0;
            y += r.offsetTop || 0;
            r = r.offsetParent;
          }

          r = n.parentNode;
          while (r && r != ro && r.nodeType) {
            x -= r.scrollLeft || 0;
            y -= r.scrollTop || 0;
            r = r.parentNode;
          }
        }

        return {
          x: x,
          y: y
        };
      },

      /**
       * Parses the specified style value into an object collection. This parser will also
       * merge and remove any redundant items that browsers might have added. It will also convert non hex
       * colors to hex values. Urls inside the styles will also be converted to absolute/relative based on settings.
       *
       * @method parseStyle
       * @param {String} st Style value to parse for example: border:1px solid red;.
       * @return {Object} Object representation of that style like {border : '1px solid red'}
       */
      parseStyle: function (st) {
        return this.styles.parse(st);
      },

      /**
       * Serializes the specified style object into a string.
       *
       * @method serializeStyle
       * @param {Object} o Object to serialize as string for example: {border : '1px solid red'}
       * @param {String} name Optional element name.
       * @return {String} String representation of the style object for example: border: 1px solid red.
       */
      serializeStyle: function (o, name) {
        return this.styles.serialize(o, name);
      },

      /**
       * Adds a style element at the top of the document with the specified cssText content.
       *
       * @method addStyle
       * @param {String} cssText CSS Text style to add to top of head of document.
       */
      addStyle: function (cssText) {
        var doc = this.doc,
          head, styleElm;

        // Create style element if needed
        styleElm = doc.getElementById('mceDefaultStyles');
        if (!styleElm) {
          styleElm = doc.createElement('style');

          styleElm.id = 'mceDefaultStyles';
          styleElm.type = 'text/css';

          head = doc.getElementsByTagName('head')[0];
          if (head.firstChild) {
            head.insertBefore(styleElm, head.firstChild);
          } else {
            head.appendChild(styleElm);
          }
        }

        // Append style data to old or new style element
        if (styleElm.styleSheet) {
          styleElm.styleSheet.cssText += cssText;
        } else {
          styleElm.appendChild(doc.createTextNode(cssText));
        }
      },

      /**
       * Imports/loads the specified CSS file into the document bound to the class.
       *
       * @method loadCSS
       * @param {String} u URL to CSS file to load.
       * @example
       * // Loads a CSS file dynamically into the current document
       * tinymce.DOM.loadCSS('somepath/some.css');
       *
       * // Loads a CSS file into the currently active editor instance
       * tinymce.activeEditor.dom.loadCSS('somepath/some.css');
       *
       * // Loads a CSS file into an editor instance by id
       * tinymce.get('someid').dom.loadCSS('somepath/some.css');
       *
       * // Loads multiple CSS files into the current document
       * tinymce.DOM.loadCSS('somepath/some.css,somepath/someother.css');
       */
      loadCSS: function (u) {
        var self = this,
          d = self.doc,
          head;

        if (!u) {
          u = '';
        }

        head = d.getElementsByTagName('head')[0];

        each(u.split(','), function (u) {
          var link;

          if (self.files[u]) {
            return;
          }

          self.files[u] = true;

          link = self.create('link', {
            rel: 'stylesheet',
            'data-cfasync': false,
            href: tinymce._addVer(u)
          });

          head.appendChild(link);
        });
      },

      /**
       * Adds a class to the specified element or elements.
       *
       * @method addClass
       * @param {String/Element/Array} Element ID string or DOM element or array with elements or IDs.
       * @param {String} c Class name to add to each element.
       * @return {String/Array} String with new class value or array with new class values for all elements.
       * @example
       * // Adds a class to all paragraphs in the active editor
       * tinymce.activeEditor.dom.addClass(tinymce.activeEditor.dom.select('p'), 'myclass');
       *
       * // Adds a class to a specific element in the current page
       * tinymce.DOM.addClass('mydiv', 'myclass');
       */
      addClass: function (e, c) {
        if (!c) {
          return '';
        }

        var values = stringToArray(c);

        return this.run(e, function (e) {
          each(values, function (cls) {
            // remove whitespace
            cls.trim();

            // skip empty value
            if (!cls) {
              return true;
            }

            e.classList.add(cls);
          });

          return e.className;
        });
      },

      /**
       * Removes a class from the specified element or elements.
       *
       * @method removeClass
       * @param {String/Element/Array} Element ID string or DOM element or array with elements or IDs.
       * @param {String} c Class name to remove to each element.
       * @return {String/Array} String with new class value or array with new class values for all elements.
       * @example
       * // Removes a class from all paragraphs in the active editor
       * tinymce.activeEditor.dom.removeClass(tinymce.activeEditor.dom.select('p'), 'myclass');
       *
       * // Removes a class from a specific element in the current page
       * tinymce.DOM.removeClass('mydiv', 'myclass');
       */
      removeClass: function (e, c) {
        var self = this;

        if (!c) {
          return '';
        }

        var values = stringToArray(c);

        return self.run(e, function (e) {
          each(values, function (cls) {
            // remove whitespace
            cls.trim();

            // skip empty value
            if (!cls) {
              return true;
            }

            e.classList.remove(cls);
          });

          // Empty class attr
          if (!e.className) {
            e.removeAttribute('class');
            e.removeAttribute('className');
          }

          return e.className;
        });
      },

      /**
       * Returns true if the specified element has the specified class.
       *
       * @method hasClass
       * @param {String/Element} n HTML element or element id string to check CSS class on.
       * @param {String} c CSS class to check for.
       * @return {Boolean} true/false if the specified element has the specified class.
       */
      hasClass: function (n, c) {
        n = this.get(n);

        if (!n || !c) {
          return false;
        }

        return n.classList && n.classList.contains(c);
      },

      /**
       * Adds or removes a class on a sepecified element
       *
       * @method toggleClass
       * @param {String/Element} n HTML element or element id string to check CSS class on.
       * @param {String} c CSS class to add or remove.
       * @return {String/Array} String with new class value or array with new class values for all elements.
       */
      toggleClass: function (n, c) {
        n = this.get(n);

        if (!n || !c) {
          return false;
        }

        if (this.hasClass(n, c)) {
          return this.removeClass(n, c);
        } else {
          return this.addClass(n, c);
        }
      },

      /**
       * Shows the specified element(s) by ID by setting the "display" style.
       *
       * @method show
       * @param {String/Element/Array} e ID of DOM element or DOM element or array with elements or IDs to show.
       */
      show: function (e) {
        return this.setStyle(e, 'display', 'block');
      },

      /**
       * Hides the specified element(s) by ID by setting the "display" style.
       *
       * @method hide
       * @param {String/Element/Array} e ID of DOM element or DOM element or array with elements or IDs to hide.
       * @example
       * // Hides a element by id in the document
       * tinymce.DOM.hide('myid');
       */
      hide: function (e) {
        return this.setStyle(e, 'display', 'none');
      },

      /**
       * Returns true/false if the element is hidden or not by checking the "display" style.
       *
       * @method isHidden
       * @param {String/Element} e Id or element to check display state on.
       * @return {Boolean} true/false if the element is hidden or not.
       */
      isHidden: function (e) {
        e = this.get(e);

        return !e || e.style.display == 'none' || this.getStyle(e, 'display') == 'none';
      },

      /**
       * Returns a unique id. This can be useful when generating elements on the fly.
       * This method will not check if the element allready exists.
       *
       * @method uniqueId
       * @param {String} p Optional prefix to add infront of all ids defaults to "mce_".
       * @return {String} Unique id.
       */
      uniqueId: function (p) {
        return (!p ? 'mce_' : p) + (this.counter++);
      },

      /**
       * Sets the specified HTML content inside the element or elements. The HTML will first be processed this means
       * URLs will get converted, hex color values fixed etc. Check processHTML for details.
       *
       * @method setHTML
       * @param {Element/String/Array} e DOM element, element id string or array of elements/ids to set HTML inside.
       * @param {String} h HTML content to set as inner HTML of the element.
       * @example
       * // Sets the inner HTML of all paragraphs in the active editor
       * tinymce.activeEditor.dom.setHTML(tinymce.activeEditor.dom.select('p'), 'some inner html');
       *
       * // Sets the inner HTML of a element by id in the document
       * tinymce.DOM.setHTML('mydiv', 'some inner html');
       */
      setHTML: function (element, html) {
        var self = this;

        return self.run(element, function (element) {
          if (isIE) {
            // Remove all child nodes, IE keeps empty text nodes in DOM
            while (element.firstChild) {
              element.removeChild(element.firstChild);
            }

            try {
              // IE will remove comments from the beginning
              // unless you padd the contents with something
              element.innerHTML = '<br />' + html;
              element.removeChild(element.firstChild);
            } catch (ex) {
              // IE sometimes produces an unknown runtime error on innerHTML if it's an block element within a block element for example a div inside a p
              // This seems to fix this problem

              // Create new div with HTML contents and a BR infront to keep comments
              var newElement = self.create('div');
              newElement.innerHTML = '<br />' + html;

              // Add all children from div to target
              each(tinymce.grep(newElement.childNodes), function (node, i) {
                // Skip br element
                if (i && element.canHaveHTML) {
                  element.appendChild(node);
                }
              });
            }
          } else {
            element.innerHTML = html;
          }

          return html;
        });
      },

      /**
       * Returns the outer HTML of an element.
       *
       * @method getOuterHTML
       * @param {String/Element} elm Element ID or element object to get outer HTML from.
       * @return {String} Outer HTML string.
       * @example
       * tinymce.DOM.getOuterHTML(editorElement);
       * tinymce.activeEditor.getOuterHTML(tinymce.activeEditor.getBody());
       */
      getOuterHTML: function (elm) {
        var doc, self = this;

        elm = self.get(elm);

        if (!elm) {
          return null;
        }

        if (elm.nodeType === 1) {
          return elm.outerHTML;
        }

        doc = (elm.ownerDocument || self.doc).createElement("body");
        doc.appendChild(elm.cloneNode(true));

        return doc.innerHTML;
      },

      /**
       * Sets the specified outer HTML on a element or elements.
       *
       * @method setOuterHTML
       * @param {Element/String/Array} e DOM element, element id string or array of elements/ids to set outer HTML on.
       * @param {Object} h HTML code to set as outer value for the element.
       * @param {Document} d Optional document scope to use in this process defaults to the document of the DOM class.
       * @example
       * // Sets the outer HTML of all paragraphs in the active editor
       * tinymce.activeEditor.dom.setOuterHTML(tinymce.activeEditor.dom.select('p'), '<div>some html</div>');
       *
       * // Sets the outer HTML of a element by id in the document
       * tinymce.DOM.setOuterHTML('mydiv', '<div>some html</div>');
       */
      setOuterHTML: function (e, h, d) {
        var self = this;

        function setHTML(e, h, d) {
          var n, tp;

          tp = d.createElement("body");
          tp.innerHTML = h;

          n = tp.lastChild;
          while (n) {
            self.insertAfter(n.cloneNode(true), e);
            n = n.previousSibling;
          }

          self.remove(e);
        }

        return this.run(e, function (e) {
          e = self.get(e);

          // Only set HTML on elements
          if (e.nodeType == 1) {
            d = d || e.ownerDocument || self.doc;

            if (isIE) {
              try {
                // Try outerHTML for IE it sometimes produces an unknown runtime error
                if (isIE && e.nodeType == 1) {
                  e.outerHTML = h;
                } else {
                  setHTML(e, h, d);
                }
              } catch (ex) {
                // Fix for unknown runtime error
                setHTML(e, h, d);
              }
            } else {
              setHTML(e, h, d);
            }
          }
        });
      },

      /**
       * Entity decode a string, resolves any HTML entities like &aring;.
       *
       * @method decode
       * @param {String} s String to decode entities on.
       * @return {String} Entity decoded string.
       */
      decode: Entities.decode,

      /**
       * Entity encodes a string, encodes the most common entities <>"& into entities.
       *
       * @method encode
       * @param {String} text String to encode with entities.
       * @return {String} Entity encoded string.
       */
      encode: Entities.encodeAllRaw,

      /**
       * Inserts a element after the reference element.
       *
       * @method insertAfter
       * @param {Element} node Element to insert after the reference.
       * @param {Element/String/Array} reference_node Reference element, element id or array of elements to insert after.
       * @return {Element/Array} Element that got added or an array with elements.
       */
      insertAfter: function (node, reference_node) {
        reference_node = this.get(reference_node);

        return this.run(node, function (node) {
          var parent, nextSibling;

          parent = reference_node.parentNode;
          nextSibling = reference_node.nextSibling;

          if (nextSibling) {
            parent.insertBefore(node, nextSibling);
          } else {
            parent.appendChild(node);
          }

          return node;
        });
      },

      insertBefore: function (node, reference_node) {
        reference_node = this.get(reference_node);

        return this.run(node, function (node) {
          reference_node.parentNode.insertBefore(node, reference_node);
          return node;
        });
      },

      /**
       * Replaces the specified element or elements with the specified element, the new element will
       * be cloned if multiple inputs elements are passed.
       *
       * @method replace
       * @param {Element} n New element to replace old ones with.
       * @param {Element/String/Array} o Element DOM node, element id or array of elements or ids to replace.
       * @param {Boolean} k Optional keep children state, if set to true child nodes from the old object will be added to new ones.
       */
      replace: function (n, o, k) {
        var self = this;

        if (is(o, 'array')) {
          n = n.cloneNode(true);
        }

        return self.run(o, function (o) {
          if (k) {
            each(tinymce.grep(o.childNodes), function (c) {
              n.appendChild(c);
            });
          }

          return o.parentNode.replaceChild(n, o);
        });
      },

      /**
       * Renames the specified element to a new name and keep it's attributes and children.
       *
       * @method rename
       * @param {Element} elm Element to rename.
       * @param {String} name Name of the new element.
       * @return New element or the old element if it needed renaming.
       */
      rename: function (elm, name) {
        var self = this,
          newElm;

        if (elm.nodeName != name.toUpperCase()) {
          // Rename block element
          newElm = self.create(name);

          // Copy attribs to new block
          each(self.getAttribs(elm), function (attr_node) {
            self.setAttrib(newElm, attr_node.nodeName, self.getAttrib(elm, attr_node.nodeName));
          });

          // Replace block
          self.replace(newElm, elm, 1);
        }

        return newElm || elm;
      },

      /**
       * Find the common ancestor of two elements. This is a shorter method than using the DOM Range logic.
       *
       * @method findCommonAncestor
       * @param {Element} a Element to find common ancestor of.
       * @param {Element} b Element to find common ancestor of.
       * @return {Element} Common ancestor element of the two input elements.
       */
      findCommonAncestor: function (a, b) {
        var ps = a,
          pe;

        while (ps) {
          pe = b;

          while (pe && ps != pe) {
            pe = pe.parentNode;
          }

          if (ps == pe) {
            break;
          }

          ps = ps.parentNode;
        }

        if (!ps && a.ownerDocument) {
          return a.ownerDocument.documentElement;
        }

        return ps;
      },

      /**
       * Parses the specified RGB color value and returns a hex version of that color.
       *
       * @method toHex
       * @param {String} s RGB string value like rgb(1,2,3)
       * @return {String} Hex version of that RGB value like #FF00FF.
       */
      toHex: function (s) {
        //var c = /^\s*rgb\s*?\(\s*?([0-9]+)\s*?,\s*?([0-9]+)\s*?,\s*?([0-9]+)\s*?,\s*?([0-9\.]*)\s*?\)\s*$/i.exec(s);

        // clean up rgb string
        s = s.replace(/\s/g, '').replace(/(rgb|rgba)\(/i, '').replace(/\)/, '').replace(/\s/g, '');

        // split by comma seperator
        var c = s.split(',');

        function hex(s) {
          s = parseInt(s, 10).toString(16);

          return s.length > 1 ? s : '0' + s; // 0 -> 00
        }

        if (c.length >= 3) {
          s = '#' + hex(c[0]) + hex(c[1]) + hex(c[2]);

          return s;
        }

        return s;
      },

      /**
       * Returns a array of all single CSS classes in the document. A single CSS class is a simple
       * rule like ".class" complex ones like "div td.class" will not be added to output.
       *
       * @method getClasses
       * @return {Array} Array with class objects each object has a class field might be other fields in the future.
       */
      getClasses: function () {
        var self = this,
          cl = [],
          lo = {},
          f = self.settings.class_filter,
          ov;

        if (self.classes) {
          return self.classes;
        }

        function addClasses(s) {
          // IE style imports
          each(s.imports, function (r) {
            addClasses(r);
          });

          each(s.cssRules || s.rules, function (r) {
            // Real type or fake it on IE
            switch (r.type || 1) {
              // Rule
              case 1:
                if (r.selectorText) {
                  each(r.selectorText.split(','), function (v) {
                    v = v.replace(/^\s*|\s*$|^\s\./g, "");

                    // Is internal or it doesn't contain a class
                    if (/\.mce/.test(v) || !/\.[\w\-]+$/.test(v)) {
                      return;
                    }

                    // Remove everything but class name
                    ov = v;
                    v = v.replace(/.*\.([a-z0-9_\-]+).*/i, '$1');

                    // Filter classes
                    if (f && !(v = f(v, ov))) {
                      return;
                    }

                    if (!lo[v]) {
                      cl.push({
                        'class': v
                      });
                      lo[v] = 1;
                    }
                  });
                }
                break;

              // Import
              case 3:
                try {
                  addClasses(r.styleSheet);
                } catch (ex) {
                  // Ignore
                }

                break;
            }
          });
        }

        try {
          each(self.doc.styleSheets, addClasses);
        } catch (ex) {
          // Ignore
        }

        if (cl.length > 0) {
          self.classes = cl;
        }

        return cl;
      },

      /**
       * Executes the specified function on the element by id or dom element node or array of elements/id.
       *
       * @method run
       * @param {String/Element/Array} Element ID or DOM element object or array with ids or elements.
       * @param {function} f Function to execute for each item.
       * @param {Object} s Optional scope to execute the function in.
       * @return {Object/Array} Single object or array with objects depending on multiple input or not.
       */
      run: function (e, f, s) {
        var self = this,
          o;

        if (self.doc && typeof (e) === 'string') {
          e = self.get(e);
        }

        if (!e) {
          return false;
        }

        s = s || this;
        if (!e.nodeType && (e.length || e.length === 0)) {
          o = [];

          each(e, function (e, i) {
            if (e) {
              if (typeof (e) == 'string') {
                e = self.doc.getElementById(e);
              }

              o.push(f.call(s, e, i));
            }
          });

          return o;
        }

        return f.call(s, e);
      },

      /**
       * Returns an NodeList with attributes for the element.
       *
       * @method getAttribs
       * @param {HTMLElement/string} n Element node or string id to get attributes from.
       * @return {NodeList} NodeList with attributes.
       */
      getAttribs: function (n) {
        var o;

        n = this.get(n);

        if (!n) {
          return [];
        }

        if (isIE) {
          o = [];

          // Object will throw exception in IE
          if (n.nodeName == 'OBJECT') {
            return n.attributes;
          }

          // IE doesn't keep the selected attribute if you clone option elements
          if (n.nodeName === 'OPTION' && this.getAttrib(n, 'selected')) {
            o.push({
              specified: 1,
              nodeName: 'selected'
            });
          }

          // It's crazy that this is faster in IE but it's because it returns all attributes all the time
          n.cloneNode(false).outerHTML.replace(/<\/?[\w:\-]+ ?|=[\"][^\"]+\"|=\'[^\']+\'|=[\w\-]+|>/gi, '').replace(/[\w:\-]+/gi, function (a) {
            o.push({
              specified: 1,
              nodeName: a
            });
          });

          return o;
        }

        return n.attributes;
      },

      /**
       * Returns true/false if the specified node is to be considered empty or not.
       *
       * @example
       * tinymce.DOM.isEmpty(node, {img : true});
       * @method isEmpty
       * @param {Object} elements Optional name/value object with elements that are automatically treated as non empty elements.
       * @return {Boolean} true/false if the node is empty or not.
       */
      isEmpty: function (node, elements) {
        var self = this,
          i, attributes, type, whitespace, walker, name, brCount = 0;

        node = node.firstChild;

        function isValidAttribute(name) {
          // allow for anchors and html templating
          if (name == "name" || name == "id" || name == "class") {
            return true;
          }

          // allow some system and generic data- attributes
          if (name.indexOf('-') != -1) {
            if (name == 'data-mce-bookmark') {
              return true;
            }

            if (name.indexOf('data-mce-') != -1) {
              return false;
            }

            return true;
          }

          return false;
        }

        if (node) {
          walker = new tinymce.dom.TreeWalker(node, node.parentNode);
          elements = elements || (self.schema ? self.schema.getNonEmptyElements() : null);
          whitespace = self.schema ? self.schema.getWhiteSpaceElements() : {};

          do {
            type = node.nodeType;

            if (type === 1) {
              // Ignore bogus elements
              var bogusVal = node.getAttribute('data-mce-bogus');
              if (bogusVal) {
                node = walker.next(bogusVal === 'all');
                continue;
              }

              // Keep empty elements like <img />
              name = node.nodeName.toLowerCase();

              if (elements && elements[name]) {
                // Ignore single BR elements in blocks like <p><br /></p> or <p><span><br /></span></p>
                if (name === 'br') {
                  brCount++;
                  node = walker.next();
                  continue;
                }

                return false;
              }

              // Keep elements with data-bookmark attributes or name attribute like <a name="1"></a>
              attributes = self.getAttribs(node);
              i = attributes.length;

              while (i--) {
                name = attributes[i].nodeName;

                if (isValidAttribute(name)) {
                  return false;
                }
              }
            }

            // Keep comment nodes
            if (type == 8) {
              return false;
            }

            // Keep non whitespace text nodes
            if (type === 3 && !whiteSpaceRegExp.test(node.nodeValue)) {
              return false;
            }

            // Keep whitespace preserve elements
            if (type === 3 && node.parentNode && whitespace[node.parentNode.nodeName] && whiteSpaceRegExp.test(node.nodeValue)) {
              return false;
            }

            node = walker.next();
          } while (node);
        }

        return brCount <= 1;
      },

      /**
       * Destroys all internal references to the DOM to solve IE leak issues.
       *
       * @method destroy
       */
      destroy: function (s) {
        var self = this;

        self.win = self.doc = self.root = self.events = self.frag = null;

        // Manual destroy then remove unload handler
        if (!s) {
          tinymce.removeUnload(self.destroy);
        }
      },

      /**
       * Created a new DOM Range object. This will use the native DOM Range API
       *
       * @method createRng
       * @return {DOMRange} DOM Range object.
       * @example
       * var rng = tinymce.DOM.createRng();
       * alert(rng.startContainer + "," + rng.startOffset);
       */
      createRng: function () {
        return this.doc.createRange();
      },

      /**
       * Returns the index of the specified node within it's parent.
       *
       * @param {Node} node Node to look for.
       * @param {boolean} normalized Optional true/false state if the index is what it would be after a normalization.
       * @return {Number} Index of the specified node.
       */
      nodeIndex: function (node, normalized) {
        var idx = 0,
          lastNodeType, nodeType;

        if (node) {
          for (lastNodeType = node.nodeType, node = node.previousSibling; node; node = node.previousSibling) {
            nodeType = node.nodeType;

            // Normalize text nodes
            if (normalized && nodeType == 3) {
              if (nodeType == lastNodeType || !node.nodeValue.length) {
                continue;
              }
            }
            idx++;
            lastNodeType = nodeType;
          }
        }

        return idx;
      },

      /**
       * Splits an element into two new elements and places the specified split
       * element or element between the new ones. For example splitting the paragraph at the bold element in
       * this example <p>abc<b>abc</b>123</p> would produce <p>abc</p><b>abc</b><p>123</p>.
       *
       * @method split
       * @param {Element} pe Parent element to split.
       * @param {Element} e Element to split at.
       * @param {Element} re Optional replacement element to replace the split element by.
       * @return {Element} Returns the split element or the replacement element if that is specified.
       */
      split: function (pe, e, re) {
        var self = this,
          r = self.createRng(),
          bef, aft, pa;

        // W3C valid browsers tend to leave empty nodes to the left/right side of the contents, this makes sense
        // but we don't want that in our code since it serves no purpose for the end user
        // For example if this is chopped:
        //   <p>text 1<span><b>CHOP</b></span>text 2</p>
        // would produce:
        //   <p>text 1<span></span></p><b>CHOP</b><p><span></span>text 2</p>
        // this function will then trim of empty edges and produce:
        //   <p>text 1</p><b>CHOP</b><p>text 2</p>
        function trim(node) {
          var i, children = node.childNodes,
            type = node.nodeType;

          function surroundedBySpans(node) {
            var previousIsSpan = node.previousSibling && node.previousSibling.nodeName == 'SPAN';
            var nextIsSpan = node.nextSibling && node.nextSibling.nodeName == 'SPAN';
            return previousIsSpan && nextIsSpan;
          }

          if (type == 1 && node.getAttribute('data-mce-type') == 'bookmark') {
            return;
          }

          for (i = children.length - 1; i >= 0; i--) {
            trim(children[i]);
          }

          if (type != 9) {
            // Keep non whitespace text nodes
            if (type == 3 && node.nodeValue.length > 0) {
              // If parent element isn't a block or there isn't any useful contents for example "<p>   </p>"
              // Also keep text nodes with only spaces if surrounded by spans.
              // eg. "<p><span>a</span> <span>b</span></p>" should keep space between a and b
              var trimmedLength = tinymce.trim(node.nodeValue).length;
              if (!self.isBlock(node.parentNode) || trimmedLength > 0 || trimmedLength === 0 && surroundedBySpans(node)) {
                return;
              }
            } else if (type == 1) {
              // If the only child is a bookmark then move it up
              children = node.childNodes;
              if (children.length == 1 && children[0] && children[0].nodeType == 1 && children[0].getAttribute('data-mce-type') == 'bookmark') {
                node.parentNode.insertBefore(children[0], node);
              }

              // Keep non empty elements or img, hr etc
              if (children.length || /^(br|hr|input|img)$/i.test(node.nodeName)) {
                return;
              }
            }

            self.remove(node);
          }

          return node;
        }

        if (pe && e) {
          // Get before chunk
          r.setStart(pe.parentNode, self.nodeIndex(pe));
          r.setEnd(e.parentNode, self.nodeIndex(e));
          bef = r.extractContents();

          // Get after chunk
          r = self.createRng();
          r.setStart(e.parentNode, self.nodeIndex(e) + 1);
          r.setEnd(pe.parentNode, self.nodeIndex(pe) + 1);
          aft = r.extractContents();

          // Insert before chunk
          pa = pe.parentNode;
          pa.insertBefore(trim(bef), pe);

          // Insert middle chunk
          if (re) {
            pa.replaceChild(re, e);
          } else {
            pa.insertBefore(e, pe);
          }

          // Insert after chunk
          pa.insertBefore(trim(aft), pe);
          self.remove(pe);

          return re || e;
        }
      },

      /**
       * Adds an event handler to the specified object.
       *
       * @method bind
       * @param {Element/Document/Window/Array/String} o Object or element id string to add event handler to or an array of elements/ids/documents.
       * @param {String} n Name of event handler to add for example: click.
       * @param {function} f Function to execute when the event occurs.
       * @param {Object} s Optional scope to execute the function in.
       * @return {function} Function callback handler the same as the one passed in.
       */
      bind: function (target, name, func, scope) {
        return this.events.add(target, name, func, scope || this);
      },

      /**
       * Removes the specified event handler by name and function from a element or collection of elements.
       *
       * @method unbind
       * @param {String/Element/Array} o Element ID string or HTML element or an array of elements or ids to remove handler from.
       * @param {String} n Event handler name like for example: "click"
       * @param {function} f Function to remove.
       * @return {bool/Array} Bool state if true if the handler was removed or an array with states if multiple elements where passed in.
       */
      unbind: function (target, name, func) {
        return this.events.remove(target, name, func);
      },

      /**
       * Fires the specified event name with object on target.
       *
       * @method fire
       * @param {Node/Document/Window} target Target element or object to fire event on.
       * @param {String} name Name of the event to fire.
       * @param {Object} evt Event object to send.
       * @return {Event} Event object.
       */
      fire: function (target, name, evt) {
        return this.events.fire(target, name, evt);
      },

      // Returns the content editable state of a node
      getContentEditable: function (node) {
        var contentEditable;

        // Check type
        if (!node || node.nodeType != 1) {
          return null;
        }

        // Check for fake content editable
        contentEditable = node.getAttribute("data-mce-contenteditable");

        if (contentEditable && contentEditable !== "inherit") {
          return contentEditable;
        }

        // Check for real content editable
        return node.contentEditable !== "inherit" ? node.contentEditable : null;
      },

      getContentEditableParent: function (node) {
        var root = this.getRoot(),
          state = null;

        for (; node && node !== root; node = node.parentNode) {
          state = this.getContentEditable(node);

          if (state !== null) {
            break;
          }
        }

        return state;
      },

      isChildOf: function (node, parent) {
        while (node) {
          if (parent === node) {
            return true;
          }

          node = node.parentNode;
        }

        return false;
      },

      // #ifdef debug

      dumpRng: function (r) {
        return 'startContainer: ' + r.startContainer.nodeName + ', startOffset: ' + r.startOffset + ', endContainer: ' + r.endContainer.nodeName + ', endOffset: ' + r.endOffset;
      },

      // #endif

      _findSib: function (node, selector, name) {
        var self = this,
          f = selector;

        if (node) {
          // If expression make a function of it using is
          if (is(f, 'string')) {
            f = function (node) {
              return self.is(node, selector);
            };
          }

          // Loop all siblings
          for (node = node[name]; node; node = node[name]) {
            if (f(node)) {
              return node;
            }
          }
        }

        return null;
      },

      _isRes: function (c) {
        // Is live resizble element
        return /^(top|left|bottom|right|width|height)/i.test(c) || /;\s*(top|left|bottom|right|width|height)/i.test(c);
      }

      /*
      walk : function(n, f, s) {
        var d = this.doc, w;

        if (d.createTreeWalker) {
          w = d.createTreeWalker(n, NodeFilter.SHOW_TEXT, null, false);

          while ((n = w.nextNode()) != null)
            f.call(s || this, n);
        } else
          tinymce.walk(n, f, 'childNodes', s);
      }
      */
    };

    /**
     * Instance of DOMUtils for the current document.
     *
     * @property DOM
     * @member tinymce
     * @type tinymce.dom.DOMUtils
     * @example
     * // Example of how to add a class to some element by id
     * tinymce.DOM.addClass('someid', 'someclass');
     */
    tinymce.DOM = new tinymce.dom.DOMUtils(document, {
      process_html: 0
    });
  })(tinymce);

  /**
   * NodeType.js
   *
   * Released under LGPL License.
   * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
   *
   * License: http://www.tinymce.com/license - Inactive
   * Licence: GNU/LGPL 2.1 or later - http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
   * Contributing: http://www.tinymce.com/contributing - Inactive
   */

  /**
   * Contains various node validation functions.
   *
   * @private
   * @class tinymce.dom.NodeType
   */
  (function (tinymce) {
    function isNodeType(type) {
      return function (node) {
        return !!node && node.nodeType == type;
      };
    }

    var isElement = isNodeType(1);

    function matchNodeNames(names) {
      names = names.toLowerCase().split(' ');

      return function (node) {
        var i, name;

        if (node && node.nodeType) {
          name = node.nodeName.toLowerCase();

          for (i = 0; i < names.length; i++) {
            if (name === names[i]) {
              return true;
            }
          }
        }

        return false;
      };
    }

    function matchStyleValues(name, values) {
      values = values.toLowerCase().split(' ');

      return function (node) {
        var i, cssValue;

        if (isElement(node)) {
          for (i = 0; i < values.length; i++) {
            cssValue = node.ownerDocument.defaultView.getComputedStyle(node, null).getPropertyValue(name);
            if (cssValue === values[i]) {
              return true;
            }
          }
        }

        return false;
      };
    }

    function hasPropValue(propName, propValue) {
      return function (node) {
        return isElement(node) && node[propName] === propValue;
      };
    }

    function hasAttributeValue(attrName, attrValue) {
      return function (node) {
        return isElement(node) && node.getAttribute(attrName) === attrValue;
      };
    }

    function isBogus(node) {
      return isElement(node) && node.hasAttribute('data-mce-bogus');
    }

    function isBookmark(node) {
      return isElement(node) && node.getAttribute('data-mce-type') == 'bookmark';
    }

    function isCaret(node) {
      return isElement(node) && node.id === '_mce_caret';
    }

    function isInternal(node) {
      return isBogus(node) || isBookmark(node) || isCaret(node);
    }

    function hasContentEditableState(value) {
      return function (node) {
        if (isElement(node)) {

          // check contenteditable override
          if (node.hasAttribute('data-mce-contenteditable')) {
            return node.getAttribute('data-mce-contenteditable') === value;
          }

          // check attribute
          if (node.contentEditable === value) {
            return true;
          }

          /*if (node.getAttribute('data-mce-contenteditable') === value) {
            return true;
          }*/
        }

        return false;
      };
    }

    tinymce.dom.NodeType = {
      isText: isNodeType(3),
      isElement: isElement,
      isComment: isNodeType(8),
      isDocument: isNodeType(9),
      isDocumentFragment: isNodeType(11),
      isBr: matchNodeNames('br'),
      isContentEditableTrue: hasContentEditableState('true'),
      isContentEditableFalse: hasContentEditableState('false'),
      matchNodeNames: matchNodeNames,
      hasPropValue: hasPropValue,
      hasAttributeValue: hasAttributeValue,
      matchStyleValues: matchStyleValues,
      isBogus: isBogus,
      isBookmark: isBookmark,
      isInternal: isInternal
    };

  })(tinymce);

  /**
   * Dimensions.js
   *
   * Released under LGPL License.
   * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
   *
   * License: http://www.tinymce.com/license - Inactive
   * Licence: GNU/LGPL 2.1 or later - http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
   * Contributing: http://www.tinymce.com/contributing - Inactive
   */

  /**
   * This module measures nodes and returns client rects. The client rects has an
   * extra node property.
   *
   * @private
   * @class tinymce.dom.Dimensions
   */
  (function (tinymce) {
    var NodeType = tinymce.dom.NodeType,
      Arr = tinymce.util.Arr,
      ClientRect = tinymce.geom.ClientRect;

    function getClientRects(node) {
      function toArrayWithNode(clientRects) {
        return Arr.map(clientRects, function (clientRect) {
          clientRect = ClientRect.clone(clientRect);
          clientRect.node = node;

          return clientRect;
        });
      }

      if (Arr.isArray(node)) {
        return Arr.reduce(node, function (result, node) {
          return result.concat(getClientRects(node));
        }, []);
      }

      if (NodeType.isElement(node)) {
        return toArrayWithNode(node.getClientRects());
      }

      if (NodeType.isText(node)) {
        var rng = node.ownerDocument.createRange();

        rng.setStart(node, 0);
        rng.setEnd(node, node.data.length);

        return toArrayWithNode(rng.getClientRects());
      }
    }

    tinymce.dom.Dimensions = {
      /**
       * Returns the client rects for a specific node.
       *
       * @method getClientRects
       * @param {Array/DOMNode} node Node or array of nodes to get client rects on.
       * @param {Array} Array of client rects with a extra node property.
       */
      getClientRects: getClientRects
    };

  })(tinymce);

  /**
   * Range.js
   *
   * Copyright, Moxiecode Systems AB
   * Released under LGPL License.
   *
   * License: http://www.tinymce.com/license - Inactive
   * Licence: GNU/LGPL 2.1 or later - http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
   * Contributing: http://www.tinymce.com/contributing - Inactive
   */
  (function (tinymce) {
  	var each = tinymce.each,
  		TreeWalker = tinymce.dom.TreeWalker;

  	function getEndChild(container, index) {
  		var childNodes = container.childNodes;

  		index--;

  		if (index > childNodes.length - 1) {
  			index = childNodes.length - 1;
  		} else if (index < 0) {
  			index = 0;
  		}

  		return childNodes[index] || container;
  	}

  	tinymce.dom.RangeUtils = function (dom) {
  		/**
  		 * Walks the specified range like object and executes the callback for each sibling collection it finds.
  		 *
  		 * @method walk
  		 * @param {Object} rng Range like object.
  		 * @param {function} callback Callback function to execute for each sibling collection.
  		 */
  		this.walk = function (rng, callback) {
  			var startContainer = rng.startContainer,
  				startOffset = rng.startOffset,
  				endContainer = rng.endContainer,
  				endOffset = rng.endOffset,
  				ancestor, startPoint,
  				endPoint, node, parent, siblings, nodes;

  			// Handle table cell and column selection
  			nodes = dom.select('td.mceSelected,th.mceSelected,div.mceSelected');

  			if (nodes.length > 0) {
  				each(nodes, function (node) {
  					callback([node]);
  				});

  				return;
  			}

  			/**
  			 * Excludes start/end text node if they are out side the range
  			 *
  			 * @private
  			 * @param {Array} nodes Nodes to exclude items from.
  			 * @return {Array} Array with nodes excluding the start/end container if needed.
  			 */
  			function exclude(nodes) {
  				var node;

  				// First node is excluded
  				node = nodes[0];
  				if (node.nodeType === 3 && node === startContainer && startOffset >= node.nodeValue.length) {
  					nodes.splice(0, 1);
  				}

  				// Last node is excluded
  				node = nodes[nodes.length - 1];
  				if (endOffset === 0 && nodes.length > 0 && node === endContainer && node.nodeType === 3) {
  					nodes.splice(nodes.length - 1, 1);
  				}

  				return nodes;
  			}

  			/**
  			 * Collects siblings
  			 *
  			 * @private
  			 * @param {Node} node Node to collect siblings from.
  			 * @param {String} name Name of the sibling to check for.
  			 * @return {Array} Array of collected siblings.
  			 */
  			function collectSiblings(node, name, end_node) {
  				var siblings = [];

  				for (; node && node != end_node; node = node[name]) {
  					siblings.push(node);
  				}

  				return siblings;
  			}

  			/**
  			 * Find an end point this is the node just before the common ancestor root.
  			 *
  			 * @private
  			 * @param {Node} node Node to start at.
  			 * @param {Node} root Root/ancestor element to stop just before.
  			 * @return {Node} Node just before the root element.
  			 */
  			function findEndPoint(node, root) {
  				do {
  					if (node.parentNode == root) {
  						return node;
  					}

  					node = node.parentNode;
  				} while (node);
  			}

  			function walkBoundary(start_node, end_node, next) {
  				var siblingName = next ? 'nextSibling' : 'previousSibling';

  				for (node = start_node, parent = node.parentNode; node && node != end_node; node = parent) {
  					parent = node.parentNode;
  					siblings = collectSiblings(node == start_node ? node : node[siblingName], siblingName);

  					if (siblings.length) {
  						if (!next) {
  							siblings.reverse();
  						}

  						callback(exclude(siblings));
  					}
  				}
  			}

  			// If index based start position then resolve it
  			if (startContainer.nodeType == 1 && startContainer.hasChildNodes()) {
  				startContainer = startContainer.childNodes[startOffset];
  			}

  			// If index based end position then resolve it
  			if (endContainer.nodeType == 1 && endContainer.hasChildNodes()) {
  				endContainer = getEndChild(endContainer, endOffset);
  			}

  			// Same container
  			if (startContainer == endContainer) {
  				return callback(exclude([startContainer]));
  			}

  			// Find common ancestor and end points
  			ancestor = dom.findCommonAncestor(startContainer, endContainer);

  			// Process left side
  			for (node = startContainer; node; node = node.parentNode) {
  				if (node === endContainer) {
  					return walkBoundary(startContainer, ancestor, true);
  				}

  				if (node === ancestor) {
  					break;
  				}
  			}

  			// Process right side
  			for (node = endContainer; node; node = node.parentNode) {
  				if (node === startContainer) {
  					return walkBoundary(endContainer, ancestor);
  				}

  				if (node === ancestor) {
  					break;
  				}
  			}

  			// Find start/end point
  			startPoint = findEndPoint(startContainer, ancestor) || startContainer;
  			endPoint = findEndPoint(endContainer, ancestor) || endContainer;

  			// Walk left leaf
  			walkBoundary(startContainer, startPoint, true);

  			// Walk the middle from start to end point
  			siblings = collectSiblings(
  				startPoint == startContainer ? startPoint : startPoint.nextSibling,
  				'nextSibling',
  				endPoint == endContainer ? endPoint.nextSibling : endPoint
  			);

  			if (siblings.length) {
  				callback(exclude(siblings));
  			}

  			// Walk right leaf
  			walkBoundary(endContainer, endPoint);
  		};

  		/**
  		 * Splits the specified range at it's start/end points.
  		 *
  		 * @private
  		 * @param {Range/RangeObject} rng Range to split.
  		 * @return {Object} Range position object.
  		 */
  		this.split = function (rng) {
  			var startContainer = rng.startContainer,
  				startOffset = rng.startOffset,
  				endContainer = rng.endContainer,
  				endOffset = rng.endOffset;

  			function splitText(node, offset) {
  				return node.splitText(offset);
  			}

  			// Handle single text node
  			if (startContainer == endContainer && startContainer.nodeType == 3) {
  				if (startOffset > 0 && startOffset < startContainer.nodeValue.length) {
  					endContainer = splitText(startContainer, startOffset);
  					startContainer = endContainer.previousSibling;

  					if (endOffset > startOffset) {
  						endOffset = endOffset - startOffset;
  						startContainer = endContainer = splitText(endContainer, endOffset).previousSibling;
  						endOffset = endContainer.nodeValue.length;
  						startOffset = 0;
  					} else {
  						endOffset = 0;
  					}
  				}
  			} else {
  				// Split startContainer text node if needed
  				if (startContainer.nodeType == 3 && startOffset > 0 && startOffset < startContainer.nodeValue.length) {
  					startContainer = splitText(startContainer, startOffset);
  					startOffset = 0;
  				}

  				// Split endContainer text node if needed
  				if (endContainer.nodeType == 3 && endOffset > 0 && endOffset < endContainer.nodeValue.length) {
  					endContainer = splitText(endContainer, endOffset).previousSibling;
  					endOffset = endContainer.nodeValue.length;
  				}
  			}

  			return {
  				startContainer: startContainer,
  				startOffset: startOffset,
  				endContainer: endContainer,
  				endOffset: endOffset
  			};
  		};

  		/**
  		 * Normalizes the specified range by finding the closest best suitable caret location.
  		 *
  		 * @private
  		 * @param {Range} rng Range to normalize.
  		 * @return {Boolean} True/false if the specified range was normalized or not.
  		 */
  		this.normalize = function (rng) {
  			var normalized, collapsed;

  			function normalizeEndPoint(start) {
  				var container, offset, walker, body = dom.getRoot(),
  					node, nonEmptyElementsMap;
  				var directionLeft, isAfterNode;

  				function hasBrBeforeAfter(node, left) {
  					var walker = new TreeWalker(node, dom.getParent(node.parentNode, dom.isBlock) || body);

  					while ((node = walker[left ? 'prev' : 'next']())) {
  						if (node.nodeName === "BR") {
  							return true;
  						}
  					}
  				}

  				function isPrevNode(node, name) {
  					return node.previousSibling && node.previousSibling.nodeName == name;
  				}

  				// Walks the dom left/right to find a suitable text node to move the endpoint into
  				// It will only walk within the current parent block or body and will stop if it hits a block or a BR/IMG
  				function findTextNodeRelative(left, startNode) {
  					var walker, lastInlineElement, parentBlockContainer;

  					startNode = startNode || container;
  					parentBlockContainer = dom.getParent(startNode.parentNode, dom.isBlock) || body;

  					// Lean left before the BR element if it's the only BR within a block element. Gecko bug: #6680
  					// This: <p><br>|</p> becomes <p>|<br></p>
  					if (left && startNode.nodeName == 'BR' && isAfterNode && dom.isEmpty(parentBlockContainer)) {
  						container = startNode.parentNode;
  						offset = dom.nodeIndex(startNode);
  						normalized = true;
  						return;
  					}

  					// Walk left until we hit a text node we can move to or a block/br/img
  					walker = new TreeWalker(startNode, parentBlockContainer);
  					while ((node = walker[left ? 'prev' : 'next']())) {
  						// Break if we hit a non content editable node
  						if (dom.getContentEditableParent(node) === "false") {
  							return;
  						}

  						// Found text node that has a length
  						if (node.nodeType === 3 && node.nodeValue.length > 0) {
  							container = node;
  							offset = left ? node.nodeValue.length : 0;
  							normalized = true;
  							return;
  						}

  						// Break if we find a block or a BR/IMG/INPUT etc
  						if (dom.isBlock(node) || nonEmptyElementsMap[node.nodeName.toLowerCase()]) {
  							return;
  						}

  						lastInlineElement = node;
  					}

  					// Only fetch the last inline element when in caret mode for now
  					if (collapsed && lastInlineElement) {
  						container = lastInlineElement;
  						normalized = true;
  						offset = 0;
  					}
  				}

  				container = rng[(start ? 'start' : 'end') + 'Container'];
  				offset = rng[(start ? 'start' : 'end') + 'Offset'];
  				isAfterNode = container.nodeType == 1 && offset === container.childNodes.length;
  				nonEmptyElementsMap = dom.schema.getNonEmptyElements();
  				directionLeft = start;

  				if (container.nodeType == 1 && offset > container.childNodes.length - 1) {
  					directionLeft = false;
  				}

  				// If the container is a document move it to the body element
  				if (container.nodeType === 9) {
  					container = dom.getRoot();
  					offset = 0;
  				}

  				// If the container is body try move it into the closest text node or position
  				if (container === body) {
  					// If start is before/after a image, table etc
  					if (directionLeft) {
  						node = container.childNodes[offset > 0 ? offset - 1 : 0];
  						if (node) {
  							if (nonEmptyElementsMap[node.nodeName] || node.nodeName == "TABLE") {
  								return;
  							}
  						}
  					}

  					// Resolve the index
  					if (container.hasChildNodes()) {
  						offset = Math.min(!directionLeft && offset > 0 ? offset - 1 : offset, container.childNodes.length - 1);
  						container = container.childNodes[offset];
  						offset = 0;

  						// Don't walk into elements that doesn't have any child nodes like a IMG
  						if (container.hasChildNodes() && !/TABLE/.test(container.nodeName)) {
  							// Walk the DOM to find a text node to place the caret at or a BR
  							node = container;
  							walker = new TreeWalker(container, body);

  							do {
  								// Found a text node use that position
  								if (node.nodeType === 3 && node.nodeValue.length > 0) {
  									offset = directionLeft ? 0 : node.nodeValue.length;
  									container = node;
  									normalized = true;
  									break;
  								}

  								// Found a BR/IMG element that we can place the caret before
  								if (nonEmptyElementsMap[node.nodeName.toLowerCase()]) {
  									offset = dom.nodeIndex(node);
  									container = node.parentNode;

  									// Put caret after image when moving the end point
  									if (node.nodeName == "IMG" && !directionLeft) {
  										offset++;
  									}

  									normalized = true;
  									break;
  								}
  							} while ((node = (directionLeft ? walker.next() : walker.prev())));
  						}
  					}
  				}

  				// Lean the caret to the left if possible
  				if (collapsed) {
  					// So this: <b>x</b><i>|x</i>
  					// Becomes: <b>x|</b><i>x</i>
  					// Seems that only gecko has issues with this
  					if (container.nodeType === 3 && offset === 0) {
  						findTextNodeRelative(true);
  					}

  					// Lean left into empty inline elements when the caret is before a BR
  					// So this: <i><b></b><i>|<br></i>
  					// Becomes: <i><b>|</b><i><br></i>
  					// Seems that only gecko has issues with this.
  					// Special edge case for <p><a>x</a>|<br></p> since we don't want <p><a>x|</a><br></p>
  					if (container.nodeType === 1) {
  						node = container.childNodes[offset];

  						// Offset is after the containers last child
  						// then use the previous child for normalization
  						if (!node) {
  							node = container.childNodes[offset - 1];
  						}

  						if (node && node.nodeName === 'BR' && !isPrevNode(node, 'A') &&
  							!hasBrBeforeAfter(node) && !hasBrBeforeAfter(node, true)) {
  							findTextNodeRelative(true, node);
  						}
  					}
  				}

  				// Lean the start of the selection right if possible
  				// So this: x[<b>x]</b>
  				// Becomes: x<b>[x]</b>
  				if (directionLeft && !collapsed && container.nodeType === 3 && offset === container.nodeValue.length) {
  					findTextNodeRelative(false);
  				}

  				// Set endpoint if it was normalized
  				if (normalized) {
  					rng['set' + (start ? 'Start' : 'End')](container, offset);
  				}
  			}

  			collapsed = rng.collapsed;

  			normalizeEndPoint(true);

  			if (!collapsed) {
  				normalizeEndPoint();
  			}

  			// If it was collapsed then make sure it still is
  			if (normalized && collapsed) {
  				rng.collapse(true);
  			}

  			return normalized;
  		};
  	};

  	/**
  	 * Compares two ranges and checks if they are equal.
  	 *
  	 * @static
  	 * @method compareRanges
  	 * @param {DOMRange} rng1 First range to compare.
  	 * @param {DOMRange} rng2 First range to compare.
  	 * @return {Boolean} true/false if the ranges are equal.
  	 */
  	tinymce.dom.RangeUtils.compareRanges = function (rng1, rng2) {
  		if (rng1 && rng2) {
  			// Compare native IE ranges
  			if (rng1.item || rng1.duplicate) {
  				// Both are control ranges and the selected element matches
  				if (rng1.item && rng2.item && rng1.item(0) === rng2.item(0)) {
  					return true;
  				}

  				// Both are text ranges and the range matches
  				if (rng1.isEqual && rng2.isEqual && rng2.isEqual(rng1)) {
  					return true;
  				}
  			} else {
  				// Compare w3c ranges
  				return rng1.startContainer == rng2.startContainer && rng1.startOffset == rng2.startOffset;
  			}
  		}

  		return false;
  	};

  	/**
  	 * Gets the caret range for the given x/y location.
  	 *
  	 * @static
  	 * @method getCaretRangeFromPoint
  	 * @param {Number} x X coordinate for range
  	 * @param {Number} y Y coordinate for range
  	 * @param {Document} doc Document that x/y are relative to
  	 * @returns {Range} caret range
  	 */
  	tinymce.dom.RangeUtils.getCaretRangeFromPoint = function (x, y, doc) {
  		var rng, point;

  		if (doc.caretPositionFromPoint) {
  			point = doc.caretPositionFromPoint(x, y);
  			rng = doc.createRange();
  			rng.setStart(point.offsetNode, point.offset);
  			rng.collapse(true);
  		} else if (doc.caretRangeFromPoint) {
  			rng = doc.caretRangeFromPoint(x, y);
  		} else if (doc.body.createTextRange) {
  			rng = doc.body.createTextRange();

  			try {
  				rng.moveToPoint(x, y);
  				rng.collapse(true);
  			} catch (ex) {
  				// Append to top or bottom depending on drop location
  				rng.collapse(y < doc.body.clientHeight);
  			}
  		}

  		return rng;
  	};

  	tinymce.dom.RangeUtils.getSelectedNode = function (range) {
  		var startContainer = range.startContainer,
  			startOffset = range.startOffset;

  		if (startContainer.hasChildNodes() && range.endOffset == startOffset + 1) {
  			return startContainer.childNodes[startOffset];
  		}

  		return null;
  	};

  	tinymce.dom.RangeUtils.getNode = function (container, offset) {
  		if (container.nodeType == 1 && container.hasChildNodes()) {
  			if (offset >= container.childNodes.length) {
  				offset = container.childNodes.length - 1;
  			}

  			container = container.childNodes[offset];
  		}

  		return container;
  	};
  })(tinymce);

  /**
   * MousePosition.js
   *
   * Released under LGPL License.
   * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
   *
   * License: http://www.tinymce.com/license - Inactive
   * Licence: GNU/LGPL 2.1 or later - http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
   * Contributing: http://www.tinymce.com/contributing - Inactive
   */

  /**
   * This module calculates an absolute coordinate inside the editor body for both local and global mouse events.
   *
   * @private
   * @class tinymce.dom.MousePosition
   */
  (function (tinymce) {
      var getAbsolutePosition = function (elm) {
        var doc, docElem, win, clientRect;

        clientRect = elm.getBoundingClientRect();
        doc = elm.ownerDocument;
        docElem = doc.documentElement;
        win = doc.defaultView;

        return {
          top: clientRect.top + win.pageYOffset - docElem.clientTop,
          left: clientRect.left + win.pageXOffset - docElem.clientLeft
        };
      };

      var getBodyPosition = function (editor) {
        return editor.inline ? getAbsolutePosition(editor.getBody()) : { left: 0, top: 0 };
      };

      var getScrollPosition = function (editor) {
        var body = editor.getBody();
        return editor.inline ? { left: body.scrollLeft, top: body.scrollTop } : { left: 0, top: 0 };
      };

      var getBodyScroll = function (editor) {
        var body = editor.getBody(), docElm = editor.getDoc().documentElement;
        var inlineScroll = { left: body.scrollLeft, top: body.scrollTop };
        var iframeScroll = { left: body.scrollLeft || docElm.scrollLeft, top: body.scrollTop || docElm.scrollTop };

        return editor.inline ? inlineScroll : iframeScroll;
      };

      var getMousePosition = function (editor, event) {
        if (event.target.ownerDocument !== editor.getDoc()) {
          var iframePosition = getAbsolutePosition(editor.getContentAreaContainer());
          var scrollPosition = getBodyScroll(editor);

          return {
            left: event.pageX - iframePosition.left + scrollPosition.left,
            top: event.pageY - iframePosition.top + scrollPosition.top
          };
        }

        return {
          left: event.pageX,
          top: event.pageY
        };
      };

      var calculatePosition = function (bodyPosition, scrollPosition, mousePosition) {
        return {
          pageX: (mousePosition.left - bodyPosition.left) + scrollPosition.left,
          pageY: (mousePosition.top - bodyPosition.top) + scrollPosition.top
        };
      };

      var calc = function (editor, event) {
        return calculatePosition(getBodyPosition(editor), getScrollPosition(editor), getMousePosition(editor, event));
      };

      tinymce.dom.MousePosition = {
        calc: calc
      };
  })(tinymce);

  /**
   * Copyright (c) Tiny Technologies, Inc. All rights reserved.
   * Licensed under the LGPL or a commercial license.
   * For LGPL see License.txt in the project root for license information.
   * For commercial licenses see https://www.tiny.cloud/
   * 
   * This is a modified version of the original TrimBody.ts file for es5 compatibility.
   * Source: https://github.com/tinymce/tinymce/blob/release/5.10/modules/tinymce/src/core/main/ts/dom/TrimBody.ts
   */

  (function (tinymce) {    
      var ZWSP = '\uFEFF';

      function getTemporaryNodeSelector(tempAttrs) {
          return "" + (tempAttrs.length === 0 ? '' : tempAttrs.map(function (attr) {
              return "[" + attr + "]";
          }).join(',') + ",") + "[data-mce-bogus=\"all\"]";
      }

      function getTemporaryNodes(body, tempAttrs) {
          return body.querySelectorAll(getTemporaryNodeSelector(tempAttrs));
      }

      function createCommentWalker(body) {
          return document.createTreeWalker(body, NodeFilter.SHOW_COMMENT, null, false);
      }

      function hasComments(body) {
          return createCommentWalker(body).nextNode() !== null;
      }

      function hasTemporaryNodes(body, tempAttrs) {
          return body.querySelector(getTemporaryNodeSelector(tempAttrs)) !== null;
      }

      function trimTemporaryNodes(body, tempAttrs) {
          tinymce.each(getTemporaryNodes(body, tempAttrs), function (elm) {
              if (elm.getAttribute('data-mce-bogus') === 'all') {
                  if (elm && elm.parentNode) {
                      elm.parentNode.removeChild(elm);
                  }
              } else {
                  tinymce.each(tempAttrs, function (attr) {
                      if (elm.hasAttribute(attr)) {
                          elm.removeAttribute(attr);
                      }
                  });
              }
          });
      }

      function removeCommentsContainingZwsp(body) {
          var walker = createCommentWalker(body);
          var nextNode = walker.nextNode();
          while (nextNode !== null) {
              var comment = walker.currentNode;
              nextNode = walker.nextNode();
              if (typeof comment.nodeValue === 'string' && comment.nodeValue.indexOf(ZWSP) !== -1) {
                  if (comment && comment.parentNode) {
                      comment.parentNode.removeChild(comment);
                  }
              }
          }
      }

      function deepClone(body) {
          return body.cloneNode(true);
      }

      function trim(body, tempAttrs) {
          var trimmed = body;

          if (hasComments(body)) {
              trimmed = deepClone(body);
              removeCommentsContainingZwsp(trimmed);
              if (hasTemporaryNodes(trimmed, tempAttrs)) {
                  trimTemporaryNodes(trimmed, tempAttrs);
              }
          } else if (hasTemporaryNodes(body, tempAttrs)) {
              trimmed = deepClone(body);
              trimTemporaryNodes(trimmed, tempAttrs);
          }

          return trimmed;
      }


      /**
       * Constucts a new DOM serializer class.
       *
       * @constructor
       * @method Serializer
       * @param {Object} settings Serializer settings object.
       * @param {tinymce.dom.DOMUtils} dom DOMUtils instance reference.
       * @param {tinymce.html.Schema} schema Optional schema reference.
       */
      tinymce.dom.TrimBody = {
          trim: trim,
          hasComments: hasComments,
          hasTemporaryNodes: hasTemporaryNodes,
          trimTemporaryNodes: trimTemporaryNodes,
          removeCommentsContainingZwsp: removeCommentsContainingZwsp
      };
  })(tinymce);

  /**
   * ExtendingChar.js
   *
   * Released under LGPL License.
   * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
   *
   * License: http://www.tinymce.com/license - Inactive
   * Licence: GNU/LGPL 2.1 or later - http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
   * Contributing: http://www.tinymce.com/contributing - Inactive
   */

  /**
   * This class contains logic for detecting extending characters.
   *
   * @private
   * @class tinymce.text.ExtendingChar
   * @example
   * var isExtending = ExtendingChar.isExtendingChar('a');
   */
  (function (tinymce) {
    // Generated from: http://www.unicode.org/Public/UNIDATA/DerivedCoreProperties.txt
    // Only includes the characters in that fit into UCS-2 16 bit
    var extendingChars = new RegExp(
      "[\u0300-\u036F\u0483-\u0487\u0488-\u0489\u0591-\u05BD\u05BF\u05C1-\u05C2\u05C4-\u05C5\u05C7\u0610-\u061A" +
      "\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7-\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0" +
      "\u07EB-\u07F3\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08E3-\u0902\u093A\u093C" +
      "\u0941-\u0948\u094D\u0951-\u0957\u0962-\u0963\u0981\u09BC\u09BE\u09C1-\u09C4\u09CD\u09D7\u09E2-\u09E3" +
      "\u0A01-\u0A02\u0A3C\u0A41-\u0A42\u0A47-\u0A48\u0A4B-\u0A4D\u0A51\u0A70-\u0A71\u0A75\u0A81-\u0A82\u0ABC" +
      "\u0AC1-\u0AC5\u0AC7-\u0AC8\u0ACD\u0AE2-\u0AE3\u0B01\u0B3C\u0B3E\u0B3F\u0B41-\u0B44\u0B4D\u0B56\u0B57" +
      "\u0B62-\u0B63\u0B82\u0BBE\u0BC0\u0BCD\u0BD7\u0C00\u0C3E-\u0C40\u0C46-\u0C48\u0C4A-\u0C4D\u0C55-\u0C56" +
      "\u0C62-\u0C63\u0C81\u0CBC\u0CBF\u0CC2\u0CC6\u0CCC-\u0CCD\u0CD5-\u0CD6\u0CE2-\u0CE3\u0D01\u0D3E\u0D41-\u0D44" +
      "\u0D4D\u0D57\u0D62-\u0D63\u0DCA\u0DCF\u0DD2-\u0DD4\u0DD6\u0DDF\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EB9" +
      "\u0EBB-\u0EBC\u0EC8-\u0ECD\u0F18-\u0F19\u0F35\u0F37\u0F39\u0F71-\u0F7E\u0F80-\u0F84\u0F86-\u0F87\u0F8D-\u0F97" +
      "\u0F99-\u0FBC\u0FC6\u102D-\u1030\u1032-\u1037\u1039-\u103A\u103D-\u103E\u1058-\u1059\u105E-\u1060\u1071-\u1074" +
      "\u1082\u1085-\u1086\u108D\u109D\u135D-\u135F\u1712-\u1714\u1732-\u1734\u1752-\u1753\u1772-\u1773\u17B4-\u17B5" +
      "\u17B7-\u17BD\u17C6\u17C9-\u17D3\u17DD\u180B-\u180D\u18A9\u1920-\u1922\u1927-\u1928\u1932\u1939-\u193B\u1A17-\u1A18" +
      "\u1A1B\u1A56\u1A58-\u1A5E\u1A60\u1A62\u1A65-\u1A6C\u1A73-\u1A7C\u1A7F\u1AB0-\u1ABD\u1ABE\u1B00-\u1B03\u1B34" +
      "\u1B36-\u1B3A\u1B3C\u1B42\u1B6B-\u1B73\u1B80-\u1B81\u1BA2-\u1BA5\u1BA8-\u1BA9\u1BAB-\u1BAD\u1BE6\u1BE8-\u1BE9" +
      "\u1BED\u1BEF-\u1BF1\u1C2C-\u1C33\u1C36-\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE0\u1CE2-\u1CE8\u1CED\u1CF4\u1CF8-\u1CF9" +
      "\u1DC0-\u1DF5\u1DFC-\u1DFF\u200C-\u200D\u20D0-\u20DC\u20DD-\u20E0\u20E1\u20E2-\u20E4\u20E5-\u20F0\u2CEF-\u2CF1" +
      "\u2D7F\u2DE0-\u2DFF\u302A-\u302D\u302E-\u302F\u3099-\u309A\uA66F\uA670-\uA672\uA674-\uA67D\uA69E-\uA69F\uA6F0-\uA6F1" +
      "\uA802\uA806\uA80B\uA825-\uA826\uA8C4\uA8E0-\uA8F1\uA926-\uA92D\uA947-\uA951\uA980-\uA982\uA9B3\uA9B6-\uA9B9\uA9BC" +
      "\uA9E5\uAA29-\uAA2E\uAA31-\uAA32\uAA35-\uAA36\uAA43\uAA4C\uAA7C\uAAB0\uAAB2-\uAAB4\uAAB7-\uAAB8\uAABE-\uAABF\uAAC1" +
      "\uAAEC-\uAAED\uAAF6\uABE5\uABE8\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFF9E-\uFF9F]"
    );

    function isExtendingChar(ch) {
      return typeof ch == "string" && ch.charCodeAt(0) >= 768 && extendingChars.test(ch);
    }

    tinymce.text.ExtendingChar = {
      isExtendingChar: isExtendingChar
    };
  })(tinymce);

  /**
   * Zwsp.js
   *
   * Released under LGPL License.
   * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
   *
   * License: http://www.tinymce.com/license - Inactive
   * Licence: GNU/LGPL 2.1 or later - http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
   * Contributing: http://www.tinymce.com/contributing - Inactive
   */

  /**
   * Utility functions for working with zero width space
   * characters used as character containers etc.
   *
   * @private
   * @class tinymce.text.Zwsp
   * @example
   * var isZwsp = Zwsp.isZwsp('\uFEFF');
   * var abc = Zwsp.trim('a\uFEFFc');
   */
  (function (tinymce) {
    // This is technically not a ZWSP but a ZWNBSP or a BYTE ORDER MARK it used to be a ZWSP
    var ZWSP = '\uFEFF';

    var isZwsp = function (chr) {
      return chr === ZWSP;
    };

    var trim = function (text) {
      return text.replace(new RegExp(ZWSP, 'g'), '');
    };

    tinymce.text.Zwsp = {
      isZwsp: isZwsp,
      ZWSP: ZWSP,
      trim: trim
    };
  })(tinymce);

  /**
   * Plugin.js
   *
   * Released under LGPL License.
   * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
   *
   * License: http://www.tinymce.com/license - Inactive
   * Licence: GNU/LGPL 2.1 or later - http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
   * Contributing: http://www.tinymce.com/contributing - Inactive
   */

  /**
   * This class contains all core logic for the code plugin.
   *
   * @class tinymce.textpattern
   * @private
   */

  tinymce.TextPattern = function (editor) {
      var self = this, isPatternsDirty = true;
      
      self.patterns = [];
      
      // Returns a sorted patterns list, ordered descending by start length
      function getPatterns() {
          if (isPatternsDirty) {
              sortPatterns(self.patterns);
              isPatternsDirty = false;
          }

          return self.patterns;
      }

      // Finds a matching pattern to the specified text
      function findPattern(text) {
          var patterns = getPatterns();

          for (var i = 0; i < patterns.length; i++) {
              if (text.indexOf(patterns[i].start) !== 0) {
                  continue;
              }

              if (patterns[i].end && text.lastIndexOf(patterns[i].end) != text.length - patterns[i].end.length) {
                  continue;
              }

              return patterns[i];
          }
      }

      function sortPatterns(patterns) {
          return patterns.sort(function (a, b) {
              if (a.start.length > b.start.length) {
                  return -1;
              }

              if (a.start.length < b.start.length) {
                  return 1;
              }

              return 0;
          });
      }

      function isMatchingPattern(pattern, text, offset, delta) {
          var textEnd = text.substr(offset - pattern.end.length - delta, pattern.end.length);
          return textEnd === pattern.end;
      }

      function hasContent(offset, delta, pattern) {
          return (offset - delta - pattern.end.length - pattern.start.length) > 0;
      }

      // Finds the best matching end pattern
      function findEndPattern(text, offset, delta) {
          var pattern, i;
          var patterns = getPatterns();
          var sortedPatterns = sortPatterns(patterns);

          // Find best matching end
          for (i = 0; i < sortedPatterns.length; i++) {
              pattern = sortedPatterns[i];
              if (pattern.end !== undefined && isMatchingPattern(pattern, text, offset, delta) && hasContent(offset, delta, pattern)) {
                  return pattern;
              }
          }
      }

      function splitContainer(container, pattern, offset, startOffset, delta) {
          // remove leading space in pattern
          if (delta && /[\u00a0 ]/.test(pattern.start)) {
              startOffset += 1;
          }

          // Split text node and remove start/end from text node
          container = startOffset > 0 ? container.splitText(startOffset) : container;
          container.splitText(offset - startOffset - delta);

          if (pattern.remove !== false) {
              container.deleteData(0, pattern.start.length);
              container.deleteData(container.data.length - pattern.end.length, pattern.end.length);
          }

          return container;
      }

      // Handles inline formats like *abc* and **abc**
      function applyInlineFormat(space) {
          var selection, dom, rng, container, offset, startOffset, text, patternRng, pattern, delta, format;

          selection = editor.selection;
          dom = editor.dom;

          if (!selection.isCollapsed()) {
              return;
          }

          rng = selection.getRng(true);
          container = rng.startContainer;
          offset = rng.startOffset;
          text = container.data;
          delta = space === true ? 1 : 0;

          if (container.nodeType != 3) {
              return;
          }

          if (dom.getParent(container, 'PRE')) {
              return;
          }

          // Find best matching end
          pattern = findEndPattern(text, offset, delta);

          if (pattern === undefined) {
              return;
          }

          // Find start of matched pattern
          // TODO: Might need to improve this if there is nested formats
          startOffset = Math.max(0, offset - delta);

          startOffset = text.lastIndexOf(pattern.start, startOffset - pattern.end.length - 1);

          if (startOffset === -1) {
              return;
          }

          // Setup a range for the matching word
          patternRng = dom.createRng();
          patternRng.setStart(container, startOffset);
          patternRng.setEnd(container, offset - delta);
          pattern = findPattern(patternRng.toString());

          if (!pattern || !pattern.end) {
              return;
          }

          // If container match doesn't have anything between start/end then do nothing
          if (container.data.length <= pattern.start.length + pattern.end.length) {
              return;
          }

          if (!pattern.format) {
              return;
          }

          format = editor.formatter.get(pattern.format);

          if (format && format[0].inline) {
              container = splitContainer(container, pattern, offset, startOffset, delta);

              // add back removed space
              if (space) {
                  container.appendData(' ');
              }

              editor.formatter.apply(pattern.format, {}, container);

              return container;
          }
      }

      // Handles block formats like ##abc or 1. abc
      function applyBlockFormat(e) {
          var selection, dom, container, firstTextNode, node, format, textBlockElm, pattern, walker, rng, offset;

          selection = editor.selection;
          dom = editor.dom;

          if (!selection.isCollapsed()) {
              return;
          }

          var startNode = selection.getStart();

          // skip in pre
          if (startNode.nodeName === 'PRE') {
              return;
          }

          textBlockElm = dom.getParent(startNode, 'p,div');

          if (textBlockElm) {
              walker = new tinymce.dom.TreeWalker(textBlockElm, textBlockElm);
              
              while ((node = walker.next())) {
                  if (node.nodeType == 3) {
                      firstTextNode = node;
                      break;
                  }
              }

              if (firstTextNode) {
                  pattern = findPattern(firstTextNode.data);

                  if (!pattern) {
                      return;
                  }
                  
                  // cancel newline on enter if the format removes the original pattern
                  if (pattern.remove) {
                      e.preventDefault();
                  }

                  rng = selection.getRng(true);
                  container = rng.startContainer;
                  offset = rng.startOffset;

                  if (firstTextNode == container) {
                      offset = Math.max(0, offset - pattern.start.length);
                  }

                  if (tinymce.trim(firstTextNode.data).length == pattern.start.length) {
                      return;
                  }

                  if (pattern.format) {
                      format = editor.formatter.get(pattern.format);

                      if (format && format[0].block) {
                          firstTextNode.deleteData(0, pattern.start.length);
                          editor.formatter.apply(pattern.format, {}, firstTextNode);

                          rng.setStart(container, offset);
                          rng.collapse(true);
                          selection.setRng(rng);
                      }

                      return;
                  }

                  if (pattern.cmd) {
                      editor.undoManager.add();

                      var length = pattern.start.length,
                          data = firstTextNode.data;

                      // remove pattern entirely
                      if (pattern.remove) {
                          length = firstTextNode.data.length;
                      }

                      firstTextNode.deleteData(0, length);

                      var parent = firstTextNode.parentNode;

                      if (dom.isEmpty(parent) && dom.isBlock(parent)) {
                          parent.innerHTML = '<br data-mce-bogus="1">';

                          window.setTimeout(function () {
                              rng.setStart(parent, 0);
                              rng.collapse(true);
                              selection.setRng(rng);
                          }, 0);
                      }

                      // pass to command
                      editor.execCommand(pattern.cmd, false, data);

                      return;
                  }
              }
          }
      }

      function handleEnter(e) {
          var rng, wrappedTextNode;

          wrappedTextNode = applyInlineFormat();

          if (wrappedTextNode) {
              rng = editor.dom.createRng();
              rng.setStart(wrappedTextNode, wrappedTextNode.data.length);
              rng.setEnd(wrappedTextNode, wrappedTextNode.data.length);
              editor.selection.setRng(rng);
          }

          applyBlockFormat(e);
      }

      function handleSpace() {
          var wrappedTextNode, lastChar, lastCharNode, rng, dom;

          wrappedTextNode = applyInlineFormat(true);

          if (wrappedTextNode) {
              dom = editor.dom;
              lastChar = wrappedTextNode.data.slice(-1);

              // Move space after the newly formatted node
              if (/[\u00a0 ]/.test(lastChar)) {
                  wrappedTextNode.deleteData(wrappedTextNode.data.length - 1, 1);
                  lastCharNode = dom.doc.createTextNode(lastChar);

                  if (wrappedTextNode.nextSibling) {
                      dom.insertAfter(lastCharNode, wrappedTextNode.nextSibling);
                  } else {
                      wrappedTextNode.parentNode.appendChild(lastCharNode);
                  }

                  rng = dom.createRng();
                  rng.setStart(lastCharNode, 1);
                  rng.setEnd(lastCharNode, 1);
                  editor.selection.setRng(rng);
              }
          }
      }

      editor.onKeyDown.addToTop(function (ed, e) {
          if (e.keyCode == 13 && !tinymce.VK.modifierPressed(e)) {
              handleEnter(e);
          }
      });

      editor.onKeyUp.add(function (ed, e) {        
          if (e.keyCode == 32 && !tinymce.VK.modifierPressed(e)) {
              handleSpace();
          }
      });

      var addPattern = function (pattern) {
          self.patterns.push(pattern);
          isPatternsDirty = true;
      };

      return {
          getPatterns: getPatterns,
          addPattern: addPattern
      };
  };

  var internalMimeType = 'x-tinymce/html';
  var internalMark = '<!-- ' + internalMimeType + ' -->';

  var mark = function (html) {
    return internalMark + html;
  };

  var unmark = function (html) {
    return html.replace(internalMark, '');
  };

  var isMarked = function (html) {
    return html.indexOf(internalMark) !== -1;
  };

  var internalHtmlMime = function () {
    return internalMimeType;
  };

  const internalHtmlMimeType = internalHtmlMime();

  var clipboardData = {
      'text/html': '',
      'text/plain': ''
  };

  clipboardData[internalHtmlMimeType] = '';

  function hasData() {
      return !!clipboardData['text/html'] || !!clipboardData['text/plain'] || !!clipboardData[internalHtmlMimeType];
  }

  function getData$1(mimetype) {
      if (mimetype) {
          return clipboardData[mimetype] || '';
      }
      
      return clipboardData;
  }

  function setData(mimetype, content) {
      clipboardData[mimetype] = content;
  }

  function clearData() {
      clipboardData = {
          'text/html': '',
          'text/plain': ''
      };

      clipboardData[internalHtmlMimeType] = '';
  }

  var FakeClipboard = /*#__PURE__*/Object.freeze({
    __proto__: null,
    clearData: clearData,
    getData: getData$1,
    hasData: hasData,
    setData: setData
  });

  var noop = function () { };

  var hasWorkingClipboardApi = function (clipboardData) {
      // iOS supports the clipboardData API but it doesn't do anything for cut operations
      return tinymce.isIOS === false && clipboardData !== undefined && typeof clipboardData.setData === 'function';
  };

  var setHtml5Clipboard = function (clipboardData, html, text) {
      // set FakeClipboard data for all instances
      clearData();
      setData('text/html', html);
      setData('text/plain', text);
      setData(internalHtmlMime(), html);
      
      if (hasWorkingClipboardApi(clipboardData)) {
          try {
              clipboardData.clearData();
              clipboardData.setData('text/html', html);
              clipboardData.setData('text/plain', text);
              clipboardData.setData(internalHtmlMime(), html);

              return true;
          } catch (e) {
              return false;
          }
      } else {
          return false;
      }
  };

  var setClipboardData = function (evt, data, fallback, done) {
      if (setHtml5Clipboard(evt.clipboardData, data.html, data.text)) {
          evt.preventDefault();
          done();
      } else {
          fallback(data.html, done);
      }
  };

  var fallback = function (editor) {
      return function (html, done) {
          var markedHtml = mark(html);
          var outer = editor.dom.create('div', {
              contenteditable: "false",
              "data-mce-bogus": "all"
          });

          var inner = editor.dom.create('div', {
              contenteditable: "true",
              "data-mce-bogus": "all"
          }, markedHtml);

          editor.dom.setStyles(outer, {
              position: 'fixed',
              left: '-3000px',
              width: '1000px',
              overflow: 'hidden'
          });

          outer.appendChild(inner);
          editor.dom.add(editor.getBody(), outer);

          var range = editor.selection.getRng();
          inner.focus();

          var offscreenRange = editor.dom.createRng();
          offscreenRange.selectNodeContents(inner);
          editor.selection.setRng(offscreenRange);

          setTimeout(function () {
              outer.parentNode.removeChild(outer);
              editor.selection.setRng(range);
              done();
          }, 0);
      };
  };

  var getData = function (editor) {
      return {
          html: editor.selection.getContent({
              contextual: true
          }),
          text: editor.selection.getContent({
              format: 'text'
          })
      };
  };

  var isTableSelection = function (editor) {
      return !!editor.dom.getParent(editor.selection.getStart(), 'td.mceSelected,th.mceSelected', editor.getBody());
  };

  var hasSelectedContent = function (editor) {
      return !editor.selection.isCollapsed() || isTableSelection(editor);
  };

  var cut = function (editor, evt) {
      if (!evt.isDefaultPrevented() && hasSelectedContent(editor)) {
          setClipboardData(evt, getData(editor), fallback(editor), function () {
              var rng = editor.selection.getRng();
              // Chrome fails to execCommand from another execCommand with this message:
              // "We don't execute document.execCommand() this time, because it is called recursively.""
              setTimeout(function () { // detach
                  editor.selection.setRng(rng);
                  editor.execCommand('Delete');
              }, 0);
          });
      }
  };

  var copy = function (editor, evt) {
      if (!evt.isDefaultPrevented() && hasSelectedContent(editor)) {
          setClipboardData(evt, getData(editor), fallback(editor), noop);
      }
  };

  var register = function (editor) {
      editor.onCut.add(cut);
      editor.onCopy.add(copy);
  };

  var DomParser$2 = tinymce.html.DomParser, Schema$1 = tinymce.html.Schema, each$4 = tinymce.each, DOM = tinymce.DOM;

  var mceInternalUrlPrefix = 'data:text/mce-internal,';

  var resetStyleAttribute = function (content) {
    var div = DOM.create('div', {}, content);

    each$4(DOM.select('[style]', div), function (elm) {
        elm.setAttribute('style', elm.getAttribute('data-mce-style') || '');
    });

    return div.innerHTML;
  };

  var parseCssToRules = function (content) {
    var doc = document.implementation.createHTMLDocument(""),
      styleElement = document.createElement("style");

    styleElement.textContent = content;

    doc.body.appendChild(styleElement);

    return styleElement.sheet.cssRules;
  };

  function parseCSS(content) {
    var rules, classes = {};

    rules = parseCssToRules(content);

    function isValue(val) {
      return val !== "" && val !== "normal" && val !== "inherit" && val !== "none" && val !== "initial";
    }

    function isValidStyle(value) {
      return Object.values(value).length;
    }

    each$4(rules, function (r) {

      if (r.selectorText) {
        var styles = {};

        each$4(r.style, function (name) {
          var value = r.style.getPropertyValue(name);

          if (isValue(value)) {
            styles[name] = value;
          }

        });

        each$4(r.selectorText.split(','), function (selector) {
          selector = selector.trim();

          if (selector.indexOf('.mce') == 0 || selector.indexOf('.mce-') !== -1 || selector.indexOf('.mso-') !== -1) {
            return;
          }

          if (isValidStyle(styles)) {
            classes[selector] = {
              styles: styles,
              text: r.cssText
            };
          }
        });
      }
    });

    return classes;
  }

  function processStylesheets(content, embed_stylesheet) {
    var div = DOM.create('div', {}, content), styles = {};

    styles = tinymce.extend(styles, parseCSS(content));

    each$4(styles, function (value, selector) {
      // skip Word stuff
      if (selector.indexOf('Mso') !== -1) {
        return true;
      }

      // skip pseudo selectors
      if (selector.indexOf(':') !== -1) {
        return true;
      }

      // skip at-rules
      if (selector.indexOf('@') === 0) {
        return true;
      }
      
      {
        DOM.setStyles(DOM.select(selector, div), value.styles);
      }
    });

    content = div.innerHTML;

    return content;
  }

  function hasContentType(clipboardContent, mimeType) {
    return mimeType in clipboardContent && clipboardContent[mimeType].length > 0;
  }

  function hasHtmlOrText(content) {
    return (hasContentType(content, 'text/html') || hasContentType(content, 'text/plain')) && !content.Files;
  }

  /**
   * Gets various content types out of a datatransfer object.
   *
   * @param {DataTransfer} dataTransfer Event fired on paste.
   * @return {Object} Object with mime types and data for those mime types.
   */
  function getDataTransferItems(dataTransfer) {
    var items = {};

    if (dataTransfer) {
      // Use old WebKit/IE API
      if (dataTransfer.getData) {
        var legacyText = dataTransfer.getData('Text');
        if (legacyText && legacyText.length > 0) {
          if (legacyText.indexOf(mceInternalUrlPrefix) === -1) {
            items['text/plain'] = legacyText;
          }
        }
      }

      if (dataTransfer.types) {
        for (var i = 0; i < dataTransfer.types.length; i++) {
          var contentType = dataTransfer.types[i];
          try { // IE11 throws exception when contentType is Files (type is present but data cannot be retrieved via getData())
            items[contentType] = dataTransfer.getData(contentType);
          } catch (ex) {
            items[contentType] = ""; // useless in general, but for consistency across browsers
          }
        }
      }
    }

    return items;
  }

  function filter(content, items) {
    tinymce.each(items, function (v) {
      if (v.constructor == RegExp) {
        content = content.replace(v, '');
      } else {
        content = content.replace(v[0], v[1]);
      }
    });

    return content;
  }

  /**
   * Gets the innerText of the specified element. It will handle edge cases
   * and works better than textContent on Gecko.
   *
   * @param {String} html HTML string to get text from.
   * @return {String} String of text with line feeds.
   */
  function innerText(html) {
    var schema = new Schema$1(),
      domParser = new DomParser$2({}, schema),
      text = '';
    var shortEndedElements = schema.getShortEndedElements();
    var ignoreElements = tinymce.makeMap('script noscript style textarea video audio iframe object', ' ');
    var blockElements = schema.getBlockElements();

    function walk(node) {
      var name = node.name,
        currentNode = node;

      if (name === 'br') {
        text += '\n';
        return;
      }

      // img/input/hr
      if (shortEndedElements[name]) {
        text += ' ';
      }

      // Ingore script, video contents
      if (ignoreElements[name]) {
        text += ' ';
        return;
      }

      if (node.type == 3) {
        text += node.value;
      }

      // Walk all children
      if (!node.shortEnded) {
        if ((node = node.firstChild)) {
          do {
            walk(node);
          } while ((node = node.next));
        }
      }

      // Add \n or \n\n for blocks or P
      if (blockElements[name] && currentNode.next) {
        text += '\n';

        if (name == 'p') {
          text += '\n';
        }
      }
    }

    html = filter(html, [
      /<!\[[^\]]+\]>/g // Conditional comments
    ]);

    walk(domParser.parse(html));

    return text;
  }

  /**
   * Trims the specified HTML by removing all WebKit fragments, all elements wrapping the body trailing BR elements etc.
   *
   * @param {String} html Html string to trim contents on.
   * @return {String} Html contents that got trimmed.
   */
  function trimHtml(html) {
    function trimSpaces(all, s1, s2) {

      // WebKit &nbsp; meant to preserve multiple spaces but instead inserted around all inline tags,
      // including the spans with inline styles created on paste
      if (!s1 && !s2) {
        return ' ';
      }

      return '\u00a0';
    }

    function getInnerFragment(html) {
      var startFragment = '<!--StartFragment-->';
      var endFragment = '<!--EndFragment-->';
      var startPos = html.indexOf(startFragment);
      if (startPos !== -1) {
        var fragmentHtml = html.substr(startPos + startFragment.length);
        var endPos = fragmentHtml.indexOf(endFragment);
        if (endPos !== -1 && /^<\/(p|h[1-6]|li)>/i.test(fragmentHtml.substr(endPos + endFragment.length, 5))) {
          return fragmentHtml.substr(0, endPos);
        }
      }

      return html;
    }

    html = filter(getInnerFragment(html), [
      /^[\s\S]*<body[^>]*>\s*|\s*<\/body[^>]*>[\s\S]*$/gi, // Remove anything but the contents within the BODY element
      /<!--StartFragment-->|<!--EndFragment-->/g, // Inner fragments (tables from excel on mac)
      [/( ?)<span class="Apple-converted-space">(\u00a0|&nbsp;)<\/span>( ?)/g, trimSpaces],
      /<br class="Apple-interchange-newline">/g,
      /^<meta[^>]+>/g, // Chrome weirdness
      /<br>$/i, // Trailing BR elements,
      /&nbsp;$/ // trailing non-breaking space
    ]);

    return html;
  }

  var each$3 = tinymce.each;

  /**
   * Removes BR elements after block elements. IE9 has a nasty bug where it puts a BR element after each
   * block element when pasting from word. This removes those elements.
   *
   * This:
   *  <p>a</p><br><p>b</p>
   *
   * Becomes:
   *  <p>a</p><p>b</p>
   */
  function removeExplorerBrElementsAfterBlocks(editor, html, internal) {
      // Produce block regexp based on the block elements in schema
      var blockElements = [];

      each$3(editor.schema.getBlockElements(), function (block, blockName) {
          blockElements.push(blockName);
      });

      var explorerBlocksRegExp = new RegExp(
          '(?:<br>&nbsp;[\\s\\r\\n]+|<br>)*(<\\/?(' + blockElements.join('|') + ')[^>]*>)(?:<br>&nbsp;[\\s\\r\\n]+|<br>)*',
          'g'
      );

      // Remove BR:s from: <BLOCK>X</BLOCK><BR>
      html = filter(html, [
          [explorerBlocksRegExp, '$1']
      ]);

      // IE9 also adds an extra BR element for each soft-linefeed and it also adds a BR for each word wrap break
      html = filter(html, [
          [/<br><br>/g, '<BR><BR>'], // Replace multiple BR elements with uppercase BR to keep them intact
          [/<br>/g, ' '], // Replace single br elements with space since they are word wrap BR:s
          [/<BR><BR>/g, '<br>'] // Replace back the double brs but into a single BR
      ]);

      return html;
  }

  /**
   * WebKit has a nasty bug where the all computed styles gets added to style attributes when copy/pasting contents.
   * This fix solves that by simply removing the whole style attribute.
   *
   * The paste_webkit_styles option can be set to specify what to keep:
   *  paste_webkit_styles: "none" // Keep no styles
   *  paste_webkit_styles: "all", // Keep all of them
   *  paste_webkit_styles: "font-weight color" // Keep specific ones
   * 
   * @param {Object} self A reference to the plugin.
   * @param {String} content Content that needs to be processed.
   * @return {String} Processed contents.
   */
  function removeWebKitStyles(editor, content) {
      // Filter away styles that isn't matching the target node
      var webKitStyles = editor.settings.paste_webkit_styles;

      if (editor.settings.paste_remove_styles_if_webkit !== true || webKitStyles == "all") {
          return content;
      }

      if (webKitStyles) {
          webKitStyles = webKitStyles.split(/[, ]/);
      }

      // Keep specific styles that doesn't match the current node computed style
      if (webKitStyles) {
          var dom = editor.dom,
              node = editor.selection.getNode();

          content = content.replace(/(<[^>]+) style="([^"]*)"([^>]*>)/gi, function (all, before, value, after) {
              var inputStyles = dom.parseStyle(value, 'span'),
                  outputStyles = {};

              if (webKitStyles === "none") {
                  return before + after;
              }

              for (var i = 0; i < webKitStyles.length; i++) {
                  var inputValue = inputStyles[webKitStyles[i]],
                      currentValue = dom.getStyle(node, webKitStyles[i], true);

                  if (/color/.test(webKitStyles[i])) {
                      inputValue = dom.toHex(inputValue);
                      currentValue = dom.toHex(currentValue);
                  }

                  if (currentValue != inputValue) {
                      outputStyles[webKitStyles[i]] = inputValue;
                  }
              }

              outputStyles = dom.serializeStyle(outputStyles, 'span');
              if (outputStyles) {
                  return before + ' style="' + outputStyles + '"' + after;
              }

              return before + after;
          });
      } else {
          // Remove all external styles
          content = content.replace(/(<[^>]+) style="([^"]*)"([^>]*>)/gi, '$1$3');
      }

      // Keep internal styles
      content = content.replace(/(<[^>]+) data-mce-style="([^"]+)"([^>]*>)/gi, function (all, before, value, after) {
          return before + ' style="' + value + '"' + after;
      });

      return content;
  }
  var setup$3 = function (editor) {
      if (tinymce.isWebKit) {
          editor.onPastePreProcess.add(function (editor, o) {
              if (!o.isWordContent) {
                  o.content = removeWebKitStyles(editor, o.content);
              }
          });
      }
      
      if (tinymce.isIE || tinymce.isIE12) {
          editor.onPastePostProcess.add(function (editor, o) {
              if (!o.isWordContent) {
                  o.content = removeExplorerBrElementsAfterBlocks(editor, o.content);
              }
          });
      }
  };

  function convertToPixels(v) {
      // return pixel value
      if (v.indexOf('px') !== -1) {
          return v;
      }

      // retun integer 0 for 0 values, eg: 0cm, 0pt etc. 
      if (parseInt(v, 10) === 0) {
          return 0;
      }

      // convert pt to px
      if (v.indexOf('pt') !== -1) {
          // convert to integer
          v = parseInt(v, 10);
          // convert to pixel value (round up to 1)
          v = Math.ceil(v / 1.33333);
          // convert to absolute integer
          v = Math.abs(v);
      }

      if (v) {
          v += 'px';
      }

      return v;
  }

  var pixelStyles = [
      'width', 'height', 'min-width', 'max-width', 'min-height', 'max-height',
      'margin-top', 'margin-right', 'margin-bottom', 'margin-left',
      'padding-top', 'padding-right', 'padding-bottom', 'padding-left',
      'border-top-width', 'border-right-width', 'border-bottom-width', 'border-left-width'
  ];

  var styleProps = [
      'background', 'background-attachment', 'background-color', 'background-image', 'background-position', 'background-repeat',
      'border', 'border-bottom', 'border-bottom-color', 'border-bottom-style', 'border-bottom-width', 'border-color', 'border-left', 'border-left-color', 'border-left-style', 'border-left-width', 'border-right', 'border-right-color', 'border-right-style', 'border-right-width', 'border-style', 'border-top', 'border-top-color', 'border-top-style', 'border-top-width', 'border-width', 'outline', 'outline-color', 'outline-style', 'outline-width',
      'height', 'max-height', 'max-width', 'min-height', 'min-width', 'width',
      'font', 'font-family', 'font-size', 'font-style', 'font-variant', 'font-weight',
      'content', 'counter-increment', 'counter-reset', 'quotes',
      'list-style', 'list-style-image', 'list-style-position', 'list-style-type',
      'margin', 'margin-bottom', 'margin-left', 'margin-right', 'margin-top',
      'padding', 'padding-bottom', 'padding-left', 'padding-right', 'padding-top',
      'bottom', 'clear', 'clip', 'cursor', 'display', 'float', 'left', 'overflow', 'position', 'right', 'top', 'visibility', 'z-index',
      'orphans', 'page-break-after', 'page-break-before', 'page-break-inside', 'widows',
      'border-collapse', 'border-spacing', 'caption-side', 'empty-cells', 'table-layout',
      'color', 'direction', 'letter-spacing', 'line-height', 'text-align', 'text-decoration', 'text-indent', 'text-shadow', 'text-transform', 'unicode-bidi', 'vertical-align', 'white-space', 'word-spacing'
  ];

  var borderStyles = [
      'border', 'border-width', 'border-style', 'border-color',
      'border-top', 'border-right', 'border-bottom', 'border-left',
      'border-top-width', 'border-right-width', 'border-bottom-width', 'border-left-width',
      'border-top-color', 'border-right-color', 'border-bottom-color', 'border-left-color',
      'border-top-style', 'border-right-style', 'border-bottom-style', 'border-left-style'
  ];

  var backgroundStyles = {
      'background-image': 'none',
      'background-position': '0% 0%',
      'background-size': 'auto auto',
      'background-repeat': 'repeat',
      'background-origin': 'padding-box',
      'background-clip': 'border-box',
      'background-attachment': 'scroll',
      'background-color': 'transparent'
  };

  var fontStyles = [
      'font', 'font-family', 'font-size',
      'font-style', 'font-variant', 'font-weight'
  ];

  var namedColors = {
      '#F0F8FF': 'AliceBlue',
      '#FAEBD7': 'AntiqueWhite',
      '#7FFFD4': 'Aquamarine',
      '#F0FFFF': 'Azure',
      '#F5F5DC': 'Beige',
      '#FFE4C4': 'Bisque',
      '#000000': 'Black',
      '#FFEBCD': 'BlanchedAlmond',
      '#0000FF': 'Blue',
      '#8A2BE2': 'BlueViolet',
      '#A52A2A': 'Brown',
      '#DEB887': 'BurlyWood',
      '#5F9EA0': 'CadetBlue',
      '#7FFF00': 'Chartreuse',
      '#D2691E': 'Chocolate',
      '#FF7F50': 'Coral',
      '#6495ED': 'CornflowerBlue',
      '#FFF8DC': 'Cornsilk',
      '#DC143C': 'Crimson',
      '#00008B': 'DarkBlue',
      '#008B8B': 'DarkCyan',
      '#B8860B': 'DarkGoldenRod',
      '#A9A9A9': 'DarkGray',
      '#006400': 'DarkGreen',
      '#BDB76B': 'DarkKhaki',
      '#8B008B': 'DarkMagenta',
      '#556B2F': 'DarkOliveGreen',
      '#FF8C00': 'Darkorange',
      '#9932CC': 'DarkOrchid',
      '#8B0000': 'DarkRed',
      '#E9967A': 'DarkSalmon',
      '#8FBC8F': 'DarkSeaGreen',
      '#483D8B': 'DarkSlateBlue',
      '#2F4F4F': 'DarkSlateGrey',
      '#00CED1': 'DarkTurquoise',
      '#9400D3': 'DarkViolet',
      '#FF1493': 'DeepPink',
      '#00BFFF': 'DeepSkyBlue',
      '#696969': 'DimGrey',
      '#1E90FF': 'DodgerBlue',
      '#B22222': 'FireBrick',
      '#FFFAF0': 'FloralWhite',
      '#228B22': 'ForestGreen',
      '#DCDCDC': 'Gainsboro',
      '#F8F8FF': 'GhostWhite',
      '#FFD700': 'Gold',
      '#DAA520': 'GoldenRod',
      '#808080': 'Grey',
      '#008000': 'Green',
      '#ADFF2F': 'GreenYellow',
      '#F0FFF0': 'HoneyDew',
      '#FF69B4': 'HotPink',
      '#CD5C5C': 'IndianRed',
      '#4B0082': 'Indigo',
      '#FFFFF0': 'Ivory',
      '#F0E68C': 'Khaki',
      '#E6E6FA': 'Lavender',
      '#FFF0F5': 'LavenderBlush',
      '#7CFC00': 'LawnGreen',
      '#FFFACD': 'LemonChiffon',
      '#ADD8E6': 'LightBlue',
      '#F08080': 'LightCoral',
      '#E0FFFF': 'LightCyan',
      '#FAFAD2': 'LightGoldenRodYellow',
      '#D3D3D3': 'LightGrey',
      '#90EE90': 'LightGreen',
      '#FFB6C1': 'LightPink',
      '#FFA07A': 'LightSalmon',
      '#20B2AA': 'LightSeaGreen',
      '#87CEFA': 'LightSkyBlue',
      '#778899': 'LightSlateGrey',
      '#B0C4DE': 'LightSteelBlue',
      '#FFFFE0': 'LightYellow',
      '#00FF00': 'Lime',
      '#32CD32': 'LimeGreen',
      '#FAF0E6': 'Linen',
      '#FF00FF': 'Magenta',
      '#800000': 'Maroon',
      '#66CDAA': 'MediumAquaMarine',
      '#0000CD': 'MediumBlue',
      '#BA55D3': 'MediumOrchid',
      '#9370D8': 'MediumPurple',
      '#3CB371': 'MediumSeaGreen',
      '#7B68EE': 'MediumSlateBlue',
      '#00FA9A': 'MediumSpringGreen',
      '#48D1CC': 'MediumTurquoise',
      '#C71585': 'MediumVioletRed',
      '#191970': 'MidnightBlue',
      '#F5FFFA': 'MintCream',
      '#FFE4E1': 'MistyRose',
      '#FFE4B5': 'Moccasin',
      '#FFDEAD': 'NavajoWhite',
      '#000080': 'Navy',
      '#FDF5E6': 'OldLace',
      '#808000': 'Olive',
      '#6B8E23': 'OliveDrab',
      '#FFA500': 'Orange',
      '#FF4500': 'OrangeRed',
      '#DA70D6': 'Orchid',
      '#EEE8AA': 'PaleGoldenRod',
      '#98FB98': 'PaleGreen',
      '#AFEEEE': 'PaleTurquoise',
      '#D87093': 'PaleVioletRed',
      '#FFEFD5': 'PapayaWhip',
      '#FFDAB9': 'PeachPuff',
      '#CD853F': 'Peru',
      '#FFC0CB': 'Pink',
      '#DDA0DD': 'Plum',
      '#B0E0E6': 'PowderBlue',
      '#800080': 'Purple',
      '#FF0000': 'Red',
      '#BC8F8F': 'RosyBrown',
      '#4169E1': 'RoyalBlue',
      '#8B4513': 'SaddleBrown',
      '#FA8072': 'Salmon',
      '#F4A460': 'SandyBrown',
      '#2E8B57': 'SeaGreen',
      '#FFF5EE': 'SeaShell',
      '#A0522D': 'Sienna',
      '#C0C0C0': 'Silver',
      '#87CEEB': 'SkyBlue',
      '#6A5ACD': 'SlateBlue',
      '#708090': 'SlateGrey',
      '#FFFAFA': 'Snow',
      '#00FF7F': 'SpringGreen',
      '#4682B4': 'SteelBlue',
      '#D2B48C': 'Tan',
      '#008080': 'Teal',
      '#D8BFD8': 'Thistle',
      '#FF6347': 'Tomato',
      '#40E0D0': 'Turquoise',
      '#EE82EE': 'Violet',
      '#F5DEB3': 'Wheat',
      '#FFFFFF': 'White',
      '#F5F5F5': 'WhiteSmoke',
      '#FFFF00': 'Yellow',
      '#9ACD32': 'YellowGreen'
  };

  function namedColorToHex(value) {
      tinymce.each(namedColors, function (name, hex) {
          if (value.toLowerCase() === name.toLowerCase()) {
              value = hex;
              return false;
          }
      });

      return value.toLowerCase();
  }

  var each$2 = tinymce.each,
      Schema = tinymce.html.Schema,
      DomParser$1 = tinymce.html.DomParser,
      Serializer$1 = tinymce.html.Serializer,
      Node = tinymce.html.Node;

  // Open Office
  var ooRe = /(Version:[\d\.]+)\s*?((Start|End)(HTML|Fragment):[\d]+\s*?){4}/;

  function cleanCssContent(content) {
      var classes = [],
          rules = parseCssToRules(content);

      each$2(rules, function (r) {
          if (r.selectorText) {
              each$2(r.selectorText.split(','), function (v) {
                  v = v.replace(/^\s*|\s*$|^\s\./g, "");

                  // Is internal or it doesn't contain a class
                  if (/\.mso/i.test(v) || !/\.[\w\-]+$/.test(v)) {
                      return;
                  }

                  var text = r.cssText || "";

                  if (!text) {
                      return;
                  }

                  if (tinymce.inArray(classes, text) === -1) {
                      classes.push(text);
                  }
              });
          }
      });

      return classes.join("");
  }

  function isWordContent(editor, content) {
      // force word cleanup
      if (editor.settings.paste_force_cleanup) {
          return true;
      }

      // Open / Libre Office
      if (/(content=\"OpenOffice.org[^\"]+\")/i.test(content) || ooRe.test(content) || /@page {/.test(content)) {
          return true; // Mark the pasted contents as word specific content
      }

      // Word / Google Docs
      return (
          (/<font face="Times New Roman"|class="?Mso|style="[^"]*\bmso-|style='[^'']*\bmso-|w:WordDocument|Excel\.Sheet|Microsoft Excel\s\d+/i).test(content) ||
          (/class="OutlineElement/).test(content) ||
          (/id="?docs\-internal\-guid\-/.test(content))
      );
  }

  /**
   * Checks if the specified text starts with "1. " or "a. " etc.
   */
  function isNumericList(text) {
      var found = "",
          patterns;

      patterns = {
          'uppper-roman': /^[IVXLMCD]{1,2}\.[ \u00a0]/,
          'lower-roman': /^[ivxlmcd]{1,2}\.[ \u00a0]/,
          'upper-alpha': /^[A-Z]{1,2}[\.\)][ \u00a0]/,
          'lower-alpha': /^[a-z]{1,2}[\.\)][ \u00a0]/,
          'numeric': /^[0-9]+\.[ \u00a0]/,
          'japanese': /^[\u3007\u4e00\u4e8c\u4e09\u56db\u4e94\u516d\u4e03\u516b\u4e5d]+\.[ \u00a0]/,
          'chinese': /^[\u58f1\u5f10\u53c2\u56db\u4f0d\u516d\u4e03\u516b\u4e5d\u62fe]+\.[ \u00a0]/
      };

      /*patterns = [
          /^[IVXLMCD]{1,2}\.[ \u00a0]/, // Roman upper case
          /^[ivxlmcd]{1,2}\.[ \u00a0]/, // Roman lower case
          /^[a-z]{1,2}[\.\)][ \u00a0]/, // Alphabetical a-z
          /^[A-Z]{1,2}[\.\)][ \u00a0]/, // Alphabetical A-Z
          /^[0-9]+\.[ \u00a0]/, // Numeric lists
          /^[\u3007\u4e00\u4e8c\u4e09\u56db\u4e94\u516d\u4e03\u516b\u4e5d]+\.[ \u00a0]/, // Japanese
          /^[\u58f1\u5f10\u53c2\u56db\u4f0d\u516d\u4e03\u516b\u4e5d\u62fe]+\.[ \u00a0]/ // Chinese
      ];*/

      text = text.replace(/^[\u00a0 ]+/, '');

      each$2(patterns, function (pattern, type) {
          if (pattern.test(text)) {
              found = type;
              return false;
          }
      });

      return found;
  }

  function isBulletList(text) {
      return /^[\s\u00a0]*[\u2022\u00b7\u00a7\u25CF]\s*/.test(text);
  }

  function postProcess$1(editor, node) {
      var dom = editor.dom;

      // fix table borders
      var borderColors = ['border-top-color', 'border-right-color', 'border-bottom-color', 'border-left-color'];
      var positions = ['top', 'right', 'bottom', 'left'];

      each$2(dom.select('table[style], td[style], th[style]', node), function (n) {
          var styles = {};

          each$2(borderStyles, function (name) {
              // process each side, eg: border-left-width
              if (/-(top|right|bottom|left)-/.test(name)) {
                  // get style
                  var value = dom.getStyle(n, name);

                  // replace default values with black
                  if (name.indexOf('color') !== -1) {
                      if (value === 'currentcolor' || value === 'windowtext') {
                          each$2(borderColors, function (str) {
                              if (str === name) {
                                  return true;
                              }

                              var val = dom.getStyle(n, str);

                              if (/(currentcolor|windowtext)/.test(val)) {
                                  return true;
                              }

                              value = val;
                          });
                      }

                      value = namedColorToHex(value);
                  }

                  // Word uses "medium" as the default border-width
                  if (value === "medium") {
                      value = '1';
                  }

                  // if border-style is not set, use "solid"
                  if (name.indexOf('style') !== -1 && value === "none") {
                      value = "solid";
                  }

                  // convert to pixels
                  if (value && /^\d[a-z]?/.test(value)) {
                      value = convertToPixels(value);
                  }

                  styles[name] = value;
              }
          });

          // convert padding and margin to pixels
          each$2(positions, function (pos) {
              var padding = dom.getStyle(n, 'padding-' + pos);
              var margin = dom.getStyle(n, 'margin-' + pos);

              if (padding) {
                  styles['padding-' + pos] = convertToPixels(padding);
              }

              if (margin) {
                  styles['margin-' + pos] = convertToPixels(margin);
              }
          });

          each$2(styles, function (value, name) {

              // remove styles with no width value
              if (name.indexOf('-width') !== -1 && value === "") {
                  var prefix = name.replace(/-width/, '');

                  delete styles[prefix + '-style'];
                  delete styles[prefix + '-color'];
                  delete styles[name];
              }

              // convert named colors to hex
              if (name.indexOf('color') !== -1) {
                  styles[name] = namedColorToHex(value);
              }
          });

          each$2(backgroundStyles, function (def, name) {
              var value = dom.getStyle(n, name);

              if (value === def) {
                  value = "";
              }

              styles[name] = value;
          });

          // remove borders
          dom.setStyle(n, 'border', '');

          // remove background
          dom.setStyle(n, 'background', '');

          dom.setStyles(n, styles);
      });

      // update indent conversion
      each$2(dom.select('[data-mce-indent]', node), function (el) {
          if (el.nodeName === "p") {
              var value = dom.getAttrib(el, 'data-mce-indent');
              var style = editor.settings.indent_use_margin ? 'margin-left' : 'padding-left';

              dom.setStyle(el, style, value + 'px');
          }

          dom.setAttrib(el, 'data-mce-indent', '');
      });

      each$2(dom.select('[data-mce-word-list]', node), function (el) {
          el.removeAttribute('data-mce-word-list');
      });
  }

  function WordFilter(editor, content) {
      var settings = editor.settings;

      var keepStyles, removeStyles, validStyles = {}, styleProps$1 = styleProps;

      // Chrome...
      content = content.replace(/<meta([^>]+)>/, '');

      // remove styles
      content = content.replace(/<style([^>]*)>([\w\W]*?)<\/style>/gi, function (match, attr, value) {
          // process to remove mso junk
          value = cleanCssContent(value);
          return '<style' + attr + '>' + value + '</style>';
      });

      // Copy paste from Java like Open Office will produce this junk on FF
      content = content.replace(/Version:[\d.]+\nStartHTML:\d+\nEndHTML:\d+\nStartFragment:\d+\nEndFragment:\d+/gi, '');

      // Open Office
      //content = content.replace(ooRe, '', 'g');

      // Remove google docs internal guid markers
      content = content.replace(/<b[^>]+id="?docs-internal-[^>]*>/gi, '');
      content = content.replace(/<br class="?Apple-interchange-newline"?>/gi, '');

      // Remove basic Word junk
      content = filter(content, [
          // Word comments like conditional comments etc
          /<!--[\s\S]+?-->/gi,

          // Remove comments, scripts (e.g., msoShowComment), XML tag, VML content,
          // MS Office namespaced tags, and a few other tags
          /<(!|script[^>]*>.*?<\/script(?=[>\s])|\/?(\?xml(:\w+)?|meta|link|\w:\w+)(?=[\s\/>]))[^>]*>/gi,

          // Convert <s> into <strike> for line-though
          [/<(\/?)s>/gi, "<$1strike>"],

          // Replace nsbp entites to char since it's easier to handle
          [/&nbsp;/gi, "\u00a0"],

          // Convert <span style="mso-spacerun:yes">___</span> to string of alternating
          // breaking/non-breaking spaces of same length
          [/<span\s+style\s*=\s*"\s*mso-spacerun\s*:\s*yes\s*;?\s*"\s*>([\s\u00a0]*)<\/span>/gi,
              function (str, spaces) {
                  return (spaces.length > 0) ?
                      spaces.replace(/./, " ").slice(Math.floor(spaces.length / 2)).split("").join("\u00a0") : "";
              }
          ]
      ]);

      // replace <u> and <strike> with styles
      if (settings.inline_styles) {
          content = content.replace(/<(u|strike)>/gi, function (match, node) {
              var value = (node === "u") ? "underline" : "line-through";
              return '<span style="text-decoration:' + value + ';">';
          });

          content = content.replace(/<\/(u|strike)>/g, '</span>');
      }

      // remove double linebreaks (IE issue?)
      if (settings.forced_root_block) {
          content = content.replace(/<br><br>/gi, '');
      }

      // styles to keep
      keepStyles = settings.paste_retain_style_properties;
      // styles to remove
      removeStyles = settings.paste_remove_style_properties;

      // remove valid styles if we are removing all styles
      if (settings.paste_remove_styles !== false) {
          validStyles = {
              'font-weight': {},
              'font-style': {}
          };

          // split to array if string
          if (keepStyles && tinymce.is(keepStyles, 'string')) {
              var styleProps$1 = tinymce.explode(keepStyles);

              each$2(styleProps$1, function (style, i) {
                  if (style === "border") {
                      // add expanded border styles
                      styleProps$1 = styleProps$1.concat(borderStyles);
                      return true;
                  }
              });
          }
      } else {
          // split to array if string
          if (removeStyles && tinymce.is(removeStyles, 'string')) {
              var removeProps = tinymce.explode(removeStyles);

              each$2(removeProps, function (style, i) {
                  if (style === "border") {
                      // add expanded border styles
                      removeProps = removeProps.concat(borderStyles);
                      return true;
                  }
              });

              // remove from core styleProps array
              styleProps$1 = tinymce.grep(styleProps$1, function (prop) {
                  return tinymce.inArray(removeProps, prop) === -1;
              });
          }
      }

      each$2(styleProps$1, function (style) {
          // add all border styles if "border" is set
          if (style === "border") {
              each$2(borderStyles, function (name) {
                  validStyles[name] = {};
              });

              return true;
          }

          validStyles[style] = {};
      });

      /**
       * Converts fake bullet and numbered lists to real semantic OL/UL.
       *
       * @param {tinymce.html.Node} node Root node to convert children of.
       */
      function convertFakeListsToProperLists(node) {
          var currentListNode, prevListNode, lastLevel = 1;

          function getText(node) {
              var txt = '';

              if (node.type === 3) {
                  return node.value;
              }

              if ((node = node.firstChild)) {
                  do {
                      txt += getText(node);
                  } while ((node = node.next));
              }

              return txt;
          }

          function trimListStart(node, regExp) {
              if (node.type === 3) {
                  if (regExp.test(node.value)) {
                      node.value = node.value.replace(regExp, '');
                      return false;
                  }
              }

              if ((node = node.firstChild)) {
                  do {
                      if (!trimListStart(node, regExp)) {
                          return false;
                      }
                  } while ((node = node.next));
              }

              return true;
          }

          function removeIgnoredNodes(node) {
              if (node._listIgnore) {
                  node.remove();
                  return;
              }

              if ((node = node.firstChild)) {
                  do {
                      removeIgnoredNodes(node);
                  } while ((node = node.next));
              }
          }

          function convertParagraphToLi(paragraphNode, listName, start, type) {
              var level = paragraphNode._listLevel || lastLevel;

              // Handle list nesting
              if (level != lastLevel) {
                  if (level < lastLevel) {
                      // Move to parent list
                      if (currentListNode) {
                          currentListNode = currentListNode.parent.parent;
                      }
                  } else {
                      // Create new list
                      prevListNode = currentListNode;
                      currentListNode = null;
                  }
              }

              if (!currentListNode || currentListNode.name != listName) {
                  prevListNode = prevListNode || currentListNode;
                  currentListNode = new Node(listName, 1);

                  // add list style if any
                  if (type && /roman|alpha/.test(type)) {
                      var style = 'list-style-type:' + type;
                      currentListNode.attr({
                          'style': style,
                          'data-mce-style': style
                      });
                  }

                  if (start > 1) {
                      currentListNode.attr('start', '' + start);
                  }

                  paragraphNode.wrap(currentListNode);
              } else {
                  currentListNode.append(paragraphNode);
              }

              paragraphNode.name = 'li';

              // Append list to previous list if it exists
              if (level > lastLevel && prevListNode) {
                  prevListNode.lastChild.append(currentListNode);
              }

              lastLevel = level;

              // Remove start of list item "1. " or "&middot; " etc
              removeIgnoredNodes(paragraphNode);
              trimListStart(paragraphNode, /^\u00a0+/);

              if (currentListNode.name === "ol") {
                  trimListStart(paragraphNode, /^\s*([\u2022\u00b7\u00a7\u25CF]|\w+\.)/);
              }

              if (currentListNode.name === "ul") {
                  trimListStart(paragraphNode, /^\s*([\u2022\u00b7\u00a7\u25CF]|\w+\.)/);
              }

              trimListStart(paragraphNode, /^\u00a0+/);
          }

          // Build a list of all root level elements before we start
          // altering them in the loop below.
          var elements = [],
              child = node.firstChild;

          while (typeof child !== 'undefined' && child !== null) {
              elements.push(child);

              child = child.walk();

              if (child !== null) {
                  while (typeof child !== 'undefined' && child.parent !== node) {
                      child = child.walk();
                  }
              }
          }

          for (var i = 0; i < elements.length; i++) {
              node = elements[i];

              if (node.name == 'p' && node.firstChild) {
                  // Find first text node in paragraph
                  var nodeText = getText(node),
                      type;

                  // Detect unordered lists look for bullets
                  if (isBulletList(nodeText)) {
                      convertParagraphToLi(node, 'ul');
                      continue;
                  }

                  // Detect ordered lists 1., a. or ixv.
                  if (node.attr('data-mce-word-list')) {

                      // remove marker
                      node.attr('data-mce-word-list', null);

                      if ((type = isNumericList(nodeText))) {
                          // Parse OL start number
                          var matches = /([0-9]+)\./.exec(nodeText);
                          var start = 1;
                          if (matches) {
                              start = parseInt(matches[1], 10);
                          }

                          convertParagraphToLi(node, 'ol', start, type);
                          continue;
                      }
                  }

                  // Convert paragraphs marked as lists but doesn't look like anything
                  if (node._listLevel) {
                      convertParagraphToLi(node, 'ul', 1);
                      continue;
                  }

                  currentListNode = null;
              } else {
                  // If the root level element isn't a p tag which can be
                  // processed by convertParagraphToLi, it interrupts the
                  // lists, causing a new list to start instead of having
                  // elements from the next list inserted above this tag.
                  prevListNode = currentListNode;
                  currentListNode = null;
              }
          }
      }

      function filterStyles(node, styleValue) {
          var outputStyles = {},
              matches, styles = editor.dom.parseStyle(styleValue);

          each$2(styles, function (value, name) {
              // Convert various MS styles to W3C styles
              switch (name) {
                  case 'mso-list':
                      // Parse out list indent level for lists
                      matches = /\w+ \w+([0-9]+)/i.exec(styleValue);
                      if (matches) {
                          node._listLevel = parseInt(matches[1], 10);
                      }

                      // Remove these nodes <span style="mso-list:Ignore">o</span>
                      // Since the span gets removed we mark the text node and the span
                      if (/Ignore/i.test(value) && node.firstChild) {
                          node._listIgnore = true;
                          node.firstChild._listIgnore = true;
                      }

                      break;

                  case "horiz-align":
                      name = "text-align";
                      break;

                  case "vert-align":
                      name = "vertical-align";
                      break;

                  case "font-color":
                  case "mso-foreground":
                  case "color":
                      name = "color";

                      // remove "windowtext"
                      if (value == "windowtext") {
                          value = "";
                      }

                      break;

                  case "mso-background":
                  case "mso-highlight":
                      name = "background";
                      break;

                  case "font-weight":
                  case "font-style":
                      if (value == "normal") {
                          value = "";
                      }

                      break;

                  case "mso-element":
                      // Remove track changes code
                      if (/^(comment|comment-list)$/i.test(value)) {
                          node.remove();
                          return;
                      }

                      break;

                  case "margin-left":
                      if (node.name === "p" && settings.paste_convert_indents !== false) {
                          var indentValue = parseInt(editor.settings.indentation, 10);
                          value = parseInt(value, 10);

                          // convert to an indent value, must be greater than 0
                          value = Math.round(value / indentValue) * indentValue;

                          // store value and remove
                          if (value) {
                              node.attr('data-mce-indent', "" + value);
                              value = "";
                          }
                      }
                      break;
              }

              if (name.indexOf('mso-comment') === 0) {
                  node.remove();
                  return true;
              }

              // Never allow mso- prefixed names
              if (name.indexOf('mso-') === 0) {
                  return true;
              }

              // convert to pixel values
              if (value && tinymce.inArray(pixelStyles, name) !== -1) {
                  value = convertToPixels(value);
              }

              // Output only valid styles
              if (validStyles[name]) {
                  outputStyles[name] = value;
              }
          });

          // Convert bold style to "b" element
          if (/(bold|700|800|900)/i.test(outputStyles["font-weight"]) && editor.schema.isValidChild('strong', node.name)) {
              delete outputStyles["font-weight"];
              node.wrap(new Node("strong", 1));
          }

          // Convert italic style to "i" element
          if (/(italic)/i.test(outputStyles["font-style"]) && editor.schema.isValidChild('em', node.name)) {
              delete outputStyles["font-style"];
              node.wrap(new Node("em", 1));
          }

          // Serialize the styles and see if there is something left to keep
          outputStyles = editor.dom.serializeStyle(outputStyles, node.name);

          if (outputStyles) {
              return outputStyles;
          }

          return null;
      }

      var validElements = settings.paste_word_valid_elements || (
          '-strong/b,-em/i,-u,-span,-p,-ol[type|start|reversed],-ul,-li,-h1,-h2,-h3,-h4,-h5,-h6,' +
          '-p/div,-a[href|name],img[src|alt|width|height],sub,sup,strike,br,del,table[width],tr,' +
          'td[colspan|rowspan|width|valign],th[colspan|rowspan|width],thead,tfoot,tbody'
      );

      // keep style tags for process_stylesheets
      if (settings.paste_process_stylesheets == 'style') {
          validElements += ',style';
      }

      // Setup strict schema
      var schema = new Schema({
          valid_elements: validElements,
          valid_children: '-li[p]'
      });
      
      // allow for extended table attributes
      if (settings.schema !== 'html5' && schema.getElementRule('table')) {
          schema.addValidElements('table[width|border|cellpadding|cellspacing]');
      }

      // Add style/class attribute to all element rules since the user might have removed them from
      // paste_word_valid_elements config option and we need to check them for properties
      each$2(schema.elements, function (rule) {
          /*eslint dot-notation:0*/
          if (!rule.attributes["class"]) {
              rule.attributes["class"] = {};
              rule.attributesOrder.push("class");
          }

          if (!rule.attributes.style) {
              rule.attributes.style = {};
              rule.attributesOrder.push("style");
          }
      });

      // Parse HTML into DOM structure
      var domParser = new DomParser$1({}, schema);

      // Filter styles to remove "mso" specific styles and convert some of them
      domParser.addAttributeFilter('style', function (nodes) {
          var i = nodes.length,
              node, style;

          while (i--) {
              node = nodes[i];

              style = node.attr('style');

              // check for fake list (unordered)
              if (style && style.indexOf('mso-list') !== -1 && node.name !== 'li') {
                  node.attr('data-mce-word-list', 1);
              }

              node.attr('style', filterStyles(node, style));

              // Remove pointess spans
              if (node.name == 'span' && node.parent && !node.attributes.length) {
                  node.unwrap();
              }
          }
      });

      // Check the class attribute for comments or del items and remove those
      domParser.addAttributeFilter('class', function (nodes) {
          var i = nodes.length,
              node, className;

          while (i--) {
              node = nodes[i];

              className = node.attr('class');

              if (/^(MsoCommentReference|MsoCommentText|msoDel)$/i.test(className)) {
                  node.remove();
                  continue;
              }

              if (/^Mso[\w]+/i.test(className) || settings.paste_strip_class_attributes !== 0) {
                  node.attr('class', null);

                  if (className && className.indexOf('MsoList') !== -1 && node.name !== 'li') {
                      node.attr('data-mce-word-list', 1);
                  }

                  if (className && /\s*Mso(Foot|End)note\s*/.test(className)) {
                      var parent = node.parent;

                      // replace footnote span with <sup>
                      if (parent && parent.name === 'a') {
                          node.name = 'sup';
                      }

                      // remove additional span tags
                      if (node.name === 'span' && !node.attributes.length) {
                          node.unwrap();
                      }
                  }

                  // blockquote
                  if (className && /\s*MsoQuote\s*/.test(className)) {
                      node.name = 'blockquote';
                  }
              }
          }
      });

      // Remove all del elements since we don't want the track changes code in the editor
      domParser.addNodeFilter('del', function (nodes) {
          var i = nodes.length;

          while (i--) {
              nodes[i].remove();
          }
      });

      var footnotes = settings.paste_process_footnotes || 'convert';

      // Keep some of the links and anchors
      domParser.addNodeFilter('a', function (nodes) {
          var i = nodes.length,
              node, href, name;

          while (i--) {
              node = nodes[i];
              href = node.attr('href');
              name = node.attr('name');

              if (href && href.indexOf('#_msocom_') != -1) {
                  node.remove();
                  continue;
              }

              // convert URL
              if (href && !name) {
                  href = editor.convertURL(href);
              }

              if (href && href.indexOf('#') == 0) {
                  href = href.substr(href.indexOf('#'));
              }

              if (!href && !name) {
                  node.unwrap();
              } else {
                  // Remove all named anchors that aren't specific to TOC, Footnotes or Endnotes
                  if (name && !/^_?(?:toc|edn|ftn)/i.test(name)) {
                      node.unwrap();
                      continue;
                  }

                  // remove footnote
                  if (name && footnotes === "remove") {
                      node.remove();
                      continue;
                  }

                  // unlink footnote
                  if (name && footnotes === "unlink") {
                      node.unwrap();
                      continue;
                  }

                  // set href, remove name
                  node.attr({
                      href: href,
                      name: null
                  });

                  // set appropriate anchor
                  if (settings.schema === "html4") {
                      node.attr('name', name);
                  } else {
                      node.attr('id', name);
                  }
              }
          }
      });

      // Remove empty span tags without attributes or content
      domParser.addNodeFilter('span', function (nodes) {
          var i = nodes.length,
              node;

          while (i--) {
              node = nodes[i];

              if (node.parent && !node.attributes.length) {
                  node.unwrap();
              }
          }
      });

      // Remove single paragraphs in table cells
      if (settings.paste_remove_paragraph_in_table_cell) {
          domParser.addNodeFilter('td', function (nodes) {
              var i = nodes.length,
                  node;

              while (i--) {
                  node = nodes[i];

                  if (!node.firstChild) {
                      continue;
                  }

                  if (node.firstChild.name == "p" && node.firstChild === node.lastChild) {
                      node.firstChild.unwrap();
                  }
              }
          });
      }

      // Parse into DOM structure
      var rootNode = domParser.parse(content);

      // Process DOM
      if (settings.paste_convert_word_fake_lists !== false) {
          convertFakeListsToProperLists(rootNode);
      }

      // Serialize DOM back to HTML
      content = new Serializer$1({
          validate: settings.validate
      }, schema).serialize(rootNode);

      return content;
  }

  var each$1 = tinymce.each;
  var isIE$1 = tinymce.isIE || tinymce.isIE12;

  function preProcess(editor, o) {
      var h = o.content;

      // Process away some basic content
      h = h.replace(/^\s*(&nbsp;)+/g, ''); // nbsp entities at the start of contents
      h = h.replace(/(&nbsp;|<br[^>]*>)+\s*$/g, ''); // nbsp entities at the end of contents

      // skip plain text
      if (o.pasteAsPlainText) {
          return h;
      }

      if (o.wordContent) {
          h = WordFilter(editor, h);
      }

      // convert some tags if cleanup is off
      if (editor.settings.verify_html === false) {
          h = h.replace(/<b\b([^>]*)>/gi, '<strong$1>');
          h = h.replace(/<\/b>/gi, '</strong>');
      }

      o.content = h;
  }

  function postProcess(editor, o) {
      var dom = editor.dom, settings = editor.settings;

      // remove url conversion containers
      dom.remove(dom.select('div[data-mce-convert]', o.node), 1);

      // skip plain text
      if (o.pasteAsPlainText) {
          return;
      }

      // Remove Apple style spans
      each$1(dom.select('span.Apple-style-span', o.node), function (n) {
          dom.remove(n, 1);
      });

      // Remove all classes
      if (settings.paste_strip_class_attributes == 1) {
          // Remove class attribute
          each$1(dom.select('*[class]', o.node), function (el) {
              el.removeAttribute('class');
          });
      }

      // Convert width and height attributes to styles
      each$1(dom.select('table, td, th', o.node), function (n) {
          var width = dom.getAttrib(n, 'width');

          if (width) {
              dom.setStyle(n, 'width', width);
              dom.setAttrib(n, 'width', '');
          }

          var height = dom.getAttrib(n, 'height');

          if (height) {
              dom.setStyle(n, 'height', height);
              dom.setAttrib(n, 'height', '');
          }
      });

      // Remove all styles if none are retained
      if (settings.paste_remove_styles !== false && !settings.paste_retain_style_properties) {
          // Remove style attribute
          each$1(dom.select('*[style]', o.node), function (el) {            
              el.removeAttribute('style');
              el.removeAttribute('data-mce-style');
          });
      } else {
          // process style attributes
          processStyles(editor, o.node);
      }

      if (o.wordContent) {
          postProcess$1(editor, o.node);
      }

      function isValidDataUriImage(value) {
          return /^(file:|data:image)\//i.test(value);
      }

      // Process images - remove local
      each$1(dom.select('img', o.node), function (el) {
          var src = dom.getAttrib(el, 'src');

          // remove or processs for upload img element if blank, local file url or base64 encoded
          if (!src || isValidDataUriImage(src)) {
              // leave it as it is to be processed as a blob (but skip file:// images)
              if (settings.paste_upload_data_images) {
                  // add marker
                  dom.setAttrib(el, 'data-mce-upload-marker', '1');
              } else {
                  dom.remove(el);
              }
               
          } else {
              dom.setAttrib(el, 'src', editor.convertURL(src));
          }
      });

      // remove font and underline tags in IE
      if (isIE$1) {
          each$1(dom.select('a', o.node), function (el) {
              each$1(dom.select('font,u'), function (n) {
                  dom.remove(n, 1);
              });
          });
      }

      // remove tags
      if (settings.paste_remove_tags) {
          dom.remove(dom.select(settings.paste_remove_tags, o.node), 1);
      }

      // keep tags
      if (settings.paste_keep_tags) {
          var tags = settings.paste_keep_tags;

          dom.remove(dom.select('*:not(' + tags + ')', o.node), 1);
      }

      // remove all spans
      if (settings.paste_remove_spans) {
          dom.remove(dom.select('span', o.node), 1);
          // remove empty spans
      } else {
          dom.remove(dom.select('span:empty', o.node));

          each$1(dom.select('span', o.node), function (n) {
              // remove span without children eg: <span></span>
              if (!n.childNodes || n.childNodes.length === 0) {
                  dom.remove(n);
              }

              // remove span without attributes
              if (dom.getAttribs(n).length === 0) {
                  dom.remove(n, 1);
              }
          });
      }

      if (settings.paste_remove_empty_paragraphs !== false) {
          dom.remove(dom.select('p:empty', o.node));

          each$1(dom.select('p', o.node), function (n) {
              var h = n.innerHTML;

              // remove paragraph without children eg: <p></p>
              if (!n.childNodes || n.childNodes.length === 0 || /^(\s|&nbsp;|\u00a0)?$/.test(h)) {
                  dom.remove(n);
              }
          });
      }

      // replace paragraphs with linebreaks
      /*if (!settings.forced_root_block')) {
          var frag = dom.createFragment('<br /><br />');

          each(dom.select('p,div', o.node), function (n) {
              // if the linebreaks are 
              if (n.parentNode.lastChild !== n) {
                  dom.insertAfter(frag, n);
              }

              dom.remove(n, 1);
          });
      }*/
  }

  /**
   * Process style attributes
   * @param node Node to process
   */
  function processStyles(editor, node) {
      var dom = editor.dom, settings = editor.settings, styleProps$1 = styleProps;

      // Style to keep
      var keepStyles = settings.paste_retain_style_properties;

      // Style to remove
      var removeStyles = settings.paste_remove_style_properties;

      // split to array if string
      if (keepStyles && tinymce.is(keepStyles, 'string')) {
          var styleProps$1 = tinymce.explode(keepStyles);

          each$1(styleProps$1, function (style, i) {
              if (style == "border") {
                  // add expanded border styles
                  styleProps$1 = styleProps$1.concat(borderStyles);
                  return true;
              }

              if (style == "font") {
                  // add expanded border styles
                  styleProps$1 = styleProps$1.concat(fontStyles);
                  return true;
              }

              if (style == "padding" || style == "margin") {
                  each$1(['top', 'bottom', 'right', 'left'], function (side) {
                      styleProps$1.push(style + '-' + side);
                  });

                  return true;
              }
          });
      }

      // split to array if string
      if (removeStyles && tinymce.is(removeStyles, 'string')) {
          var removeProps = tinymce.explode(removeStyles);

          each$1(removeProps, function (style, i) {
              if (style === "border") {
                  // add expanded border styles
                  removeProps = removeProps.concat(borderStyles);
                  return true;
              }

              if (style == "font") {
                  // add expanded border styles
                  removeProps = removeProps.concat(fontStyles);
                  return true;
              }

              if (style == "padding" || style == "margin") {
                  each$1(['top', 'bottom', 'right', 'left'], function (side) {
                      removeProps.push(style + '-' + side);
                  });

                  return true;
              }
          });

          // remove from core styleProps array
          styleProps$1 = tinymce.grep(styleProps$1, function (prop) {
              return tinymce.inArray(removeProps, prop) === -1;
          });
      }

      // Retains some style properties
      each$1(dom.select('*[style]', node), function (n) {
          var ns = {},
              x = 0;

          // get styles on element
          var styles = dom.parseStyle(n.style.cssText);

          // check style against styleProps array
          each$1(styles, function (v, k) {
              if (tinymce.inArray(styleProps$1, k) != -1) {
                  ns[k] = v;
                  x++;
              }
          });

          // Remove all of the existing styles
          dom.setAttrib(n, 'style', '');

          // compress
          ns = dom.parseStyle(dom.serializeStyle(ns, n.nodeName));

          if (x > 0) {
              dom.setStyles(n, ns); // Add back the stored subset of styles
          } else {
              // Remove empty span tags that do not have class attributes
              if (n.nodeName == 'SPAN' && !n.className) {
                  dom.remove(n, true);
              }
          }

          // We need to compress the styles on WebKit since if you paste <img border="0" /> it will become <img border="0" style="... lots of junk ..." />
          // Removing the mce_style that contains the real value will force the Serializer engine to compress the styles
          if (tinymce.isWebKit) {
              n.removeAttribute('data-mce-style');
          }
      });

      // convert some attributes
      each$1(dom.select('*[align]', node), function (el) {
          var v = dom.getAttrib(el, 'align');

          if (v === "left" || v === "right" || v === "center") {
              if (/(IFRAME|IMG|OBJECT|VIDEO|AUDIO|EMBED)/i.test(el.nodeName)) {
                  if (v === "center") {
                      dom.setStyles(el, {
                          'margin': 'auto',
                          'display': 'block'
                      });
                  } else {
                      dom.setStyle(el, 'float', v);
                  }
              } else {
                  dom.setStyle(el, 'text-align', v);
              }
          }

          el.removeAttribute('align');
      });
  }

  const setup$2 = function (editor) {
      editor.onPastePreProcess.add(function (editor, o) {        
          preProcess(editor, o);
      });

      editor.onPastePostProcess.add(function (editor, o) {
          postProcess(editor, o);
      });
  };

  var Entities = tinymce.html.Entities;

  var isPlainText = function (text) {
      // so basically any tag that is not one of the "p, div, br", or is one of them, but is followed
      // by some additional characters qualifies the text as not a plain text (having some HTML tags)
      return !/<(?:(?!\/?(?:\w+))[^>]*|(?:\w+)\s+\w[^>]+)>/.test(text);
  };

  var toBRs = function (text) {
      return text.replace(/\r?\n/g, '<br>');
  };

  var openContainer = function (rootTag, rootAttrs) {
      var key, attrs = [];
      var tag = '<' + rootTag;

      if (typeof rootAttrs === 'object') {
          for (key in rootAttrs) {
              if (Object.prototype.hasOwnProperty.call(rootAttrs, key)) {
                  attrs.push(key + '="' + Entities.encodeAllRaw(rootAttrs[key]) + '"');
              }
          }

          if (attrs.length) {
              tag += ' ' + attrs.join(' ');
          }
      }
      return tag + '>';
  };

  var toBlockElements = function (text, rootTag, rootAttrs) {
      var pieces = text.split(/\r?\n/);
      var i = 0,
          len = pieces.length;
      var stack = [];
      var blocks = [];
      var tagOpen = openContainer(rootTag, rootAttrs);
      var tagClose = '</' + rootTag + '>';
      var isLast, newlineFollows, isSingleNewline;

      // if single-line text then nothing to do
      if (pieces.length === 1) {
          return text;
      }

      for (; i < len; i++) {
          isLast = i === len - 1;
          newlineFollows = !isLast && !pieces[i + 1];
          isSingleNewline = !pieces[i] && !stack.length;

          stack.push(pieces[i] ? pieces[i] : '&nbsp;');

          if (isLast || newlineFollows || isSingleNewline) {
              blocks.push(stack.join('<br>'));
              stack = [];
          }

          if (newlineFollows) {
              i++; // extra progress for extra newline
          }
      }

      return blocks.length === 1 ? blocks[0] : tagOpen + blocks.join(tagClose + tagOpen) + tagClose;
  };

  var convert = function (text, rootTag, rootAttrs) {    
      return rootTag ? toBlockElements(text, rootTag, rootAttrs) : toBRs(text);
  };

  var each = tinymce.each,
      VK = tinymce.VK,
      DomParser = tinymce.html.DomParser,
      Serializer = tinymce.html.Serializer,
      BlobCache = tinymce.file.BlobCache,
      Env = tinymce.util.Env;

  // IE flag to include Edge
  var isIE = tinymce.isIE || tinymce.isIE12;

  function getBase64FromUri(uri) {
      var idx;

      idx = uri.indexOf(',');
      if (idx !== -1) {
          return uri.substr(idx + 1);
      }

      return null;
  }

  function isValidDataUriImage(settings, imgElm) {
      return settings.images_dataimg_filter ? settings.images_dataimg_filter(imgElm) : true;
  }

  function pasteImage(editor, rng, reader, blob) {
      if (rng) {
          editor.selection.setRng(rng);
          rng = null;
      }

      var dataUri = reader.result;
      var base64 = getBase64FromUri(dataUri);

      var img = new Image();
      img.src = dataUri;

      // TODO: Move the bulk of the cache logic to EditorUpload
      if (isValidDataUriImage(editor.settings, img)) {
          var blobInfo, existingBlobInfo;

          existingBlobInfo = BlobCache.findFirst(function (cachedBlobInfo) {
              return cachedBlobInfo.base64() === base64;
          });

          if (!existingBlobInfo) {
              blobInfo = BlobCache.create('mceclip', blob, base64);
              BlobCache.add(blobInfo);
          } else {
              blobInfo = existingBlobInfo;
          }

          return '<img src="' + blobInfo.blobUri() + '" />';

      } else {
          return '<img src="' + dataUri + '" />';
      }
  }

  /**
   * Convert URL strings to elements
   * @param content HTML to process
   */
  function convertURLs(editor, content) {

      var ex = '([-!#$%&\'\*\+\\./0-9=?A-Z^_`a-z{|}~]+@[-!#$%&\'\*\+\\/0-9=?A-Z^_`a-z{|}~]+\.[-!#$%&\'*+\\./0-9=?A-Z^_`a-z{|}~]+)';
      var ux = '((?:news|telnet|nttp|file|http|ftp|https)://[-!#$%&\'\*\+\\/0-9=?A-Z^_`a-z{|}~;]+\.[-!#$%&@\'\*\+\\./0-9=?A-Z^_`a-z{|}~;]+)';

      // Match attribute patterns, e.g., href="url"
      var attribRe = '(?:[a-zA-Z0-9_-]+=["\'])';

      // Match shortcode/markdown brackets, e.g., {url}, [url], [text](url)
      var bracketRe = '(?:\}|\].?)';

      function createLink(url) {
          // create attribs and decode url to prevent double encoding in dom.createHTML
          var attribs = { 'href': editor.dom.decode(url) }, params = editor.settings.link || {};

          attribs = tinymce.extend(attribs, params.attributes || {});

          return editor.dom.createHTML('a', attribs, url);
      }

      function wrapContent(content) {
          if (content.indexOf('data-mce-convert="url"') === -1) {
              return '<div data-mce-convert="url">' + content + '</div>';
          }

          return content;
      }

      // existing link...
      var decoded = editor.dom.decode(content);

      // skip blobs and data uri
      if (/^<img src="(data|blob):[^>]+?>/.test(content)) {
          return content;
      }

      if (/^<a([^>]+)>([\s\S]+?)<\/a>$/.test(decoded)) {
          return content;
      }

      var urlProcessed = false;

      if (editor.settings.autolink_url !== false) {        
          if (new RegExp('^' + ux + '$').test(content)) {
              content = createLink(content);
              return content;
          }

          // Replace URLs with links if not already linked
          content = content.replace(new RegExp('(' + attribRe + '|' + bracketRe + ')?' + ux, 'gi'), function (match, extra, url) {
              if (extra) {
                  return match; // Skip if part of an attribute or shortcode
              }

              // Create a link for the detected URL
              return createLink(url);
          });

          urlProcessed = true;
      }

      if (editor.settings.autolink_email !== false) {
          if (new RegExp('^' + ex + '$').test(content)) {
              return '<a href="mailto:' + content + '">' + content + '</a>';
          }

          content = content.replace(new RegExp('(href="[^"]+?)?(' + ex + ')', 'g'), function (match, attrib, email) {            
              // Only process if the match is not already part of an href
              if (!attrib && email && !email.includes('//')) {
                  return '<a href="mailto:' + email + '">' + email + '</a>';
              }
              
              return match; // Return the original match if it's already part of an href or not a valid email
          });        
          
          urlProcessed = true;
      }

      if (urlProcessed) {
          // wrap content - this seems to be required to prevent repeats of link conversion
          content = wrapContent(content);
      }

      return content;
  }

  /**
   * Gets various content types out of the Clipboard API. It will also get the
   * plain text using older IE and WebKit API:s.
   *
   * @param {ClipboardEvent} clipboardEvent Event fired on paste.
   * @return {Object} Object with mime types and data for those mime types.
   */
  function getClipboardContent(editor, clipboardEvent) {
      if (hasData()) {
          content = getData$1();

          clearData();

          return content;
      }
      
      var content = getDataTransferItems(clipboardEvent.clipboardData || clipboardEvent.dataTransfer || editor.getDoc().dataTransfer);
      //var content = getDataTransferItems(clipboardEvent.clipboardData || editor.getDoc().dataTransfer);

      return content;
  }

  function isKeyboardPasteEvent(e) {
      return (VK.metaKeyPressed(e) && e.keyCode == 86) || (e.shiftKey && e.keyCode == 45);
  }

  /**
   * Inserts the specified contents at the caret position.
   */
  function insertData(editor, content, skip_undo) {
      // get validate setting
      var validate = editor.settings.validate;

      // reset validate setting
      editor.settings.validate = true;

      // insert content
      editor.execCommand('mceInsertContent', false, content);

      // reset validate
      editor.settings.validate = validate;
  }

  function pasteText(editor, text) {    
      // encode text and replace returns
      text = editor.dom.encode(text).replace(/\r\n/g, '\n');

      // convert newlines to block elements
      text = convert(text, editor.settings.forced_root_block, editor.settings.forced_root_block_attrs);

      pasteHtml(editor, text);
  }

  function sanitizePastedHTML(editor, html) {
      var parser = new DomParser({ allow_event_attributes: !!editor.settings.paste_allow_event_attributes }, editor.schema);

      // Strip elements
      parser.addNodeFilter('meta,svg,script,noscript', function (nodes) {
          var i = nodes.length;

          while (i--) {
              nodes[i].remove();
          }
      });

      // remove spans
      if (editor.settings.paste_remove_spans) {
          parser.addNodeFilter('span', function (nodes, name) {
              var i = nodes.length;

              while (i--) {
                  nodes[i].unwrap();
              }
          });
      }

      // remove attributes
      var remove_attribs = editor.settings.paste_remove_attributes;

      if (remove_attribs) {
          parser.addAttributeFilter(remove_attribs, function (nodes, name) {
              var i = nodes.length;

              while (i--) {
                  nodes[i].attr(name, null);
              }
          });
      }

      var fragment = parser.parse(html, { forced_root_block: false, isRootContent: true });

      return new Serializer({ validate: editor.settings.validate }, editor.schema).serialize(fragment);
  }

  function pasteHtml(editor, content, internal, pasteAsPlainText) {
      if (!content) {
          return false;
      }

      // create object to process
      var o = {
          content: content,
          internal: internal,
          pasteAsPlainText: pasteAsPlainText
      };

      // only process externally sourced content
      if (!internal && editor.settings.paste_enable_default_filters !== false) {
          // set wordContent flag
          o.wordContent = isWordContent(editor, o.content);

          // process stylesheets into content
          if (editor.settings.paste_process_stylesheets) {
              o.content = processStylesheets(o.content);
          }

          // trim
          o.content = trimHtml(o.content);

          // Execute pre process handlers
          editor.onPastePreProcess.dispatch(editor, o);

          // sanitize content
          o.content = sanitizePastedHTML(editor, o.content);

          // convert urls in content
          if (editor.settings.paste_convert_urls !== false) {
              o.content = convertURLs(editor, o.content);
          }

          // Create DOM structure
          o.node = editor.dom.create('div', { style: 'display:none' }, o.content);

          // Execute post process handlers
          editor.onPastePostProcess.dispatch(editor, o);

          // get content from node
          o.content = o.node.innerHTML;

          // remove empty paragraphs
          if (editor.settings.paste_remove_empty_paragraphs !== false) {
              o.content = o.content.replace(/<p([^>]+)>(&nbsp;|\u00a0)?<\/p>/g, '');
          }

          // clean up extra whitespace
          if (editor.settings.paste_remove_whitespace) {
              o.content = o.content.replace(/(&nbsp;|\u00a0|\s| ){2,}/g, ' ');
          }

          // process regular expression
          if (editor.settings.paste_filter) {
              var re, rules = editor.settings.paste_filter.split(';');

              each(rules, function (s) {
                  // if it is already in Regular Expression format...
                  if (/^\/.*\/(g|i|m)*$/.test(s)) {
                      re = (new Function('return ' + s))();
                      // ...else create expression
                  } else {
                      re = new RegExp(s);
                  }

                  o.content = o.content.replace(re, "");
              });
          }
      }

      editor.onPasteBeforeInsert.dispatch(editor, o);

      if (o.terminate) {
          return;
      }

      insertData(editor, o.content);
  }

  // This function executes the process handlers and inserts the contents
  function insertClipboardContent(editor, clipboardContent, internal, pasteAsPlainText) {
      var content, isPlainTextHtml;

      editor.onGetClipboardContent.dispatch(editor, clipboardContent, pasteAsPlainText);

      // get html content
      content = clipboardContent['x-tinymce/html'] || clipboardContent['text/html'];

      // mark as internal
      internal = internal ? internal : isMarked(content);

      // unmark content
      content = unmark(content);

      // pasting content into a pre element so encode html first, then insert using setContent
      if (isPasteInPre(editor)) {
          var text = clipboardContent['text/plain'];

          // encode
          text = editor.dom.encode(text);

          // prefer plain text, otherwise use encoded html
          if (content && !text) {
              content = trimHtml(content);
              text = editor.dom.encode(content);
          }

          editor.selection.setContent(text, { no_events: true });

          return true;
      }

      /*if (!internal && isPlainTextPaste(clipboardContent)) {
          // set pasteAsPlainText state
          self.pasteAsPlainText = clipboardContent['text/plain'] == content;
      }*/

      var isPlainTextHtml = (internal === false && (isPlainText(content)));

      // If we got nothing from clipboard API and pastebin or the content is a plain text (with only
      // some BRs, Ps or DIVs as newlines) then we fallback to plain/text
      if (!content.length || isPlainTextHtml) {
          pasteAsPlainText = true;
      }

      // paste text
      if (pasteAsPlainText) {
          // Use plain text contents from Clipboard API unless the HTML contains paragraphs then
          // we should convert the HTML to plain text since works better when pasting HTML/Word contents as plain text
          if (hasContentType(clipboardContent, 'text/plain') && isPlainTextHtml) {
              content = clipboardContent['text/plain'];
          } else {
              content = innerText(content);
          }

          pasteText(editor, content);

          return true;
      }

      // paste HTML
      pasteHtml(editor, content, internal, pasteAsPlainText);
  }

  /**
   * Chrome on Android doesn't support proper clipboard access so we have no choice but to allow the browser default behavior.
   *
   * @param {Event} e Paste event object to check if it contains any data.
   * @return {Boolean} true/false if the clipboard is empty or not.
   */
  function isBrokenAndroidClipboardEvent(e) {
      var clipboardData = e.clipboardData;
      return navigator.userAgent.indexOf('Android') !== -1 && clipboardData && clipboardData.items && clipboardData.items.length === 0;
  }

  function isHtmlPaste(content) {
      if (!hasContentType(content, "text/html")) {
          return false;
      }

      return true;
  }

  function pasteImageData(editor, e, lastRng) {
      var dataTransfer = e.clipboardData || e.dataTransfer;

      function processItems(items) {
          var i, item, hadImage = false;

          if (items) {
              for (i = 0; i < items.length; i++) {
                  item = items[i];

                  if (/^image\/(jpeg|png|gif|bmp)$/.test(item.type)) {
                      hadImage = true;
                      e.preventDefault();

                      if (editor.settings.paste_data_images !== false) {
                          var blob = item.getAsFile ? item.getAsFile() : item;

                          var reader = new FileReader();
                          // eslint-disable-next-line no-loop-func
                          reader.onload = function () {
                              var html = pasteImage(editor, lastRng, reader, blob);
                              pasteHtml(editor, html);
                          };

                          reader.readAsDataURL(blob);
                      } else {
                          pasteHtml(editor, '<img src="' + Env.transparentSrc + '" data-mce-upload-marker="1" />', true);
                      }
                  }
              }
          }

          return hadImage;
      }

      if (!dataTransfer) {
          return true;
      }

      processItems(dataTransfer.items) || processItems(dataTransfer.files);

      return true;
  }

  function isPasteInPre(editor) {
      var node = editor.selection.getNode();
      return editor.settings.html_paste_in_pre !== false && node && node.nodeName === 'PRE';
  }

  function isPlainTextFileUrl$1(content) {
      var plainTextContent = content['text/plain'];
      return plainTextContent ? plainTextContent.indexOf('file://') === 0 : false;
  }

  var setup$1 = function (editor, pasteBin) {
      var keyboardPastePlainTextState, keyboardPasteTimeStamp = 0;

      // Add command for external usage
      editor.addCommand('mceInsertClipboardContent', function (u, data) {        
          if (data.text) {
              pasteText(editor, data.text);
          }

          if (data.content) {
              pasteHtml(editor, data.content, data.internal || false);
          }
      });

      var getLastRng = function () {
          return pasteBin.getLastRng() || editor.selection.getRng();
      };

      function getContentAndInsert(e) {
          // Getting content from the Clipboard can take some time
          var clipboardTimer = new Date().getTime();
          var clipboardContent = getClipboardContent(editor, e);
          var clipboardDelay = new Date().getTime() - clipboardTimer;

          function isKeyBoardPaste() {
              if (e.type == 'drop') {
                  return false;
              }

              return (new Date().getTime() - keyboardPasteTimeStamp - clipboardDelay) < 1000;
          }

          var internal = hasContentType(clipboardContent, internalHtmlMime());

          var pasteAsPlainText = keyboardPastePlainTextState;
          keyboardPastePlainTextState = false;

          if (e.isDefaultPrevented() || isBrokenAndroidClipboardEvent(e)) {
              pasteBin.remove();
              return;
          }

          // Not a keyboard paste prevent default paste and try to grab the clipboard contents using different APIs
          if (!isKeyBoardPaste()) {
              e.preventDefault();
          }

          // Try IE only method if paste isn't a keyboard paste
          if (isIE && (!isKeyBoardPaste() || e.ieFake) && !hasContentType(clipboardContent, 'text/html')) {
              pasteBin.create();

              editor.dom.bind(editor.dom.get('mcepastebin'), 'paste', function (e) {
                  e.stopPropagation();
              });

              editor.getDoc().execCommand('Paste', false, null);
              clipboardContent["text/html"] = pasteBin.getHtml();
          }

          if (isPlainTextFileUrl$1(clipboardContent)) {
              pasteBin.remove();
              return;
          }

          if (!hasHtmlOrText(clipboardContent) && pasteImageData(editor, e, getLastRng())) {
              pasteBin.remove();
              return;
          }

          // Grab HTML from paste bin as a fallback
          if (!isHtmlPaste(clipboardContent)) {
              var content = pasteBin.getHtml();

              // no content....?
              if (pasteBin.isDefaultContent(content)) {
                  pasteAsPlainText = true;
              } else {
                  clipboardContent['text/html'] = content;
              }
          }

          // If clipboard API has HTML then use that directly
          if (isHtmlPaste(clipboardContent)) {
              e.preventDefault();

              // if clipboard lacks internal mime type, inspect html for internal markings
              if (!internal) {
                  internal = isMarked(clipboardContent['text/html']);
              }

              insertClipboardContent(editor, clipboardContent, internal, pasteAsPlainText);

              pasteBin.remove();

          } else if (hasContentType(clipboardContent, 'text/plain') && hasContentType(clipboardContent, 'text/uri-list')) {
              /*
              Safari adds the uri-list attribute to links copied within it.
              When pasting something with the url-list within safari using the default functionality it will convert it from www.example.com to <a href="www.example.com">www.example.com</a> when pasting into the pasteBin-div.
              This causes issues. To solve this we bypass the default paste functionality for this situation.
               */
              e.preventDefault();

              clipboardContent['text/html'] = clipboardContent['text/plain'];

              insertClipboardContent(editor, clipboardContent, internal, pasteAsPlainText);
          } else {
              setTimeout(function () {
                  function block(e) {
                      e.preventDefault();
                  }

                  // Block mousedown and click to prevent selection change
                  editor.dom.bind(editor.getDoc(), 'mousedown', block);
                  editor.dom.bind(editor.getDoc(), 'keydown', block);

                  insertClipboardContent(editor, clipboardContent, internal, pasteAsPlainText);

                  // Block mousedown and click to prevent selection change
                  editor.dom.unbind(editor.getDoc(), 'mousedown', block);
                  editor.dom.unbind(editor.getDoc(), 'keydown', block);

                  pasteBin.remove();
              }, 0);
          }
      }

      // Grab contents on paste event
      editor.onPaste.add(function (editor, e) {
          if (e.isDefaultPrevented() || isBrokenAndroidClipboardEvent(e) && !hasData()) {
              pasteBin.remove();
              return false;
          }

          getContentAndInsert(e);

          e.preventDefault();
      });

      function removePasteBinOnKeyUp(e) {
          // Ctrl+V or Shift+Insert
          if (isKeyboardPasteEvent(e) && !e.isDefaultPrevented()) {
              pasteBin.remove();
          }
      }

      editor.onKeyDown.add(function (editor, e) {
          // Ctrl+V or Shift+Insert
          if (isKeyboardPasteEvent(e) && !e.isDefaultPrevented()) {
              keyboardPasteTimeStamp = new Date().getTime();

              // Prevent undoManager keydown handler from making an undo level with the pastebin in it
              e.stopImmediatePropagation();

              keyboardPastePlainTextState = e.shiftKey && e.keyCode == 86;

              // Remove pastebin if we get a keyup and no paste event
              // For example pasting a file in IE 11 will not produce a paste event
              editor.dom.bind(editor.getBody(), 'keyup', function handler(e) {
                  removePasteBinOnKeyUp(e);
                  editor.dom.unbind(editor.getBody(), 'keyup', handler);
              });

              editor.dom.bind(editor.getBody(), 'paste', function handler(e) {
                  removePasteBinOnKeyUp(e);
                  editor.dom.unbind(editor.getBody(), 'paste', handler);
              });
          }
      });

      editor.addCommand('mcePasteFakeClipboard', function (ui, e) {
          var content = getData$1();

          insertClipboardContent(editor, content, true, e.isPlainText === true);

          clearData();
      });
  };

  tinymce.clipboard.FakeClipboard = FakeClipboard;

  var RangeUtils = tinymce.dom.RangeUtils, Delay = tinymce.util.Delay;

  var getCaretRangeFromEvent = function (editor, e) {
      return RangeUtils.getCaretRangeFromPoint(e.clientX, e.clientY, editor.getDoc());
  };

  var isPlainTextFileUrl = function (content) {
      var plainTextContent = content['text/plain'];
      return plainTextContent ? plainTextContent.indexOf('file://') === 0 : false;
  };

  var setFocusedRange = function (editor, rng) {
      editor.focus();
      editor.selection.setRng(rng);
  };

  var draggingInternallyState = false;

  var setup = function (editor) {
      // Block all drag/drop events
      if (editor.settings.paste_block_drop) {
          editor.dom.bind(editor.getBody(), ['dragend', 'dragover', 'draggesture', 'dragdrop', 'drop', 'drag'], function (e) {
              e.preventDefault();
              e.stopPropagation();
          });
      }

      // Prevent users from dropping data images on Gecko
      if (editor.settings.paste_data_images === false) {
          editor.dom.bind(editor.getBody(), 'drop', function (e) {
              var dataTransfer = e.dataTransfer;

              if (dataTransfer && dataTransfer.files && dataTransfer.files.length > 0) {
                  e.preventDefault();
              }
          });
      }

      editor.dom.bind(editor.getBody(), 'drop', function (e) {
          var dropContent, rng;

          rng = getCaretRangeFromEvent(editor, e);

          if (e.isDefaultPrevented()) {
              return;
          }

          dropContent = getDataTransferItems(e.dataTransfer);
          var internal = hasContentType(dropContent, internalHtmlMime()) || draggingInternallyState;

          if ((!hasHtmlOrText(dropContent) || isPlainTextFileUrl(dropContent)) && pasteImageData(e, rng)) {
              return;
          }

          if (rng && editor.settings.paste_filter_drop !== false) {
              var content = dropContent[internalHtmlMime()] || dropContent['text/html'] || dropContent['text/plain'];

              if (content) {
                  e.preventDefault();

                  // FF 45 doesn't paint a caret when dragging in text in due to focus call by execCommand
                  Delay.setEditorTimeout(editor, function () {
                      editor.undoManager.add();

                      if (internal) {
                          editor.execCommand('Delete', false, null, { skip_undo: true });
                          editor.selection.getRng().deleteContents();
                      }

                      setFocusedRange(editor, rng);

                      content = trimHtml(content);

                      var data = {};

                      if (!dropContent['text/html']) {
                          data.text = content;
                      } else {
                          // reset styles, replacing style attribute with data-mce-style value or remove
                          content = resetStyleAttribute(content);

                          data.content = content;
                          data.internal = internal || draggingInternallyState;
                      }

                      editor.execCommand('mceInsertClipboardContent', false, data, { skip_undo: true });
                  });
              }
          }
      });

      editor.dom.bind(editor.getBody(), 'dragstart', function (e) {
          draggingInternallyState = true;

          if (e.altKey) {
              e.dataTransfer.effectAllowed = "copy";
              e.dataTransfer.dropEffect = "copy";
          }
      });

      editor.dom.bind(editor.getBody(), ['dragover', 'dragend'], function (e) {
          if (editor.settings.clipboard_paste_data_images && draggingInternallyState == false) {
              e.preventDefault();
              setFocusedRange(editor, getCaretRangeFromEvent(editor, e));
          }

          if (e.type == 'dragend') {
              draggingInternallyState = false;
          }
      });
  };

  var pasteBinDefaultContent = '%MCEPASTEBIN%';

  /**
   * Creates a paste bin element as close as possible to the current caret location and places the focus inside that element
   * so that when the real paste event occurs the contents gets inserted into this element
   * instead of the current editor selection element.
   */
  var create = function (editor, lastRng) {
    var dom = editor.dom, body = editor.getBody();
    var viewport = editor.dom.getViewPort(editor.getWin()), scrollTop = viewport.y, top = 20;
    var pasteBinElm;
    var scrollContainer;

    if (editor.inline) {
      scrollContainer = editor.selection.getScrollContainer();

      // Can't always rely on scrollTop returning a useful value.
      // It returns 0 if the browser doesn't support scrollTop for the element or is non-scrollable
      if (scrollContainer && scrollContainer.scrollTop > 0) {
        scrollTop = scrollContainer.scrollTop;
      }
    }
    
    /**
     * Returns the rect of the current caret if the caret is in an empty block before a
     * BR we insert a temporary invisible character that we get the rect this way we always get a proper rect.
     *
     * TODO: This might be useful in core.
     */
    function getCaretRect(rng) {
      var rects, textNode, node, container = rng.startContainer;

      rects = rng.getClientRects();
      if (rects.length) {
        return rects[0];
      }

      if (!rng.collapsed || container.nodeType != 1) {
        return;
      }

      node = container.childNodes[lastRng.startOffset];

      // Skip empty whitespace nodes
      while (node && node.nodeType == 3 && !node.data.length) {
        node = node.nextSibling;
      }

      if (!node) {
        return;
      }

      // Check if the location is |<br>
      // TODO: Might need to expand this to say |<table>
      if (node.tagName == 'BR') {
        textNode = dom.doc.createTextNode('\uFEFF');
        node.parentNode.insertBefore(textNode, node);

        rng = dom.createRng();
        rng.setStartBefore(textNode);
        rng.setEndAfter(textNode);

        rects = rng.getClientRects();
        dom.remove(textNode);
      }

      if (rects.length) {
        return rects[0];
      }
    }

    // Calculate top cordinate this is needed to avoid scrolling to top of document
    // We want the paste bin to be as close to the caret as possible to avoid scrolling
    if (lastRng.getClientRects) {
      var rect = getCaretRect(lastRng);

      if (rect) {
        // Client rects gets us closes to the actual
        // caret location in for example a wrapped paragraph block
        top = scrollTop + (rect.top - dom.getPos(body).y);
      } else {
        top = scrollTop;

        // Check if we can find a closer location by checking the range element
        var container = lastRng.startContainer;
        if (container) {
          if (container.nodeType == 3 && container.parentNode != body) {
            container = container.parentNode;
          }

          if (container.nodeType == 1) {
            top = dom.getPos(container, scrollContainer || body).y;
          }
        }
      }
    }

    // Create a pastebin
    pasteBinElm = editor.dom.add(editor.getBody(), 'div', {
      id: "mcepastebin",
      contentEditable: true,
      "data-mce-bogus": "all",
      style: 'position: absolute; top: ' + top + 'px; width: 10px; height: 10px; overflow: hidden; opacity: 0'
    }, pasteBinDefaultContent);

    // Move paste bin out of sight since the controlSelection rect gets displayed otherwise on IE and Gecko
    if (tinymce.isGecko) {
      dom.setStyle(pasteBinElm, 'left', dom.getStyle(body, 'direction', true) == 'rtl' ? 0xFFFF : -0xFFFF);
    }

    // Prevent focus events from bubbeling fixed FocusManager issues
    dom.bind(pasteBinElm, 'beforedeactivate focusin focusout', function (e) {
      e.stopPropagation();
    });

    pasteBinElm.focus();
    editor.selection.select(pasteBinElm, true);
  };

  /**
   * Removes the paste bin if it exists.
   */
  var remove = function (editor, lastRng) {
    if (getEl(editor)) {
      var pasteBinClone;

      // WebKit/Blink might clone the div so
      // lets make sure we remove all clones
      // TODO: Man o man is this ugly. WebKit is the new IE! Remove this if they ever fix it!
      while ((pasteBinClone = editor.dom.get('mcepastebin'))) {
        editor.dom.remove(pasteBinClone);
        editor.dom.unbind(pasteBinClone);
      }

      if (lastRng) {
        editor.selection.setRng(lastRng);
      }
    }

    lastRng = null;
  };

  var getEl = function (editor) {
    return editor.dom.get('mcepastebin');
  };

  /**
   * Returns the contents of the paste bin as a HTML string.
   *
   * @return {String} Get the contents of the paste bin.
   */
  var getHtml = function (editor) {
    var pasteBinElm, pasteBinClones, i, dirtyWrappers, cleanWrapper;

    // Since WebKit/Chrome might clone the paste bin when pasting
    // for example: <img style="float: right"> we need to check if any of them contains some useful html.
    // TODO: Man o man is this ugly. WebKit is the new IE! Remove this if they ever fix it!

    var copyAndRemove = function (toElm, fromElm) {
      toElm.appendChild(fromElm);
      editor.dom.remove(fromElm, true); // remove, but keep children
    };

    // find only top level elements (there might be more nested inside them as well, see TINY-1162)
    pasteBinClones = tinymce.grep(editor.getBody().childNodes, function (elm) {
      return elm.id === 'mcepastebin';
    });
    pasteBinElm = pasteBinClones.shift();

    // if clones were found, move their content into the first bin
    tinymce.each(pasteBinClones, function (pasteBinClone) {
      copyAndRemove(pasteBinElm, pasteBinClone);
    });

    // TINY-1162: when copying plain text (from notepad for example) WebKit clones
    // paste bin (with styles and attributes) and uses it as a default  wrapper for
    // the chunks of the content, here we cycle over the whole paste bin and replace
    // those wrappers with a basic div
    dirtyWrappers = editor.dom.select('div[id=mcepastebin]', pasteBinElm);
    for (i = dirtyWrappers.length - 1; i >= 0; i--) {
      cleanWrapper = editor.dom.create('div');
      pasteBinElm.insertBefore(cleanWrapper, dirtyWrappers[i]);
      copyAndRemove(cleanWrapper, dirtyWrappers[i]);
    }

    return pasteBinElm ? pasteBinElm.innerHTML : '';
  };

  var getLastRng = function (lastRng) {
    return lastRng;
  };

  var isDefaultPasteBinContent = function (content) {
    return content === pasteBinDefaultContent;
  };

  var PasteBin = function (editor) {
    var lastRng;

    return {
      create: function () {
        lastRng = editor.selection.getRng();
        return create(editor, lastRng);
      },
      remove: function () {
        return remove(editor, lastRng);
      },
      getEl: function () {
        return getEl(editor);
      },
      getHtml: function () {
        return getHtml(editor);
      },
      getLastRng: function () {
        return getLastRng(lastRng);
      },
      isDefaultContent: function (value) {
        return isDefaultPasteBinContent(value);
      }
    };
  };

  /**
   * @package   	JCE
   * @copyright 	Copyright (c) 2009-2022 Ryan Demmer. All rights reserved.
   * @copyright   Copyright (c) 1999-2017 Ephox Corp. All rights reserved
   * @license   	GNU/LGPL 2.1 or later - http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
   * JCE is free software. This version may have been modified pursuant
   * to the GNU General Public License, and as distributed it includes or
   * is derivative of works licensed under the GNU General Public License or
   * other free or open source software licenses.
   */


  var Dispatcher = tinymce.util.Dispatcher;

  tinymce.Clipboard = function (editor) {
      var pasteBin = new PasteBin(editor);

      editor.onGetClipboardContent = new Dispatcher(this);
      editor.onPastePreProcess = new Dispatcher(this);
      editor.onPastePostProcess = new Dispatcher(this);
      editor.onPasteBeforeInsert = new Dispatcher(this);

      setup$3(editor);

      setup$2(editor);
    
      // IMPORTANT: The following event hooks need to be setup later so that other things
      // can hook in and prevent the event so core paste doesn't handle them.
      editor.onPreInit.add(function () {
        register(editor);
        setup(editor);
        setup$1(editor, pasteBin);
      });
  };

  /**
   * CaretBookmark.js
   *
   * Released under LGPL License.
   * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
   *
   * License: http://www.tinymce.com/license - Inactive
   * Licence: GNU/LGPL 2.1 or later - http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
   * Contributing: http://www.tinymce.com/contributing - Inactive
   */

  /**
   * This module creates or resolves xpath like string representation of a CaretPositions.
   *
   * The format is a / separated list of chunks with:
   * <element|text()>[index|after|before]
   *
   * For example:
   *  p[0]/b[0]/text()[0],1 = <p><b>a|c</b></p>
   *  p[0]/img[0],before = <p>|<img></p>
   *  p[0]/img[0],after = <p><img>|</p>
   *
   * @private
   * @static
   * @class tinymce.caret.CaretBookmark
   * @example
   * var bookmark = CaretBookmark.create(rootElm, CaretPosition.before(rootElm.firstChild));
   * var caretPosition = CaretBookmark.resolve(bookmark);
   */
  (function (tinymce) {
    var NodeType = tinymce.dom.NodeType, DOMUtils = tinymce.DOM;
    var Fun = tinymce.util.Fun, Arr = tinymce.util.Arr;

    var isText = NodeType.isText,
      isBogus = NodeType.isBogus,
      nodeIndex = DOMUtils.nodeIndex;

    function normalizedParent(node) {
      var parentNode = node.parentNode;

      if (isBogus(parentNode)) {
        return normalizedParent(parentNode);
      }

      return parentNode;
    }

    function getChildNodes(node) {
      if (!node) {
        return [];
      }

      return Arr.reduce(node.childNodes, function (result, node) {
        if (isBogus(node) && node.nodeName != 'BR') {
          result = result.concat(getChildNodes(node));
        } else {
          result.push(node);
        }

        return result;
      }, []);
    }

    function normalizedTextOffset(textNode, offset) {
      while ((textNode = textNode.previousSibling)) {
        if (!isText(textNode)) {
          break;
        }

        offset += textNode.data.length;
      }

      return offset;
    }

    function equal(targetValue) {
      return function (value) {
        return targetValue === value;
      };
    }

    function normalizedNodeIndex(node) {
      var nodes, index, numTextFragments;

      nodes = getChildNodes(normalizedParent(node));
      index = Arr.findIndex(nodes, equal(node), node);
      nodes = nodes.slice(0, index + 1);
      numTextFragments = Arr.reduce(nodes, function (result, node, i) {
        if (isText(node) && isText(nodes[i - 1])) {
          result++;
        }

        return result;
      }, 0);

      nodes = Arr.filter(nodes, NodeType.matchNodeNames(node.nodeName));
      index = Arr.findIndex(nodes, equal(node), node);

      return index - numTextFragments;
    }

    function createPathItem(node) {
      var name;

      if (isText(node)) {
        name = 'text()';
      } else {
        name = node.nodeName.toLowerCase();
      }

      return name + '[' + normalizedNodeIndex(node) + ']';
    }

    function parentsUntil(rootNode, node, predicate) {
      var parents = [];

      for (node = node.parentNode; node != rootNode; node = node.parentNode) {

        parents.push(node);
      }

      return parents;
    }

    function create(rootNode, caretPosition) {
      var container, offset, path = [],
        outputOffset, childNodes, parents;

      container = caretPosition.container();
      offset = caretPosition.offset();

      if (isText(container)) {
        outputOffset = normalizedTextOffset(container, offset);
      } else {
        childNodes = container.childNodes;
        if (offset >= childNodes.length) {
          outputOffset = 'after';
          offset = childNodes.length - 1;
        } else {
          outputOffset = 'before';
        }

        container = childNodes[offset];
      }

      path.push(createPathItem(container));
      parents = parentsUntil(rootNode, container);
      parents = Arr.filter(parents, Fun.negate(NodeType.isBogus));
      path = path.concat(Arr.map(parents, function (node) {
        return createPathItem(node);
      }));

      return path.reverse().join('/') + ',' + outputOffset;
    }

    function resolvePathItem(node, name, index) {
      var nodes = getChildNodes(node);

      nodes = Arr.filter(nodes, function (node, index) {
        return !isText(node) || !isText(nodes[index - 1]);
      });

      nodes = Arr.filter(nodes, NodeType.matchNodeNames(name));
      return nodes[index];
    }

    function findTextPosition(container, offset) {
      var node = container,
        targetOffset = 0,
        dataLen;

      while (isText(node)) {
        dataLen = node.data.length;

        if (offset >= targetOffset && offset <= targetOffset + dataLen) {
          container = node;
          offset = offset - targetOffset;
          break;
        }

        if (!isText(node.nextSibling)) {
          container = node;
          offset = dataLen;
          break;
        }

        targetOffset += dataLen;
        node = node.nextSibling;
      }

      if (offset > container.data.length) {
        offset = container.data.length;
      }

      return new tinymce.caret.CaretPosition(container, offset);
    }

    function resolve(rootNode, path) {
      var parts, container, offset;

      if (!path) {
        return null;
      }

      parts = path.split(',');
      path = parts[0].split('/');
      offset = parts.length > 1 ? parts[1] : 'before';

      container = Arr.reduce(path, function (result, value) {
        value = /([\w\-\(\)]+)\[([0-9]+)\]/.exec(value);
        if (!value) {
          return null;
        }

        if (value[1] === 'text()') {
          value[1] = '#text';
        }

        return resolvePathItem(result, value[1], parseInt(value[2], 10));
      }, rootNode);

      if (!container) {
        return null;
      }

      if (!isText(container)) {
        if (offset === 'after') {
          offset = nodeIndex(container) + 1;
        } else {
          offset = nodeIndex(container);
        }

        return new tinymce.caret.CaretPosition(container.parentNode, offset);
      }

      return findTextPosition(container, parseInt(offset, 10));
    }

    tinymce.caret.CaretBookmark = {
      /**
       * Create a xpath bookmark location for the specified caret position.
       *
       * @method create
       * @param {Node} rootNode Root node to create bookmark within.
       * @param {tinymce.caret.CaretPosition} caretPosition Caret position within the root node.
       * @return {String} String xpath like location of caret position.
       */
      create: create,

      /**
       * Resolves a xpath like bookmark location to the a caret position.
       *
       * @method resolve
       * @param {Node} rootNode Root node to resolve xpath bookmark within.
       * @param {String} bookmark Bookmark string to resolve.
       * @return {tinymce.caret.CaretPosition} Caret position resolved from xpath like bookmark.
       */
      resolve: resolve
    };

  })(tinymce);

  /**
   * CaretContainer.js
   *
   * Released under LGPL License.
   * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
   *
   * License: http://www.tinymce.com/license - Inactive
   * Licence: GNU/LGPL 2.1 or later - http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
   * Contributing: http://www.tinymce.com/contributing - Inactive
   */

  /**
   * This module handles caret containers. A caret container is a node that
   * holds the caret for positional purposes.
   *
   * @private
   * @class tinymce.caret.CaretContainer
   */
  (function (tinymce) {
    var NodeType = tinymce.dom.NodeType, Zwsp = tinymce.text.Zwsp;

    var isElement = NodeType.isElement,
      isText = NodeType.isText;

    function isCaretContainerBlock(node) {
      if (isText(node)) {
        node = node.parentNode;
      }

      return isElement(node) && node.hasAttribute('data-mce-caret');
    }

    function isCaretContainerInline(node) {
      return isText(node) && Zwsp.isZwsp(node.data);
    }

    function isCaretContainer(node) {
      return isCaretContainerBlock(node) || isCaretContainerInline(node);
    }

    var hasContent = function (node) {
      return node.firstChild !== node.lastChild || !NodeType.isBr(node.firstChild);
    };

    function insertInline(node, before) {
      var doc, sibling, textNode, parentNode;

      doc = node.ownerDocument;
      textNode = doc.createTextNode(Zwsp.ZWSP);
      parentNode = node.parentNode;

      if (!before) {
        sibling = node.nextSibling;
        if (isText(sibling)) {
          if (isCaretContainer(sibling)) {
            return sibling;
          }

          if (startsWithCaretContainer(sibling)) {
            sibling.splitText(1);
            return sibling;
          }
        }

        if (node.nextSibling) {
          parentNode.insertBefore(textNode, node.nextSibling);
        } else {
          parentNode.appendChild(textNode);
        }
      } else {
        sibling = node.previousSibling;
        if (isText(sibling)) {
          if (isCaretContainer(sibling)) {
            return sibling;
          }

          if (endsWithCaretContainer(sibling)) {
            return sibling.splitText(sibling.data.length - 1);
          }
        }

        parentNode.insertBefore(textNode, node);
      }

      return textNode;
    }

    function createBogusBr() {
      var br = document.createElement('br');
      br.setAttribute('data-mce-bogus', '1');
      return br;
    }

    function insertBlock(blockName, node, before) {
      var doc, blockNode, parentNode;

      doc = node.ownerDocument;
      blockNode = doc.createElement(blockName);
      blockNode.setAttribute('data-mce-caret', before ? 'before' : 'after');
      blockNode.setAttribute('data-mce-bogus', 'all');
      blockNode.appendChild(createBogusBr());
      parentNode = node.parentNode;

      if (!before) {
        if (node.nextSibling) {
          parentNode.insertBefore(blockNode, node.nextSibling);
        } else {
          parentNode.appendChild(blockNode);
        }
      } else {
        parentNode.insertBefore(blockNode, node);
      }

      return blockNode;
    }

    function startsWithCaretContainer(node) {
      return isText(node) && node.data[0] == Zwsp.ZWSP;
    }

    function endsWithCaretContainer(node) {
      return isText(node) && node.data[node.data.length - 1] == Zwsp.ZWSP;
    }

    function trimBogusBr(elm) {
      var brs = elm.getElementsByTagName('br');
      var lastBr = brs[brs.length - 1];
      if (NodeType.isBogus(lastBr)) {
        lastBr.parentNode.removeChild(lastBr);
      }
    }

    function showCaretContainerBlock(caretContainer) {
      if (caretContainer && caretContainer.hasAttribute('data-mce-caret')) {
        trimBogusBr(caretContainer);
        caretContainer.removeAttribute('data-mce-caret');
        caretContainer.removeAttribute('data-mce-bogus');
        caretContainer.removeAttribute('style');
        caretContainer.removeAttribute('_moz_abspos');
        return caretContainer;
      }

      return null;
    }

    tinymce.caret.CaretContainer = {
      isCaretContainer: isCaretContainer,
      isCaretContainerBlock: isCaretContainerBlock,
      isCaretContainerInline: isCaretContainerInline,
      showCaretContainerBlock: showCaretContainerBlock,
      insertInline: insertInline,
      insertBlock: insertBlock,
      hasContent: hasContent,
      startsWithCaretContainer: startsWithCaretContainer,
      endsWithCaretContainer: endsWithCaretContainer
    };

  })(tinymce);

  /**
   * CaretCandidate.js
   *
   * Released under LGPL License.
   * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
   *
   * License: http://www.tinymce.com/license - Inactive
   * Licence: GNU/LGPL 2.1 or later - http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
   * Contributing: http://www.tinymce.com/contributing - Inactive
   */

  /**
   * This module contains logic for handling caret candidates. A caret candidate is
   * for example text nodes, images, input elements, cE=false elements etc.
   *
   * @private
   * @class tinymce.caret.CaretCandidate
   */
  (function (tinymce) {
    var NodeType = tinymce.dom.NodeType, CaretContainer = tinymce.caret.CaretContainer;
    var Arr = tinymce.util.Arr;

    var isContentEditableTrue = NodeType.isContentEditableTrue,
      isContentEditableFalse = NodeType.isContentEditableFalse,
      isBr = NodeType.isBr,
      isText = NodeType.isText,
      isInvalidTextElement = NodeType.matchNodeNames('script style textarea'),
      isAtomicInline = NodeType.matchNodeNames('img input textarea hr iframe video audio object'),
      isTable = NodeType.matchNodeNames('table'),
      isCaretContainer = CaretContainer.isCaretContainer;

    function isCaretCandidate(node) {
      if (isCaretContainer(node)) {
        return false;
      }

      if (isText(node)) {
        if (isInvalidTextElement(node.parentNode)) {
          return false;
        }

        return true;
      }

      return isAtomicInline(node) || isBr(node) || isTable(node) || isContentEditableFalse(node);
    }

    function isInEditable(node, rootNode) {
      for (node = node.parentNode; node && node != rootNode; node = node.parentNode) {
        if (isContentEditableFalse(node)) {
          return false;
        }

        if (isContentEditableTrue(node)) {
          return true;
        }
      }

      return true;
    }

    function isAtomicContentEditableFalse(node) {
      if (!isContentEditableFalse(node)) {
        return false;
      }

      return Arr.reduce(node.getElementsByTagName('*'), function (result, elm) {
        return result || isContentEditableTrue(elm);
      }, false) !== true;
    }

    function isAtomic(node) {
      return isAtomicInline(node) || isAtomicContentEditableFalse(node);
    }

    function isEditableCaretCandidate(node, rootNode) {
      return isCaretCandidate(node) && isInEditable(node, rootNode);
    }

    tinymce.caret.CaretCandidate = {
      isCaretCandidate: isCaretCandidate,
      isInEditable: isInEditable,
      isAtomic: isAtomic,
      isEditableCaretCandidate: isEditableCaretCandidate
    };
  })(tinymce);

  /**
   * CaretContainerRemove.js
   *
   * Released under LGPL License.
   * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
   *
   * License: http://www.tinymce.com/license - Inactive
   * Licence: GNU/LGPL 2.1 or later - http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
   * Contributing: http://www.tinymce.com/contributing - Inactive
   */
  (function (tinymce) {
    var NodeType = tinymce.dom.NodeType, Zwsp = tinymce.text.Zwsp, CaretContainer = tinymce.caret.CaretContainer, CaretPosition = tinymce.caret.CaretPosition;
    var Arr = tinymce.util.Arr;

    var isElement = NodeType.isElement;
    var isText = NodeType.isText;

    var removeNode = function (node) {
      var parentNode = node.parentNode;
      if (parentNode) {
        parentNode.removeChild(node);
      }
    };

    var getNodeValue = function (node) {
      try {
        return node.nodeValue;
      } catch (ex) {
        // IE sometimes produces "Invalid argument" on nodes
        return "";
      }
    };

    var setNodeValue = function (node, text) {
      if (text.length === 0) {
        removeNode(node);
      } else {
        node.nodeValue = text;
      }
    };

    var trimCount = function (text) {
      var trimmedText = Zwsp.trim(text);
      return {
        count: text.length - trimmedText.length,
        text: trimmedText
      };
    };

    var removeUnchanged = function (caretContainer, pos) {
      remove(caretContainer);
      return pos;
    };

    var removeTextAndReposition = function (caretContainer, pos) {
      var before = trimCount(caretContainer.data.substr(0, pos.offset()));
      var after = trimCount(caretContainer.data.substr(pos.offset()));
      var text = before.text + after.text;

      if (text.length > 0) {
        setNodeValue(caretContainer, text);
        return new CaretPosition(caretContainer, pos.offset() - before.count);
      } else {
        return pos;
      }
    };

    var removeElementAndReposition = function (caretContainer, pos) {
      var parentNode = pos.container();
      var newPosition = Arr.indexOf(parentNode.childNodes, caretContainer).map(function (index) {
        return index < pos.offset() ? new CaretPosition(parentNode, pos.offset() - 1) : pos;
      }).getOr(pos);
      remove(caretContainer);
      return newPosition;
    };

    var removeTextCaretContainer = function (caretContainer, pos) {
      return pos.container() === caretContainer ? removeTextAndReposition(caretContainer, pos) : removeUnchanged(caretContainer, pos);
    };

    var removeElementCaretContainer = function (caretContainer, pos) {
      return pos.container() === caretContainer.parentNode ? removeElementAndReposition(caretContainer, pos) : removeUnchanged(caretContainer, pos);
    };

    var removeAndReposition = function (container, pos) {
      return CaretPosition.isTextPosition(pos) ? removeTextCaretContainer(container, pos) : removeElementCaretContainer(container, pos);
    };

    var remove = function (caretContainerNode) {
      if (isElement(caretContainerNode) && CaretContainer.isCaretContainer(caretContainerNode)) {
        if (CaretContainer.hasContent(caretContainerNode)) {
          caretContainerNode.removeAttribute('data-mce-caret');
        } else {
          removeNode(caretContainerNode);
        }
      }

      if (isText(caretContainerNode)) {
        var text = Zwsp.trim(getNodeValue(caretContainerNode));
        setNodeValue(caretContainerNode, text);
      }
    };

    tinymce.caret.CaretContainerRemove = {
      removeAndReposition: removeAndReposition,
      remove: remove
    };

  })(tinymce);

  /**
   * CaretPosition.js
   *
   * Released under LGPL License.
   * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
   *
   * License: http://www.tinymce.com/license - Inactive
   * Licence: GNU/LGPL 2.1 or later - http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
   * Contributing: http://www.tinymce.com/contributing - Inactive
   */

  /**
   * This module contains logic for creating caret positions within a document a caretposition
   * is similar to a DOMRange object but it doesn't have two endpoints and is also more lightweight
   * since it's now updated live when the DOM changes.
   *
   * @private
   * @class tinymce.caret.CaretPosition
   * @example
   * var caretPos1 = new CaretPosition(container, offset);
   * var caretPos2 = CaretPosition.fromRangeStart(someRange);
   */

  (function (tinymce) {
    var NodeType = tinymce.dom.NodeType,
      DOMUtils = tinymce.DOM,
      CaretCandidate = tinymce.caret.CaretCandidate,
      RangeUtils = tinymce.dom.RangeUtils,
      ClientRect = tinymce.geom.ClientRect,
      ExtendingChar = tinymce.text.ExtendingChar,
      Fun = tinymce.util.Fun;

    var isElement = NodeType.isElement,
      isCaretCandidate = CaretCandidate.isCaretCandidate,
      isBlock = NodeType.matchStyleValues('display', 'block table'),
      isFloated = NodeType.matchStyleValues('float', 'left right'),
      isValidElementCaretCandidate = Fun.and(isElement, isCaretCandidate, Fun.negate(isFloated)),
      isNotPre = Fun.negate(NodeType.matchStyleValues('white-space', 'pre pre-line pre-wrap')),
      isText = NodeType.isText,
      isBr = NodeType.isBr,
      nodeIndex = DOMUtils.nodeIndex,
      resolveIndex = RangeUtils.getNode;

    function createRange(doc) {
      return "createRange" in doc ? doc.createRange() : DOMUtils.createRng();
    }

    function isWhiteSpace(chr) {
      return chr && /[\r\n\t ]/.test(chr);
    }

    function isHiddenWhiteSpaceRange(range) {
      var container = range.startContainer,
        offset = range.startOffset,
        text;

      if (isWhiteSpace(range.toString()) && isNotPre(container.parentNode)) {
        text = container.data;

        if (isWhiteSpace(text[offset - 1]) || isWhiteSpace(text[offset + 1])) {
          return true;
        }
      }

      return false;
    }

    function getCaretPositionClientRects(caretPosition) {
      var clientRects = [],
        beforeNode, node;

      function getBoundingClientRect(item) {
        var clientRect, clientRects;

        clientRects = item.getClientRects();
        if (clientRects.length > 0) {
          clientRect = ClientRect.clone(clientRects[0]);
        } else {
          clientRect = ClientRect.clone(item.getBoundingClientRect());
        }

        return clientRect;
      }

      function collapseAndInflateWidth(clientRect, toStart) {
        clientRect = ClientRect.collapse(clientRect, toStart);
        clientRect.width = 1;
        clientRect.right = clientRect.left + 1;

        return clientRect;
      }

      function addUniqueAndValidRect(clientRect) {
        if (clientRect.height === 0) {
          return;
        }

        if (clientRects.length > 0) {
          if (ClientRect.isEqual(clientRect, clientRects[clientRects.length - 1])) {
            return;
          }
        }

        clientRects.push(clientRect);
      }

      function addCharacterOffset(container, offset) {
        var range = createRange(container.ownerDocument);

        if (offset < container.data.length) {
          if (ExtendingChar.isExtendingChar(container.data[offset])) {
            return clientRects;
          }

          // WebKit returns two client rects for a position after an extending
          // character a\uxxx|b so expand on "b" and collapse to start of "b" box
          if (ExtendingChar.isExtendingChar(container.data[offset - 1])) {
            range.setStart(container, offset);
            range.setEnd(container, offset + 1);

            if (!isHiddenWhiteSpaceRange(range)) {
              addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect(range), false));
              return clientRects;
            }
          }
        }

        if (offset > 0) {
          range.setStart(container, offset - 1);
          range.setEnd(container, offset);

          if (!isHiddenWhiteSpaceRange(range)) {
            addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect(range), false));
          }
        }

        if (offset < container.data.length) {
          range.setStart(container, offset);
          range.setEnd(container, offset + 1);

          if (!isHiddenWhiteSpaceRange(range)) {
            addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect(range), true));
          }
        }
      }

      if (isText(caretPosition.container())) {
        addCharacterOffset(caretPosition.container(), caretPosition.offset());
        return clientRects;
      }

      if (isElement(caretPosition.container())) {
        if (caretPosition.isAtEnd()) {
          node = resolveIndex(caretPosition.container(), caretPosition.offset());
          if (isText(node)) {
            addCharacterOffset(node, node.data.length);
          }

          if (isValidElementCaretCandidate(node) && !isBr(node)) {
            addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect(node), false));
          }
        } else {
          node = resolveIndex(caretPosition.container(), caretPosition.offset());
          if (isText(node)) {
            addCharacterOffset(node, 0);
          }

          if (isValidElementCaretCandidate(node) && caretPosition.isAtEnd()) {
            addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect(node), false));
            return clientRects;
          }

          beforeNode = resolveIndex(caretPosition.container(), caretPosition.offset() - 1);
          if (isValidElementCaretCandidate(beforeNode) && !isBr(beforeNode)) {
            if (isBlock(beforeNode) || isBlock(node) || !isValidElementCaretCandidate(node)) {
              addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect(beforeNode), false));
            }
          }

          if (isValidElementCaretCandidate(node)) {
            addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect(node), true));
          }
        }
      }

      return clientRects;
    }

    /**
     * Represents a location within the document by a container and an offset.
     *
     * @constructor
     * @param {Node} container Container node.
     * @param {Number} offset Offset within that container node.
     * @param {Array} clientRects Optional client rects array for the position.
     */
    function CaretPosition(container, offset, clientRects) {
      function isAtStart() {
        if (isText(container)) {
          return offset === 0;
        }

        return offset === 0;
      }

      function isAtEnd() {
        if (isText(container)) {
          return offset >= container.data.length;
        }

        return offset >= container.childNodes.length;
      }

      function toRange() {
        var range;

        range = createRange(container.ownerDocument);
        range.setStart(container, offset);
        range.setEnd(container, offset);

        return range;
      }

      function getClientRects() {
        if (!clientRects) {
          clientRects = getCaretPositionClientRects(new CaretPosition(container, offset));
        }

        return clientRects;
      }

      function isVisible() {
        return getClientRects().length > 0;
      }

      function isEqual(caretPosition) {
        return caretPosition && container === caretPosition.container() && offset === caretPosition.offset();
      }

      function getNode(before) {
        return resolveIndex(container, before ? offset - 1 : offset);
      }

      return {
        /**
         * Returns the container node.
         *
         * @method container
         * @return {Node} Container node.
         */
        container: Fun.constant(container),

        /**
         * Returns the offset within the container node.
         *
         * @method offset
         * @return {Number} Offset within the container node.
         */
        offset: Fun.constant(offset),

        /**
         * Returns a range out of a the caret position.
         *
         * @method toRange
         * @return {DOMRange} range for the caret position.
         */
        toRange: toRange,

        /**
         * Returns the client rects for the caret position. Might be multiple rects between
         * block elements.
         *
         * @method getClientRects
         * @return {Array} Array of client rects.
         */
        getClientRects: getClientRects,

        /**
         * Returns true if the caret location is visible/displayed on screen.
         *
         * @method isVisible
         * @return {Boolean} true/false if the position is visible or not.
         */
        isVisible: isVisible,

        /**
         * Returns true if the caret location is at the beginning of text node or container.
         *
         * @method isVisible
         * @return {Boolean} true/false if the position is at the beginning.
         */
        isAtStart: isAtStart,

        /**
         * Returns true if the caret location is at the end of text node or container.
         *
         * @method isVisible
         * @return {Boolean} true/false if the position is at the end.
         */
        isAtEnd: isAtEnd,

        /**
         * Compares the caret position to another caret position. This will only compare the
         * container and offset not it's visual position.
         *
         * @method isEqual
         * @param {tinymce.caret.CaretPosition} caretPosition Caret position to compare with.
         * @return {Boolean} true if the caret positions are equal.
         */
        isEqual: isEqual,

        /**
         * Returns the closest resolved node from a node index. That means if you have an offset after the
         * last node in a container it will return that last node.
         *
         * @method getNode
         * @return {Node} Node that is closest to the index.
         */
        getNode: getNode
      };
    }

    /**
     * Creates a caret position from the start of a range.
     *
     * @method fromRangeStart
     * @param {DOMRange} range DOM Range to create caret position from.
     * @return {tinymce.caret.CaretPosition} Caret position from the start of DOM range.
     */
    CaretPosition.fromRangeStart = function (range) {
      return new CaretPosition(range.startContainer, range.startOffset);
    };

    /**
     * Creates a caret position from the end of a range.
     *
     * @method fromRangeEnd
     * @param {DOMRange} range DOM Range to create caret position from.
     * @return {tinymce.caret.CaretPosition} Caret position from the end of DOM range.
     */
    CaretPosition.fromRangeEnd = function (range) {
      return new CaretPosition(range.endContainer, range.endOffset);
    };

    /**
     * Creates a caret position from a node and places the offset after it.
     *
     * @method after
     * @param {Node} node Node to get caret position from.
     * @return {tinymce.caret.CaretPosition} Caret position from the node.
     */
    CaretPosition.after = function (node) {
      return new CaretPosition(node.parentNode, nodeIndex(node) + 1);
    };

    /**
     * Creates a caret position from a node and places the offset before it.
     *
     * @method before
     * @param {Node} node Node to get caret position from.
     * @return {tinymce.caret.CaretPosition} Caret position from the node.
     */
    CaretPosition.before = function (node) {
      return new CaretPosition(node.parentNode, nodeIndex(node));
    };

    tinymce.caret.CaretPosition = CaretPosition;

  })(tinymce);

  /**
   * CaretUtils.js
   *
   * Released under LGPL License.
   * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
   *
   * License: http://www.tinymce.com/license - Inactive
   * Licence: GNU/LGPL 2.1 or later - http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
   * Contributing: http://www.tinymce.com/contributing - Inactive
   */

  /**
   * Utility functions shared by the caret logic.
   *
   * @private
   * @class tinymce.caret.CaretUtils
   */
  (function (tinymce) {
    var NodeType = tinymce.dom.NodeType,
      TreeWalker = tinymce.dom.TreeWalker,
      CaretContainer = tinymce.caret.CaretContainer,
      CaretCandidate = tinymce.caret.CaretCandidate,
      Fun = tinymce.util.Fun;

    var isContentEditableTrue = NodeType.isContentEditableTrue,
      isContentEditableFalse = NodeType.isContentEditableFalse,
      isBlockLike = NodeType.matchStyleValues('display', 'block table table-cell table-caption'),
      isCaretContainer = CaretContainer.isCaretContainer,
      isCaretContainerBlock = CaretContainer.isCaretContainerBlock,
      curry = Fun.curry,
      isElement = NodeType.isElement,
      isCaretCandidate = CaretCandidate.isCaretCandidate;

    function isForwards(direction) {
      return direction > 0;
    }

    function isBackwards(direction) {
      return direction < 0;
    }

    function skipCaretContainers(walk, shallow) {
      var node;

      while ((node = walk(shallow))) {
        if (!isCaretContainerBlock(node)) {
          return node;
        }
      }

      return null;
    }

    function findNode(node, direction, predicateFn, rootNode, shallow) {
      var walker = new TreeWalker(node, rootNode);

      if (isBackwards(direction)) {
        if (isContentEditableFalse(node) || isCaretContainerBlock(node)) {
          node = skipCaretContainers(walker.prev, true);
          if (predicateFn(node)) {
            return node;
          }
        }

        while ((node = skipCaretContainers(walker.prev, shallow))) {
          if (predicateFn(node)) {
            return node;
          }
        }
      }

      if (isForwards(direction)) {
        if (isContentEditableFalse(node) || isCaretContainerBlock(node)) {
          node = skipCaretContainers(walker.next, true);
          if (predicateFn(node)) {
            return node;
          }
        }

        while ((node = skipCaretContainers(walker.next, shallow))) {
          if (predicateFn(node)) {
            return node;
          }
        }
      }

      return null;
    }

    function getEditingHost(node, rootNode) {
      for (node = node.parentNode; node && node != rootNode; node = node.parentNode) {
        if (isContentEditableTrue(node)) {
          return node;
        }
      }

      return rootNode;
    }

    function getParentBlock(node, rootNode) {
      while (node && node != rootNode) {
        if (isBlockLike(node)) {
          return node;
        }

        node = node.parentNode;
      }

      return null;
    }

    function isInSameBlock(caretPosition1, caretPosition2, rootNode) {
      return getParentBlock(caretPosition1.container(), rootNode) == getParentBlock(caretPosition2.container(), rootNode);
    }

    function isInSameEditingHost(caretPosition1, caretPosition2, rootNode) {
      return getEditingHost(caretPosition1.container(), rootNode) == getEditingHost(caretPosition2.container(), rootNode);
    }

    function getChildNodeAtRelativeOffset(relativeOffset, caretPosition) {
      var container, offset;

      if (!caretPosition) {
        return null;
      }

      container = caretPosition.container();
      offset = caretPosition.offset();

      if (!isElement(container)) {
        return null;
      }

      return container.childNodes[offset + relativeOffset];
    }

    function beforeAfter(before, node) {
      var range = node.ownerDocument.createRange();

      if (before) {
        range.setStartBefore(node);
        range.setEndBefore(node);
      } else {
        range.setStartAfter(node);
        range.setEndAfter(node);
      }

      return range;
    }

    function isNodesInSameBlock(rootNode, node1, node2) {
      return getParentBlock(node1, rootNode) == getParentBlock(node2, rootNode);
    }

    function lean(left, rootNode, node) {
      var sibling, siblingName;

      if (left) {
        siblingName = 'previousSibling';
      } else {
        siblingName = 'nextSibling';
      }

      while (node && node != rootNode) {
        sibling = node[siblingName];

        if (isCaretContainer(sibling)) {
          sibling = sibling[siblingName];
        }

        if (isContentEditableFalse(sibling)) {
          if (isNodesInSameBlock(rootNode, sibling, node)) {
            return sibling;
          }

          break;
        }

        if (isCaretCandidate(sibling)) {
          break;
        }

        node = node.parentNode;
      }

      return null;
    }

    var before = curry(beforeAfter, true);
    var after = curry(beforeAfter, false);

    function normalizeRange(direction, rootNode, range) {
      var node, container, offset, location;
      var leanLeft = curry(lean, true, rootNode);
      var leanRight = curry(lean, false, rootNode);

      container = range.startContainer;
      offset = range.startOffset;

      if (CaretContainer.isCaretContainerBlock(container)) {
        if (!isElement(container)) {
          container = container.parentNode;
        }

        location = container.getAttribute('data-mce-caret');

        if (location == 'before') {
          node = container.nextSibling;
          if (isContentEditableFalse(node)) {
            return before(node);
          }
        }

        if (location == 'after') {
          node = container.previousSibling;
          if (isContentEditableFalse(node)) {
            return after(node);
          }
        }
      }

      if (!range.collapsed) {
        return range;
      }

      if (NodeType.isText(container)) {
        if (isCaretContainer(container)) {
          if (direction === 1) {
            node = leanRight(container);
            if (node) {
              return before(node);
            }

            node = leanLeft(container);
            if (node) {
              return after(node);
            }
          }

          if (direction === -1) {
            node = leanLeft(container);
            if (node) {
              return after(node);
            }

            node = leanRight(container);
            if (node) {
              return before(node);
            }
          }

          return range;
        }

        if (CaretContainer.endsWithCaretContainer(container) && offset >= container.data.length - 1) {
          if (direction === 1) {
            node = leanRight(container);
            if (node) {
              return before(node);
            }
          }

          return range;
        }

        if (CaretContainer.startsWithCaretContainer(container) && offset <= 1) {
          if (direction === -1) {
            node = leanLeft(container);
            if (node) {
              return after(node);
            }
          }

          return range;
        }

        if (offset === container.data.length) {
          node = leanRight(container);
          if (node) {
            return before(node);
          }

          return range;
        }

        if (offset === 0) {
          node = leanLeft(container);
          if (node) {
            return after(node);
          }

          return range;
        }
      }

      return range;
    }

    function isNextToContentEditableFalse(relativeOffset, caretPosition) {
      return isContentEditableFalse(getChildNodeAtRelativeOffset(relativeOffset, caretPosition));
    }

    tinymce.caret.CaretUtils = {
      isForwards: isForwards,
      isBackwards: isBackwards,
      findNode: findNode,
      getEditingHost: getEditingHost,
      getParentBlock: getParentBlock,
      isInSameBlock: isInSameBlock,
      isInSameEditingHost: isInSameEditingHost,
      isBeforeContentEditableFalse: curry(isNextToContentEditableFalse, 0),
      isAfterContentEditableFalse: curry(isNextToContentEditableFalse, -1),
      normalizeRange: normalizeRange
    };

  })(tinymce);

  /**
   * CaretWalker.js
   *
   * Released under LGPL License.
   * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
   *
   * License: http://www.tinymce.com/license - Inactive
   * Licence: GNU/LGPL 2.1 or later - http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
   * Contributing: http://www.tinymce.com/contributing - Inactive
   */

  /**
   * This module contains logic for moving around a virtual caret in logical order within a DOM element.
   *
   * It ignores the most obvious invalid caret locations such as within a script element or within a
   * contentEditable=false element but it will return locations that isn't possible to render visually.
   *
   * @private
   * @class tinymce.caret.CaretWalker
   * @example
   * var caretWalker = new CaretWalker(rootElm);
   *
   * var prevLogicalCaretPosition = caretWalker.prev(CaretPosition.fromRangeStart(range));
   * var nextLogicalCaretPosition = caretWalker.next(CaretPosition.fromRangeEnd(range));
   */
  (function (tinymce) {
    var NodeType = tinymce.dom.NodeType,
      CaretPosition = tinymce.caret.CaretPosition,
      CaretUtils = tinymce.caret.CaretUtils,
      CaretCandidate = tinymce.caret.CaretCandidate,
      Arr = tinymce.util.Arr,
      Fun = tinymce.util.Fun;

    var isContentEditableFalse = NodeType.isContentEditableFalse,
      isText = NodeType.isText,
      isElement = NodeType.isElement,
      isBr = NodeType.isBr,
      isForwards = CaretUtils.isForwards,
      isBackwards = CaretUtils.isBackwards,
      isCaretCandidate = CaretCandidate.isCaretCandidate,
      isAtomic = CaretCandidate.isAtomic,
      isEditableCaretCandidate = CaretCandidate.isEditableCaretCandidate;

    function getParents(node, rootNode) {
      var parents = [];

      while (node && node != rootNode) {
        parents.push(node);
        node = node.parentNode;
      }

      return parents;
    }

    function nodeAtIndex(container, offset) {
      if (container.hasChildNodes() && offset < container.childNodes.length) {
        return container.childNodes[offset];
      }

      return null;
    }

    function getCaretCandidatePosition(direction, node) {
      if (isForwards(direction)) {
        if (isCaretCandidate(node.previousSibling) && !isText(node.previousSibling)) {
          return CaretPosition.before(node);
        }

        if (isText(node)) {
          return CaretPosition(node, 0);
        }
      }

      if (isBackwards(direction)) {
        if (isCaretCandidate(node.nextSibling) && !isText(node.nextSibling)) {
          return CaretPosition.after(node);
        }

        if (isText(node)) {
          return CaretPosition(node, node.data.length);
        }
      }

      if (isBackwards(direction)) {
        if (isBr(node)) {
          return CaretPosition.before(node);
        }

        return CaretPosition.after(node);
      }

      return CaretPosition.before(node);
    }

    // Jumps over BR elements <p>|<br></p><p>a</p> -> <p><br></p><p>|a</p>
    function isBrBeforeBlock(node, rootNode) {
      var next;

      if (!NodeType.isBr(node)) {
        return false;
      }

      next = findCaretPosition(1, CaretPosition.after(node), rootNode);
      if (!next) {
        return false;
      }

      return !CaretUtils.isInSameBlock(CaretPosition.before(node), CaretPosition.before(next), rootNode);
    }

    function findCaretPosition(direction, startCaretPosition, rootNode) {
      var container, offset, node, nextNode, innerNode,
        rootContentEditableFalseElm, caretPosition;

      if (!isElement(rootNode) || !startCaretPosition) {
        return null;
      }

      caretPosition = startCaretPosition;
      container = caretPosition.container();
      offset = caretPosition.offset();

      if (isText(container)) {
        if (isBackwards(direction) && offset > 0) {
          return CaretPosition(container, --offset);
        }

        if (isForwards(direction) && offset < container.length) {
          return CaretPosition(container, ++offset);
        }

        node = container;
      } else {
        if (isBackwards(direction) && offset > 0) {
          nextNode = nodeAtIndex(container, offset - 1);
          if (isCaretCandidate(nextNode)) {
            if (!isAtomic(nextNode)) {
              innerNode = CaretUtils.findNode(nextNode, direction, isEditableCaretCandidate, nextNode);
              if (innerNode) {
                if (isText(innerNode)) {
                  return CaretPosition(innerNode, innerNode.data.length);
                }

                return CaretPosition.after(innerNode);
              }
            }

            if (isText(nextNode)) {
              return CaretPosition(nextNode, nextNode.data.length);
            }

            return CaretPosition.before(nextNode);
          }
        }

        if (isForwards(direction) && offset < container.childNodes.length) {
          nextNode = nodeAtIndex(container, offset);
          if (isCaretCandidate(nextNode)) {
            if (isBrBeforeBlock(nextNode, rootNode)) {
              return findCaretPosition(direction, CaretPosition.after(nextNode), rootNode);
            }

            if (!isAtomic(nextNode)) {
              innerNode = CaretUtils.findNode(nextNode, direction, isEditableCaretCandidate, nextNode);
              if (innerNode) {
                if (isText(innerNode)) {
                  return CaretPosition(innerNode, 0);
                }

                return CaretPosition.before(innerNode);
              }
            }

            if (isText(nextNode)) {
              return CaretPosition(nextNode, 0);
            }

            return CaretPosition.after(nextNode);
          }
        }

        node = caretPosition.getNode();
      }

      if ((isForwards(direction) && caretPosition.isAtEnd()) || (isBackwards(direction) && caretPosition.isAtStart())) {
        node = CaretUtils.findNode(node, direction, Fun.constant(true), rootNode, true);
        if (isEditableCaretCandidate(node)) {
          return getCaretCandidatePosition(direction, node);
        }
      }

      nextNode = CaretUtils.findNode(node, direction, isEditableCaretCandidate, rootNode);

      rootContentEditableFalseElm = Arr.last(Arr.filter(getParents(container, rootNode), isContentEditableFalse));
      if (rootContentEditableFalseElm && (!nextNode || !rootContentEditableFalseElm.contains(nextNode))) {
        if (isForwards(direction)) {
          caretPosition = CaretPosition.after(rootContentEditableFalseElm);
        } else {
          caretPosition = CaretPosition.before(rootContentEditableFalseElm);
        }

        return caretPosition;
      }

      if (nextNode) {
        return getCaretCandidatePosition(direction, nextNode);
      }

      return null;
    }

    tinymce.caret.CaretWalker = function (rootNode) {
      return {
        /**
         * Returns the next logical caret position from the specificed input
         * caretPoisiton or null if there isn't any more positions left for example
         * at the end specified root element.
         *
         * @method next
         * @param {tinymce.caret.CaretPosition} caretPosition Caret position to start from.
         * @return {tinymce.caret.CaretPosition} CaretPosition or null if no position was found.
         */
        next: function (caretPosition) {
          return findCaretPosition(1, caretPosition, rootNode);
        },

        /**
         * Returns the previous logical caret position from the specificed input
         * caretPoisiton or null if there isn't any more positions left for example
         * at the end specified root element.
         *
         * @method prev
         * @param {tinymce.caret.CaretPosition} caretPosition Caret position to start from.
         * @return {tinymce.caret.CaretPosition} CaretPosition or null if no position was found.
         */
        prev: function (caretPosition) {
          return findCaretPosition(-1, caretPosition, rootNode);
        }
      };
    };

  })(tinymce);

  /**
   * FakeCaret.js
   *
   * Released under LGPL License.
   * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
   *
   * License: http://www.tinymce.com/license - Inactive
   * Licence: GNU/LGPL 2.1 or later - http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
   * Contributing: http://www.tinymce.com/contributing - Inactive
   */

  /**
   * This module contains logic for rendering a fake visual caret.
   *
   * @private
   * @class tinymce.caret.FakeCaret
   */
  (function (tinymce) {
    var NodeType = tinymce.dom.NodeType,
      DOM = tinymce.DOM,
      ClientRect = tinymce.geom.ClientRect,
      CaretContainer = tinymce.caret.CaretContainer,
      CaretContainerRemove = tinymce.caret.CaretContainerRemove;

    var isContentEditableFalse = NodeType.isContentEditableFalse;

    tinymce.caret.FakeCaret = function (rootNode, isBlock) {
      var cursorInterval, $lastVisualCaret, caretContainerNode;

      function getAbsoluteClientRect(node, before) {
        var clientRect = ClientRect.collapse(node.getBoundingClientRect(), before),
          docElm, scrollX, scrollY, margin, rootRect;

        if (rootNode.tagName == 'BODY') {
          docElm = rootNode.ownerDocument.documentElement;
          scrollX = rootNode.scrollLeft || docElm.scrollLeft;
          scrollY = rootNode.scrollTop || docElm.scrollTop;
        } else {
          rootRect = rootNode.getBoundingClientRect();
          scrollX = rootNode.scrollLeft - rootRect.left;
          scrollY = rootNode.scrollTop - rootRect.top;
        }

        clientRect.left += scrollX;
        clientRect.right += scrollX;
        clientRect.top += scrollY;
        clientRect.bottom += scrollY;
        clientRect.width = 1;

        margin = node.offsetWidth - node.clientWidth;

        if (margin > 0) {
          if (before) {
            margin *= -1;
          }

          clientRect.left += margin;
          clientRect.right += margin;
        }

        return clientRect;
      }

      function trimInlineCaretContainers() {
        var contentEditableFalseNodes, node, sibling, i, data;

        contentEditableFalseNodes = DOM.select('*[contentEditable=false]', rootNode);

        for (i = 0; i < contentEditableFalseNodes.length; i++) {
          node = contentEditableFalseNodes[i];

          sibling = node.previousSibling;
          if (CaretContainer.endsWithCaretContainer(sibling)) {
            data = sibling.data;

            if (data.length == 1) {
              sibling.parentNode.removeChild(sibling);
            } else {
              sibling.deleteData(data.length - 1, 1);
            }
          }

          sibling = node.nextSibling;
          if (CaretContainer.startsWithCaretContainer(sibling)) {
            data = sibling.data;

            if (data.length == 1) {
              sibling.parentNode.removeChild(sibling);
            } else {
              sibling.deleteData(0, 1);
            }
          }
        }

        return null;
      }

      function show(before, node) {
        var clientRect, rng;

        hide();

        if (isBlock(node)) {
          caretContainerNode = CaretContainer.insertBlock('p', node, before);
          clientRect = getAbsoluteClientRect(node, before);
          DOM.setStyle(caretContainerNode, 'top', clientRect.top);

          $lastVisualCaret = DOM.add(rootNode, 'div', { 'class': 'mce-visual-caret', 'data-mce-bogus': 'all', 'style': clientRect });

          if (before) {
            DOM.addClass($lastVisualCaret, 'mce-visual-caret-before');
          }

          startBlink();

          rng = node.ownerDocument.createRange();
          rng.setStart(caretContainerNode, 0);
          rng.setEnd(caretContainerNode, 0);
        } else {
          caretContainerNode = CaretContainer.insertInline(node, before);
          rng = node.ownerDocument.createRange();

          if (isContentEditableFalse(caretContainerNode.nextSibling)) {
            rng.setStart(caretContainerNode, 0);
            rng.setEnd(caretContainerNode, 0);
          } else {
            rng.setStart(caretContainerNode, 1);
            rng.setEnd(caretContainerNode, 1);
          }

          return rng;
        }

        return rng;
      }

      function hide() {
        trimInlineCaretContainers();

        if (caretContainerNode) {
          CaretContainerRemove.remove(caretContainerNode);
          caretContainerNode = null;
        }

        if ($lastVisualCaret) {
          DOM.remove($lastVisualCaret);
          $lastVisualCaret = null;
        }

        clearInterval(cursorInterval);
      }

      var hasFocus = function () {
        return rootNode.ownerDocument.activeElement === rootNode;
      };

      function startBlink() {
        cursorInterval = setInterval(function () {
          var caret = DOM.select('div.mce-visual-caret', rootNode)[0];

          if (hasFocus()) {
            DOM.toggleClass(caret, 'mce-visual-caret-hidden');
          } else {
            DOM.addClass(caret, 'mce-visual-caret-hidden');
          }
        }, 500);
      }

      function destroy() {
        clearInterval(cursorInterval);
      }

      function getCss() {
        return (
          '.mce-visual-caret {' +
          'position: absolute;' +
          'background-color: black;' +
          'background-color: currentcolor;' +
          '}' +
          '.mce-visual-caret-hidden {' +
          'display: none;' +
          '}' +
          '*[data-mce-caret] {' +
          'position: absolute;' +
          'left: -1000px;' +
          'right: auto;' +
          'top: 0;' +
          'margin: 0;' +
          'padding: 0;' +
          '}'
        );
      }

      return {
        show: show,
        hide: hide,
        getCss: getCss,
        destroy: destroy
      };
    };

  })(tinymce);

  /**
   * LineUtils.js
   *
   * Released under LGPL License.
   * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
   *
   * License: http://www.tinymce.com/license - Inactive
   * Licence: GNU/LGPL 2.1 or later - http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
   * Contributing: http://www.tinymce.com/contributing - Inactive
   */

  /**
   * Utility functions for working with lines.
   *
   * @private
   * @class tinymce.caret.LineUtils
   */
  (function (tinymce) {
    var NodeType = tinymce.dom.NodeType,
      Fun = tinymce.util.Fun, Arr = tinymce.util.Arr,
      Dimensions = tinymce.dom.Dimensions,
      ClientRect = tinymce.geom.ClientRect,
      CaretUtils = tinymce.caret.CaretUtils,
      CaretCandidate = tinymce.caret.CaretCandidate;

    var isContentEditableFalse = NodeType.isContentEditableFalse,
      findNode = CaretUtils.findNode,
      curry = Fun.curry;

    function distanceToRectLeft(clientRect, clientX) {
      return Math.abs(clientRect.left - clientX);
    }

    function distanceToRectRight(clientRect, clientX) {
      return Math.abs(clientRect.right - clientX);
    }

    function findClosestClientRect(clientRects, clientX) {
      function isInside(clientX, clientRect) {
        return clientX >= clientRect.left && clientX <= clientRect.right;
      }

      return Arr.reduce(clientRects, function (oldClientRect, clientRect) {
        var oldDistance, newDistance;

        oldDistance = Math.min(distanceToRectLeft(oldClientRect, clientX), distanceToRectRight(oldClientRect, clientX));
        newDistance = Math.min(distanceToRectLeft(clientRect, clientX), distanceToRectRight(clientRect, clientX));

        if (isInside(clientX, clientRect)) {
          return clientRect;
        }

        if (isInside(clientX, oldClientRect)) {
          return oldClientRect;
        }

        // cE=false has higher priority
        if (newDistance == oldDistance && isContentEditableFalse(clientRect.node)) {
          return clientRect;
        }

        if (newDistance < oldDistance) {
          return clientRect;
        }

        return oldClientRect;
      });
    }

    function walkUntil(direction, rootNode, predicateFn, node) {
      while ((node = findNode(node, direction, CaretCandidate.isEditableCaretCandidate, rootNode))) {
        if (predicateFn(node)) {
          return;
        }
      }
    }

    function findLineNodeRects(rootNode, targetNodeRect) {
      var clientRects = [];

      function collect(checkPosFn, node) {
        var lineRects;

        lineRects = Arr.filter(Dimensions.getClientRects(node), function (clientRect) {
          return !checkPosFn(clientRect, targetNodeRect);
        });

        clientRects = clientRects.concat(lineRects);

        return lineRects.length === 0;
      }

      clientRects.push(targetNodeRect);
      walkUntil(-1, rootNode, curry(collect, ClientRect.isAbove), targetNodeRect.node);
      walkUntil(1, rootNode, curry(collect, ClientRect.isBelow), targetNodeRect.node);

      return clientRects;
    }

    function getContentEditableFalseChildren(rootNode) {
      return Arr.filter(Arr.toArray(rootNode.getElementsByTagName('*')), isContentEditableFalse);
    }

    function caretInfo(clientRect, clientX) {
      return {
        node: clientRect.node,
        before: distanceToRectLeft(clientRect, clientX) < distanceToRectRight(clientRect, clientX)
      };
    }

    function closestCaret(rootNode, clientX, clientY) {
      var contentEditableFalseNodeRects, closestNodeRect;

      contentEditableFalseNodeRects = Dimensions.getClientRects(getContentEditableFalseChildren(rootNode));
      contentEditableFalseNodeRects = Arr.filter(contentEditableFalseNodeRects, function (clientRect) {
        return clientY >= clientRect.top && clientY <= clientRect.bottom;
      });

      closestNodeRect = findClosestClientRect(contentEditableFalseNodeRects, clientX);
      if (closestNodeRect) {
        closestNodeRect = findClosestClientRect(findLineNodeRects(rootNode, closestNodeRect), clientX);
        if (closestNodeRect && isContentEditableFalse(closestNodeRect.node)) {
          return caretInfo(closestNodeRect, clientX);
        }
      }

      return null;
    }

    tinymce.caret.LineUtils = {
      findClosestClientRect: findClosestClientRect,
      findLineNodeRects: findLineNodeRects,
      closestCaret: closestCaret
    };

  })(tinymce);

  /**
   * LineWalker.js
   *
   * Released under LGPL License.
   * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
   *
   * License: http://www.tinymce.com/license - Inactive
   * Licence: GNU/LGPL 2.1 or later - http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
   * Contributing: http://www.tinymce.com/contributing - Inactive
   */

  /**
   * This module lets you walk the document line by line
   * returing nodes and client rects for each line.
   *
   * @private
   * @class tinymce.caret.LineWalker
   */
  (function (tinymce) {
    var Fun = tinymce.util.Fun, Arr = tinymce.util.Arr,
      Dimensions = tinymce.dom.Dimensions,
      ClientRect = tinymce.geom.ClientRect,
      CaretUtils = tinymce.caret.CaretUtils,
      CaretCandidate = tinymce.caret.CaretCandidate,
      CaretWalker = tinymce.caret.CaretWalker,
      CaretPosition = tinymce.caret.CaretPosition;

    var curry = Fun.curry;

    function findUntil(direction, rootNode, predicateFn, node) {
      while ((node = CaretUtils.findNode(node, direction, CaretCandidate.isEditableCaretCandidate, rootNode))) {
        if (predicateFn(node)) {
          return;
        }
      }
    }

    function walkUntil(direction, isAboveFn, isBeflowFn, rootNode, predicateFn, caretPosition) {
      var line = 0,
        node, result = [],
        targetClientRect;

      function add(node) {
        var i, clientRect, clientRects;

        clientRects = Dimensions.getClientRects(node);
        if (direction == -1) {
          clientRects = clientRects.reverse();
        }

        for (i = 0; i < clientRects.length; i++) {
          clientRect = clientRects[i];
          if (isBeflowFn(clientRect, targetClientRect)) {
            continue;
          }

          if (result.length > 0 && isAboveFn(clientRect, Arr.last(result))) {
            line++;
          }

          clientRect.line = line;

          if (predicateFn(clientRect)) {
            return true;
          }

          result.push(clientRect);
        }
      }

      targetClientRect = Arr.last(caretPosition.getClientRects());
      if (!targetClientRect) {
        return result;
      }

      node = caretPosition.getNode();
      add(node);
      findUntil(direction, rootNode, add, node);

      return result;
    }

    function aboveLineNumber(lineNumber, clientRect) {
      return clientRect.line > lineNumber;
    }

    function isLine(lineNumber, clientRect) {
      return clientRect.line === lineNumber;
    }

    var upUntil = curry(walkUntil, -1, ClientRect.isAbove, ClientRect.isBelow);
    var downUntil = curry(walkUntil, 1, ClientRect.isBelow, ClientRect.isAbove);

    function positionsUntil(direction, rootNode, predicateFn, node) {
      var caretWalker = new CaretWalker(rootNode),
        walkFn, isBelowFn, isAboveFn,
        caretPosition, result = [],
        line = 0,
        clientRect, targetClientRect;

      function getClientRect(caretPosition) {
        if (direction == 1) {
          return Arr.last(caretPosition.getClientRects());
        }

        return Arr.last(caretPosition.getClientRects());
      }

      if (direction == 1) {
        walkFn = caretWalker.next;
        isBelowFn = ClientRect.isBelow;
        isAboveFn = ClientRect.isAbove;
        caretPosition = CaretPosition.after(node);
      } else {
        walkFn = caretWalker.prev;
        isBelowFn = ClientRect.isAbove;
        isAboveFn = ClientRect.isBelow;
        caretPosition = CaretPosition.before(node);
      }

      targetClientRect = getClientRect(caretPosition);

      do {
        if (!caretPosition.isVisible()) {
          continue;
        }

        clientRect = getClientRect(caretPosition);

        if (isAboveFn(clientRect, targetClientRect)) {
          continue;
        }

        if (result.length > 0 && isBelowFn(clientRect, Arr.last(result))) {
          line++;
        }

        clientRect = ClientRect.clone(clientRect);
        clientRect.position = caretPosition;
        clientRect.line = line;

        if (predicateFn(clientRect)) {
          return result;
        }

        result.push(clientRect);
      } while ((caretPosition = walkFn(caretPosition)));

      return result;
    }

    tinymce.caret.LineWalker = {
      upUntil: upUntil,
      downUntil: downUntil,

      /**
       * Find client rects with line and caret position until the predicate returns true.
       *
       * @method positionsUntil
       * @param {Number} direction Direction forward/backward 1/-1.
       * @param {DOMNode} rootNode Root node to walk within.
       * @param {function} predicateFn Gets the client rect as it's input.
       * @param {DOMNode} node Node to start walking from.
       * @return {Array} Array of client rects with line and position properties.
       */
      positionsUntil: positionsUntil,

      isAboveLine: curry(aboveLineNumber),
      isLine: curry(isLine)
    };

  })(tinymce);

  /*jshint bitwise:false, expr:true, noempty:false, sub:true, eqnull:true, latedef:false, maxlen:255 */
  /*eslint-disable */

  /*
   * Sizzle CSS Selector Engine
   *  Copyright, The Dojo Foundation
   *  Released under the MIT, BSD, and GPL Licenses.
   *  More information: http://sizzlejs.com/
   */
  (function (tinymce) {

  	var i,
  		support,
  		Expr,
  		getText,
  		isXML,
  		tokenize,
  		compile,
  		select,
  		outermostContext,
  		sortInput,
  		hasDuplicate,

  		// Local document vars
  		setDocument,
  		document,
  		docElem,
  		documentIsHTML,
  		rbuggyQSA,
  		rbuggyMatches,
  		matches,
  		contains,

  		// Instance-specific data
  		expando = "sizzle" + -(new Date()),
  		preferredDoc = window.document,
  		dirruns = 0,
  		done = 0,
  		classCache = createCache(),
  		tokenCache = createCache(),
  		compilerCache = createCache(),
  		sortOrder = function (a, b) {
  			if (a === b) {
  				hasDuplicate = true;
  			}
  			return 0;
  		},

  		// General-purpose constants
  		strundefined = typeof undefined,
  		MAX_NEGATIVE = 1 << 31,

  		// Instance methods
  		hasOwn = ({}).hasOwnProperty,
  		arr = [],
  		pop = arr.pop,
  		push_native = arr.push,
  		push = arr.push,
  		slice = arr.slice,
  		// Use a stripped-down indexOf if we can't use a native one
  		indexOf = arr.indexOf || function (elem) {
  			var i = 0,
  				len = this.length;
  			for (; i < len; i++) {
  				if (this[i] === elem) {
  					return i;
  				}
  			}
  			return -1;
  		},

  		booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",

  		// Regular expressions

  		// http://www.w3.org/TR/css3-selectors/#whitespace
  		whitespace = "[\\x20\\t\\r\\n\\f]",

  		// http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
  		identifier = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",

  		// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
  		attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace +
  		// Operator (capture 2)
  		"*([*^$|!~]?=)" + whitespace +
  		// "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
  		"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace +
  		"*\\]",

  		pseudos = ":(" + identifier + ")(?:\\((" +
  		// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
  		// 1. quoted (capture 3; capture 4 or capture 5)
  		"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +
  		// 2. simple (capture 6)
  		"((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +
  		// 3. anything else (capture 2)
  		".*" +
  		")\\)|)",

  		// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
  		rtrim = new RegExp("^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g"),

  		rcomma = new RegExp("^" + whitespace + "*," + whitespace + "*"),
  		rcombinators = new RegExp("^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*"),

  		rattributeQuotes = new RegExp("=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g"),

  		rpseudo = new RegExp(pseudos),
  		ridentifier = new RegExp("^" + identifier + "$"),

  		matchExpr = {
  			"ID": new RegExp("^#(" + identifier + ")"),
  			"CLASS": new RegExp("^\\.(" + identifier + ")"),
  			"TAG": new RegExp("^(" + identifier + "|[*])"),
  			"ATTR": new RegExp("^" + attributes),
  			"PSEUDO": new RegExp("^" + pseudos),
  			"CHILD": new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace +
  				"*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
  				"*(\\d+)|))" + whitespace + "*\\)|)", "i"),
  			"bool": new RegExp("^(?:" + booleans + ")$", "i"),
  			// For use in libraries implementing .is()
  			// We use this for POS matching in `select`
  			"needsContext": new RegExp("^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +
  				whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i")
  		},

  		rinputs = /^(?:input|select|textarea|button)$/i,
  		rheader = /^h\d$/i,

  		rnative = /^[^{]+\{\s*\[native \w/,

  		// Easily-parseable/retrievable ID or TAG or CLASS selectors
  		rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

  		rsibling = /[+~]/,
  		rescape = /'|\\/g,

  		// CSS escapes http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
  		runescape = new RegExp("\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig"),
  		funescape = function (_, escaped, escapedWhitespace) {
  			var high = "0x" + escaped - 0x10000;
  			// NaN means non-codepoint
  			// Support: Firefox<24
  			// Workaround erroneous numeric interpretation of +"0x"
  			return high !== high || escapedWhitespace ?
  				escaped :
  				high < 0 ?
  				// BMP codepoint
  				String.fromCharCode(high + 0x10000) :
  				// Supplemental Plane codepoint (surrogate pair)
  				String.fromCharCode(high >> 10 | 0xD800, high & 0x3FF | 0xDC00);
  		};

  	// Optimize for push.apply( _, NodeList )
  	try {
  		push.apply(
  			(arr = slice.call(preferredDoc.childNodes)),
  			preferredDoc.childNodes
  		);
  		// Support: Android<4.0
  		// Detect silently failing push.apply
  		arr[preferredDoc.childNodes.length].nodeType;
  	} catch (e) {
  		push = {
  			apply: arr.length ?

  				// Leverage slice if possible
  				function (target, els) {
  					push_native.apply(target, slice.call(els));
  				} :

  				// Support: IE<9
  				// Otherwise append directly
  				function (target, els) {
  					var j = target.length,
  						i = 0;
  					// Can't trust NodeList.length
  					while ((target[j++] = els[i++])) {}
  					target.length = j - 1;
  				}
  		};
  	}

  	function Sizzle(selector, context, results, seed) {
  		var match, elem, m, nodeType,
  			// QSA vars
  			i, groups, old, nid, newContext, newSelector;

  		if ((context ? context.ownerDocument || context : preferredDoc) !== document) {
  			setDocument(context);
  		}

  		context = context || document;
  		results = results || [];

  		if (!selector || typeof selector !== "string") {
  			return results;
  		}

  		if ((nodeType = context.nodeType) !== 1 && nodeType !== 9) {
  			return [];
  		}

  		if (documentIsHTML && !seed) {

  			// Shortcuts
  			if ((match = rquickExpr.exec(selector))) {
  				// Speed-up: Sizzle("#ID")
  				if ((m = match[1])) {
  					if (nodeType === 9) {
  						elem = context.getElementById(m);
  						// Check parentNode to catch when Blackberry 4.6 returns
  						// nodes that are no longer in the document (jQuery #6963)
  						if (elem && elem.parentNode) {
  							// Handle the case where IE, Opera, and Webkit return items
  							// by name instead of ID
  							if (elem.id === m) {
  								results.push(elem);
  								return results;
  							}
  						} else {
  							return results;
  						}
  					} else {
  						// Context is not a document
  						if (context.ownerDocument && (elem = context.ownerDocument.getElementById(m)) &&
  							contains(context, elem) && elem.id === m) {
  							results.push(elem);
  							return results;
  						}
  					}

  					// Speed-up: Sizzle("TAG")
  				} else if (match[2]) {
  					push.apply(results, context.getElementsByTagName(selector));
  					return results;

  					// Speed-up: Sizzle(".CLASS")
  				} else if ((m = match[3]) && support.getElementsByClassName) {
  					push.apply(results, context.getElementsByClassName(m));
  					return results;
  				}
  			}

  			// QSA path
  			if (support.qsa && (!rbuggyQSA || !rbuggyQSA.test(selector))) {
  				nid = old = expando;
  				newContext = context;
  				newSelector = nodeType === 9 && selector;

  				// qSA works strangely on Element-rooted queries
  				// We can work around this by specifying an extra ID on the root
  				// and working up from there (Thanks to Andrew Dupont for the technique)
  				// IE 8 doesn't work on object elements
  				if (nodeType === 1 && context.nodeName.toLowerCase() !== "object") {
  					groups = tokenize(selector);

  					if ((old = context.getAttribute("id"))) {
  						nid = old.replace(rescape, "\\$&");
  					} else {
  						context.setAttribute("id", nid);
  					}
  					nid = "[id='" + nid + "'] ";

  					i = groups.length;
  					while (i--) {
  						groups[i] = nid + toSelector(groups[i]);
  					}
  					newContext = rsibling.test(selector) && testContext(context.parentNode) || context;
  					newSelector = groups.join(",");
  				}

  				if (newSelector) {
  					try {
  						push.apply(results,
  							newContext.querySelectorAll(newSelector)
  						);
  						return results;
  					} catch (qsaError) {} finally {
  						if (!old) {
  							context.removeAttribute("id");
  						}
  					}
  				}
  			}
  		}

  		// All others
  		return select(selector.replace(rtrim, "$1"), context, results, seed);
  	}

  	/**
  	 * Create key-value caches of limited size
  	 * @returns {Function(string, Object)} Returns the Object data after storing it on itself with
  	 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
  	 *	deleting the oldest entry
  	 */
  	function createCache() {
  		var keys = [];

  		function cache(key, value) {
  			// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
  			if (keys.push(key + " ") > Expr.cacheLength) {
  				// Only keep the most recent entries
  				delete cache[keys.shift()];
  			}
  			return (cache[key + " "] = value);
  		}
  		return cache;
  	}

  	/**
  	 * Mark a function for special use by Sizzle
  	 * @param {Function} fn The function to mark
  	 */
  	function markFunction(fn) {
  		fn[expando] = true;
  		return fn;
  	}

  	/**
  	 * Support testing using an element
  	 * @param {Function} fn Passed the created div and expects a boolean result
  	 */
  	function assert(fn) {
  		var div = document.createElement("div");

  		try {
  			return !!fn(div);
  		} catch (e) {
  			return false;
  		} finally {
  			// Remove from its parent by default
  			if (div.parentNode) {
  				div.parentNode.removeChild(div);
  			}
  			// release memory in IE
  			div = null;
  		}
  	}

  	/**
  	 * Adds the same handler for all of the specified attrs
  	 * @param {String} attrs Pipe-separated list of attributes
  	 * @param {Function} handler The method that will be applied
  	 */
  	function addHandle(attrs, handler) {
  		var arr = attrs.split("|"),
  			i = attrs.length;

  		while (i--) {
  			Expr.attrHandle[arr[i]] = handler;
  		}
  	}

  	/**
  	 * Checks document order of two siblings
  	 * @param {Element} a
  	 * @param {Element} b
  	 * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
  	 */
  	function siblingCheck(a, b) {
  		var cur = b && a,
  			diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
  			(~b.sourceIndex || MAX_NEGATIVE) -
  			(~a.sourceIndex || MAX_NEGATIVE);

  		// Use IE sourceIndex if available on both nodes
  		if (diff) {
  			return diff;
  		}

  		// Check if b follows a
  		if (cur) {
  			while ((cur = cur.nextSibling)) {
  				if (cur === b) {
  					return -1;
  				}
  			}
  		}

  		return a ? 1 : -1;
  	}

  	/**
  	 * Returns a function to use in pseudos for input types
  	 * @param {String} type
  	 */
  	function createInputPseudo(type) {
  		return function (elem) {
  			var name = elem.nodeName.toLowerCase();
  			return name === "input" && elem.type === type;
  		};
  	}

  	/**
  	 * Returns a function to use in pseudos for buttons
  	 * @param {String} type
  	 */
  	function createButtonPseudo(type) {
  		return function (elem) {
  			var name = elem.nodeName.toLowerCase();
  			return (name === "input" || name === "button") && elem.type === type;
  		};
  	}

  	/**
  	 * Returns a function to use in pseudos for positionals
  	 * @param {Function} fn
  	 */
  	function createPositionalPseudo(fn) {
  		return markFunction(function (argument) {
  			argument = +argument;
  			return markFunction(function (seed, matches) {
  				var j,
  					matchIndexes = fn([], seed.length, argument),
  					i = matchIndexes.length;

  				// Match elements found at the specified indexes
  				while (i--) {
  					if (seed[(j = matchIndexes[i])]) {
  						seed[j] = !(matches[j] = seed[j]);
  					}
  				}
  			});
  		});
  	}

  	/**
  	 * Checks a node for validity as a Sizzle context
  	 * @param {Element|Object=} context
  	 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
  	 */
  	function testContext(context) {
  		return context && typeof context.getElementsByTagName !== strundefined && context;
  	}

  	// Expose support vars for convenience
  	support = Sizzle.support = {};

  	/**
  	 * Detects XML nodes
  	 * @param {Element|Object} elem An element or a document
  	 * @returns {Boolean} True iff elem is a non-HTML XML node
  	 */
  	isXML = Sizzle.isXML = function (elem) {
  		// documentElement is verified for cases where it doesn't yet exist
  		// (such as loading iframes in IE - #4833)
  		var documentElement = elem && (elem.ownerDocument || elem).documentElement;
  		return documentElement ? documentElement.nodeName !== "HTML" : false;
  	};

  	/**
  	 * Sets document-related variables once based on the current document
  	 * @param {Element|Object} [doc] An element or document object to use to set the document
  	 * @returns {Object} Returns the current document
  	 */
  	setDocument = Sizzle.setDocument = function (node) {
  		var hasCompare,
  			doc = node ? node.ownerDocument || node : preferredDoc,
  			parent = doc.defaultView;

  		function getTop(win) {
  			// Edge throws a lovely Object expected if you try to get top on a detached reference see #2642
  			try {
  				return win.top;
  			} catch (ex) {
  				// Ignore
  			}

  			return null;
  		}

  		// If no document and documentElement is available, return
  		if (doc === document || doc.nodeType !== 9 || !doc.documentElement) {
  			return document;
  		}

  		// Set our document
  		document = doc;
  		docElem = doc.documentElement;

  		// Support tests
  		documentIsHTML = !isXML(doc);

  		// Support: IE>8
  		// If iframe document is assigned to "document" variable and if iframe has been reloaded,
  		// IE will throw "permission denied" error when accessing "document" variable, see jQuery #13936
  		// IE6-8 do not support the defaultView property so parent will be undefined
  		if (parent && parent !== getTop(parent)) {
  			// IE11 does not have attachEvent, so all must suffer
  			if (parent.addEventListener) {
  				parent.addEventListener("unload", function () {
  					setDocument();
  				}, false);
  			} else if (parent.attachEvent) {
  				parent.attachEvent("onunload", function () {
  					setDocument();
  				});
  			}
  		}

  		/* Attributes
  		---------------------------------------------------------------------- */

  		// Support: IE<8
  		// Verify that getAttribute really returns attributes and not properties (excepting IE8 booleans)
  		support.attributes = assert(function (div) {
  			div.className = "i";
  			return !div.getAttribute("className");
  		});

  		/* getElement(s)By*
  		---------------------------------------------------------------------- */

  		// Check if getElementsByTagName("*") returns only elements
  		support.getElementsByTagName = assert(function (div) {
  			div.appendChild(doc.createComment(""));
  			return !div.getElementsByTagName("*").length;
  		});

  		// Support: IE<9
  		support.getElementsByClassName = rnative.test(doc.getElementsByClassName);

  		// Support: IE<10
  		// Check if getElementById returns elements by name
  		// The broken getElementById methods don't pick up programatically-set names,
  		// so use a roundabout getElementsByName test
  		support.getById = assert(function (div) {
  			docElem.appendChild(div).id = expando;
  			return !doc.getElementsByName || !doc.getElementsByName(expando).length;
  		});

  		// ID find and filter
  		if (support.getById) {
  			Expr.find["ID"] = function (id, context) {
  				if (typeof context.getElementById !== strundefined && documentIsHTML) {
  					var m = context.getElementById(id);
  					// Check parentNode to catch when Blackberry 4.6 returns
  					// nodes that are no longer in the document #6963
  					return m && m.parentNode ? [m] : [];
  				}
  			};
  			Expr.filter["ID"] = function (id) {
  				var attrId = id.replace(runescape, funescape);
  				return function (elem) {
  					return elem.getAttribute("id") === attrId;
  				};
  			};
  		} else {
  			// Support: IE6/7
  			// getElementById is not reliable as a find shortcut
  			delete Expr.find["ID"];

  			Expr.filter["ID"] = function (id) {
  				var attrId = id.replace(runescape, funescape);
  				return function (elem) {
  					var node = typeof elem.getAttributeNode !== strundefined && elem.getAttributeNode("id");
  					return node && node.value === attrId;
  				};
  			};
  		}

  		// Tag
  		Expr.find["TAG"] = support.getElementsByTagName ?
  			function (tag, context) {
  				if (typeof context.getElementsByTagName !== strundefined) {
  					return context.getElementsByTagName(tag);
  				}
  			} :
  			function (tag, context) {
  				var elem,
  					tmp = [],
  					i = 0,
  					results = context.getElementsByTagName(tag);

  				// Filter out possible comments
  				if (tag === "*") {
  					while ((elem = results[i++])) {
  						if (elem.nodeType === 1) {
  							tmp.push(elem);
  						}
  					}

  					return tmp;
  				}
  				return results;
  			};

  		// Class
  		Expr.find["CLASS"] = support.getElementsByClassName && function (className, context) {
  			if (documentIsHTML) {
  				return context.getElementsByClassName(className);
  			}
  		};

  		/* QSA/matchesSelector
  		---------------------------------------------------------------------- */

  		// QSA and matchesSelector support

  		// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
  		rbuggyMatches = [];

  		// qSa(:focus) reports false when true (Chrome 21)
  		// We allow this because of a bug in IE8/9 that throws an error
  		// whenever `document.activeElement` is accessed on an iframe
  		// So, we allow :focus to pass through QSA all the time to avoid the IE error
  		// See http://bugs.jquery.com/ticket/13378
  		rbuggyQSA = [];

  		if ((support.qsa = rnative.test(doc.querySelectorAll))) {
  			// Build QSA regex
  			// Regex strategy adopted from Diego Perini
  			assert(function (div) {
  				// Select is set to empty string on purpose
  				// This is to test IE's treatment of not explicitly
  				// setting a boolean content attribute,
  				// since its presence should be enough
  				// http://bugs.jquery.com/ticket/12359
  				div.innerHTML = "<select msallowcapture=''><option selected=''></option></select>";

  				// Support: IE8, Opera 11-12.16
  				// Nothing should be selected when empty strings follow ^= or $= or *=
  				// The test attribute must be unknown in Opera but "safe" for WinRT
  				// http://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
  				if (div.querySelectorAll("[msallowcapture^='']").length) {
  					rbuggyQSA.push("[*^$]=" + whitespace + "*(?:''|\"\")");
  				}

  				// Support: IE8
  				// Boolean attributes and "value" are not treated correctly
  				if (!div.querySelectorAll("[selected]").length) {
  					rbuggyQSA.push("\\[" + whitespace + "*(?:value|" + booleans + ")");
  				}

  				// Webkit/Opera - :checked should return selected option elements
  				// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
  				// IE8 throws error here and will not see later tests
  				if (!div.querySelectorAll(":checked").length) {
  					rbuggyQSA.push(":checked");
  				}
  			});

  			assert(function (div) {
  				// Support: Windows 8 Native Apps
  				// The type and name attributes are restricted during .innerHTML assignment
  				var input = doc.createElement("input");
  				input.setAttribute("type", "hidden");
  				div.appendChild(input).setAttribute("name", "D");

  				// Support: IE8
  				// Enforce case-sensitivity of name attribute
  				if (div.querySelectorAll("[name=d]").length) {
  					rbuggyQSA.push("name" + whitespace + "*[*^$|!~]?=");
  				}

  				// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
  				// IE8 throws error here and will not see later tests
  				if (!div.querySelectorAll(":enabled").length) {
  					rbuggyQSA.push(":enabled", ":disabled");
  				}

  				// Opera 10-11 does not throw on post-comma invalid pseudos
  				div.querySelectorAll("*,:x");
  				rbuggyQSA.push(",.*:");
  			});
  		}

  		if ((support.matchesSelector = rnative.test((matches = docElem.matches ||
  				docElem.webkitMatchesSelector ||
  				docElem.mozMatchesSelector ||
  				docElem.oMatchesSelector ||
  				docElem.msMatchesSelector)))) {

  			assert(function (div) {
  				// Check to see if it's possible to do matchesSelector
  				// on a disconnected node (IE 9)
  				support.disconnectedMatch = matches.call(div, "div");

  				// This should fail with an exception
  				// Gecko does not error, returns false instead
  				matches.call(div, "[s!='']:x");
  				rbuggyMatches.push("!=", pseudos);
  			});
  		}

  		rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join("|"));
  		rbuggyMatches = rbuggyMatches.length && new RegExp(rbuggyMatches.join("|"));

  		/* Contains
  		---------------------------------------------------------------------- */
  		hasCompare = rnative.test(docElem.compareDocumentPosition);

  		// Element contains another
  		// Purposefully does not implement inclusive descendent
  		// As in, an element does not contain itself
  		contains = hasCompare || rnative.test(docElem.contains) ?
  			function (a, b) {
  				var adown = a.nodeType === 9 ? a.documentElement : a,
  					bup = b && b.parentNode;
  				return a === bup || !!(bup && bup.nodeType === 1 && (
  					adown.contains ?
  					adown.contains(bup) :
  					a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16
  				));
  			} :
  			function (a, b) {
  				if (b) {
  					while ((b = b.parentNode)) {
  						if (b === a) {
  							return true;
  						}
  					}
  				}
  				return false;
  			};

  		/* Sorting
  		---------------------------------------------------------------------- */

  		// Document order sorting
  		sortOrder = hasCompare ?
  			function (a, b) {

  				// Flag for duplicate removal
  				if (a === b) {
  					hasDuplicate = true;
  					return 0;
  				}

  				// Sort on method existence if only one input has compareDocumentPosition
  				var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
  				if (compare) {
  					return compare;
  				}

  				// Calculate position if both inputs belong to the same document
  				compare = (a.ownerDocument || a) === (b.ownerDocument || b) ?
  					a.compareDocumentPosition(b) :

  					// Otherwise we know they are disconnected
  					1;

  				// Disconnected nodes
  				if (compare & 1 ||
  					(!support.sortDetached && b.compareDocumentPosition(a) === compare)) {

  					// Choose the first element that is related to our preferred document
  					if (a === doc || a.ownerDocument === preferredDoc && contains(preferredDoc, a)) {
  						return -1;
  					}
  					if (b === doc || b.ownerDocument === preferredDoc && contains(preferredDoc, b)) {
  						return 1;
  					}

  					// Maintain original order
  					return sortInput ?
  						(indexOf.call(sortInput, a) - indexOf.call(sortInput, b)) :
  						0;
  				}

  				return compare & 4 ? -1 : 1;
  			} :
  			function (a, b) {
  				// Exit early if the nodes are identical
  				if (a === b) {
  					hasDuplicate = true;
  					return 0;
  				}

  				var cur,
  					i = 0,
  					aup = a.parentNode,
  					bup = b.parentNode,
  					ap = [a],
  					bp = [b];

  				// Parentless nodes are either documents or disconnected
  				if (!aup || !bup) {
  					return a === doc ? -1 :
  						b === doc ? 1 :
  						aup ? -1 :
  						bup ? 1 :
  						sortInput ?
  						(indexOf.call(sortInput, a) - indexOf.call(sortInput, b)) :
  						0;

  					// If the nodes are siblings, we can do a quick check
  				} else if (aup === bup) {
  					return siblingCheck(a, b);
  				}

  				// Otherwise we need full lists of their ancestors for comparison
  				cur = a;
  				while ((cur = cur.parentNode)) {
  					ap.unshift(cur);
  				}
  				cur = b;
  				while ((cur = cur.parentNode)) {
  					bp.unshift(cur);
  				}

  				// Walk down the tree looking for a discrepancy
  				while (ap[i] === bp[i]) {
  					i++;
  				}

  				return i ?
  					// Do a sibling check if the nodes have a common ancestor
  					siblingCheck(ap[i], bp[i]) :

  					// Otherwise nodes in our document sort first
  					ap[i] === preferredDoc ? -1 :
  					bp[i] === preferredDoc ? 1 :
  					0;
  			};

  		return doc;
  	};

  	Sizzle.matches = function (expr, elements) {
  		return Sizzle(expr, null, null, elements);
  	};

  	Sizzle.matchesSelector = function (elem, expr) {
  		// Set document vars if needed
  		if ((elem.ownerDocument || elem) !== document) {
  			setDocument(elem);
  		}

  		// Make sure that attribute selectors are quoted
  		expr = expr.replace(rattributeQuotes, "='$1']");

  		if (support.matchesSelector && documentIsHTML &&
  			(!rbuggyMatches || !rbuggyMatches.test(expr)) &&
  			(!rbuggyQSA || !rbuggyQSA.test(expr))) {

  			try {
  				var ret = matches.call(elem, expr);

  				// IE 9's matchesSelector returns false on disconnected nodes
  				if (ret || support.disconnectedMatch ||
  					// As well, disconnected nodes are said to be in a document
  					// fragment in IE 9
  					elem.document && elem.document.nodeType !== 11) {
  					return ret;
  				}
  			} catch (e) {}
  		}

  		return Sizzle(expr, document, null, [elem]).length > 0;
  	};

  	Sizzle.contains = function (context, elem) {
  		// Set document vars if needed
  		if ((context.ownerDocument || context) !== document) {
  			setDocument(context);
  		}
  		return contains(context, elem);
  	};

  	Sizzle.attr = function (elem, name) {
  		// Set document vars if needed
  		if ((elem.ownerDocument || elem) !== document) {
  			setDocument(elem);
  		}

  		var fn = Expr.attrHandle[name.toLowerCase()],
  			// Don't get fooled by Object.prototype properties (jQuery #13807)
  			val = fn && hasOwn.call(Expr.attrHandle, name.toLowerCase()) ?
  			fn(elem, name, !documentIsHTML) :
  			undefined;

  		return val !== undefined ?
  			val :
  			support.attributes || !documentIsHTML ?
  			elem.getAttribute(name) :
  			(val = elem.getAttributeNode(name)) && val.specified ?
  			val.value :
  			null;
  	};

  	Sizzle.error = function (msg) {
  		throw new Error("Syntax error, unrecognized expression: " + msg);
  	};

  	/**
  	 * Document sorting and removing duplicates
  	 * @param {ArrayLike} results
  	 */
  	Sizzle.uniqueSort = function (results) {
  		var elem,
  			duplicates = [],
  			j = 0,
  			i = 0;

  		// Unless we *know* we can detect duplicates, assume their presence
  		hasDuplicate = !support.detectDuplicates;
  		sortInput = !support.sortStable && results.slice(0);
  		results.sort(sortOrder);

  		if (hasDuplicate) {
  			while ((elem = results[i++])) {
  				if (elem === results[i]) {
  					j = duplicates.push(i);
  				}
  			}
  			while (j--) {
  				results.splice(duplicates[j], 1);
  			}
  		}

  		// Clear input after sorting to release objects
  		// See https://github.com/jquery/sizzle/pull/225
  		sortInput = null;

  		return results;
  	};

  	/**
  	 * Utility function for retrieving the text value of an array of DOM nodes
  	 * @param {Array|Element} elem
  	 */
  	getText = Sizzle.getText = function (elem) {
  		var node,
  			ret = "",
  			i = 0,
  			nodeType = elem.nodeType;

  		if (!nodeType) {
  			// If no nodeType, this is expected to be an array
  			while ((node = elem[i++])) {
  				// Do not traverse comment nodes
  				ret += getText(node);
  			}
  		} else if (nodeType === 1 || nodeType === 9 || nodeType === 11) {
  			// Use textContent for elements
  			// innerText usage removed for consistency of new lines (jQuery #11153)
  			if (typeof elem.textContent === "string") {
  				return elem.textContent;
  			} else {
  				// Traverse its children
  				for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
  					ret += getText(elem);
  				}
  			}
  		} else if (nodeType === 3 || nodeType === 4) {
  			return elem.nodeValue;
  		}
  		// Do not include comment or processing instruction nodes

  		return ret;
  	};

  	Expr = Sizzle.selectors = {

  		// Can be adjusted by the user
  		cacheLength: 50,

  		createPseudo: markFunction,

  		match: matchExpr,

  		attrHandle: {},

  		find: {},

  		relative: {
  			">": {
  				dir: "parentNode",
  				first: true
  			},
  			" ": {
  				dir: "parentNode"
  			},
  			"+": {
  				dir: "previousSibling",
  				first: true
  			},
  			"~": {
  				dir: "previousSibling"
  			}
  		},

  		preFilter: {
  			"ATTR": function (match) {
  				match[1] = match[1].replace(runescape, funescape);

  				// Move the given value to match[3] whether quoted or unquoted
  				match[3] = (match[3] || match[4] || match[5] || "").replace(runescape, funescape);

  				if (match[2] === "~=") {
  					match[3] = " " + match[3] + " ";
  				}

  				return match.slice(0, 4);
  			},

  			"CHILD": function (match) {
  				/* matches from matchExpr["CHILD"]
  					1 type (only|nth|...)
  					2 what (child|of-type)
  					3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
  					4 xn-component of xn+y argument ([+-]?\d*n|)
  					5 sign of xn-component
  					6 x of xn-component
  					7 sign of y-component
  					8 y of y-component
  				*/
  				match[1] = match[1].toLowerCase();

  				if (match[1].slice(0, 3) === "nth") {
  					// nth-* requires argument
  					if (!match[3]) {
  						Sizzle.error(match[0]);
  					}

  					// numeric x and y parameters for Expr.filter.CHILD
  					// remember that false/true cast respectively to 0/1
  					match[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * (match[3] === "even" || match[3] === "odd"));
  					match[5] = +((match[7] + match[8]) || match[3] === "odd");

  					// other types prohibit arguments
  				} else if (match[3]) {
  					Sizzle.error(match[0]);
  				}

  				return match;
  			},

  			"PSEUDO": function (match) {
  				var excess,
  					unquoted = !match[6] && match[2];

  				if (matchExpr["CHILD"].test(match[0])) {
  					return null;
  				}

  				// Accept quoted arguments as-is
  				if (match[3]) {
  					match[2] = match[4] || match[5] || "";

  					// Strip excess characters from unquoted arguments
  				} else if (unquoted && rpseudo.test(unquoted) &&
  					// Get excess from tokenize (recursively)
  					(excess = tokenize(unquoted, true)) &&
  					// advance to the next closing parenthesis
  					(excess = unquoted.indexOf(")", unquoted.length - excess) - unquoted.length)) {

  					// excess is a negative index
  					match[0] = match[0].slice(0, excess);
  					match[2] = unquoted.slice(0, excess);
  				}

  				// Return only captures needed by the pseudo filter method (type and argument)
  				return match.slice(0, 3);
  			}
  		},

  		filter: {

  			"TAG": function (nodeNameSelector) {
  				var nodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();
  				return nodeNameSelector === "*" ?
  					function () {
  						return true;
  					} :
  					function (elem) {
  						return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
  					};
  			},

  			"CLASS": function (className) {
  				var pattern = classCache[className + " "];

  				return pattern ||
  					(pattern = new RegExp("(^|" + whitespace + ")" + className + "(" + whitespace + "|$)")) &&
  					classCache(className, function (elem) {
  						return pattern.test(typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== strundefined && elem.getAttribute("class") || "");
  					});
  			},

  			"ATTR": function (name, operator, check) {
  				return function (elem) {
  					var result = Sizzle.attr(elem, name);

  					if (result == null) {
  						return operator === "!=";
  					}
  					if (!operator) {
  						return true;
  					}

  					result += "";

  					return operator === "=" ? result === check :
  						operator === "!=" ? result !== check :
  						operator === "^=" ? check && result.indexOf(check) === 0 :
  						operator === "*=" ? check && result.indexOf(check) > -1 :
  						operator === "$=" ? check && result.slice(-check.length) === check :
  						operator === "~=" ? (" " + result + " ").indexOf(check) > -1 :
  						operator === "|=" ? result === check || result.slice(0, check.length + 1) === check + "-" :
  						false;
  				};
  			},

  			"CHILD": function (type, what, argument, first, last) {
  				var simple = type.slice(0, 3) !== "nth",
  					forward = type.slice(-4) !== "last",
  					ofType = what === "of-type";

  				return first === 1 && last === 0 ?

  					// Shortcut for :nth-*(n)
  					function (elem) {
  						return !!elem.parentNode;
  					} :

  					function (elem, context, xml) {
  						var cache, outerCache, node, diff, nodeIndex, start,
  							dir = simple !== forward ? "nextSibling" : "previousSibling",
  							parent = elem.parentNode,
  							name = ofType && elem.nodeName.toLowerCase(),
  							useCache = !xml && !ofType;

  						if (parent) {

  							// :(first|last|only)-(child|of-type)
  							if (simple) {
  								while (dir) {
  									node = elem;
  									while ((node = node[dir])) {
  										if (ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) {
  											return false;
  										}
  									}
  									// Reverse direction for :only-* (if we haven't yet done so)
  									start = dir = type === "only" && !start && "nextSibling";
  								}
  								return true;
  							}

  							start = [forward ? parent.firstChild : parent.lastChild];

  							// non-xml :nth-child(...) stores cache data on `parent`
  							if (forward && useCache) {
  								// Seek `elem` from a previously-cached index
  								outerCache = parent[expando] || (parent[expando] = {});
  								cache = outerCache[type] || [];
  								nodeIndex = cache[0] === dirruns && cache[1];
  								diff = cache[0] === dirruns && cache[2];
  								node = nodeIndex && parent.childNodes[nodeIndex];

  								while ((node = ++nodeIndex && node && node[dir] ||

  										// Fallback to seeking `elem` from the start
  										(diff = nodeIndex = 0) || start.pop())) {

  									// When found, cache indexes on `parent` and break
  									if (node.nodeType === 1 && ++diff && node === elem) {
  										outerCache[type] = [dirruns, nodeIndex, diff];
  										break;
  									}
  								}

  								// Use previously-cached element index if available
  							} else if (useCache && (cache = (elem[expando] || (elem[expando] = {}))[type]) && cache[0] === dirruns) {
  								diff = cache[1];

  								// xml :nth-child(...) or :nth-last-child(...) or :nth(-last)?-of-type(...)
  							} else {
  								// Use the same loop as above to seek `elem` from the start
  								while ((node = ++nodeIndex && node && node[dir] ||
  										(diff = nodeIndex = 0) || start.pop())) {

  									if ((ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) && ++diff) {
  										// Cache the index of each encountered element
  										if (useCache) {
  											(node[expando] || (node[expando] = {}))[type] = [dirruns, diff];
  										}

  										if (node === elem) {
  											break;
  										}
  									}
  								}
  							}

  							// Incorporate the offset, then check against cycle size
  							diff -= last;
  							return diff === first || (diff % first === 0 && diff / first >= 0);
  						}
  					};
  			},

  			"PSEUDO": function (pseudo, argument) {
  				// pseudo-class names are case-insensitive
  				// http://www.w3.org/TR/selectors/#pseudo-classes
  				// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
  				// Remember that setFilters inherits from pseudos
  				var args,
  					fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] ||
  					Sizzle.error("unsupported pseudo: " + pseudo);

  				// The user may use createPseudo to indicate that
  				// arguments are needed to create the filter function
  				// just as Sizzle does
  				if (fn[expando]) {
  					return fn(argument);
  				}

  				// But maintain support for old signatures
  				if (fn.length > 1) {
  					args = [pseudo, pseudo, "", argument];
  					return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ?
  						markFunction(function (seed, matches) {
  							var idx,
  								matched = fn(seed, argument),
  								i = matched.length;
  							while (i--) {
  								idx = indexOf.call(seed, matched[i]);
  								seed[idx] = !(matches[idx] = matched[i]);
  							}
  						}) :
  						function (elem) {
  							return fn(elem, 0, args);
  						};
  				}

  				return fn;
  			}
  		},

  		pseudos: {
  			// Potentially complex pseudos
  			"not": markFunction(function (selector) {
  				// Trim the selector passed to compile
  				// to avoid treating leading and trailing
  				// spaces as combinators
  				var input = [],
  					results = [],
  					matcher = compile(selector.replace(rtrim, "$1"));

  				return matcher[expando] ?
  					markFunction(function (seed, matches, context, xml) {
  						var elem,
  							unmatched = matcher(seed, null, xml, []),
  							i = seed.length;

  						// Match elements unmatched by `matcher`
  						while (i--) {
  							if ((elem = unmatched[i])) {
  								seed[i] = !(matches[i] = elem);
  							}
  						}
  					}) :
  					function (elem, context, xml) {
  						input[0] = elem;
  						matcher(input, null, xml, results);
  						return !results.pop();
  					};
  			}),

  			"has": markFunction(function (selector) {
  				return function (elem) {
  					return Sizzle(selector, elem).length > 0;
  				};
  			}),

  			"contains": markFunction(function (text) {
  				text = text.replace(runescape, funescape);
  				return function (elem) {
  					return (elem.textContent || elem.innerText || getText(elem)).indexOf(text) > -1;
  				};
  			}),

  			// "Whether an element is represented by a :lang() selector
  			// is based solely on the element's language value
  			// being equal to the identifier C,
  			// or beginning with the identifier C immediately followed by "-".
  			// The matching of C against the element's language value is performed case-insensitively.
  			// The identifier C does not have to be a valid language name."
  			// http://www.w3.org/TR/selectors/#lang-pseudo
  			"lang": markFunction(function (lang) {
  				// lang value must be a valid identifier
  				if (!ridentifier.test(lang || "")) {
  					Sizzle.error("unsupported lang: " + lang);
  				}
  				lang = lang.replace(runescape, funescape).toLowerCase();
  				return function (elem) {
  					var elemLang;
  					do {
  						if ((elemLang = documentIsHTML ?
  								elem.lang :
  								elem.getAttribute("xml:lang") || elem.getAttribute("lang"))) {

  							elemLang = elemLang.toLowerCase();
  							return elemLang === lang || elemLang.indexOf(lang + "-") === 0;
  						}
  					} while ((elem = elem.parentNode) && elem.nodeType === 1);
  					return false;
  				};
  			}),

  			// Miscellaneous
  			"target": function (elem) {
  				var hash = window.location && window.location.hash;
  				return hash && hash.slice(1) === elem.id;
  			},

  			"root": function (elem) {
  				return elem === docElem;
  			},

  			"focus": function (elem) {
  				return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
  			},

  			// Boolean properties
  			"enabled": function (elem) {
  				return elem.disabled === false;
  			},

  			"disabled": function (elem) {
  				return elem.disabled === true;
  			},

  			"checked": function (elem) {
  				// In CSS3, :checked should return both checked and selected elements
  				// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
  				var nodeName = elem.nodeName.toLowerCase();
  				return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
  			},

  			"selected": function (elem) {
  				// Accessing this property makes selected-by-default
  				// options in Safari work properly
  				if (elem.parentNode) {
  					elem.parentNode.selectedIndex;
  				}

  				return elem.selected === true;
  			},

  			// Contents
  			"empty": function (elem) {
  				// http://www.w3.org/TR/selectors/#empty-pseudo
  				// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
  				//   but not by others (comment: 8; processing instruction: 7; etc.)
  				// nodeType < 6 works because attributes (2) do not appear as children
  				for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
  					if (elem.nodeType < 6) {
  						return false;
  					}
  				}
  				return true;
  			},

  			"parent": function (elem) {
  				return !Expr.pseudos["empty"](elem);
  			},

  			// Element/input types
  			"header": function (elem) {
  				return rheader.test(elem.nodeName);
  			},

  			"input": function (elem) {
  				return rinputs.test(elem.nodeName);
  			},

  			"button": function (elem) {
  				var name = elem.nodeName.toLowerCase();
  				return name === "input" && elem.type === "button" || name === "button";
  			},

  			"text": function (elem) {
  				var attr;
  				return elem.nodeName.toLowerCase() === "input" &&
  					elem.type === "text" &&

  					// Support: IE<8
  					// New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
  					((attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text");
  			},

  			// Position-in-collection
  			"first": createPositionalPseudo(function () {
  				return [0];
  			}),

  			"last": createPositionalPseudo(function (matchIndexes, length) {
  				return [length - 1];
  			}),

  			"eq": createPositionalPseudo(function (matchIndexes, length, argument) {
  				return [argument < 0 ? argument + length : argument];
  			}),

  			"even": createPositionalPseudo(function (matchIndexes, length) {
  				var i = 0;
  				for (; i < length; i += 2) {
  					matchIndexes.push(i);
  				}
  				return matchIndexes;
  			}),

  			"odd": createPositionalPseudo(function (matchIndexes, length) {
  				var i = 1;
  				for (; i < length; i += 2) {
  					matchIndexes.push(i);
  				}
  				return matchIndexes;
  			}),

  			"lt": createPositionalPseudo(function (matchIndexes, length, argument) {
  				var i = argument < 0 ? argument + length : argument;
  				for (; --i >= 0;) {
  					matchIndexes.push(i);
  				}
  				return matchIndexes;
  			}),

  			"gt": createPositionalPseudo(function (matchIndexes, length, argument) {
  				var i = argument < 0 ? argument + length : argument;
  				for (; ++i < length;) {
  					matchIndexes.push(i);
  				}
  				return matchIndexes;
  			})
  		}
  	};

  	Expr.pseudos["nth"] = Expr.pseudos["eq"];

  	// Add button/input type pseudos
  	for (i in {
  			radio: true,
  			checkbox: true,
  			file: true,
  			password: true,
  			image: true
  		}) {
  		Expr.pseudos[i] = createInputPseudo(i);
  	}
  	for (i in {
  			submit: true,
  			reset: true
  		}) {
  		Expr.pseudos[i] = createButtonPseudo(i);
  	}

  	// Easy API for creating new setFilters
  	function setFilters() {}
  	setFilters.prototype = Expr.filters = Expr.pseudos;
  	Expr.setFilters = new setFilters();

  	tokenize = Sizzle.tokenize = function (selector, parseOnly) {
  		var matched, match, tokens, type,
  			soFar, groups, preFilters,
  			cached = tokenCache[selector + " "];

  		if (cached) {
  			return parseOnly ? 0 : cached.slice(0);
  		}

  		soFar = selector;
  		groups = [];
  		preFilters = Expr.preFilter;

  		while (soFar) {

  			// Comma and first run
  			if (!matched || (match = rcomma.exec(soFar))) {
  				if (match) {
  					// Don't consume trailing commas as valid
  					soFar = soFar.slice(match[0].length) || soFar;
  				}
  				groups.push((tokens = []));
  			}

  			matched = false;

  			// Combinators
  			if ((match = rcombinators.exec(soFar))) {
  				matched = match.shift();
  				tokens.push({
  					value: matched,
  					// Cast descendant combinators to space
  					type: match[0].replace(rtrim, " ")
  				});
  				soFar = soFar.slice(matched.length);
  			}

  			// Filters
  			for (type in Expr.filter) {
  				if ((match = matchExpr[type].exec(soFar)) && (!preFilters[type] ||
  						(match = preFilters[type](match)))) {
  					matched = match.shift();
  					tokens.push({
  						value: matched,
  						type: type,
  						matches: match
  					});
  					soFar = soFar.slice(matched.length);
  				}
  			}

  			if (!matched) {
  				break;
  			}
  		}

  		// Return the length of the invalid excess
  		// if we're just parsing
  		// Otherwise, throw an error or return tokens
  		return parseOnly ?
  			soFar.length :
  			soFar ?
  			Sizzle.error(selector) :
  			// Cache the tokens
  			tokenCache(selector, groups).slice(0);
  	};

  	function toSelector(tokens) {
  		var i = 0,
  			len = tokens.length,
  			selector = "";
  		for (; i < len; i++) {
  			selector += tokens[i].value;
  		}
  		return selector;
  	}

  	function addCombinator(matcher, combinator, base) {
  		var dir = combinator.dir,
  			checkNonElements = base && dir === "parentNode",
  			doneName = done++;

  		return combinator.first ?
  			// Check against closest ancestor/preceding element
  			function (elem, context, xml) {
  				while ((elem = elem[dir])) {
  					if (elem.nodeType === 1 || checkNonElements) {
  						return matcher(elem, context, xml);
  					}
  				}
  			} :

  			// Check against all ancestor/preceding elements
  			function (elem, context, xml) {
  				var oldCache, outerCache,
  					newCache = [dirruns, doneName];

  				// We can't set arbitrary data on XML nodes, so they don't benefit from dir caching
  				if (xml) {
  					while ((elem = elem[dir])) {
  						if (elem.nodeType === 1 || checkNonElements) {
  							if (matcher(elem, context, xml)) {
  								return true;
  							}
  						}
  					}
  				} else {
  					while ((elem = elem[dir])) {
  						if (elem.nodeType === 1 || checkNonElements) {
  							outerCache = elem[expando] || (elem[expando] = {});
  							if ((oldCache = outerCache[dir]) &&
  								oldCache[0] === dirruns && oldCache[1] === doneName) {

  								// Assign to newCache so results back-propagate to previous elements
  								return (newCache[2] = oldCache[2]);
  							} else {
  								// Reuse newcache so results back-propagate to previous elements
  								outerCache[dir] = newCache;

  								// A match means we're done; a fail means we have to keep checking
  								if ((newCache[2] = matcher(elem, context, xml))) {
  									return true;
  								}
  							}
  						}
  					}
  				}
  			};
  	}

  	function elementMatcher(matchers) {
  		return matchers.length > 1 ?
  			function (elem, context, xml) {
  				var i = matchers.length;
  				while (i--) {
  					if (!matchers[i](elem, context, xml)) {
  						return false;
  					}
  				}
  				return true;
  			} :
  			matchers[0];
  	}

  	function multipleContexts(selector, contexts, results) {
  		var i = 0,
  			len = contexts.length;
  		for (; i < len; i++) {
  			Sizzle(selector, contexts[i], results);
  		}
  		return results;
  	}

  	function condense(unmatched, map, filter, context, xml) {
  		var elem,
  			newUnmatched = [],
  			i = 0,
  			len = unmatched.length,
  			mapped = map != null;

  		for (; i < len; i++) {
  			if ((elem = unmatched[i])) {
  				if (!filter || filter(elem, context, xml)) {
  					newUnmatched.push(elem);
  					if (mapped) {
  						map.push(i);
  					}
  				}
  			}
  		}

  		return newUnmatched;
  	}

  	function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {
  		if (postFilter && !postFilter[expando]) {
  			postFilter = setMatcher(postFilter);
  		}
  		if (postFinder && !postFinder[expando]) {
  			postFinder = setMatcher(postFinder, postSelector);
  		}
  		return markFunction(function (seed, results, context, xml) {
  			var temp, i, elem,
  				preMap = [],
  				postMap = [],
  				preexisting = results.length,

  				// Get initial elements from seed or context
  				elems = seed || multipleContexts(selector || "*", context.nodeType ? [context] : context, []),

  				// Prefilter to get matcher input, preserving a map for seed-results synchronization
  				matcherIn = preFilter && (seed || !selector) ?
  				condense(elems, preMap, preFilter, context, xml) :
  				elems,

  				matcherOut = matcher ?
  				// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
  				postFinder || (seed ? preFilter : preexisting || postFilter) ?

  				// ...intermediate processing is necessary
  				[] :

  				// ...otherwise use results directly
  				results :
  				matcherIn;

  			// Find primary matches
  			if (matcher) {
  				matcher(matcherIn, matcherOut, context, xml);
  			}

  			// Apply postFilter
  			if (postFilter) {
  				temp = condense(matcherOut, postMap);
  				postFilter(temp, [], context, xml);

  				// Un-match failing elements by moving them back to matcherIn
  				i = temp.length;
  				while (i--) {
  					if ((elem = temp[i])) {
  						matcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem);
  					}
  				}
  			}

  			if (seed) {
  				if (postFinder || preFilter) {
  					if (postFinder) {
  						// Get the final matcherOut by condensing this intermediate into postFinder contexts
  						temp = [];
  						i = matcherOut.length;
  						while (i--) {
  							if ((elem = matcherOut[i])) {
  								// Restore matcherIn since elem is not yet a final match
  								temp.push((matcherIn[i] = elem));
  							}
  						}
  						postFinder(null, (matcherOut = []), temp, xml);
  					}

  					// Move matched elements from seed to results to keep them synchronized
  					i = matcherOut.length;
  					while (i--) {
  						if ((elem = matcherOut[i]) &&
  							(temp = postFinder ? indexOf.call(seed, elem) : preMap[i]) > -1) {

  							seed[temp] = !(results[temp] = elem);
  						}
  					}
  				}

  				// Add elements to results, through postFinder if defined
  			} else {
  				matcherOut = condense(
  					matcherOut === results ?
  					matcherOut.splice(preexisting, matcherOut.length) :
  					matcherOut
  				);
  				if (postFinder) {
  					postFinder(null, results, matcherOut, xml);
  				} else {
  					push.apply(results, matcherOut);
  				}
  			}
  		});
  	}

  	function matcherFromTokens(tokens) {
  		var checkContext, matcher, j,
  			len = tokens.length,
  			leadingRelative = Expr.relative[tokens[0].type],
  			implicitRelative = leadingRelative || Expr.relative[" "],
  			i = leadingRelative ? 1 : 0,

  			// The foundational matcher ensures that elements are reachable from top-level context(s)
  			matchContext = addCombinator(function (elem) {
  				return elem === checkContext;
  			}, implicitRelative, true),
  			matchAnyContext = addCombinator(function (elem) {
  				return indexOf.call(checkContext, elem) > -1;
  			}, implicitRelative, true),
  			matchers = [function (elem, context, xml) {
  				return (!leadingRelative && (xml || context !== outermostContext)) || (
  					(checkContext = context).nodeType ?
  					matchContext(elem, context, xml) :
  					matchAnyContext(elem, context, xml));
  			}];

  		for (; i < len; i++) {
  			if ((matcher = Expr.relative[tokens[i].type])) {
  				matchers = [addCombinator(elementMatcher(matchers), matcher)];
  			} else {
  				matcher = Expr.filter[tokens[i].type].apply(null, tokens[i].matches);

  				// Return special upon seeing a positional matcher
  				if (matcher[expando]) {
  					// Find the next relative operator (if any) for proper handling
  					j = ++i;
  					for (; j < len; j++) {
  						if (Expr.relative[tokens[j].type]) {
  							break;
  						}
  					}
  					return setMatcher(
  						i > 1 && elementMatcher(matchers),
  						i > 1 && toSelector(
  							// If the preceding token was a descendant combinator, insert an implicit any-element `*`
  							tokens.slice(0, i - 1).concat({
  								value: tokens[i - 2].type === " " ? "*" : ""
  							})
  						).replace(rtrim, "$1"),
  						matcher,
  						i < j && matcherFromTokens(tokens.slice(i, j)),
  						j < len && matcherFromTokens((tokens = tokens.slice(j))),
  						j < len && toSelector(tokens)
  					);
  				}
  				matchers.push(matcher);
  			}
  		}

  		return elementMatcher(matchers);
  	}

  	function matcherFromGroupMatchers(elementMatchers, setMatchers) {
  		var bySet = setMatchers.length > 0,
  			byElement = elementMatchers.length > 0,
  			superMatcher = function (seed, context, xml, results, outermost) {
  				var elem, j, matcher,
  					matchedCount = 0,
  					i = "0",
  					unmatched = seed && [],
  					setMatched = [],
  					contextBackup = outermostContext,
  					// We must always have either seed elements or outermost context
  					elems = seed || byElement && Expr.find["TAG"]("*", outermost),
  					// Use integer dirruns iff this is the outermost matcher
  					dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
  					len = elems.length;

  				if (outermost) {
  					outermostContext = context !== document && context;
  				}

  				// Add elements passing elementMatchers directly to results
  				// Keep `i` a string if there are no elements so `matchedCount` will be "00" below
  				// Support: IE<9, Safari
  				// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
  				for (; i !== len && (elem = elems[i]) != null; i++) {
  					if (byElement && elem) {
  						j = 0;
  						while ((matcher = elementMatchers[j++])) {
  							if (matcher(elem, context, xml)) {
  								results.push(elem);
  								break;
  							}
  						}
  						if (outermost) {
  							dirruns = dirrunsUnique;
  						}
  					}

  					// Track unmatched elements for set filters
  					if (bySet) {
  						// They will have gone through all possible matchers
  						if ((elem = !matcher && elem)) {
  							matchedCount--;
  						}

  						// Lengthen the array for every element, matched or not
  						if (seed) {
  							unmatched.push(elem);
  						}
  					}
  				}

  				// Apply set filters to unmatched elements
  				matchedCount += i;
  				if (bySet && i !== matchedCount) {
  					j = 0;
  					while ((matcher = setMatchers[j++])) {
  						matcher(unmatched, setMatched, context, xml);
  					}

  					if (seed) {
  						// Reintegrate element matches to eliminate the need for sorting
  						if (matchedCount > 0) {
  							while (i--) {
  								if (!(unmatched[i] || setMatched[i])) {
  									setMatched[i] = pop.call(results);
  								}
  							}
  						}

  						// Discard index placeholder values to get only actual matches
  						setMatched = condense(setMatched);
  					}

  					// Add matches to results
  					push.apply(results, setMatched);

  					// Seedless set matches succeeding multiple successful matchers stipulate sorting
  					if (outermost && !seed && setMatched.length > 0 &&
  						(matchedCount + setMatchers.length) > 1) {

  						Sizzle.uniqueSort(results);
  					}
  				}

  				// Override manipulation of globals by nested matchers
  				if (outermost) {
  					dirruns = dirrunsUnique;
  					outermostContext = contextBackup;
  				}

  				return unmatched;
  			};

  		return bySet ?
  			markFunction(superMatcher) :
  			superMatcher;
  	}

  	compile = Sizzle.compile = function (selector, match /* Internal Use Only */ ) {
  		var i,
  			setMatchers = [],
  			elementMatchers = [],
  			cached = compilerCache[selector + " "];

  		if (!cached) {
  			// Generate a function of recursive functions that can be used to check each element
  			if (!match) {
  				match = tokenize(selector);
  			}
  			i = match.length;
  			while (i--) {
  				cached = matcherFromTokens(match[i]);
  				if (cached[expando]) {
  					setMatchers.push(cached);
  				} else {
  					elementMatchers.push(cached);
  				}
  			}

  			// Cache the compiled function
  			cached = compilerCache(selector, matcherFromGroupMatchers(elementMatchers, setMatchers));

  			// Save selector and tokenization
  			cached.selector = selector;
  		}
  		return cached;
  	};

  	/**
  	 * A low-level selection function that works with Sizzle's compiled
  	 *  selector functions
  	 * @param {String|Function} selector A selector or a pre-compiled
  	 *  selector function built with Sizzle.compile
  	 * @param {Element} context
  	 * @param {Array} [results]
  	 * @param {Array} [seed] A set of elements to match against
  	 */
  	select = Sizzle.select = function (selector, context, results, seed) {
  		var i, tokens, token, type, find,
  			compiled = typeof selector === "function" && selector,
  			match = !seed && tokenize((selector = compiled.selector || selector));

  		results = results || [];

  		// Try to minimize operations if there is no seed and only one group
  		if (match.length === 1) {

  			// Take a shortcut and set the context if the root selector is an ID
  			tokens = match[0] = match[0].slice(0);
  			if (tokens.length > 2 && (token = tokens[0]).type === "ID" &&
  				support.getById && context.nodeType === 9 && documentIsHTML &&
  				Expr.relative[tokens[1].type]) {

  				context = (Expr.find["ID"](token.matches[0].replace(runescape, funescape), context) || [])[0];
  				if (!context) {
  					return results;

  					// Precompiled matchers will still verify ancestry, so step up a level
  				} else if (compiled) {
  					context = context.parentNode;
  				}

  				selector = selector.slice(tokens.shift().value.length);
  			}

  			// Fetch a seed set for right-to-left matching
  			i = matchExpr["needsContext"].test(selector) ? 0 : tokens.length;
  			while (i--) {
  				token = tokens[i];

  				// Abort if we hit a combinator
  				if (Expr.relative[(type = token.type)]) {
  					break;
  				}
  				if ((find = Expr.find[type])) {
  					// Search, expanding context for leading sibling combinators
  					if ((seed = find(
  							token.matches[0].replace(runescape, funescape),
  							rsibling.test(tokens[0].type) && testContext(context.parentNode) || context
  						))) {

  						// If seed is empty or no tokens remain, we can return early
  						tokens.splice(i, 1);
  						selector = seed.length && toSelector(tokens);
  						if (!selector) {
  							push.apply(results, seed);
  							return results;
  						}

  						break;
  					}
  				}
  			}
  		}

  		// Compile and execute a filtering function if one is not provided
  		// Provide `match` to avoid retokenization if we modified the selector above
  		(compiled || compile(selector, match))(
  			seed,
  			context,
  			!documentIsHTML,
  			results,
  			rsibling.test(selector) && testContext(context.parentNode) || context
  		);
  		return results;
  	};

  	// One-time assignments

  	// Sort stability
  	support.sortStable = expando.split("").sort(sortOrder).join("") === expando;

  	// Support: Chrome 14-35+
  	// Always assume duplicates if they aren't passed to the comparison function
  	support.detectDuplicates = !!hasDuplicate;

  	// Initialize against the default document
  	setDocument();

  	// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
  	// Detached nodes confoundingly follow *each other*
  	support.sortDetached = assert(function (div1) {
  		// Should return 1, but returns 4 (following)
  		return div1.compareDocumentPosition(document.createElement("div")) & 1;
  	});

  	// Support: IE<8
  	// Prevent attribute/property "interpolation"
  	// http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
  	if (!assert(function (div) {
  			div.innerHTML = "<a href='#'></a>";
  			return div.firstChild.getAttribute("href") === "#";
  		})) {
  		addHandle("type|href|height|width", function (elem, name, isXML) {
  			if (!isXML) {
  				return elem.getAttribute(name, name.toLowerCase() === "type" ? 1 : 2);
  			}
  		});
  	}

  	// Support: IE<9
  	// Use defaultValue in place of getAttribute("value")
  	if (!support.attributes || !assert(function (div) {
  			div.innerHTML = "<input/>";
  			div.firstChild.setAttribute("value", "");
  			return div.firstChild.getAttribute("value") === "";
  		})) {
  		addHandle("value", function (elem, name, isXML) {
  			if (!isXML && elem.nodeName.toLowerCase() === "input") {
  				return elem.defaultValue;
  			}
  		});
  	}

  	// Support: IE<9
  	// Use getAttributeNode to fetch booleans when getAttribute lies
  	if (!assert(function (div) {
  			return div.getAttribute("disabled") == null;
  		})) {
  		addHandle(booleans, function (elem, name, isXML) {
  			var val;
  			if (!isXML) {
  				return elem[name] === true ? name.toLowerCase() :
  					(val = elem.getAttributeNode(name)) && val.specified ?
  					val.value :
  					null;
  			}
  		});
  	}

  	// EXPOSE

  	tinymce.dom.Sizzle = Sizzle;

  })(tinymce);

  /*eslint-enable */

  /**
   * ScrollIntoView.js
   *
   * Released under LGPL License.
   * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
   *
   * License: http://www.tinymce.com/license - Inactive
   * Licence: GNU/LGPL 2.1 or later - http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
   * Contributing: http://www.tinymce.com/contributing - Inactive
   */


  (function (tinymce) {

    var NodeType = tinymce.dom.NodeType, Dispatcher = tinymce.util.Dispatcher;

    var getPos = function (elm) {
      var x = 0,
        y = 0;

      var offsetParent = elm;
      while (offsetParent && offsetParent.nodeType) {
        x += offsetParent.offsetLeft || 0;
        y += offsetParent.offsetTop || 0;
        offsetParent = offsetParent.offsetParent;
      }

      return {
        x: x,
        y: y
      };
    };

    var fireScrollIntoViewEvent = function (editor, elm, alignToTop) {
      var scrollEvent = {
        elm: elm,
        alignToTop: alignToTop,
        cancel: false
      };

      editor.onScrollIntoView.dispatch(editor, scrollEvent);

      return scrollEvent.cancel === true;
    };

    tinymce.dom.ScrollIntoView = function (editor, elm, alignToTop) {
      var y, viewPort, dom = editor.dom,
        root = dom.getRoot(),
        viewPortY, viewPortH, offsetY = 0;

      editor.onScrollIntoView = new Dispatcher();

      if (fireScrollIntoViewEvent(editor, elm, alignToTop)) {
        return;
      }

      if (!NodeType.isElement(elm)) {
        return;
      }

      if (alignToTop === false) {
        offsetY = elm.offsetHeight;
      }

      if (root.nodeName !== 'BODY') {
        var scrollContainer = editor.selection.getScrollContainer();
        if (scrollContainer) {
          y = getPos(elm).y - getPos(scrollContainer).y + offsetY;
          viewPortH = scrollContainer.clientHeight;
          viewPortY = scrollContainer.scrollTop;
          if (y < viewPortY || y + 25 > viewPortY + viewPortH) {
            scrollContainer.scrollTop = y < viewPortY ? y : y - viewPortH + 25;
          }

          return;
        }
      }

      viewPort = dom.getViewPort(editor.getWin());
      y = dom.getPos(elm).y + offsetY;
      viewPortY = viewPort.y;
      viewPortH = viewPort.h;
      if (y < viewPort.y || y + 25 > viewPortY + viewPortH) {
        editor.getWin().scrollTo(0, y < viewPortY ? y : y - viewPortH + 25);
      }
    };

  })(tinymce);

  /**
   * BookmarkManager.js
   *
   * Released under LGPL License.
   * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
   *
   * License: http://www.tinymce.com/license - Inactive
   * Licence: GNU/LGPL 2.1 or later - http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
   * Contributing: http://www.tinymce.com/contributing - Inactive
   */

  /**
   * This class handles selection bookmarks.
   *
   * @class tinymce.dom.BookmarkManager
   */
  (function (tinymce) {
    var NodeType = tinymce.dom.NodeType,
      CaretBookmark = tinymce.caret.CaretBookmark,
      CaretContainer = tinymce.caret.CaretContainer,
      CaretPosition = tinymce.caret.CaretPosition,
      RangeUtils = tinymce.dom.RangeUtils,
      Zwsp = tinymce.text.Zwsp,
      Arr = tinymce.util.Arr;

    var isContentEditableFalse = NodeType.isContentEditableFalse;

    var getNormalizedTextOffset = function (container, offset) {
      var node, trimmedOffset;

      trimmedOffset = Zwsp.trim(container.data.slice(0, offset)).length;
      for (node = container.previousSibling; node && node.nodeType === 3; node = node.previousSibling) {
        trimmedOffset += Zwsp.trim(node.data).length;
      }

      return trimmedOffset;
    };

    var trimEmptyTextNode = function (node) {
      if (NodeType.isText(node) && node.data.length === 0) {
        node.parentNode.removeChild(node);
      }
    };

    /**
     * Constructs a new BookmarkManager instance for a specific selection instance.
     *
     * @constructor
     * @method BookmarkManager
     * @param {tinymce.dom.Selection} selection Selection instance to handle bookmarks for.
     */
    function BookmarkManager(selection) {
      var dom = selection.dom;

      /**
       * Returns a bookmark location for the current selection. This bookmark object
       * can then be used to restore the selection after some content modification to the document.
       *
       * @method getBookmark
       * @param {Number} type Optional state if the bookmark should be simple or not. Default is complex.
       * @param {Boolean} normalized Optional state that enables you to get a position that it would be after normalization.
       * @return {Object} Bookmark object, use moveToBookmark with this object to restore the selection.
       * @example
       * // Stores a bookmark of the current selection
       * var bm = tinymce.activeEditor.selection.getBookmark();
       *
       * tinymce.activeEditor.setContent(tinymce.activeEditor.getContent() + 'Some new content');
       *
       * // Restore the selection bookmark
       * tinymce.activeEditor.selection.moveToBookmark(bm);
       */
      this.getBookmark = function (type, normalized) {
        var rng, rng2, id, collapsed, name, element, chr = '&#xFEFF;',
          styles;

        function findIndex(name, element) {
          var count = 0;

          tinymce.each(dom.select(name), function (node) {
            if (node.getAttribute('data-mce-bogus') === 'all') {
              return;
            }

            if (node == element) {
              return false;
            }

            count++;
          });

          return count;
        }

        function normalizeTableCellSelection(rng) {
          function moveEndPoint(start) {
            var container, offset, childNodes, prefix = start ? 'start' : 'end';

            container = rng[prefix + 'Container'];
            offset = rng[prefix + 'Offset'];

            if (container.nodeType == 1 && container.nodeName == "TR") {
              childNodes = container.childNodes;
              container = childNodes[Math.min(start ? offset : offset - 1, childNodes.length - 1)];
              if (container) {
                offset = start ? 0 : container.childNodes.length;
                rng['set' + (start ? 'Start' : 'End')](container, offset);
              }
            }
          }

          moveEndPoint(true);
          moveEndPoint();

          return rng;
        }

        function getLocation(rng) {
          var root = dom.getRoot(),
            bookmark = {};

          function getPoint(rng, start) {
            var container = rng[start ? 'startContainer' : 'endContainer'],
              offset = rng[start ? 'startOffset' : 'endOffset'],
              point = [],
              childNodes, after = 0;

            if (container.nodeType === 3) {
              point.push(normalized ? getNormalizedTextOffset(container, offset) : offset);
            } else {
              childNodes = container.childNodes;

              if (offset >= childNodes.length && childNodes.length) {
                after = 1;
                offset = Math.max(0, childNodes.length - 1);
              }

              point.push(dom.nodeIndex(childNodes[offset], normalized) + after);
            }

            for (; container && container != root; container = container.parentNode) {
              point.push(dom.nodeIndex(container, normalized));
            }

            return point;
          }

          bookmark.start = getPoint(rng, true);

          if (!selection.isCollapsed()) {
            bookmark.end = getPoint(rng);
          }

          return bookmark;
        }

        function findAdjacentContentEditableFalseElm(rng) {
          function findSibling(node, offset) {
            var sibling;

            if (NodeType.isElement(node)) {
              node = RangeUtils.getNode(node, offset);
              if (isContentEditableFalse(node)) {
                return node;
              }
            }

            if (CaretContainer.isCaretContainer(node)) {
              if (NodeType.isText(node) && CaretContainer.isCaretContainerBlock(node)) {
                node = node.parentNode;
              }

              sibling = node.previousSibling;
              if (isContentEditableFalse(sibling)) {
                return sibling;
              }

              sibling = node.nextSibling;
              if (isContentEditableFalse(sibling)) {
                return sibling;
              }
            }
          }

          return findSibling(rng.startContainer, rng.startOffset) || findSibling(rng.endContainer, rng.endOffset);
        }

        if (type == 2) {
          element = selection.getNode();
          name = element ? element.nodeName : null;
          rng = selection.getRng();

          if (isContentEditableFalse(element) || name == 'IMG') {
            return {
              name: name,
              index: findIndex(name, element)
            };
          }

          if (selection.tridentSel) {
            return selection.tridentSel.getBookmark(type);
          }

          element = findAdjacentContentEditableFalseElm(rng);
          if (element) {
            name = element.tagName;
            return {
              name: name,
              index: findIndex(name, element)
            };
          }

          return getLocation(rng);
        }

        if (type == 3) {
          rng = selection.getRng();

          return {
            start: CaretBookmark.create(dom.getRoot(), CaretPosition.fromRangeStart(rng)),
            end: CaretBookmark.create(dom.getRoot(), CaretPosition.fromRangeEnd(rng))
          };
        }

        // Handle simple range
        if (type) {
          return {
            rng: selection.getRng()
          };
        }

        rng = selection.getRng();
        id = dom.uniqueId();
        collapsed = selection.isCollapsed();
        styles = 'overflow:hidden;line-height:0px';

        // Explorer method
        if (rng.duplicate || rng.item) {
          // Text selection
          if (!rng.item) {
            rng2 = rng.duplicate();

            try {
              // Insert start marker
              rng.collapse();
              rng.pasteHTML('<span data-mce-type="bookmark" id="' + id + '_start" style="' + styles + '">' + chr + '</span>');

              // Insert end marker
              if (!collapsed) {
                rng2.collapse(false);

                // Detect the empty space after block elements in IE and move the
                // end back one character <p></p>] becomes <p>]</p>
                rng.moveToElementText(rng2.parentElement());
                if (rng.compareEndPoints('StartToEnd', rng2) === 0) {
                  rng2.move('character', -1);
                }

                rng2.pasteHTML('<span data-mce-type="bookmark" id="' + id + '_end" style="' + styles + '">' + chr + '</span>');
              }
            } catch (ex) {
              // IE might throw unspecified error so lets ignore it
              return null;
            }
          } else {
            // Control selection
            element = rng.item(0);
            name = element.nodeName;

            return {
              name: name,
              index: findIndex(name, element)
            };
          }
        } else {
          element = selection.getNode();
          name = element.nodeName;
          if (name == 'IMG') {
            return {
              name: name,
              index: findIndex(name, element)
            };
          }

          // W3C method
          rng2 = normalizeTableCellSelection(rng.cloneRange());

          // Insert end marker
          if (!collapsed) {
            rng2.collapse(false);
            var endBookmarkNode = dom.create('span', {
              'data-mce-type': "bookmark",
              id: id + '_end',
              style: styles
            }, chr);
            rng2.insertNode(endBookmarkNode);
            trimEmptyTextNode(endBookmarkNode.nextSibling);
          }

          rng = normalizeTableCellSelection(rng);
          rng.collapse(true);
          var startBookmarkNode = dom.create('span', {
            'data-mce-type': "bookmark",
            id: id + '_start',
            style: styles
          }, chr);
          rng.insertNode(startBookmarkNode);
          trimEmptyTextNode(startBookmarkNode.previousSibling);
        }

        selection.moveToBookmark({
          id: id,
          keep: 1
        });

        return {
          id: id
        };
      };

      /**
       * Restores the selection to the specified bookmark.
       *
       * @method moveToBookmark
       * @param {Object} bookmark Bookmark to restore selection from.
       * @return {Boolean} true/false if it was successful or not.
       * @example
       * // Stores a bookmark of the current selection
       * var bm = tinymce.activeEditor.selection.getBookmark();
       *
       * tinymce.activeEditor.setContent(tinymce.activeEditor.getContent() + 'Some new content');
       *
       * // Restore the selection bookmark
       * tinymce.activeEditor.selection.moveToBookmark(bm);
       */
      this.moveToBookmark = function (bookmark) {
        var rng, root, startContainer, endContainer, startOffset, endOffset;

        function setEndPoint(start) {
          var point = bookmark[start ? 'start' : 'end'],
            i, node, offset, children;

          if (point) {
            offset = point[0];

            // Find container node
            for (node = root, i = point.length - 1; i >= 1; i--) {
              children = node.childNodes;

              if (point[i] > children.length - 1) {
                return;
              }

              node = children[point[i]];
            }

            // Move text offset to best suitable location
            if (node.nodeType === 3) {
              offset = Math.min(point[0], node.nodeValue.length);
            }

            // Move element offset to best suitable location
            if (node.nodeType === 1) {
              offset = Math.min(point[0], node.childNodes.length);
            }

            // Set offset within container node
            if (start) {
              rng.setStart(node, offset);
            } else {
              rng.setEnd(node, offset);
            }
          }

          return true;
        }

        function restoreEndPoint(suffix) {
          var marker = dom.get(bookmark.id + '_' + suffix),
            node, idx, next, prev, keep = bookmark.keep;

          if (marker) {
            node = marker.parentNode;

            if (suffix == 'start') {
              if (!keep) {
                idx = dom.nodeIndex(marker);
              } else {
                node = marker.firstChild;
                idx = 1;
              }

              startContainer = endContainer = node;
              startOffset = endOffset = idx;
            } else {
              if (!keep) {
                idx = dom.nodeIndex(marker);
              } else {
                node = marker.firstChild;
                idx = 1;
              }

              endContainer = node;
              endOffset = idx;
            }

            if (!keep) {
              prev = marker.previousSibling;
              next = marker.nextSibling;

              // Remove all marker text nodes
              tinymce.each(tinymce.grep(marker.childNodes), function (node) {
                if (node.nodeType == 3) {
                  node.nodeValue = node.nodeValue.replace(/\uFEFF/g, '');
                }
              });

              // Remove marker but keep children if for example contents where inserted into the marker
              // Also remove duplicated instances of the marker for example by a
              // split operation or by WebKit auto split on paste feature
              while ((marker = dom.get(bookmark.id + '_' + suffix))) {
                dom.remove(marker, 1);
              }

              // If siblings are text nodes then merge them unless it's Opera since it some how removes the node
              // and we are sniffing since adding a lot of detection code for a browser with 3% of the market
              // isn't worth the effort. Sorry, Opera but it's just a fact
              if (prev && next && prev.nodeType == next.nodeType && prev.nodeType == 3) {
                idx = prev.nodeValue.length;
                prev.appendData(next.nodeValue);
                dom.remove(next);

                if (suffix == 'start') {
                  startContainer = endContainer = prev;
                  startOffset = endOffset = idx;
                } else {
                  endContainer = prev;
                  endOffset = idx;
                }
              }
            }
          }
        }

        function addBogus(node) {
          // Adds a bogus BR element for empty block elements
          if (dom.isBlock(node) && !node.innerHTML) {
            node.innerHTML = '<br data-mce-bogus="1" />';
          }

          return node;
        }

        function resolveCaretPositionBookmark() {
          var rng, pos;

          rng = dom.createRng();
          pos = CaretBookmark.resolve(dom.getRoot(), bookmark.start);
          rng.setStart(pos.container(), pos.offset());

          pos = CaretBookmark.resolve(dom.getRoot(), bookmark.end);
          rng.setEnd(pos.container(), pos.offset());

          return rng;
        }

        if (bookmark) {
          if (Arr.isArray(bookmark.start)) {
            rng = dom.createRng();
            root = dom.getRoot();

            if (selection.tridentSel) {
              return selection.tridentSel.moveToBookmark(bookmark);
            }

            if (setEndPoint(true) && setEndPoint()) {
              selection.setRng(rng);
            }
          } else if (typeof bookmark.start == 'string') {
            selection.setRng(resolveCaretPositionBookmark());
          } else if (bookmark.id) {
            // Restore start/end points
            restoreEndPoint('start');
            restoreEndPoint('end');

            if (startContainer) {
              rng = dom.createRng();
              rng.setStart(addBogus(startContainer), startOffset);
              rng.setEnd(addBogus(endContainer), endOffset);
              selection.setRng(rng);
            }
          } else if (bookmark.name) {
            selection.select(dom.select(bookmark.name)[bookmark.index]);
          } else if (bookmark.rng) {
            selection.setRng(bookmark.rng);
          }
        }
      };
    }

    /**
     * Returns true/false if the specified node is a bookmark node or not.
     *
     * @static
     * @method isBookmarkNode
     * @param {DOMNode} node DOM Node to check if it's a bookmark node or not.
     * @return {Boolean} true/false if the node is a bookmark node or not.
     */
    BookmarkManager.isBookmarkNode = function (node) {
      return node && node.tagName === 'SPAN' && node.getAttribute('data-mce-type') === 'bookmark';
    };

    tinymce.dom.BookmarkManager = BookmarkManager;

  })(tinymce);

  /**
   * ControlSelection.js
   *
   * Released under LGPL License.
   * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
   *
   * License: http://www.tinymce.com/license - Inactive
   * Licence: GNU/LGPL 2.1 or later - http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
   * Contributing: http://www.tinymce.com/contributing - Inactive
   */


  (function (tinymce) {
    var Dispatcher = tinymce.util.Dispatcher,
      VK = tinymce.VK;

    function debounce(callback, time) {
      var timer, func;

      func = function () {
        var args = arguments;

        clearTimeout(timer);

        timer = setTimeout(function () {
          callback.apply(this, args);
        }, 0);
      };

      func.stop = function () {
        clearTimeout(timer);
      };

      return func;
    }

    function hasContentEditableState(node, value) {
      if (node && node.nodeType === 1) {
        if (node.contentEditable === value) {
          return true;
        }

        if (node.getAttribute('data-mce-contenteditable') === value) {
          return true;
        }
      }

      return false;
    }

    /**
  	 * This class handles control selection of elements. Controls are elements
  	 * that can be resized and needs to be selected as a whole. It adds custom resize handles
  	 * to all browser engines that support properly disabling the built in resize logic.
  	 *
  	 * @class tinymce.dom.ControlSelection
  	 */

    /**
  	 * Constucts a new ControlSelection class.
  	 *
  	 * @constructor
  	 * @method Serializer
  	 * @param {Object} settings Serializer settings object.
  	 * @param {tinymce.dom.DOMUtils} dom DOMUtils instance reference.
  	 * @param {tinymce.html.Schema} schema Optional schema reference.
  	 */
    tinymce.dom.ControlSelection = function (selection, editor) {

      function getContentEditableRoot(root, node) {
        while (node && node != root) {
          if (hasContentEditableState(node, 'true') || hasContentEditableState(node, 'false')) {
            return node;
          }

          node = node.parentNode;
        }

        return null;
      }

      var dom = editor.dom,
        each = tinymce.each;
      var selectedElm, selectedElmGhost, resizeHelper, resizeHandles, selectedHandle, lastMouseDownEvent;
      var startX, startY, selectedElmX, selectedElmY, startW, startH, ratio, resizeStarted;
      var width, height, editableDoc = editor.getDoc(),
        rootDocument = document,
        isIE = tinymce.isIE && tinymce.isIE < 11;

      var abs = Math.abs,
        round = Math.round,
        rootElement = editor.getBody(),
        startScrollWidth, startScrollHeight;

      // Set up events
      editor.onObjectSelected = new Dispatcher();
      editor.onObjectResizeStart = new Dispatcher();
      editor.onObjectResized = new Dispatcher();

      // Details about each resize handle how to scale etc
      resizeHandles = {
        /*n: [0.5, 0, 0, -1],
  			e: [1, 0.5, 1, 0],
  			s: [0.5, 1, 0, 1],
  			w: [0, 0.5, -1, 0],*/
        nw: [0, 0, -1, -1],
        ne: [1, 0, 1, -1],
        se: [1, 1, 1, 1],
        sw: [0, 1, -1, 1]
      };

      function isResizable(elm) {
        var selector = editor.settings.object_resizing;

        if (selector === false) {
          return false;
        }

        /*if (tinymce.isIOS) {
  				return false;
  			}*/

        if (typeof selector != 'string') {
          selector = 'table,img,[data-mce-resize]';
        }

        if (elm.getAttribute('data-mce-resize') === 'false') {
          return false;
        }

        if (elm == editor.getBody()) {
          return false;
        }

        return editor.dom.is(elm, selector);
      }

      function updateWithTouchData(e) {
        var keys, i;

        if (e.changedTouches) {
          keys = "screenX screenY pageX pageY clientX clientY".split(' ');
          for (i = 0; i < keys.length; i++) {
            e[keys[i]] = e.changedTouches[0][keys[i]];
          }
        }
      }

      function isProportionalResize(elm) {
        return elm.nodeName === 'IMG' || elm.getAttribute('data-mce-resize') === 'proportional';
      }

      function resizeGhostElement(e) {
        var deltaX, deltaY, proportional;
        var resizeHelperX, resizeHelperY;

        updateWithTouchData(e);

        // Calc new width/height
        deltaX = e.screenX - startX;
        deltaY = e.screenY - startY;

        // Calc new size
        width = deltaX * selectedHandle[2] + startW;
        height = deltaY * selectedHandle[3] + startH;

        // Never scale down lower than 5 pixels
        width = width < 5 ? 5 : width;
        height = height < 5 ? 5 : height;

        if (isProportionalResize(selectedElm) && editor.settings.resize_img_proportional !== false) {
          proportional = !VK.modifierPressed(e);
        } else {
          proportional = VK.modifierPressed(e) || (selectedElm.nodeName == "IMG" && selectedHandle[2] * selectedHandle[3] !== 0);
        }

        // Constrain proportions
        if (proportional) {
          if (abs(deltaX) > abs(deltaY)) {
            height = round(width * ratio);
            width = round(height / ratio);
          } else {
            width = round(height / ratio);
            height = round(width * ratio);
          }
        }

        // Update ghost size
        dom.setStyles(selectedElmGhost, {
          width: width,
          height: height
        });

        // Update resize helper position
        resizeHelperX = selectedHandle.startPos.x + deltaX;
        resizeHelperY = selectedHandle.startPos.y + deltaY;
        resizeHelperX = resizeHelperX > 0 ? resizeHelperX : 0;
        resizeHelperY = resizeHelperY > 0 ? resizeHelperY : 0;

        dom.setStyles(resizeHelper, {
          left: resizeHelperX,
          top: resizeHelperY,
          display: 'block'
        });

        resizeHelper.innerHTML = width + ' &times; ' + height;

        // Update ghost X position if needed
        if (selectedHandle[2] < 0 && selectedElmGhost.clientWidth <= width) {
          dom.setStyle(selectedElmGhost, 'left', selectedElmX + (startW - width));
        }

        // Update ghost Y position if needed
        if (selectedHandle[3] < 0 && selectedElmGhost.clientHeight <= height) {
          dom.setStyle(selectedElmGhost, 'top', selectedElmY + (startH - height));
        }

        // Calculate how must overflow we got
        deltaX = rootElement.scrollWidth - startScrollWidth;
        deltaY = rootElement.scrollHeight - startScrollHeight;

        // Re-position the resize helper based on the overflow
        if (deltaX + deltaY !== 0) {
          dom.setStyles(resizeHelper, {
            left: resizeHelperX - deltaX,
            top: resizeHelperY - deltaY
          });
        }

        if (!resizeStarted) {
          editor.onObjectResizeStart.dispatch(editor, selectedElm, startW, startH);
          resizeStarted = true;
        }
      }

      function endGhostResize() {
        resizeStarted = false;

        function setSizeProp(name, value) {
          if (value) {
            // Resize by using style or attribute
            if (selectedElm.nodeName !== 'IMG') {
              dom.setStyle(selectedElm, name, value);
            } else {
              dom.setAttrib(selectedElm, name, value);
            }
          }
        }

        // Set width/height properties
        setSizeProp('width', width);
        setSizeProp('height', height);

        dom.unbind(editableDoc, 'mousemove touchmove', resizeGhostElement);
        dom.unbind(editableDoc, 'mouseup touchend', endGhostResize);

        if (rootDocument != editableDoc) {
          dom.unbind(rootDocument, 'mousemove touchmove', resizeGhostElement);
          dom.unbind(rootDocument, 'mouseup touchend', endGhostResize);
        }

        // Remove ghost/helper and update resize handle positions
        dom.remove(selectedElmGhost);
        dom.remove(resizeHelper);

        dom.removeClass(selectedElm, 'mce-resizing');

        if (!isIE || selectedElm.nodeName == "TABLE") {
          showResizeRect(selectedElm);
        }

        editor.onObjectResized.dispatch(editor, selectedElm, width, height);

        dom.setAttrib(selectedElm, 'style', dom.getAttrib(selectedElm, 'style'));
        editor.nodeChanged();
      }

      function showResizeRect(targetElm, mouseDownHandleName, mouseDownEvent) {
        var position, targetWidth, targetHeight, rect;

        hideResizeRect();
        unbindResizeHandleEvents();

        // Get position and size of target
        position = dom.getPos(targetElm, rootElement);
        selectedElmX = position.x;
        selectedElmY = position.y;
        rect = targetElm.getBoundingClientRect(); // Fix for Gecko offsetHeight for table with caption
        targetWidth = rect.width || (rect.right - rect.left);
        targetHeight = rect.height || (rect.bottom - rect.top);

        // Reset width/height if user selects a new image/table
        if (selectedElm != targetElm) {
          detachResizeStartListener();
          selectedElm = targetElm;
          width = height = 0;
        }

        // Makes it possible to disable resizing
        editor.onObjectSelected.dispatch(editor, targetElm);

        if (isResizable(targetElm)) {
          each(resizeHandles, function (handle, name) {
            var handleElm;

            function startDrag(e) {
              startX = e.screenX;
              startY = e.screenY;
              startW = selectedElm.clientWidth;
              startH = selectedElm.clientHeight;
              ratio = startH / startW;
              selectedHandle = handle;

              handle.startPos = {
                x: targetWidth * handle[0] + selectedElmX,
                y: targetHeight * handle[1] + selectedElmY
              };

              startScrollWidth = rootElement.scrollWidth;
              startScrollHeight = rootElement.scrollHeight;

              // create clone as ghost of parent item only
              selectedElmGhost = selectedElm.cloneNode();
              dom.addClass(selectedElmGhost, 'mce-clonedresizable');
              dom.setAttrib(selectedElmGhost, 'data-mce-bogus', 'all');
              selectedElmGhost.contentEditable = false; // Hides IE move layer cursor
              selectedElmGhost.unSelectabe = true;

              dom.setStyles(selectedElmGhost, {
                left: selectedElmX,
                top: selectedElmY,
                margin: 0
              });

              // mark selectedElm
              dom.addClass(selectedElm, 'mce-resizing');

              selectedElmGhost.removeAttribute('data-mce-selected');
              rootElement.appendChild(selectedElmGhost);

              dom.bind(editableDoc, 'mousemove touchmove', resizeGhostElement);
              dom.bind(editableDoc, 'mouseup touchend', endGhostResize);

              if (rootDocument != editableDoc) {
                dom.bind(rootDocument, 'mousemove touchmove', resizeGhostElement);
                dom.bind(rootDocument, 'mouseup touchend', endGhostResize);
              }

              resizeHelper = dom.add(rootElement, 'div', {
                'class': 'mce-resize-helper',
                'data-mce-bogus': 'all'
              }, startW + ' &times; ' + startH);
            }

            if (mouseDownHandleName) {
              // Drag started by IE native resizestart
              if (name == mouseDownHandleName) {
                startDrag(mouseDownEvent);
              }

              return;
            }

            // Get existing or render resize handle
            handleElm = dom.get('mceResizeHandle' + name.toUpperCase());

            if (handleElm) {
              dom.remove(handleElm);
            }

            handleElm = dom.add(rootElement, 'div', {
              id: 'mceResizeHandle' + name.toUpperCase(),
              'data-mce-bogus': 'all',
              'class': 'mce-resizehandle mce-resizehandle-' + name,
              unselectable: true,
              style: 'cursor:' + name + '-resize;'
            });

            // Hides IE move layer cursor
            // If we set it on Chrome we get this wounderful bug: #6725
            // Edge doesn't have this issue however setting contenteditable
            // will move the selection to that element on Edge 17 see #TINY-1679
            if (isIE === 11) {
              handleElm.contentEditable = false;
            }

            dom.bind(handleElm, 'mousedown', function (e) {
              e.stopImmediatePropagation();
              e.preventDefault();
              startDrag(e);
            });

            handle.elm = handleElm;

            // Position element
            dom.setStyles(handleElm, {
              left: (targetWidth * handle[0] + selectedElmX) - (handleElm.offsetWidth / 2),
              top: (targetHeight * handle[1] + selectedElmY) - (handleElm.offsetHeight / 2)
            });
          });
        } else {
          hideResizeRect();
        }

        selectedElm.setAttribute('data-mce-selected', '1');
      }

      function hideResizeRect() {
        var name, handleElm;

        unbindResizeHandleEvents();

        if (selectedElm) {
          selectedElm.removeAttribute('data-mce-selected');
        }

        for (name in resizeHandles) {
          handleElm = dom.get('mceResizeHandle' + name.toUpperCase());
          if (handleElm) {
            dom.unbind(handleElm);
            dom.remove(handleElm);
          }
        }
      }

      function updateResizeRect(e) {
        var startElm, controlElm;

        function isChildOrEqual(node, parent) {
          if (node) {
            do {
              if (node === parent) {
                return true;
              }
            } while ((node = node.parentNode));
          }
        }

        // Ignore all events while resizing or if the editor instance was removed
        if (resizeStarted || editor.removed || editor !== tinymce.activeEditor) {
          return;
        }

        // Remove data-mce-selected from all elements since they might have been copied using Ctrl+c/v
        each(dom.select('img[data-mce-selected][data-mce-resize],hr[data-mce-selected][data-mce-resize],span[data-mce-selected][data-mce-resize]'), function (img) {
          img.removeAttribute('data-mce-selected');
        });

        controlElm = e.type == 'mousedown' ? e.target : selection.getNode();
        controlElm = dom.closest(controlElm, isIE ? 'table' : 'table,img,[data-mce-resize]')[0];

        if (isChildOrEqual(controlElm, rootElement)) {
          disableGeckoResize();
          startElm = selection.getStart(true);

          if (isChildOrEqual(startElm, controlElm) && isChildOrEqual(selection.getEnd(true), controlElm)) {
            if (!isIE || (controlElm != startElm && startElm.nodeName !== 'IMG')) {
              showResizeRect(controlElm);
              return;
            }
          }
        }

        hideResizeRect();
      }

      function attachEvent(elm, name, func) {
        if (elm && elm.attachEvent) {
          elm.attachEvent('on' + name, func);
        }
      }

      function detachEvent(elm, name, func) {
        if (elm && elm.detachEvent) {
          elm.detachEvent('on' + name, func);
        }
      }

      function resizeNativeStart(e) {
        var target = e.srcElement,
          pos, name, corner, cornerX, cornerY, relativeX, relativeY;

        pos = target.getBoundingClientRect();
        relativeX = lastMouseDownEvent.clientX - pos.left;
        relativeY = lastMouseDownEvent.clientY - pos.top;

        // Figure out what corner we are draging on
        for (name in resizeHandles) {
          corner = resizeHandles[name];

          cornerX = target.offsetWidth * corner[0];
          cornerY = target.offsetHeight * corner[1];

          if (abs(cornerX - relativeX) < 8 && abs(cornerY - relativeY) < 8) {
            selectedHandle = corner;
            break;
          }
        }

        // Remove native selection and let the magic begin
        resizeStarted = true;

        editor.onObjectResizeStart.dispatch(editor, selectedElm, selectedElm.clientWidth, selectedElm.clientHeight);

        editor.getDoc().selection.empty();
        showResizeRect(target, name, lastMouseDownEvent);
      }

      function preventDefault(e) {
        if (e.preventDefault) {
          e.preventDefault();
        } else {
          e.returnValue = false; // IE
        }
      }

      function isWithinContentEditableFalse(elm) {
        return hasContentEditableState(getContentEditableRoot(editor.getBody(), elm), 'false');
      }

      function nativeControlSelect(e) {
        var target = e.srcElement;

        if (isWithinContentEditableFalse(target)) {
          preventDefault(e);
          return;
        }

        if (target != selectedElm) {
          editor.onObjectSelected.dispatch(editor, target);

          detachResizeStartListener();

          if (target.id.indexOf('mceResizeHandle') === 0) {
            e.returnValue = false;
            return;
          }

          if (target.nodeName == 'IMG' || target.nodeName == 'TABLE') {
            hideResizeRect();
            selectedElm = target;
            attachEvent(target, 'resizestart', resizeNativeStart);
          }
        }
      }

      function detachResizeStartListener() {
        detachEvent(selectedElm, 'resizestart', resizeNativeStart);
      }

      function unbindResizeHandleEvents() {
        for (var name in resizeHandles) {
          var handle = resizeHandles[name];

          if (handle.elm) {
            dom.unbind(handle.elm);
            delete handle.elm;
          }
        }
      }

      function disableGeckoResize() {
        try {
          // Disable object resizing on Gecko
          editor.getDoc().execCommand('enableObjectResizing', false, false);
        } catch (ex) {
          // Ignore
        }
      }

      function controlSelect(elm) {
        var ctrlRng;

        if (!isIE) {
          return;
        }

        ctrlRng = editableDoc.body.createControlRange();

        try {
          ctrlRng.addElement(elm);
          ctrlRng.select();
          return true;
        } catch (ex) {
          // Ignore since the element can't be control selected for example a P tag
        }
      }

      function selectControl(editor, e) {
        var target = e.target,
          nodeName = target.nodeName;

        if (!resizeStarted && /^(TABLE|IMG|HR)$/.test(nodeName) && !isWithinContentEditableFalse(target)) {
          editor.selection.select(target, nodeName == 'TABLE');

          // Only fire once since nodeChange is expensive
          if (e.type == 'mousedown') {
            editor.nodeChanged();
          }
        }
      }

      editor.onInit.add(function (editor) {
        if (isIE) {
          // Hide the resize rect on resize and reselect the image
          editor.onObjectResized.add(function (editor, e) {
            if (e.target.nodeName != 'TABLE') {
              hideResizeRect();
              controlSelect(e.target);
            }
          });

          attachEvent(rootElement, 'controlselect', nativeControlSelect);

          editor.onMouseDown.add(function (editor, e) {
            lastMouseDownEvent = e;
          });
        } else {
          disableGeckoResize();

          // Sniff sniff, hard to feature detect this stuff
          if (tinymce.isIE >= 11 || tinymce.isIE12) {
            // Needs to be click on Edge / WebKit to properly select images
            editor.onClick.add(selectControl);

            // Needs to be mousedown for drag/drop to work on IE 11
            editor.onMouseDown.add(selectControl);

            editor.dom.bind(rootElement, 'mscontrolselect', function (e) {
              function delayedSelect(node) {
                setTimeout(function () {
                  editor.selection.select(node);
                }, 0);
              }

              if (isWithinContentEditableFalse(e.target)) {
                e.preventDefault();
                delayedSelect(e.target);
                return;
              }

              if (/^(TABLE|IMG|HR)$/.test(e.target.nodeName)) {
                e.preventDefault();

                // This moves the selection from being a control selection to a text like selection like in WebKit #6753
                // TODO: Fix this the day IE works like other browsers without this nasty native ugly control selections.
                if (e.target.tagName == 'IMG') {
                  delayedSelect(e.target);
                }
              }
            });
          }
        }

        var throttledUpdateResizeRect = debounce(function (e) {
          updateResizeRect(e);
        });

        // Toogle resize when image is selected
        editor.onNodeChange.add(function () {        
          setTimeout(function () {
            throttledUpdateResizeRect({
              type: ''
            });
          }, 100);
        });

        // Toogle resize when image is dropped
        editor.dom.bind(editor.getBody(), 'drop', function (e) {
          throttledUpdateResizeRect(e);
        });

        // Remove resize rect when getting content from the editor
        editor.onBeforeGetContent.add(hideResizeRect);

        function updateTableRect(editor, e) {
          if (selectedElm && selectedElm.nodeName == "TABLE") {
            throttledUpdateResizeRect(e);
          }
        }

        // Update resize rect while typing in a table
        editor.onKeyUp.add(updateTableRect);

        // Don't update the resize rect while composing since it blows away the IME see: #2710
        editor.dom.bind(editor.getBody(), 'compositionend', function (e) {
          updateTableRect(editor, e);
        });

        editor.onBlur.add(hideResizeRect);
        editor.onHide.add(hideResizeRect);
      });

      editor.onRemove.add(unbindResizeHandleEvents);

      function destroy() {
        selectedElm = selectedElmGhost = null;

        if (isIE) {
          detachResizeStartListener();
          detachEvent(rootElement, 'controlselect', nativeControlSelect);
        }
      }

      return {
        isResizable: isResizable,
        showResizeRect: showResizeRect,
        hideResizeRect: hideResizeRect,
        updateResizeRect: updateResizeRect,
        controlSelect: controlSelect,
        destroy: destroy
      };
    };
  })(tinymce);

  /**
   * Selection.js
   *
   * Copyright, Moxiecode Systems AB
   * Released under LGPL License.
   *
   * License: http://www.tinymce.com/license - Inactive
   * Licence: GNU/LGPL 2.1 or later - http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
   * Contributing: http://www.tinymce.com/contributing - Inactive
   */

  (function (tinymce) {
    // Shorten names
    var is = tinymce.is,
      isIE = tinymce.isIE,
      each = tinymce.each,
      extend = tinymce.extend,
      TreeWalker = tinymce.dom.TreeWalker,
      BookmarkManager = tinymce.dom.BookmarkManager,
      ControlSelection = tinymce.dom.ControlSelection;


    function isRestricted(element) {
      return !!element && !Object.getPrototypeOf(element);
    }

    /**
     * This class handles text and control selection it's an crossbrowser utility class.
     * Consult the TinyMCE Wiki API for more details and examples on how to use this class.
     *
     * @class tinymce.dom.Selection
     * @example
     * // Getting the currently selected node for the active editor
     * alert(tinymce.activeEditor.selection.getNode().nodeName);
     */
    /**
       * Constructs a new selection instance.
       *
       * @constructor
       * @method Selection
       * @param {tinymce.dom.DOMUtils} dom DOMUtils object reference.
       * @param {Window} win Window to bind the selection object to.
       * @param {tinymce.dom.Serializer} serializer DOM serialization class to use for getContent.
       */
    tinymce.dom.Selection = function (dom, win, serializer, editor) {
      var self = this;

      self.dom = dom;
      self.win = win;
      self.serializer = serializer;
      self.editor = editor;

      self.bookmarkManager = new BookmarkManager(self);
      self.controlSelection = new ControlSelection(self, editor);

      // Add events
      each([
        /**
         * This event gets executed before contents is extracted from the selection.
         *
         * @event onBeforeSetContent
         * @param {tinymce.dom.Selection} selection Selection object that fired the event.
         * @param {Object} args Contains things like the contents that will be returned.
         */
        'onBeforeSetContent',

        /**
         * This event gets executed before contents is inserted into selection.
         *
         * @event onBeforeGetContent
         * @param {tinymce.dom.Selection} selection Selection object that fired the event.
         * @param {Object} args Contains things like the contents that will be inserted.
         */
        'onBeforeGetContent',

        /**
         * This event gets executed when contents is inserted into selection.
         *
         * @event onSetContent
         * @param {tinymce.dom.Selection} selection Selection object that fired the event.
         * @param {Object} args Contains things like the contents that will be inserted.
         */
        'onSetContent',

        /**
         * This event gets executed when contents is extracted from the selection.
         *
         * @event onGetContent
         * @param {tinymce.dom.Selection} selection Selection object that fired the event.
         * @param {Object} args Contains things like the contents that will be returned.
         */
        'onGetContent',

        /**
         * This event gets executed when a range is extracted from the selection.
         *
         * @event onSetSelectionRange
         * @param {tinymce.dom.Selection} selection Selection object that fired the event.
         * @param {Object} args Contains things like the contents that will be returned.
         */
        'onGetSelectionRange',

        /**
         * This event gets executed when a selection range is set.
         *
         * @event onSetSelectionRange
         * @param {tinymce.dom.Selection} selection Selection object that fired the event.
         * @param {Object} args Contains things like the contents that will be returned.
         */
        'onSetSelectionRange',

        /**
         * This event gets executed after a selection range is set.
         *
         * @event onAfterSetSelectionRange
         * @param {tinymce.dom.Selection} selection Selection object that fired the event.
         * @param {Object} args Contains things like the contents that will be returned.
         */
        'onAfterSetSelectionRange'
      ], function (e) {
        self[e] = new tinymce.util.Dispatcher(self);
      });

      // Add onBeforeSetContent with cleanup
      self.onBeforeSetContent.add(function (e, args) {
        if (args.format !== 'raw') {
          var node = new tinymce.html.DomParser(editor.settings, editor.schema).parse(args.content, extend(args, { isRootContent: true, forced_root_block: false }));
          args.content = new tinymce.html.Serializer({ validate: false }, editor.schema).serialize(node);
        }
      });

      /*if (tinymce.isIE && !tinymce.isIE11 && dom.boxModel) {
        this._fixIESelection();
      }*/

      // Prevent leaks
      tinymce.addUnload(self.destroy, self);
    };

    tinymce.dom.Selection.prototype = {

      /**
       * Move the selection cursor range to the specified node and offset.
       * @param node Node to put the cursor in.
       * @param offset Offset from the start of the node to put the cursor at.
       */
      setCursorLocation: function (node, offset) {
        var self = this;
        var r = self.dom.createRng();
        r.setStart(node, offset);
        r.setEnd(node, offset);
        self.setRng(r);
        self.collapse(false);
      },

      getContextualFragment: function (rng, frag) {
        var self = this,
          ed = self.editor,
          dom = self.dom;

        function isBlock(elm) {
          return dom.isBlock(elm) && !/H[1-6]/.test(elm.nodeName);
        }

        var node = rng.commonAncestorContainer;

        // skip if the node is the editor body
        if (node === ed.getBody()) {
          return frag;
        }

        var tableCells = dom.select('td.mceSelected, th.mceSelected', node);

        if (tableCells.length) {
          var table = dom.getParent(node, 'table');

          if (table) {
            var parent = dom.clone(table),
              row = dom.create('tr');

            each(tableCells, function (cell) {
              row.appendChild(dom.clone(cell, true));
            });

            parent.appendChild(row);

            return parent;
          }
        }

        if (rng.collapsed) {
          return frag;
        }

        // get all parents of the ancestor node, excluding the body
        var parents = dom.getParents(node, null, ed.getBody());

        // filter to get inline and heading elements
        var elms = tinymce.grep(parents, function (elm) {
          return elm.nodeType === 1 && !isBlock(elm);
        });

        // no elements selected, return range contents
        if (!elms.length) {
          return frag;
        }

        // create fragment to return
        var nodes = document.createDocumentFragment();

        // clone each parent node, adding fragment
        each(elms, function (elm) {
          var n = dom.clone(elm);

          n.appendChild(frag);

          nodes.appendChild(n);
        });

        return nodes;
      },

      /**
       * Returns the selected contents using the DOM serializer passed in to this class.
       *
       * @method getContent
       * @param {Object} s Optional settings class with for example output format text or html.
       * @return {String} Selected contents in for example HTML format.
       * @example
       * // Alerts the currently selected contents
       * alert(tinymce.activeEditor.selection.getContent());
       *
       * // Alerts the currently selected contents as plain text
       * alert(tinymce.activeEditor.selection.getContent({format : 'text'}));
       */
      getContent: function (s) {
        var self = this,
        ed = self.editor,
          r = self.getRng(),
          e = self.dom.create("body"),
          se = self.getSel(),
          wb, wa, frag;

        s = s || {};
        wb = wa = '';
        s.get = true;
        s.format = s.format || 'html';
        s.forced_root_block = '';
        self.onBeforeGetContent.dispatch(self, s);

        s.selection = true;

        ed.onBeforeGetContent.dispatch(ed, s);

        if (s.format == 'text') {
          return self.isCollapsed() ? '' : (r.text || (se.toString ? se.toString() : ''));
        }

        if (r.cloneContents) {
          frag = r.cloneContents();

          if (frag) {

            // internal content selection for cut/copy
            if (s.contextual) {
              frag = self.getContextualFragment(r, frag);
            }

            e.appendChild(frag);
          }
        } else if (is(r.item) || is(r.htmlText)) {
          // IE will produce invalid markup if elements are present that
          // it doesn't understand like custom elements or HTML5 elements.
          // Adding a BR in front of the contents and then remoiving it seems to fix it though.
          e.innerHTML = '<br>' + (r.item ? r.item(0).outerHTML : r.htmlText);
          e.removeChild(e.firstChild);
        } else {
          e.innerHTML = r.toString();
        }

        // Keep whitespace before and after
        if (/^\s/.test(e.innerHTML)) {
          wb = ' ';
        }

        if (/\s+$/.test(e.innerHTML)) {
          wa = ' ';
        }

        s.getInner = true;

        s.content = self.isCollapsed() ? '' : wb + self.serializer.serialize(e, s) + wa;

        self.onGetContent.dispatch(self, s);

        ed.onGetContent.dispatch(ed, s);

        return s.content;
      },

      /**
       * Sets the current selection to the specified content. If any contents is selected it will be replaced
       * with the contents passed in to this function. If there is no selection the contents will be inserted
       * where the caret is placed in the editor/page.
       *
       * @method setContent
       * @param {String} content HTML contents to set could also be other formats depending on settings.
       * @param {Object} args Optional settings object with for example data format.
       * @example
       * // Inserts some HTML contents at the current selection
       * tinymce.activeEditor.selection.setContent('<strong>Some contents</strong>');
       */
      setContent: function (content, args) {
        var self = this,
        ed = self.editor,
          rng = self.getRng(),
          caretNode, doc = self.win.document;

        args = args || {
          format: 'html'
        };
        args.set = true;
        args.content = content;

        args.selection = true;

        // Dispatch before set content event
        if (!args.no_events) {
          //self.onBeforeSetContent.dispatch(self, args);

          ed.onBeforeSetContent.dispatch(ed, args);
        }

        content = args.content;

        if (rng.insertNode) {
          // Make caret marker since insertNode places the caret in the beginning of text after insert
          content += '<span id="__caret">_</span>';

          // Delete and insert new node
          if (rng.startContainer == doc && rng.endContainer == doc) {
            // WebKit will fail if the body is empty since the range is then invalid and it can't insert contents
            doc.body.innerHTML = content;
          } else {
            rng.deleteContents();

            if (doc.body.childNodes.length === 0) {
              doc.body.innerHTML = content;
            } else {
              rng.insertNode(rng.createContextualFragment(content));
            }
          }

          // Move to caret marker
          caretNode = self.dom.get('__caret');

          // Make sure we wrap it compleatly, Opera fails with a simple select call
          rng = doc.createRange();
          rng.setStartBefore(caretNode);
          rng.setEndBefore(caretNode);
          self.setRng(rng);

          // Remove the caret position
          self.dom.remove('__caret');

          try {
            self.setRng(rng);
          } catch (ex) {
            // Might fail on Opera for some odd reason
          }
        } else {
          if (rng.item) {
            // Delete content and get caret text selection
            doc.execCommand('Delete', false, null);
            rng = self.getRng();
          }

          // Explorer removes spaces from the beginning of pasted contents
          if (/^\s+/.test(content)) {
            rng.pasteHTML('<span id="__mce_tmp">_</span>' + content);
            self.dom.remove('__mce_tmp');
          } else {
            rng.pasteHTML(content);
          }
        }

        // Dispatch set content event
        if (!args.no_events) {
          //self.onSetContent.dispatch(self, args);

          ed.onSetContent.dispatch(ed, args);
        }
      },

      /**
       * Returns the start element of a selection range. If the start is in a text
       * node the parent element will be returned.
       *
       * @method getStart
       * @param {Boolean} real Optional state to get the real parent when the selection is collapsed not the closest element.
       * @return {Element} Start element of selection range.
       */
      getStart: function (real) {
        var self = this,
          rng = self.getRng(),
          startElement, parentElement, checkRng, node;

        if (rng.duplicate || rng.item) {
          // Control selection, return first item
          if (rng.item) {
            return rng.item(0);
          }

          // Get start element
          checkRng = rng.duplicate();
          checkRng.collapse(1);
          startElement = checkRng.parentElement();

          if (startElement.ownerDocument !== self.dom.doc) {
            startElement = self.dom.getRoot();
          }

          // Check if range parent is inside the start element, then return the inner parent element
          // This will fix issues when a single element is selected, IE would otherwise return the wrong start element
          parentElement = node = rng.parentElement();

          while ((node = node.parentNode)) {
            if (node == startElement) {
              startElement = parentElement;
              break;
            }
          }

          return startElement;
        }

        startElement = rng.startContainer;

        if (startElement.nodeType == 1 && startElement.hasChildNodes()) {
          if (!real || !rng.collapsed) {
            startElement = startElement.childNodes[Math.min(startElement.childNodes.length - 1, rng.startOffset)];
          }
        }

        if (startElement && startElement.nodeType == 3) {
          return startElement.parentNode;
        }

        return startElement;
      },

      /**
       * Returns the end element of a selection range. If the end is in a text
       * node the parent element will be returned.
       *
       * @method getEnd
       * @param {Boolean} real Optional state to get the real parent when the selection is collapsed not the closest element.
       * @return {Element} End element of selection range.
       */
      getEnd: function (real) {
        var self = this,
          rng = self.getRng(),
          endElement, endOffset;

        if (rng.duplicate || rng.item) {
          if (rng.item) {
            return rng.item(0);
          }

          rng = rng.duplicate();
          rng.collapse(0);
          endElement = rng.parentElement();
          if (endElement.ownerDocument !== self.dom.doc) {
            endElement = self.dom.getRoot();
          }

          if (endElement && endElement.nodeName == 'BODY') {
            return endElement.lastChild || endElement;
          }

          return endElement;
        }

        endElement = rng.endContainer;
        endOffset = rng.endOffset;

        if (endElement.nodeType == 1 && endElement.hasChildNodes()) {
          if (!real || !rng.collapsed) {
            endElement = endElement.childNodes[endOffset > 0 ? endOffset - 1 : endOffset];
          }
        }

        if (endElement && endElement.nodeType == 3) {
          return endElement.parentNode;
        }

        return endElement;
      },

      /**
       * Returns a bookmark location for the current selection. This bookmark object
       * can then be used to restore the selection after some content modification to the document.
       *
       * @method getBookmark
       * @param {Number} type Optional state if the bookmark should be simple or not. Default is complex.
       * @param {Boolean} normalized Optional state that enables you to get a position that it would be after normalization.
       * @return {Object} Bookmark object, use moveToBookmark with this object to restore the selection.
       * @example
       * // Stores a bookmark of the current selection
       * var bm = tinymce.activeEditor.selection.getBookmark();
       *
       * tinymce.activeEditor.setContent(tinymce.activeEditor.getContent() + 'Some new content');
       *
       * // Restore the selection bookmark
       * tinymce.activeEditor.selection.moveToBookmark(bm);
       */
      getBookmark: function (type, normalized) {
        return this.bookmarkManager.getBookmark(type, normalized);
      },

      /**
       * Restores the selection to the specified bookmark.
       *
       * @method moveToBookmark
       * @param {Object} bookmark Bookmark to restore selection from.
       * @return {Boolean} true/false if it was successful or not.
       * @example
       * // Stores a bookmark of the current selection
       * var bm = tinymce.activeEditor.selection.getBookmark();
       *
       * tinymce.activeEditor.setContent(tinymce.activeEditor.getContent() + 'Some new content');
       *
       * // Restore the selection bookmark
       * tinymce.activeEditor.selection.moveToBookmark(bm);
       */
      moveToBookmark: function (bookmark) {
        return this.bookmarkManager.moveToBookmark(bookmark);
      },

      /**
       * Selects the specified element. This will place the start and end of the selection range around the element.
       *
       * @method select
       * @param {Element} node HMTL DOM element to select.
       * @param {Boolean} content Optional bool state if the contents should be selected or not on non IE browser.
       * @return {Element} Selected element the same element as the one that got passed in.
       * @example
       * // Select the first paragraph in the active editor
       * tinymce.activeEditor.selection.select(tinymce.activeEditor.dom.select('p')[0]);
       */
      select: function (node, content) {
        var self = this,
          dom = self.dom,
          rng = dom.createRng(),
          idx;

        function setPoint(node, start) {
          var walker = new TreeWalker(node, node);

          do {
            // Text node
            if (node.nodeType == 3 && tinymce.trim(node.nodeValue).length !== 0) {
              if (start) {
                rng.setStart(node, 0);
              } else {
                rng.setEnd(node, node.nodeValue.length);
              }

              return;
            }

            // BR element
            if (node.nodeName == 'BR') {
              if (start) {
                rng.setStartBefore(node);
              } else {
                rng.setEndBefore(node);
              }

              return;
            }
          } while ((node = (start ? walker.next() : walker.prev())));
        }

        if (node) {
          if (!content && self.controlSelection.controlSelect(node)) {
            return;
          }

          idx = dom.nodeIndex(node);
          rng.setStart(node.parentNode, idx);
          rng.setEnd(node.parentNode, idx + 1);

          // Find first/last text node or BR element
          if (content) {
            setPoint(node, 1);
            setPoint(node);
          }

          self.setRng(rng);
        }

        return node;
      },

      /**
       * Returns true/false if the selection range is collapsed or not. Collapsed means if it's a caret or a larger selection.
       *
       * @method isCollapsed
       * @return {Boolean} true/false state if the selection range is collapsed or not. Collapsed means if it's a caret or a larger selection.
       */
      isCollapsed: function () {
        var self = this,
          r = self.getRng(),
          s = self.getSel();

        if (!r || r.item) {
          return false;
        }

        if (r.compareEndPoints) {
          return r.compareEndPoints('StartToEnd', r) === 0;
        }

        return !s || r.collapsed;
      },

      /**
       * Collapse the selection to start or end of range.
       *
       * @method collapse
       * @param {Boolean} to_start Optional boolean state if to collapse to end or not. Defaults to start.
       */
      collapse: function (to_start) {
        var self = this,
          rng = self.getRng(),
          node;

        // Control range on IE
        if (rng.item) {
          node = rng.item(0);
          rng = self.win.document.body.createTextRange();
          rng.moveToElementText(node);
        }

        rng.collapse(!!to_start);
        self.setRng(rng);
      },

      /**
       * Returns the browsers internal selection object.
       *
       * @method getSel
       * @return {Selection} Internal browser selection object.
       */
      getSel: function () {
        var w = this.win;

        return w.getSelection ? w.getSelection() : w.document.selection;
      },

      /**
       * Returns the browsers internal range object.
       *
       * @method getRng
       * @param {Boolean} w3c Forces a compatible W3C range on IE.
       * @return {Range} Internal browser range object.
       * @see http://www.quirksmode.org/dom/range_intro.html
       * @see http://www.dotvoid.com/2001/03/using-the-range-object-in-mozilla/
       */
      getRng: function (w3c) {
        var self = this,
          selection, rng, elm, doc, ieRng, evt;

        function tryCompareBoundaryPoints(how, sourceRange, destinationRange) {
          try {
            return sourceRange.compareBoundaryPoints(how, destinationRange);
          } catch (ex) {
            // Gecko throws wrong document exception if the range points
            // to nodes that where removed from the dom #6690
            // Browsers should mutate existing DOMRange instances so that they always point
            // to something in the document this is not the case in Gecko works fine in IE/WebKit/Blink
            // For performance reasons just return -1
            return -1;
          }
        }

        if (!self.win) {
          return null;
        }

        doc = self.win.document;

        if (typeof doc === 'undefined' || doc === null) {
          return null;
        }

        // Use last rng passed from FocusManager if it's available this enables
        // calls to editor.selection.getStart() to work when caret focus is lost on IE
        if (!w3c && self.lastFocusBookmark) {
          var bookmark = self.lastFocusBookmark;

          // Convert bookmark to range IE 11 fix
          if (bookmark.startContainer) {
            rng = doc.createRange();
            rng.setStart(bookmark.startContainer, bookmark.startOffset);
            rng.setEnd(bookmark.endContainer, bookmark.endOffset);
          } else {
            rng = bookmark;
          }

          return rng;
        }

        try {
          if ((selection = self.getSel()) && !isRestricted(selection.anchorNode)) {
            if (selection.rangeCount > 0) {
              rng = selection.getRangeAt(0);
            } else {
              rng = selection.createRange ? selection.createRange() : doc.createRange();
            }
          }
        } catch (ex) {
          // IE throws unspecified error here if TinyMCE is placed in a frame/iframe
        }

        evt = { range: rng };

        self.onGetSelectionRange.dispatch(self, evt);

        if (evt.range !== rng) {
          return evt.range;
        }

        // We have W3C ranges and it's IE then fake control selection since IE9 doesn't handle that correctly yet
        // IE 11 doesn't support the selection object so we check for that as well
        if (isIE && rng && rng.setStart && doc.selection) {
          try {
            // IE will sometimes throw an exception here
            ieRng = doc.selection.createRange();
          } catch (ex) {
            // Ignore
          }

          if (ieRng && ieRng.item) {
            elm = ieRng.item(0);
            rng = doc.createRange();
            rng.setStartBefore(elm);
            rng.setEndAfter(elm);
          }
        }

        // Firefox throws an error in restricted ranges, such as when clicking in a video element, so reset rng
        if (rng && isRestricted(rng.startContainer)) {
          rng = null;
        }

        // No range found then create an empty one
        // This can occur when the editor is placed in a hidden container element on Gecko
        // Or on IE when there was an exception
        if (!rng) {
          rng = doc.createRange ? doc.createRange() : doc.body.createTextRange();
        }

        // If range is at start of document then move it to start of body
        if (rng.setStart && rng.startContainer.nodeType === 9 && rng.collapsed) {
          elm = self.dom.getRoot();
          rng.setStart(elm, 0);
          rng.setEnd(elm, 0);
        }

        if (self.selectedRange && self.explicitRange) {
          if (tryCompareBoundaryPoints(rng.START_TO_START, rng, self.selectedRange) === 0 &&
            tryCompareBoundaryPoints(rng.END_TO_END, rng, self.selectedRange) === 0) {
            // Safari, Opera and Chrome only ever select text which causes the range to change.
            // This lets us use the originally set range if the selection hasn't been changed by the user.
            rng = self.explicitRange;
          } else {
            self.selectedRange = null;
            self.explicitRange = null;
          }
        }

        return rng;
      },

      /**
       * Changes the selection to the specified DOM range.
       *
       * @method setRng
       * @param {Range} rng Range to select.
       * @param {Boolean} forward Optional boolean if the selection is forwards or backwards.
       */
      setRng: function (rng, forward) {
        var self = this,
          sel, node, doc = self.win.document;

        if (!rng) {
          return;
        }

        // Is IE specific range
        if (rng.select) {
          self.explicitRange = null;

          try {
            rng.select();
          } catch (ex) {
            // Needed for some odd IE bug #1843306
          }

          return;
        }

        sel = self.getSel();

        var evt = { range: rng };

        self.onSetSelectionRange.dispatch(self, evt);

        rng = evt.range;

        if (sel) {
          self.explicitRange = rng;

          try {
            sel.removeAllRanges();

            if (doc.contains(rng.startContainer)) {
              sel.addRange(rng);
            }
            
          } catch (ex) {
            // IE might throw errors here if the editor is within a hidden container and selection is changed
          }

          // Forward is set to false and we have an extend function
          if (forward === false && sel.extend) {
            sel.collapse(rng.endContainer, rng.endOffset);
            sel.extend(rng.startContainer, rng.startOffset);
          }

          // adding range isn't always successful so we need to check range count otherwise an exception can occur
          self.selectedRange = sel.rangeCount > 0 ? sel.getRangeAt(0) : null;
        }

        // WebKit egde case selecting images works better using setBaseAndExtent when the image is floated
        if (!rng.collapsed && rng.startContainer === rng.endContainer && sel.setBaseAndExtent && !tinymce.isIE) {
          if (rng.endOffset - rng.startOffset < 2) {
            if (rng.startContainer.hasChildNodes()) {
              node = rng.startContainer.childNodes[rng.startOffset];
              if (node && node.tagName === 'IMG') {
                sel.setBaseAndExtent(
                  rng.startContainer,
                  rng.startOffset,
                  rng.endContainer,
                  rng.endOffset
                );

                // Since the setBaseAndExtent is fixed in more recent Blink versions we
                // need to detect if it's doing the wrong thing and falling back to the
                // crazy incorrect behavior api call since that seems to be the only way
                // to get it to work on Safari WebKit as of 2017-02-23
                if (sel.anchorNode !== rng.startContainer || sel.focusNode !== rng.endContainer) {
                  sel.setBaseAndExtent(node, 0, node, 1);
                }
              }
            }
          }
        }

        self.onAfterSetSelectionRange.dispatch(self, {
          range: rng
        });
      },

      /**
       * Sets the current selection to the specified DOM element.
       *
       * @method setNode
       * @param {Element} n Element to set as the contents of the selection.
       * @return {Element} Returns the element that got passed in.
       * @example
       * // Inserts a DOM node at current selection/caret location
       * tinymce.activeEditor.selection.setNode(tinymce.activeEditor.dom.create('img', {src : 'some.gif', title : 'some title'}));
       */
      setNode: function (n) {
        var self = this;

        self.setContent(self.dom.getOuterHTML(n));

        return n;
      },

      /**
       * Returns the currently selected element or the common ancestor element for both start and end of the selection.
       *
       * @method getNode
       * @return {Element} Currently selected element or common ancestor element.
       * @example
       * // Alerts the currently selected elements node name
       * alert(tinymce.activeEditor.selection.getNode().nodeName);
       */
      getNode: function () {
        var self = this,
          rng = self.getRng(),
          elm;
        var startContainer, endContainer, startOffset, endOffset, root = self.dom.getRoot();

        function skipEmptyTextNodes(node, forwards) {
          var orig = node;

          while (node && node.nodeType === 3 && node.length === 0) {
            node = forwards ? node.nextSibling : node.previousSibling;
          }

          return node || orig;
        }

        // Range maybe lost after the editor is made visible again
        if (!rng) {
          return root;
        }

        startContainer = rng.startContainer;
        endContainer = rng.endContainer;
        startOffset = rng.startOffset;
        endOffset = rng.endOffset;

        if (rng.setStart) {
          elm = rng.commonAncestorContainer;

          // Handle selection a image or other control like element such as anchors
          if (!rng.collapsed) {
            if (startContainer == endContainer) {
              if (endOffset - startOffset < 2) {
                if (startContainer.hasChildNodes()) {
                  elm = startContainer.childNodes[startOffset];
                }
              }
            }

            // If the anchor node is a element instead of a text node then return this element
            //if (tinymce.isWebKit && sel.anchorNode && sel.anchorNode.nodeType == 1)
            // return sel.anchorNode.childNodes[sel.anchorOffset];

            // Handle cases where the selection is immediately wrapped around a node and return that node instead of it's parent.
            // This happens when you double click an underlined word in FireFox.
            if (startContainer.nodeType === 3 && endContainer.nodeType === 3) {
              if (startContainer.length === startOffset) {
                startContainer = skipEmptyTextNodes(startContainer.nextSibling, true);
              } else {
                startContainer = startContainer.parentNode;
              }

              if (endOffset === 0) {
                endContainer = skipEmptyTextNodes(endContainer.previousSibling, false);
              } else {
                endContainer = endContainer.parentNode;
              }

              if (startContainer && startContainer === endContainer) {
                return startContainer;
              }
            }
          }

          if (elm && elm.nodeType == 3) {
            return elm.parentNode;
          }

          return elm;
        }

        elm = rng.item ? rng.item(0) : rng.parentElement();

        return elm;
      },

      getSelectedBlocks: function (st, en) {
        var self = this,
          dom = self.dom,
          sb, eb, n, bl = [];

        sb = dom.getParent(st || self.getStart(), dom.isBlock);
        eb = dom.getParent(en || self.getEnd(), dom.isBlock);

        if (sb) {
          bl.push(sb);
        }

        if (sb && eb && sb != eb) {
          n = sb;

          var walker = new TreeWalker(sb, dom.getRoot());
          while ((n = walker.next()) && n != eb) {
            if (dom.isBlock(n)) {
              bl.push(n);
            }
          }
        }

        if (eb && sb != eb) {
          bl.push(eb);
        }

        return bl;
      },

      getSelectedNodes: function (start, end) {
        var self = this,
          startNode, endNode, node, nodes = [], rng = self.getRng();

        startNode = start || rng.startContainer;
        endNode = end || rng.endContainer;

        if (startNode) {
          nodes.push(startNode);
        }

        if (startNode && endNode && startNode != endNode) {
          node = startNode;

          var walker = new TreeWalker(startNode, self.dom.getRoot());

          while ((node = walker.next()) && node != endNode) {

            // check for parent node that is an element...
            if (node.parentNode !== self.dom.getRoot()) {
              continue;
            }

            nodes.push(node);
          }
        }

        if (endNode && startNode != endNode) {
          nodes.push(endNode);
        }

        return nodes;
      },

      isForward: function () {
        var dom = this.dom,
          sel = this.getSel(),
          anchorRange, focusRange;

        // No support for selection direction then always return true
        if (!sel || sel.anchorNode == null || sel.focusNode == null) {
          return true;
        }

        anchorRange = dom.createRng();
        anchorRange.setStart(sel.anchorNode, sel.anchorOffset);
        anchorRange.collapse(true);

        focusRange = dom.createRng();
        focusRange.setStart(sel.focusNode, sel.focusOffset);
        focusRange.collapse(true);

        return anchorRange.compareBoundaryPoints(anchorRange.START_TO_START, focusRange) <= 0;
      },

      normalize: function () {
        var self = this,
          rng, normalized, collapsed;

        function normalizeEndPoint(start) {
          var container, offset, walker, dom = self.dom,
            body = dom.getRoot(),
            node, nonEmptyElementsMap;

          function hasBrBeforeAfter(node, left) {
            var walker = new TreeWalker(node, dom.getParent(node.parentNode, dom.isBlock) || body);

            while ((node = walker[left ? 'prev' : 'next']())) {
              if (node.nodeName === "BR") {
                return true;
              }
            }
          }

          // Walks the dom left/right to find a suitable text node to move the endpoint into
          // It will only walk within the current parent block or body and will stop if it hits a block or a BR/IMG
          function findTextNodeRelative(left, startNode) {
            var walker, lastInlineElement;

            startNode = startNode || container;
            walker = new TreeWalker(startNode, dom.getParent(startNode.parentNode, dom.isBlock) || body);

            // Walk left until we hit a text node we can move to or a block/br/img
            while ((node = walker[left ? 'prev' : 'next']())) {
              // Found text node that has a length
              if (node.nodeType === 3 && node.nodeValue.length > 0) {
                container = node;
                offset = left ? node.nodeValue.length : 0;
                normalized = true;
                return;
              }

              // Break if we find a block or a BR/IMG/INPUT etc
              if (dom.isBlock(node) || nonEmptyElementsMap[node.nodeName.toLowerCase()]) {
                return;
              }

              lastInlineElement = node;
            }

            // Only fetch the last inline element when in caret mode for now
            if (collapsed && lastInlineElement) {
              container = lastInlineElement;
              normalized = true;
              offset = 0;
            }
          }

          container = rng[(start ? 'start' : 'end') + 'Container'];
          offset = rng[(start ? 'start' : 'end') + 'Offset'];
          nonEmptyElementsMap = dom.schema.getNonEmptyElements();

          // If the container is a document move it to the body element
          if (container.nodeType === 9) {
            container = dom.getRoot();
            offset = 0;
          }

          // If the container is body try move it into the closest text node or position
          if (container === body) {
            // If start is before/after a image, table etc
            if (start) {
              node = container.childNodes[offset > 0 ? offset - 1 : 0];
              if (node) {
                if (nonEmptyElementsMap[node.nodeName] || node.nodeName == "TABLE") {
                  return;
                }
              }
            }

            // Resolve the index
            if (container.hasChildNodes()) {
              container = container.childNodes[Math.min(!start && offset > 0 ? offset - 1 : offset, container.childNodes.length - 1)];
              offset = 0;

              // Don't walk into elements that doesn't have any child nodes like a IMG
              if (container.hasChildNodes() && !/TABLE/.test(container.nodeName)) {
                // Walk the DOM to find a text node to place the caret at or a BR
                node = container;
                walker = new TreeWalker(container, body);

                do {
                  // Found a text node use that position
                  if (node.nodeType === 3 && node.nodeValue.length > 0) {
                    offset = start ? 0 : node.nodeValue.length;
                    container = node;
                    normalized = true;
                    break;
                  }

                  // Found a BR/IMG element that we can place the caret before
                  if (nonEmptyElementsMap[node.nodeName.toLowerCase()]) {
                    offset = dom.nodeIndex(node);
                    container = node.parentNode;

                    // Put caret after image when moving the end point
                    if (node.nodeName == "IMG" && !start) {
                      offset++;
                    }

                    normalized = true;
                    break;
                  }
                } while ((node = (start ? walker.next() : walker.prev())));
              }
            }
          }

          // Lean the caret to the left if possible
          if (collapsed) {
            // So this: <b>x</b><i>|x</i>
            // Becomes: <b>x|</b><i>x</i>
            // Seems that only gecko has issues with this
            if (container.nodeType === 3 && offset === 0) {
              findTextNodeRelative(true);
            }

            // Lean left into empty inline elements when the caret is before a BR
            // So this: <i><b></b><i>|<br></i>
            // Becomes: <i><b>|</b><i><br></i>
            // Seems that only gecko has issues with this
            if (container.nodeType === 1) {
              node = container.childNodes[offset];
              if (node && node.nodeName === 'BR' && !hasBrBeforeAfter(node) && !hasBrBeforeAfter(node, true)) {
                findTextNodeRelative(true, container.childNodes[offset]);
              }
            }
          }

          // Lean the start of the selection right if possible
          // So this: x[<b>x]</b>
          // Becomes: x<b>[x]</b>
          if (start && !collapsed && container.nodeType === 3 && offset === container.nodeValue.length) {
            findTextNodeRelative(false);
          }

          // Set endpoint if it was normalized
          if (normalized) {
            rng['set' + (start ? 'Start' : 'End')](container, offset);
          }
        }

        // Normalize only on non IE browsers for now
        if (tinymce.isIE) {
          return;
        }

        rng = self.getRng();
        collapsed = rng.collapsed;

        // Normalize the end points
        normalizeEndPoint(true);

        if (!collapsed) {
          normalizeEndPoint();
        }

        // Set the selection if it was normalized
        if (normalized) {
          // If it was collapsed then make sure it still is
          if (collapsed) {
            rng.collapse(true);
          }

          //console.log(self.dom.dumpRng(rng));
          self.setRng(rng, self.isForward());
        }
      },

      /**
       * Executes callback of the current selection matches the specified selector or not and passes the state and args to the callback.
       *
       * @method selectorChanged
       * @param {String} selector CSS selector to check for.
       * @param {function} callback Callback with state and args when the selector is matches or not.
       */
      selectorChanged: function (selector, callback) {
        var self = this,
          currentSelectors;

        if (!self.selectorChangedData) {
          self.selectorChangedData = {};
          currentSelectors = {};

          self.editor.onNodeChange.addToTop(function (ed, cm, node) {
            var dom = self.dom,
              parents = dom.getParents(node, null, dom.getRoot()),
              matchedSelectors = {};

            // Check for new matching selectors
            each(self.selectorChangedData, function (callbacks, selector) {
              each(parents, function (node) {
                if (dom.is(node, selector)) {
                  if (!currentSelectors[selector]) {
                    // Execute callbacks
                    each(callbacks, function (callback) {
                      callback(true, {
                        node: node,
                        selector: selector,
                        parents: parents
                      });
                    });

                    currentSelectors[selector] = callbacks;
                  }

                  matchedSelectors[selector] = callbacks;
                  return false;
                }
              });
            });

            // Check if current selectors still match
            each(currentSelectors, function (callbacks, selector) {
              if (!matchedSelectors[selector]) {
                delete currentSelectors[selector];

                each(callbacks, function (callback) {
                  callback(false, {
                    node: node,
                    selector: selector,
                    parents: parents
                  });
                });
              }
            });
          });
        }

        // Add selector listeners
        if (!self.selectorChangedData[selector]) {
          self.selectorChangedData[selector] = [];
        }

        self.selectorChangedData[selector].push(callback);

        return self;
      },

      getScrollContainer: function () {
        var scrollContainer, node = this.dom.getRoot();
    
        while (node && node.nodeName != 'BODY') {
          if (node.scrollHeight > node.clientHeight) {
            scrollContainer = node;
            break;
          }
    
          node = node.parentNode;
        }
    
        return scrollContainer;
      },

      scrollIntoView: function (elm, alignToTop) {
        tinymce.dom.ScrollIntoView(this.editor, elm, alignToTop);
      },

      placeCaretAt: function (clientX, clientY) {
        this.setRng(tinymce.dom.RangeUtils.getCaretRangeFromPoint(clientX, clientY, this.editor.getDoc()));
      },

      destroy: function (manual) {
        var self = this;

        self.win = null;

        // Manual destroy then remove unload handler
        if (!manual) {
          tinymce.removeUnload(self.destroy);
        }
      },

      // IE has an issue where you can't select/move the caret by clicking outside the body if the document is in standards mode
      _fixIESelection: function () {
        var dom = this.dom,
          doc = dom.doc,
          body = doc.body,
          started, startRng, htmlElm;

        // Return range from point or null if it failed
        function rngFromPoint(x, y) {
          var rng = body.createTextRange();

          try {
            rng.moveToPoint(x, y);
          } catch (ex) {
            // IE sometimes throws and exception, so lets just ignore it
            rng = null;
          }

          return rng;
        }

        // Fires while the selection is changing
        function selectionChange(e) {
          var pointRng;

          // Check if the button is down or not
          if (e.button) {
            // Create range from mouse position
            pointRng = rngFromPoint(e.x, e.y);

            if (pointRng) {
              // Check if pointRange is before/after selection then change the endPoint
              if (pointRng.compareEndPoints('StartToStart', startRng) > 0) {
                pointRng.setEndPoint('StartToStart', startRng);
              } else {
                pointRng.setEndPoint('EndToEnd', startRng);
              }

              pointRng.select();
            }
          } else {
            endSelection();
          }
        }

        // Removes listeners
        function endSelection() {
          var rng = doc.selection.createRange();

          // If the range is collapsed then use the last start range
          if (startRng && !rng.item && rng.compareEndPoints('StartToEnd', rng) === 0) {
            startRng.select();
          }

          dom.unbind(doc, 'mouseup', endSelection);
          dom.unbind(doc, 'mousemove', selectionChange);
          startRng = started = 0;
        }

        // Make HTML element unselectable since we are going to handle selection by hand
        doc.documentElement.unselectable = true;

        // Detect when user selects outside BODY
        dom.bind(doc, ['mousedown', 'contextmenu'], function (e) {
          if (e.target.nodeName === 'HTML') {
            if (started) {
              endSelection();
            }

            // Detect vertical scrollbar, since IE will fire a mousedown on the scrollbar and have target set as HTML
            htmlElm = doc.documentElement;
            if (htmlElm.scrollHeight > htmlElm.clientHeight) {
              return;
            }

            started = 1;
            // Setup start position
            startRng = rngFromPoint(e.x, e.y);
            if (startRng) {
              // Listen for selection change events
              dom.bind(doc, 'mouseup', endSelection);
              dom.bind(doc, 'mousemove', selectionChange);

              dom.win.focus();
              startRng.select();
            }
          }
        });
      }
    };
  })(tinymce);

  /**
   * Serializer.js
   *
   * Copyright, Moxiecode Systems AB
   * Released under LGPL License.
   *
   * License: http://www.tinymce.com/license - Inactive
   * Licence: GNU/LGPL 2.1 or later - http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
   * Contributing: http://www.tinymce.com/contributing - Inactive
   */

  (function (tinymce) {
    /**
     * This class is used to serialize DOM trees into a string. Consult the TinyMCE Wiki API for more details and examples on how to use this class.
     *
     * @class tinymce.dom.Serializer
     */

    /**
     * Constucts a new DOM serializer class.
     *
     * @constructor
     * @method Serializer
     * @param {Object} settings Serializer settings object.
     * @param {tinymce.dom.DOMUtils} dom DOMUtils instance reference.
     * @param {tinymce.html.Schema} schema Optional schema reference.
     */
    tinymce.dom.Serializer = function (settings, dom, schema) {
      var self = this,
        onPreProcess, onPostProcess, isIE = tinymce.isIE,
        each = tinymce.each,
        htmlParser;

      // Support the old apply_source_formatting option
      if (!settings.apply_source_formatting) {
        settings.indent = false;
      }

      // Default DOM and Schema if they are undefined
      dom = dom || tinymce.DOM;
      schema = schema || new tinymce.html.Schema(settings);
      settings.entity_encoding = settings.entity_encoding || 'named';
      settings.remove_trailing_brs = "remove_trailing_brs" in settings ? settings.remove_trailing_brs : true;

      var tempAttrs = ['data-mce-selected'];

      /**
       * IE 11 has a fantastic bug where it will produce two trailing BR elements to iframe bodies when
       * the iframe is hidden by display: none on a parent container. The DOM is actually out of sync
       * with innerHTML in this case. It's like IE adds shadow DOM BR elements that appears on innerHTML
       * but not as the lastChild of the body. So this fix simply removes the last two
       * BR elements at the end of the document.
       *
       * Example of what happens: <body>text</body> becomes <body>text<br><br></body>
       */
      function trimTrailingBr(rootNode) {
        var brNode1, brNode2;

        function isBr(node) {
          return node && node.name === 'br';
        }

        brNode1 = rootNode.lastChild;
        if (isBr(brNode1)) {
          brNode2 = brNode1.prev;

          if (isBr(brNode2)) {
            brNode1.remove();
            brNode2.remove();
          }
        }
      }

      /**
       * This event gets executed before a HTML fragment gets serialized into a HTML string. This event enables you to do modifications to the DOM before the serialization occurs. It's important to know that the element that is getting serialized is cloned so it's not inside a document.
       *
       * @event onPreProcess
       * @param {tinymce.dom.Serializer} sender object/Serializer instance that is serializing an element.
       * @param {Object} args Object containing things like the current node.
       * @example
       * // Adds an observer to the onPreProcess event
       * serializer.onPreProcess.add(function(se, o) {
       *     // Add a class to each paragraph
       *     se.dom.addClass(se.dom.select('p', o.node), 'myclass');
       * });
       */
      onPreProcess = new tinymce.util.Dispatcher(self);

      /**
       * This event gets executed after a HTML fragment has been serialized into a HTML string. This event enables you to do modifications to the HTML string like regexp replaces etc.
       *
       * @event onPreProcess
       * @param {tinymce.dom.Serializer} sender object/Serializer instance that is serializing an element.
       * @param {Object} args Object containing things like the current contents.
       * @example
       * // Adds an observer to the onPostProcess event
       * serializer.onPostProcess.add(function(se, o) {
       *    // Remove all paragraphs and replace with BR
       *    o.content = o.content.replace(/<p[^>]+>|<p>/g, '');
       *    o.content = o.content.replace(/<\/p>/g, '<br />');
       * });
       */
      onPostProcess = new tinymce.util.Dispatcher(self);

      htmlParser = new tinymce.html.DomParser(settings, schema);

      // Convert tabindex back to elements when serializing contents
      htmlParser.addAttributeFilter('data-mce-tabindex', function (nodes, name) {
        var i = nodes.length,
          node;

        while (i--) {
          node = nodes[i];
          node.attr('tabindex', node.attributes.map['data-mce-tabindex']);
          node.attr(name, null);
        }
      });

      // Convert move data-mce-src, data-mce-href and data-mce-style into nodes or process them if needed
      htmlParser.addAttributeFilter('src,href,style', function (nodes, name) {
        var i = nodes.length,
          node, value, internalName = 'data-mce-' + name,
          urlConverter = settings.url_converter,
          urlConverterScope = settings.url_converter_scope,
          undef;

        while (i--) {
          node = nodes[i];

          value = node.attributes.map[internalName];
          if (value !== undef) {
            // Set external name to internal value and remove internal
            node.attr(name, value.length > 0 ? value : null);
            node.attr(internalName, null);
          } else {
            // No internal attribute found then convert the value we have in the DOM
            value = node.attributes.map[name];

            if (name === "style") {
              if (settings.validate_styles) {
                value = dom.serializeStyle(dom.parseStyle(value), node.name);
              }
            } else if (urlConverter) {
              value = urlConverter.call(urlConverterScope, value, name, node.name);
            }

            node.attr(name, value.length > 0 ? value : null);
          }
        }
      });

      // Remove internal classes mceItem<..> or mceSelected
      htmlParser.addAttributeFilter('class', function (nodes) {
        var i = nodes.length,
          node, value;

        while (i--) {
          node = nodes[i];
          value = node.attr('class');

          if (value) {
            value = node.attr('class').replace(/(?:^|\s)mce(-?)(Item[\w-]+|Selected)(?!\S)/gi, '');
            value = value.replace(/\s+/g, ' ').replace(/^\s*|\s*$/g, '');

            node.attr('class', value.length > 0 ? value : null);
          }
        }
      });

      // Remove bookmark and temp elements
      htmlParser.addAttributeFilter('data-mce-type', function (nodes, name, args) {
        var i = nodes.length,
          node;

        while (i--) {
          node = nodes[i];

          if (node.attributes.map['data-mce-type'] === 'temp') {
            node.remove();
            continue;
          }

          if (node.attributes.map['data-mce-type'] === 'bookmark' && !args.cleanup) {
            node.remove();
          }
        }
      });

      // Remove bogus elements
      /*htmlParser.addAttributeFilter('data-mce-bogus', function(nodes, name, args) {
        var i = nodes.length, node;

        while (i--) {
          node = nodes[i];

          if (node.attributes.map['data-mce-bogus'] === 'all' && !args.cleanup) {
            node.remove();
          }
        }
      });*/

      htmlParser.addNodeFilter('noscript', function (nodes) {
        var i = nodes.length,
          node;

        while (i--) {
          node = nodes[i].firstChild;

          if (node) {
            node.value = tinymce.html.Entities.decode(node.value);
          }
        }
      });

      // Force script into CDATA sections and remove the mce- prefix also add comments around styles
      htmlParser.addNodeFilter('script,style', function (nodes, name) {
        var i = nodes.length,
          node, value, type;

        function trim(value) {
          return value.replace(/(<!--\[CDATA\[|\]\]-->)/g, '\n')
            .replace(/^[\r\n]*|[\r\n]*$/g, '')
            .replace(/^\s*((<!--)?(\s*\/\/)?\s*<!\[CDATA\[|(<!--\s*)?\/\*\s*<!\[CDATA\[\s*\*\/|(\/\/)?\s*<!--|\/\*\s*<!--\s*\*\/)\s*[\r\n]*/gi, '')
            .replace(/\s*(\/\*\s*\]\]>\s*\*\/(-->)?|\s*\/\/\s*\]\]>(-->)?|\/\/\s*(-->)?|\]\]>|\/\*\s*-->\s*\*\/|\s*-->\s*)\s*$/g, '');
        }

        while (i--) {
          node = nodes[i];
          value = node.firstChild ? node.firstChild.value : '';

          if (name === "script") {
            // Remove mce- prefix from script elements and remove default type since the user specified
            // a script element without type attribute
            type = node.attr('type');

            if (type) {
              node.attr('type', type == 'mce-no/type' ? null : type.replace(/^mce\-/, ''));
            }

            if (value.length > 0) {
              //node.firstChild.value = '// <![CDATA[\n' + trim(value) + '\n// ]]>';
              node.firstChild.value = trim(value);
            }
          } else {
            if (value.length > 0) {
              //node.firstChild.value = '<!--\n' + trim(value) + '\n-->';
              node.firstChild.value = trim(value);
            }
          }
        }
      });

      // Convert comments to cdata and handle protected comments
      htmlParser.addNodeFilter('#comment', function (nodes) {
        var i = nodes.length,
          node;

        while (i--) {
          node = nodes[i];

          if (node.value.indexOf('[CDATA[') === 0) {
            node.name = '#cdata';
            node.type = 4;
            node.value = node.value.replace(/^\[CDATA\[|\]\]$/g, '');
          } else if (node.value.indexOf('mce:protected ') === 0) {
            node.name = "#text";
            node.type = 3;
            node.raw = true;
            node.value = unescape(node.value).substr(14);
          }
        }
      });

      htmlParser.addNodeFilter('xml:namespace,input', function (nodes, name) {
        var i = nodes.length,
          node;

        while (i--) {
          node = nodes[i];
          if (node.type === 7) {
            node.remove();
          } else if (node.type === 1) {
            if (name === "input" && !("type" in node.attributes.map)) {
              node.attr('type', 'text');
            }
          }
        }
      });

      // Fix list elements, TODO: Replace this later
      if (settings.fix_list_elements) {
        htmlParser.addNodeFilter('ul,ol', function (nodes) {
          var i = nodes.length,
            node, parentNode;

          while (i--) {
            node = nodes[i];
            parentNode = node.parent;

            if (parentNode.name === 'ul' || parentNode.name === 'ol') {
              if (node.prev && node.prev.name === 'li') {
                node.prev.append(node);
              }
            }
          }
        });
      }

      // Remove internal data attributes
      htmlParser.addAttributeFilter(
        'data-mce-src,data-mce-href,data-mce-style,' +
        'data-mce-selected,data-mce-expando,' +
        'data-mce-type,data-mce-resize,data-mce-new',

        function (nodes, name) {
          var i = nodes.length;

          while (i--) {
            nodes[i].attr(name, null);
          }
        }
      );

      // Return public methods
      return {
        /**
         * Schema instance that was used to when the Serializer was constructed.
         *
         * @field {tinymce.html.Schema} schema
         */
        schema: schema,

        /**
         * Adds a node filter function to the parser used by the serializer, the parser will collect the specified nodes by name
         * and then execute the callback ones it has finished parsing the document.
         *
         * @example
         * parser.addNodeFilter('p,h1', function(nodes, name) {
         *		for (var i = 0; i < nodes.length; i++) {
         *			console.log(nodes[i].name);
         *		}
         * });
         * @method addNodeFilter
         * @method {String} name Comma separated list of nodes to collect.
         * @param {function} callback Callback function to execute once it has collected nodes.
         */
        addNodeFilter: htmlParser.addNodeFilter,

        /**
         * Adds a attribute filter function to the parser used by the serializer, the parser will collect nodes that has the specified attributes
         * and then execute the callback ones it has finished parsing the document.
         *
         * @example
         * parser.addAttributeFilter('src,href', function(nodes, name) {
         *		for (var i = 0; i < nodes.length; i++) {
         *			console.log(nodes[i].name);
         *		}
         * });
         * @method addAttributeFilter
         * @method {String} name Comma separated list of nodes to collect.
         * @param {function} callback Callback function to execute once it has collected nodes.
         */
        addAttributeFilter: htmlParser.addAttributeFilter,

        /**
         * Fires when the Serializer does a preProcess on the contents.
         *
         * @event onPreProcess
         * @param {tinymce.Editor} sender Editor instance.
         * @param {Object} obj PreProcess object.
         * @option {Node} node DOM node for the item being serialized.
         * @option {String} format The specified output format normally "html".
         * @option {Boolean} get Is true if the process is on a getContent operation.
         * @option {Boolean} set Is true if the process is on a setContent operation.
         * @option {Boolean} cleanup Is true if the process is on a cleanup operation.
         */
        onPreProcess: onPreProcess,

        /**
         * Fires when the Serializer does a postProcess on the contents.
         *
         * @event onPostProcess
         * @param {tinymce.Editor} sender Editor instance.
         * @param {Object} obj PreProcess object.
         */
        onPostProcess: onPostProcess,

        /**
         * Serializes the specified browser DOM node into a HTML string.
         *
         * @method serialize
         * @param {DOMNode} node DOM node to serialize.
         * @param {Object} args Arguments option that gets passed to event handlers.
         */
        serialize: function (node, args) {
          var impl, doc, oldDoc, htmlSerializer, content, rootNode;

          // Explorer won't clone contents of script and style and the
          // selected index of select elements are cleared on a clone operation.
          if (isIE && dom.select('script,style,select,map').length > 0) {
            content = node.innerHTML;
            node = node.cloneNode(false);
            dom.setHTML(node, content);
          } else {
            node = node.cloneNode(true);
          }

          // Nodes needs to be attached to something in WebKit/Opera
          // This fix will make DOM ranges and make Sizzle happy!
          impl = document.implementation;
          if (impl.createHTMLDocument) {
            // Create an empty HTML document
            doc = impl.createHTMLDocument("");

            // Add the element or it's children if it's a body element to the new document
            each(node.nodeName == 'BODY' ? node.childNodes : [node], function (node) {
              doc.body.appendChild(doc.importNode(node, true));
            });

            // Grab first child or body element for serialization
            if (node.nodeName != 'BODY') {
              node = doc.body.firstChild;
            } else {
              node = doc.body;
            }

            // set the new document in DOMUtils so createElement etc works
            oldDoc = dom.doc;
            dom.doc = doc;
          }

          args = args || {};
          args.format = args.format || 'html';

          // Don't wrap content if we want selected html
          if (args.selection) {
            args.forced_root_block = '';
          }

          // Pre process
          if (!args.no_events) {
            args.node = node;
            onPreProcess.dispatch(self, args);
          }

          // Parse HTML
          rootNode = htmlParser.parse(tinymce.trim(args.getInner ? node.innerHTML : dom.getOuterHTML(node)), args);
          trimTrailingBr(rootNode);

          // Serialize HTML
          htmlSerializer = new tinymce.html.Serializer(settings, schema);
          args.content = htmlSerializer.serialize(rootNode);

          // Replace all BOM characters for now until we can find a better solution
          if (!args.cleanup) {
            args.content = args.content.replace(/\uFEFF/g, '');
          }

          // Post process
          if (!args.no_events) {
            onPostProcess.dispatch(self, args);
          }

          // Restore the old document if it was changed
          if (oldDoc) {
            dom.doc = oldDoc;
          }

          args.node = null;

          return args.content;
        },

        /**
         * Adds valid elements rules to the serializers schema instance this enables you to specify things
         * like what elements should be outputted and what attributes specific elements might have.
         * Consult the Wiki for more details on this format.
         *
         * @method addRules
         * @param {String} rules Valid elements rules string to add to schema.
         */
        addRules: function (rules) {
          schema.addValidElements(rules);
        },

        /**
         * Sets the valid elements rules to the serializers schema instance this enables you to specify things
         * like what elements should be outputted and what attributes specific elements might have.
         * Consult the Wiki for more details on this format.
         *
         * @method setRules
         * @param {String} rules Valid elements rules string.
         */
        setRules: function (rules) {
          schema.setValidElements(rules);
        },

        addTempAttr: function (name) {
          if (tinymce.inArray(tempAttrs, name) === -1) {
            htmlParser.addAttributeFilter(name, function (nodes, name) {
              var i = nodes.length;

              while (i--) {
                nodes[i].attr(name, null);
              }
            });

            tempAttrs.push(name);
          }
        },

        getTempAttrs: function () {
          return tempAttrs;
        }
      };
    };
  })(tinymce);

  /**
   * ScriptLoader.js
   *
   * Copyright, Moxiecode Systems AB
   * Released under LGPL License.
   *
   * License: http://www.tinymce.com/license - Inactive
   * Licence: GNU/LGPL 2.1 or later - http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
   * Contributing: http://www.tinymce.com/contributing - Inactive
   */

  /*eslint no-console:1 */

  (function (tinymce) {
    /**
  	 * This class handles asynchronous/synchronous loading of JavaScript files it will execute callbacks when various items gets loaded. This class is useful to load external JavaScript files.
  	 *
  	 * @class tinymce.dom.ScriptLoader
  	 * @example
  	 * // Load a script from a specific URL using the global script loader
  	 * tinymce.ScriptLoader.load('somescript.js');
  	 *
  	 * // Load a script using a unique instance of the script loader
  	 * var scriptLoader = new tinymce.dom.ScriptLoader();
  	 *
  	 * scriptLoader.load('somescript.js');
  	 *
  	 * // Load multiple scripts
  	 * var scriptLoader = new tinymce.dom.ScriptLoader();
  	 *
  	 * scriptLoader.add('somescript1.js');
  	 * scriptLoader.add('somescript2.js');
  	 * scriptLoader.add('somescript3.js');
  	 *
  	 * scriptLoader.loadQueue(function() {
  	 *    alert('All scripts are now loaded.');
  	 * });
  	 */
    tinymce.dom.ScriptLoader = function () {
      var QUEUED = 0,
        LOADING = 1,
        LOADED = 2,
        states = {},
        queue = [],
        scriptLoadedCallbacks = {},
        queueLoadedCallbacks = [],
        loading = 0,
        undef;

      /**
  		 * Loads a specific script directly without adding it to the load queue.
  		 *
  		 * @method load
  		 * @param {String} url Absolute URL to script to add.
  		 * @param {function} callback Optional callback function to execute ones this script gets loaded.
  		 * @param {Object} scope Optional scope to execute callback in.
  		 */
      function loadScript(url, callback) {
        var dom = tinymce.DOM,
          elm, id;

        // Execute callback when script is loaded
        function done() {
          dom.remove(id);

          if (elm) {
            elm.onreadystatechange = elm.onload = elm = null;
          }

          callback();
        }

        function error() {
          // Report the error so it's easier for people to spot loading errors
          if (typeof (console) !== "undefined" && console.log) {
            console.log("Failed to load: " + url);
          }

          // We can't mark it as done if there is a load error since
          // A) We don't want to produce 404 errors on the server and
          // B) the onerror event won't fire on all browsers.
          // done();
        }

        id = dom.uniqueId();

        // Create new script element
        elm = document.createElement('script');
        // prevent cloudflare rocket-loader caching
        elm.setAttribute('data-cfasync', false);

        elm.id = id;
        elm.type = 'text/javascript';
        elm.src = tinymce._addVer(url);

        // Add onload listener for non IE browsers since IE9
        // fires onload event before the script is parsed and executed
        if (!tinymce.isIE || tinymce.isIE11) {
          elm.onload = done;
        }

        // Add onerror event will get fired on some browsers but not all of them
        elm.onerror = error;

        // Opera 9.60 doesn't seem to fire the onreadystate event at correctly
        if (!tinymce.isOpera) {
          elm.onreadystatechange = function () {
            var state = elm.readyState;

            // Loaded state is passed on IE 6 however there
            // are known issues with this method but we can't use
            // XHR in a cross domain loading
            if (state == 'complete' || state == 'loaded') {
              done();
            }
          };
        }

        // Most browsers support this feature so we report errors
        // for those at least to help users track their missing plugins etc
        // todo: Removed since it produced error if the document is unloaded by navigating away, re-add it as an option
        /*elm.onerror = function() {
  				alert('Failed to load: ' + url);
  			};*/

        // Add script to document
        (document.getElementsByTagName('head')[0] || document.body).appendChild(elm);
      }

      /**
  		 * Returns true/false if a script has been loaded or not.
  		 *
  		 * @method isDone
  		 * @param {String} url URL to check for.
  		 * @return [Boolean} true/false if the URL is loaded.
  		 */
      this.isDone = function (url) {
        return states[url] == LOADED;
      };

      /**
  		 * Marks a specific script to be loaded. This can be useful if a script got loaded outside
  		 * the script loader or to skip it from loading some script.
  		 *
  		 * @method markDone
  		 * @param {string} u Absolute URL to the script to mark as loaded.
  		 */
      this.markDone = function (url) {
        states[url] = LOADED;
      };

      /**
  		 * Adds a specific script to the load queue of the script loader.
  		 *
  		 * @method add
  		 * @param {String} url Absolute URL to script to add.
  		 * @param {function} callback Optional callback function to execute ones this script gets loaded.
  		 * @param {Object} scope Optional scope to execute callback in.
  		 */
      this.add = this.load = function (url, callback, scope) {
        var state = states[url];

        // Add url to load queue
        if (state == undef) {
          queue.push(url);
          states[url] = QUEUED;
        }

        if (callback) {
          // Store away callback for later execution
          if (!scriptLoadedCallbacks[url]) {
            scriptLoadedCallbacks[url] = [];
          }

          scriptLoadedCallbacks[url].push({
            func: callback,
            scope: scope || this
          });
        }
      };

      /**
  		 * Starts the loading of the queue.
  		 *
  		 * @method loadQueue
  		 * @param {function} callback Optional callback to execute when all queued items are loaded.
  		 * @param {Object} scope Optional scope to execute the callback in.
  		 */
      this.loadQueue = function (callback, scope) {
        this.loadScripts(queue, callback, scope);
      };

      /**
  		 * Loads the specified queue of files and executes the callback ones they are loaded.
  		 * This method is generally not used outside this class but it might be useful in some scenarios.
  		 *
  		 * @method loadScripts
  		 * @param {Array} scripts Array of queue items to load.
  		 * @param {function} callback Optional callback to execute ones all items are loaded.
  		 * @param {Object} scope Optional scope to execute callback in.
  		 */
      this.loadScripts = function (scripts, callback, scope) {
        var loadScripts;

        function execScriptLoadedCallbacks(url) {
          // Execute URL callback functions
          tinymce.each(scriptLoadedCallbacks[url], function (callback) {
            callback.func.call(callback.scope);
          });

          scriptLoadedCallbacks[url] = undef;
        }

        queueLoadedCallbacks.push({
          func: callback,
          scope: scope || this
        });

        loadScripts = function () {
          var loadingScripts = tinymce.grep(scripts);

          // Current scripts has been handled
          scripts.length = 0;

          // Load scripts that needs to be loaded
          tinymce.each(loadingScripts, function (url) {
            // Script is already loaded then execute script callbacks directly
            if (states[url] == LOADED) {
              execScriptLoadedCallbacks(url);
              return;
            }

            // Is script not loading then start loading it
            if (states[url] != LOADING) {
              states[url] = LOADING;
              loading++;

              loadScript(url, function () {
                states[url] = LOADED;
                loading--;

                execScriptLoadedCallbacks(url);

                // Load more scripts if they where added by the recently loaded script
                loadScripts();
              });
            }
          });

          // No scripts are currently loading then execute all pending queue loaded callbacks
          if (!loading) {
            tinymce.each(queueLoadedCallbacks, function (callback) {
              callback.func.call(callback.scope);
            });

            queueLoadedCallbacks.length = 0;
          }
        };

        loadScripts();
      };
    };

    // Global script loader
    tinymce.ScriptLoader = new tinymce.dom.ScriptLoader();
  })(tinymce);

  /**
   * StyleSheetLoader.js
   *
   * Copyright, Moxiecode Systems AB
   * Released under LGPL License.
   *
   * This is a modified version of the ScriptLoader to load stylesheet files
   *
   * License: https://github.com/tinymce/tinymce/blob/3.x/LICENSE.TXT
   */

  /*eslint no-console:1 */

  (function (tinymce) {
    /**
  	 * This class handles asynchronous/synchronous loading of stylesheet files it will execute callbacks when various items gets loaded. This class is useful to load external stylesheet files.
  	 *
  	 * @class tinymce.dom.StyleSheetLoader
  	 * @example
  	 * // Load a stylesheet from a specific URL using the global stylesheet loader
  	 * tinymce.StyleSheetLoader.load('somestylesheet.js');
  	 *
  	 * // Load a stylesheet using a unique instance of the stylesheet loader
  	 * var StyleSheetLoader = new tinymce.dom.StyleSheetLoader();
  	 *
  	 * StyleSheetLoader.load('somestylesheet.js');
  	 *
  	 * // Load multiple stylesheets
  	 * var StyleSheetLoader = new tinymce.dom.StyleSheetLoader();
  	 *
  	 * StyleSheetLoader.add('somestylesheet1.js');
  	 * StyleSheetLoader.add('somestylesheet2.js');
  	 * StyleSheetLoader.add('somestylesheet3.js');
  	 *
  	 * StyleSheetLoader.loadQueue(function() {
  	 *    alert('All stylesheets are now loaded.');
  	 * });
  	 */
    tinymce.dom.StyleSheetLoader = function (document) {
      var QUEUED = 0,
        LOADING = 1,
        LOADED = 2,
        states = {},
        queue = [],
        stylesheetLoadedCallbacks = {},
        queueLoadedCallbacks = [],
        loading = 0,
        undef,
        maxLoadTime = 5000;

      /**
  		 * Loads a specific stylesheet directly without adding it to the load queue.
  		 *
  		 * @method load
  		 * @param {String} url Absolute URL to stylesheet to add.
  		 * @param {function} callback Optional callback function to execute ones this stylesheet gets loaded.
  		 * @param {Object} scope Optional scope to execute callback in.
  		 */
      function loadStylesheet(url, callback) {
        var dom = tinymce.DOM,
          elm, id, startTime, complete;

        // Execute callback when stylesheet is loaded
        function done() {
          if (complete) {
            return;
          }

          complete = true;

          if (elm) {
            elm.onreadystatechange = elm.onload = elm = null;
          }

          callback();
        }

        function error() {
          // Report the error so it's easier for people to spot loading errors
          if (typeof (console) !== "undefined" && console.log) {
            console.log("Failed to load: " + url);
          }

          // We can't mark it as done if there is a load error since
          // A) We don't want to produce 404 errors on the server and
          // B) the onerror event won't fire on all browsers.
          done();
        }

        // Calls the waitCallback until the test returns true or the timeout occurs
        // Uses methods from Tinymce 4.x for testing stylesheet files - https://github.com/tinymce/tinymce/blob/4.5.x/js/tinymce/classes/dom/StyleSheetLoader.js
        function wait(testCallback, waitCallback) {
          if (!testCallback()) {
            // Wait for timeout
            if ((new Date().getTime()) - startTime < maxLoadTime) {
              setTimeout(waitCallback);
            } else {
              error();
            }
          }
        }

        function waitForLoaded() {
          wait(function () {
            var styleSheets = document.styleSheets,
              styleSheet, i = styleSheets.length,
              owner;

            while (i--) {
              styleSheet = styleSheets[i];

              owner = styleSheet.ownerNode ? styleSheet.ownerNode : styleSheet.owningElement;
              if (owner && owner.id === elm.id) {
                done();
                return true;
              }
            }
          }, waitForLoaded);
        }

        id = dom.uniqueId();

        // Create new link element
        elm = document.createElement('link');
        elm.rel = 'stylesheet';
        elm.type = 'text/css';
        elm.href = tinymce._addVer(url);
        elm.async = false;
        elm.defer = false;

        startTime = new Date().getTime();

        // prevent cloudflare rocket-loader caching
        elm.setAttribute('data-cfasync', false);
        elm.id = id;

        // Add onload listener
        elm.onload = waitForLoaded;

        // Add onerror event
        elm.onerror = error;

        // Add stylesheet to document
        (document.getElementsByTagName('head')[0] || document.body).appendChild(elm);
      }

      /**
  		 * Returns true/false if a stylesheet has been loaded or not.
  		 *
  		 * @method isDone
  		 * @param {String} url URL to check for.
  		 * @return [Boolean} true/false if the URL is loaded.
  		 */
      this.isDone = function (url) {
        return states[url] == LOADED;
      };

      /**
  		 * Marks a specific stylesheet to be loaded. This can be useful if a stylesheet got loaded outside
  		 * the stylesheet loader or to skip it from loading some stylesheet.
  		 *
  		 * @method markDone
  		 * @param {string} u Absolute URL to the stylesheet to mark as loaded.
  		 */
      this.markDone = function (url) {
        states[url] = LOADED;
      };

      /**
  		 * Adds a specific stylesheet to the load queue of the stylesheet loader.
  		 *
  		 * @method add
  		 * @param {String} url Absolute URL to stylesheet to add.
  		 * @param {function} callback Optional callback function to execute ones this stylesheet gets loaded.
  		 * @param {Object} scope Optional scope to execute callback in.
  		 */
      this.add = this.load = function (url, callback, scope) {
        var state = states[url];

        // Add url to load queue
        if (state == undef) {
          queue.push(url);
          states[url] = QUEUED;
        }

        if (callback) {
          // Store away callback for later execution
          if (!stylesheetLoadedCallbacks[url]) {
            stylesheetLoadedCallbacks[url] = [];
          }

          stylesheetLoadedCallbacks[url].push({
            func: callback,
            scope: scope || this
          });
        }
      };

      /**
  		 * Starts the loading of the queue.
  		 *
  		 * @method loadQueue
  		 * @param {function} callback Optional callback to execute when all queued items are loaded.
  		 * @param {Object} scope Optional scope to execute the callback in.
  		 */
      this.loadQueue = function (callback, scope) {
        this.loadStylesheets(queue, callback, scope);
      };

      /**
  		 * Loads the specified queue of files and executes the callback ones they are loaded.
  		 * This method is generally not used outside this class but it might be useful in some scenarios.
  		 *
  		 * @method loadStylesheets
  		 * @param {Array} stylesheets Array of queue items to load.
  		 * @param {function} callback Optional callback to execute ones all items are loaded.
  		 * @param {Object} scope Optional scope to execute callback in.
  		 */
      this.loadStylesheets = function (stylesheets, callback, scope) {
        var loadStylesheets;

        function execstylesheetLoadedCallbacks(url) {
          // Execute URL callback functions
          tinymce.each(stylesheetLoadedCallbacks[url], function (callback) {
            callback.func.call(callback.scope);
          });

          stylesheetLoadedCallbacks[url] = undef;
        }

        queueLoadedCallbacks.push({
          func: callback,
          scope: scope || this
        });

        loadStylesheets = function () {
          var loadingstylesheets = tinymce.grep(stylesheets);

          // Current stylesheets has been handled
          stylesheets.length = 0;

          // Load stylesheets that needs to be loaded
          tinymce.each(loadingstylesheets, function (url) {
            // stylesheet is already loaded then execute stylesheet callbacks directly
            if (states[url] == LOADED) {
              execstylesheetLoadedCallbacks(url);
              return;
            }

            // Is stylesheet not loading then start loading it
            if (states[url] != LOADING) {
              states[url] = LOADING;
              loading++;

              loadStylesheet(url, function () {
                states[url] = LOADED;
                loading--;

                execstylesheetLoadedCallbacks(url);

                // Load more stylesheets if they where added by the recently loaded stylesheet
                loadStylesheets();
              });
            }
          });

          // No stylesheets are currently loading then execute all pending queue loaded callbacks
          if (!loading) {
            tinymce.each(queueLoadedCallbacks, function (callback) {
              callback.func.call(callback.scope);
            });

            queueLoadedCallbacks.length = 0;
          }
        };

        loadStylesheets();
      };

      this.loadStylesheet = loadStylesheet;
    };

    // Global stylesheet loader
    tinymce.StyleSheetLoader = new tinymce.dom.StyleSheetLoader();
  })(tinymce);

  /**
   * FocusManager.js
   *
   * Released under LGPL License.
   * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
   *
   * License: http://www.tinymce.com/license - Inactive
   * Licence: GNU/LGPL 2.1 or later - http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
   * Contributing: http://www.tinymce.com/contributing - Inactive
   */

  /**
   * This class manages the focus/blur state of the editor. This class is needed since some
   * browsers fire false focus/blur states when the selection is moved to a UI dialog or similar.
   *
   * This class will fire two events focus and blur on the editor instances that got affected.
   * It will also handle the restore of selection when the focus is lost and returned.
   *
   * @class tinymce.FocusManager
   */
  (function (tinymce) {
    var DOM = tinymce.DOM;

    var selectionChangeHandler, documentFocusInHandler, documentMouseUpHandler;

    var isUIElement = function (editor, elm) {
      var customSelector = editor ? editor.settings.custom_ui_selector : '';
      var parent = DOM.getParent(elm, function (elm) {
        return (
          FocusManager.isEditorUIElement(elm) ||
                  (customSelector ? editor.dom.is(elm, customSelector) : false)
        );
      });
      return parent !== null;
    };

    var isElementOutsideEditor = function (editor, target) {
      return editor.dom.isChildOf(target, editor.getBody()) === false;
    };

    /**
       * Constructs a new focus manager instance.
       *
       * @constructor FocusManager
       * @param {tinymce.EditorManager} editorManager Editor manager instance to handle focus for.
       */
    function FocusManager(editorManager) {
      function getActiveElement() {
        try {
          return document.activeElement;
        } catch (ex) {
          // IE sometimes fails to get the activeElement when resizing table
          // TODO: Investigate this
          return document.body;
        }
      }

      // We can't store a real range on IE 11 since it gets mutated so we need to use a bookmark object
      // TODO: Move this to a separate range utils class since it's it's logic is present in Selection as well.
      function createBookmark(dom, rng) {
        if (rng && rng.startContainer) {
          // Verify that the range is within the root of the editor
          if (!dom.isChildOf(rng.startContainer, dom.getRoot()) || !dom.isChildOf(rng.endContainer, dom.getRoot())) {
            return;
          }

          return {
            startContainer: rng.startContainer,
            startOffset: rng.startOffset,
            endContainer: rng.endContainer,
            endOffset: rng.endOffset
          };
        }

        return rng;
      }

      function bookmarkToRng(editor, bookmark) {
        var rng;

        if (bookmark.startContainer) {
          rng = editor.getDoc().createRange();
          rng.setStart(bookmark.startContainer, bookmark.startOffset);
          rng.setEnd(bookmark.endContainer, bookmark.endOffset);
        } else {
          rng = bookmark;
        }

        return rng;
      }

      function registerEvents(editor) {
        editor.onSetContent.add(function () {
          editor.lastRng = null;
        });

        // Remove last selection bookmark on mousedown see #6305
        editor.onMouseDown.add(function () {
          editor.selection.lastFocusBookmark = null;
        });

        editor.onFocusIn.add(function () {
          var focusedEditor = editorManager.focusedEditor,
            lastRng;

          if (editor.selection.lastFocusBookmark) {
            lastRng = bookmarkToRng(editor, editor.selection.lastFocusBookmark);
            editor.selection.lastFocusBookmark = null;
            editor.selection.setRng(lastRng);
          }

          if (focusedEditor != editor) {
            if (focusedEditor) {
              focusedEditor.onBlur.dispatch(focusedEditor, {
                focusedEditor: editor
              });

              focusedEditor.onDeactivate.dispatch(focusedEditor, editor);
            }

            editorManager.setActive(editor);
            editorManager.focusedEditor = editor;

            editor.onFocus.dispatch(editor, {
              blurredEditor: focusedEditor
            });

            editor.onActivate.dispatch(editor, focusedEditor);

            editor.focus(true);
          }

          editor.lastRng = null;
        });

        editor.onFocusOut.add(function () {
          setTimeout(function () {
            var focusedEditor = editorManager.focusedEditor;

            // Still the same editor the blur was outside any editor UI
            if (!isUIElement(editor, getActiveElement()) && focusedEditor == editor) {

              editor.onBlur.dispatch(editor, {
                focusedEditor: null
              });

              editorManager.focusedEditor = null;

              // Make sure selection is valid could be invalid if the editor is blured and removed before the timeout occurs
              if (editor.selection) {
                editor.selection.lastFocusBookmark = null;
              }
            }
          }, 10);
        });

        // Check if focus is moved to an element outside the active editor by checking if the target node
        // isn't within the body of the activeEditor nor a UI element such as a dialog child control
        if (!documentFocusInHandler) {
          documentFocusInHandler = function (e) {
            var activeEditor = editorManager.activeEditor,
              target;

            target = e.target;

            if (activeEditor && target.ownerDocument === document) {
              // Check to make sure we have a valid selection don't update the bookmark if it's
              // a focusin to the body of the editor see #7025
              if (activeEditor.selection && target !== activeEditor.getBody() && isElementOutsideEditor(editor, target)) {
                activeEditor.selection.lastFocusBookmark = createBookmark(activeEditor.dom, activeEditor.lastRng);
              }

              // Fire a blur event if the element isn't a UI element
              if (target !== document.body && !isUIElement(activeEditor, target) && editorManager.focusedEditor === activeEditor) {

                activeEditor.onBlur.dispatch(editor, {
                  focusedEditor: null
                });

                editorManager.focusedEditor = null;
              }
            }
          };

          DOM.bind(document, 'focusin', documentFocusInHandler);
        }
      }

      function unregisterDocumentEvents(editor) {
        if (editorManager.focusedEditor == editor) {
          editorManager.focusedEditor = null;
        }

        if (!editorManager.activeEditor) {
          DOM.unbind(document, 'selectionchange', selectionChangeHandler);
          DOM.unbind(document, 'focusin', documentFocusInHandler);
          DOM.unbind(document, 'mouseup', documentMouseUpHandler);
          selectionChangeHandler = documentFocusInHandler = documentMouseUpHandler = null;
        }
      }

      editorManager.onAddEditor.add(function (mgr, editor) {
        registerEvents(editor);
      });

      editorManager.onRemoveEditor.add(function (mgr, editor) {
        unregisterDocumentEvents(editor);
      });
    }

    /**
       * Returns true if the specified element is part of the UI for example an button or text input.
       *
       * @method isEditorUIElement
       * @param  {Element} elm Element to check if it's part of the UI or not.
       * @return {Boolean} True/false state if the element is part of the UI or not.
       */
    FocusManager.isEditorUIElement = function (elm) {
      // Needs to be converted to string since svg can have focus: #6776
      return elm.className.toString().indexOf('mce') !== -1;
    };

    tinymce.dom.FocusManager = FocusManager;

  })(tinymce);

  /**
   * KeyboardNavigation.js
   *
   * Copyright, Moxiecode Systems AB
   * Released under LGPL License.
   *
   * License: http://www.tinymce.com/license - Inactive
   * Licence: GNU/LGPL 2.1 or later - http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
   * Contributing: http://www.tinymce.com/contributing - Inactive
   */

  (function (tinymce) {
    var Event = tinymce.dom.Event,
      each = tinymce.each;

    /**
  	 * This class provides basic keyboard navigation using the arrow keys to children of a component.
  	 * For example, this class handles moving between the buttons on the toolbars.
  	 *
  	 * @class tinymce.ui.KeyboardNavigation
  	 */
    tinymce.create('tinymce.ui.KeyboardNavigation', {
      /**
  		 * Create a new KeyboardNavigation instance to handle the focus for a specific element.
  		 *
  		 * @constructor
  		 * @method KeyboardNavigation
  		 * @param {Object} settings the settings object to define how keyboard navigation works.
  		 * @param {DOMUtils} dom the DOMUtils instance to use.
  		 *
  		 * @setting {Element/String} root the root element or ID of the root element for the control.
  		 * @setting {Array} items an array containing the items to move focus between. Every object in this array must have an id attribute which maps to the actual DOM element. If the actual elements are passed without an ID then one is automatically assigned.
  		 * @setting {Function} onCancel the callback for when the user presses escape or otherwise indicates cancelling.
  		 * @setting {Function} onAction (optional) the action handler to call when the user activates an item.
  		 * @setting {Boolean} enableLeftRight (optional, default) when true, the up/down arrows move through items.
  		 * @setting {Boolean} enableUpDown (optional) when true, the up/down arrows move through items.
  		 * Note for both up/down and left/right explicitly set both enableLeftRight and enableUpDown to true.
  		 */
      KeyboardNavigation: function (settings, dom) {
        var self = this, root = settings.root,
          items = settings.items,
          enableUpDown = settings.enableUpDown,
          enableLeftRight = settings.enableLeftRight || !settings.enableUpDown,
          excludeFromTabOrder = settings.excludeFromTabOrder,
          itemFocussed, itemBlurred, rootKeydown, rootFocussed, focussedId;

        dom = dom || tinymce.DOM;

        itemFocussed = function (evt) {
          focussedId = evt.target.id;
        };

        itemBlurred = function (evt) {
          dom.setAttrib(evt.target.id, 'tabindex', '-1');
        };

        rootFocussed = function () {
          var item = dom.get(focussedId);
          dom.setAttrib(item, 'tabindex', '0');
          item.focus();
        };

        this.focus = function () {
          dom.get(focussedId).focus();
        };

        this.update = function (value) {
          items = value;

          each(items, function (item, idx) {
            var tabindex, elm;

            if (!item.id) {
              item.id = dom.uniqueId('_mce_item_');
            }

            elm = dom.get(item.id);

            if (excludeFromTabOrder) {
              dom.bind(elm, 'blur', itemBlurred);
              tabindex = '-1';
            } else {
              tabindex = (idx === 0 ? '0' : '-1');
            }

            elm.setAttribute('tabindex', tabindex);
            dom.bind(elm, 'focus', itemFocussed);
          });
        };

        /**
  			 * Destroys the KeyboardNavigation and unbinds any focus/blur event handles it might have added.
  			 *
  			 * @method destroy
  			 */
        this.destroy = function () {
          each(items, function (item) {
            var elm = dom.get(item.id);

            dom.unbind(elm, 'focus', itemFocussed);
            dom.unbind(elm, 'blur', itemBlurred);
          });

          var rootElm = dom.get(root);
          dom.unbind(rootElm, 'focus', rootFocussed);
          dom.unbind(rootElm, 'keydown', rootKeydown);

          items = dom = root = this.focus = itemFocussed = itemBlurred = rootKeydown = rootFocussed = null;
          this.destroy = function () {};
        };

        this.moveFocus = function (dir, evt) {
          var idx = -1,
            newFocus;

          if (!focussedId) {
            return;
          }

          each(items, function (item, index) {
            if (item.id === focussedId) {
              idx = index;
              return false;
            }
          });

          idx += dir;

          if (idx < 0) {
            idx = items.length - 1;
          } else if (idx >= items.length) {
            idx = 0;
          }

          newFocus = items[idx];
          dom.setAttrib(focussedId, 'tabindex', '-1');
          dom.setAttrib(newFocus.id, 'tabindex', '0');
          dom.get(newFocus.id).focus();

          if (settings.actOnFocus) {
            settings.onAction(newFocus.id);
          }

          if (evt) {
            Event.cancel(evt);
          }
        };

        rootKeydown = function (evt) {
          var DOM_VK_LEFT = 37,
            DOM_VK_RIGHT = 39,
            DOM_VK_UP = 38,
            DOM_VK_DOWN = 40,
            DOM_VK_ESCAPE = 27,
            DOM_VK_ENTER = 14,
            DOM_VK_RETURN = 13,
            DOM_VK_SPACE = 32;

          switch (evt.keyCode) {
            case DOM_VK_LEFT:
              if (enableLeftRight) {
                self.moveFocus(-1);
                Event.cancel(evt);
              }
              break;

            case DOM_VK_RIGHT:
              if (enableLeftRight) {
                self.moveFocus(1);
                Event.cancel(evt);
              }
              break;

            case DOM_VK_UP:
              if (enableUpDown) {
                self.moveFocus(-1);
                Event.cancel(evt);
              }
              break;

            case DOM_VK_DOWN:
              if (enableUpDown) {
                self.moveFocus(1);
                Event.cancel(evt);
              }
              break;

            case DOM_VK_ESCAPE:
              if (settings.onCancel) {
                settings.onCancel();
                Event.cancel(evt);
              }
              break;

            case DOM_VK_ENTER:
            case DOM_VK_RETURN:
            case DOM_VK_SPACE:
              if (settings.onAction) {
                Event.cancel(evt);
                settings.onAction(evt, focussedId);
              }
              break;
          }
        };

        // Set up state and listeners for each item.
        this.update(items);

        // Setup initial state for root element.
        if (items[0]) {
          focussedId = items[0].id;
        }

        dom.setAttrib(root, 'tabindex', '-1');

        // Setup listeners for root element.
        var rootElm = dom.get(root);
        dom.bind(rootElm, 'focus', rootFocussed);
        dom.bind(rootElm, 'keydown', rootKeydown);
      }
    });
  })(tinymce);

  /**
   * Control.js
   *
   * Copyright, Moxiecode Systems AB
   * Released under LGPL License.
   *
   * License: http://www.tinymce.com/license - Inactive
   * Licence: GNU/LGPL 2.1 or later - http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
   * Contributing: http://www.tinymce.com/contributing - Inactive
   */

  (function (tinymce) {
    // Shorten class names
    var DOM = tinymce.DOM;

    /**
  	 * This class is the base class for all controls like buttons, toolbars, containers. This class should not
  	 * be instantiated directly other controls should inherit from this one.
  	 *
  	 * @class tinymce.ui.Control
  	 */
    tinymce.create('tinymce.ui.Control', {
      /**
  		 * Constructs a new control instance.
  		 *
  		 * @constructor
  		 * @method Control
  		 * @param {String} id Control id.
  		 * @param {Object} settings Optional name/value settings object.
  		 */
      Control: function (id, settings, editor) {
        this.id = id;
        this.settings = settings || {};
        this.rendered = false;
        this.onRender = new tinymce.util.Dispatcher(this);
        this.classPrefix = 'mce';
        this.scope = this.settings.scope || this;
        this.disabled = 0;
        this.active = 0;
        this.editor = editor;

        this.name = this.settings.name || id;
      },

      setAriaProperty: function (property, value) {
        var element = DOM.get(this.id + '_aria') || DOM.get(this.id);

        if (element) {
          element.setAttribute('aria-' + property, '' + !!value);
        }
      },

      focus: function () {
        DOM.get(this.id).focus();
      },

      /**
  		 * Sets the disabled state for the control. This will add CSS classes to the
  		 * element that contains the control. So that it can be disabled visually.
  		 *
  		 * @method setDisabled
  		 * @param {Boolean} state Boolean state if the control should be disabled or not.
  		 */
      setDisabled: function (state) {
        if (state != this.disabled) {
          this.setAriaProperty('disabled', state);

          this.setState('Disabled', state);
          this.setState('Enabled', !state);

          this.disabled = state;
        }
      },

      /**
  		 * Returns true/false if the control is disabled or not. This is a method since you can then
  		 * choose to check some class or some internal bool state in subclasses.
  		 *
  		 * @method isDisabled
  		 * @return {Boolean} true/false if the control is disabled or not.
  		 */
      isDisabled: function () {
        return this.disabled;
      },

      /**
  		 * Sets the activated state for the control. This will add CSS classes to the
  		 * element that contains the control. So that it can be activated visually.
  		 *
  		 * @method setActive
  		 * @param {Boolean} s Boolean state if the control should be activated or not.
  		 */
      setActive: function (s) {
        if (s != this.active) {
          this.setState('Active', s);
          this.active = s;
          this.setAriaProperty('current', s);
        }
      },

      /**
  		 * Returns true/false if the control is disabled or not. This is a method since you can then
  		 * choose to check some class or some internal bool state in subclasses.
  		 *
  		 * @method isActive
  		 * @return {Boolean} true/false if the control is disabled or not.
  		 */
      isActive: function () {
        return this.active;
      },

      /**
  		 * Sets the specified class state for the control.
  		 *
  		 * @method setState
  		 * @param {String} c Class name to add/remove depending on state.
  		 * @param {Boolean} s True/false state if the class should be removed or added.
  		 */
      setState: function (c, s) {
        var n = DOM.get(this.id);

        c = this.classPrefix + c;

        if (s) {
          DOM.addClass(n, c);
        } else {
          DOM.removeClass(n, c);
        }
      },

      /**
  		 * Returns true/false if the control has been rendered or not.
  		 *
  		 * @method isRendered
  		 * @return {Boolean} State if the control has been rendered or not.
  		 */
      isRendered: function () {
        return this.rendered;
      },

      /**
  		 * Renders the control as a HTML string. This method is much faster than using the DOM and when
  		 * creating a whole toolbar with buttons it does make a lot of difference.
  		 *
  		 * @method renderHTML
  		 * @return {String} HTML for the button control element.
  		 */
      renderHTML: function () {},

      /**
  		 * Renders the control to the specified container element.
  		 *
  		 * @method renderTo
  		 * @param {Element} n HTML DOM element to add control to.
  		 */
      renderTo: function (n) {
        var frag = DOM.createFragment(this.renderHTML());
        n.appendChild(frag);

        this.postRender();
      },

      /**
  		 * Post render event. This will be executed after the control has been rendered and can be used to
  		 * set states, add events to the control etc. It's recommended for subclasses of the control to call this method by using this._super().
  		 *
  		 * @method postRender
  		 */
      postRender: function () {
        var state;

        // Set pending states
        if (tinymce.is(this.disabled)) {
          state = this.disabled;
          this.disabled = -1;
          this.setDisabled(state);
        }

        if (tinymce.is(this.active)) {
          state = this.active;
          this.active = -1;
          this.setActive(state);
        }

        this.onRender.dispatch();
      },

      parent: function (ctrl) {
        if (!ctrl) {
          return this._parent || null;
        }
        
        this._parent = ctrl;
      },

      /**
  		 * Removes the control. This means it will be removed from the DOM and any
  		 * events tied to it will also be removed.
  		 *
  		 * @method remove
  		 */
      remove: function () {
        this.destroy();

        DOM.remove(this.id);
      },

      /**
  		 * Destroys the control will free any memory by removing event listeners etc.
  		 *
  		 * @method destroy
  		 */
       destroy: function () {
        tinymce.dom.Event.clear(this.id);
      }
    });
  })(tinymce);

  /**
   * Container.js
   *
   * Copyright, Moxiecode Systems AB
   * Released under LGPL License.
   *
   * License: http://www.tinymce.com/license - Inactive
   * Licence: GNU/LGPL 2.1 or later - http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
   * Contributing: http://www.tinymce.com/contributing - Inactive
   */

  /**
   * This class is the base class for all container controls like toolbars. This class should not
   * be instantiated directly other container controls should inherit from this one.
   *
   * @class tinymce.ui.Container
   * @extends tinymce.ui.Control
   */

  tinymce.create('tinymce.ui.Container:tinymce.ui.Control', {
  	/**
  	 * Base contrustor a new container control instance.
  	 *
  	 * @constructor
  	 * @method Container
  	 * @param {String} id Control id to use for the container.
  	 * @param {Object} settings Optional name/value settings object.
  	 */
  	Container: function (id, settings, editor) {
  		var self = this;

  		settings = settings || {};

  		this._super(id, settings, editor);

  		/**
  		 * Array of controls added to the container.
  		 *
  		 * @property controls
  		 * @type Array
  		 */
  		this.controls = [];

  		this.lookup = {};

  		if (settings.controls) {
  			tinymce.each(settings.controls, function (ctrl) {
  				self.add(ctrl);
  			});
  		}
  	},

  	/**
  	 * Adds a control to the collection of controls for the container.
  	 *
  	 * @method add
  	 * @param {tinymce.ui.Control} c Control instance to add to the container.
  	 * @return {tinymce.ui.Control} Same control instance that got passed in.
  	 */
  	add: function (ctrl) {
  		this.lookup[ctrl.id] = ctrl;
  		this.controls.push(ctrl);

  		ctrl.parent(this);

  		return ctrl;
  	},

  	destroy: function () {
  		var i;

  		this._super();

  		for (i = 0; i < this.controls.length; i++) {
  			this.controls[i].destroy();
  		}

  		delete this.lookup[this.id];
  	},

  	/**
  	 * Returns a control by id from the containers collection.
  	 *
  	 * @method get
  	 * @param {String} id Id for the control to retrive.
  	 * @return {tinymce.ui.Control} Control instance by the specified name or undefined if it wasn't found.
  	 */
  	get: function (id) {
  		return this.lookup[id];
  	},

  	/**
  	 * Returns a control by name from the containers collection.
  	 * @param {String} name Name for the control to retrieve.
  	 * @return {tinymce.ui.Control} Control instance by the specified name or undefined if it wasn't found.
  	 */
  	find: function (name) {
  		var i;

  		// Check if it's a id selector
  		if (name.charAt(0) === '#') {
  			return this.get(name.substring(1));
  		}

  		for (i = 0; i < this.controls.length; i++) {
  			if (this.controls[i].name === name) {
  				return this.controls[i];
  			}
  		}
  	}
  });

  /**
   * Form.js
   *
   * Copyright, Moxiecode Systems AB
   * Released under LGPL License.
   *
   * License: http://www.tinymce.com/license - Inactive
   * Licence: GNU/LGPL 2.1 or later - http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
   * Contributing: http://www.tinymce.com/contributing - Inactive
   */
  (function (tinymce) {
    // Shorten class names
    var dom = tinymce.DOM;
    /**
     * This class is used to create layouts. A layout is a container for other controls like buttons etc.
     *
     * @class tinymce.ui.Form
     * @extends tinymce.ui.Container
     */
    tinymce.create('tinymce.ui.Form:tinymce.ui.Container', {

      /**
         * Renders the toolbar as a HTML string. This method is much faster than using the DOM and when
         * creating a whole toolbar with buttons it does make a lot of difference.
         *
         * @method renderHTML
         * @return {String} HTML for the toolbar control.
         */
      renderHTML: function () {
        var html = '',
          settings = this.settings,
          i;

        for (i = 0; i < this.controls.length; i++) {
          var ctrl = this.controls[i], s = ctrl.settings;

          if (s.subtype && s.subtype == 'hidden') {
            html += ctrl.renderHTML();
            continue;
          }

          html += '<div class="mceFormRow">';

          if (s.label) {
            html += '<label for="' + ctrl.id + '">' + s.label + '</label>';
          }

          html += '	<div class="mceFormControl">';
          html += ctrl.renderHTML();
          html += '	</div>';
          html += '</div>';
        }

        return dom.createHTML('div', {
          id: this.id,
          'class': 'mceForm' + (settings['class'] ? ' ' + settings['class'] : ''),
          role: 'group'
        }, html);
      },

      submit: function () {
        var i, data = {};

        for (i = 0; i < this.controls.length; i++) {
          var ctrl = this.controls[i];

          if (typeof ctrl.value === 'function') {
            data[ctrl.name] = ctrl.value();
          }
        }

        return data;
      },

      update: function (data) {
        var i;

        for (i = 0; i < this.controls.length; i++) {
          var ctrl = this.controls[i];

          if (data[ctrl.name]) {
            if (typeof ctrl.value === 'function') {
              ctrl.value(data[ctrl.name]);
            }
          }
        }
      },

      empty: function () {
        var i;

        for (i = 0; i < this.controls.length; i++) {
          this.controls[i].remove();
        }

        this.controls = [];
        this.lookup = {};
      },

      add: function (ctrl) {
        if (!this.get(ctrl.id)) {
          return this._super(ctrl);
        }

        return false;
      },

      show: function (ctrl) {
        var elm = dom.get(ctrl.id), row = dom.getParent(elm, '.mceFormRow');

        if (row) {
          row.style.display = '';
        }
      },

      hide: function (ctrl) {
        var elm = dom.get(ctrl.id), row = dom.getParent(elm, '.mceFormRow');

        if (row) {
          row.style.display = 'none';
        }
      },

      postRender: function () {
        var i;

        this._super();

        for (i = 0; i < this.controls.length; i++) {
          this.controls[i].postRender();
        }
      }
    });
  })(tinymce);

  /**
   * Separator.js
   *
   * Copyright, Moxiecode Systems AB
   * Released under LGPL License.
   *
   * License: http://www.tinymce.com/license - Inactive
   * Licence: GNU/LGPL 2.1 or later - http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
   * Contributing: http://www.tinymce.com/contributing - Inactive
   */

  /**
   * This class is used to create vertical separator between other controls.
   *
   * @class tinymce.ui.Separator
   * @extends tinymce.ui.Control
   */
  tinymce.create('tinymce.ui.Separator:tinymce.ui.Control', {
    /**
       * Separator constructor.
       *
       * @constructor
       * @method Separator
       * @param {String} id Control id to use for the Separator.
       * @param {Object} s Optional name/value settings object.
       */
    Separator: function (id, s) {
      this._super(id, s);
      this.classPrefix = 'mceSeparator';
      this.setDisabled(true);
    },

    /**
       * Renders the separator as a HTML string. This method is much faster than using the DOM and when
       * creating a whole toolbar with buttons it does make a lot of difference.
       *
       * @method renderHTML
       * @return {String} HTML for the separator control element.
       */
    renderHTML: function () {
      return tinymce.DOM.createHTML('span', {
        'class': this.classPrefix,
        role: 'separator',
        'aria-orientation': 'vertical',
        tabindex: '-1'
      }, '');
    }
  });

  /**
   * MenuItem.js
   *
   * Copyright, Moxiecode Systems AB
   * Released under LGPL License.
   *
   * License: http://www.tinymce.com/license - Inactive
   * Licence: GNU/LGPL 2.1 or later - http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
   * Contributing: http://www.tinymce.com/contributing - Inactive
   */

  (function (tinymce) {
  	/**
  	 * This class is base class for all menu item types like DropMenus items etc. This class should not
  	 * be instantiated directly other menu items should inherit from this one.
  	 *
  	 * @class tinymce.ui.MenuItem
  	 * @extends tinymce.ui.Control
  	 */
  	tinymce.create('tinymce.ui.MenuItem:tinymce.ui.Control', {
  		/**
  		 * Constructs a new button control instance.
  		 *
  		 * @constructor
  		 * @method MenuItem
  		 * @param {String} id Button control id for the button.
  		 * @param {Object} s Optional name/value settings object.
  		 */
  		MenuItem: function (id, settings) {
  			this._super(id, settings);
  		},

  		/**
  		 * Sets the selected state for the control. This will add CSS classes to the
  		 * element that contains the control. So that it can be selected visually.
  		 *
  		 * @method setSelected
  		 * @param {Boolean} state Boolean state if the control should be selected or not.
  		 */
  		setSelected: function (state) {
  			this.setState('Selected', state);
  			this.setAriaProperty('selected', !!state);
  			this.selected = state;
  		},

  		/**
  		 * Returns true/false if the control is selected or not.
  		 *
  		 * @method isSelected
  		 * @return {Boolean} true/false if the control is selected or not.
  		 */
  		isSelected: function () {
  			return this.selected;
  		},

  		/**
  		 * Post render handler. This function will be called after the UI has been
  		 * rendered so that events can be added.
  		 *
  		 * @method postRender
  		 */
  		postRender: function () {
  			this._super();

  			var state;

  			// Set pending states
  			if (tinymce.is(this.disabled)) {
  				state = this.disabled;
  				this.disabled = -1;
  				this.setDisabled(state);
  			}

  			if (tinymce.is(this.active)) {
  				state = this.active;
  				this.active = -1;
  				this.setActive(state);
  			}

  			// Set pending state
  			if (tinymce.is(this.selected)) {
  				this.setSelected(this.selected);
  			}
  		}
  	});
  })(tinymce);

  /**
   * Menu.js
   *
   * Copyright, Moxiecode Systems AB
   * Released under LGPL License.
   *
   * License: http://www.tinymce.com/license - Inactive
   * Licence: GNU/LGPL 2.1 or later - http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
   * Contributing: http://www.tinymce.com/contributing - Inactive
   */

  (function (tinymce) {
    var DOM = tinymce.DOM,
      walk = tinymce.walk;

    /**
  	 * This class is base class for all menu types like DropMenus etc. This class should not
  	 * be instantiated directly other menu controls should inherit from this one.
  	 *
  	 * @class tinymce.ui.Menu
  	 * @extends tinymce.ui.MenuItem
  	 */
    tinymce.create('tinymce.ui.Menu:tinymce.ui.MenuItem', {
      /**
  		 * Constructs a new button control instance.
  		 *
  		 * @constructor
  		 * @method Menu
  		 * @param {String} id Button control id for the button.
  		 * @param {Object} s Optional name/value settings object.
  		 */
      Menu: function (id, settings) {
        this._super(id, settings);
        this.items = {};
        this.collapsed = false;
        this.menuCount = 0;
        this.onAddItem = new tinymce.util.Dispatcher(this);
      },

      /**
  		 * Expands the menu, this will show them menu and all menu items.
  		 *
  		 * @method expand
  		 * @param {Boolean} d Optional deep state. If this is set to true all children will be expanded as well.
  		 */
      expand: function (d) {
        var self = this;

        if (d) {
          walk(self, function (o) {
            if (o.expand) {
              o.expand();
            }
          }, 'items', self);
        }

        this.collapsed = false;
      },

      /**
  		 * Collapses the menu, this will hide the menu and all menu items.
  		 *
  		 * @method collapse
  		 * @param {Boolean} state Optional deep state. If this is set to true all children will be collapsed as well.
  		 */
      collapse: function (state) {
        var self = this;

        if (state) {
          walk(self, function (menu) {
            if (menu.collapse) {
              menu.collapse();
            }
          }, 'items', self);
        }

        this.collapsed = true;
      },

      /**
  		 * Returns true/false if the menu has been collapsed or not.
  		 *
  		 * @method isCollapsed
  		 * @return {Boolean} True/false state if the menu has been collapsed or not.
  		 */
      isCollapsed: function () {
        return this.collapsed;
      },

      /**
  		 * Adds a new menu, menu item or sub classes of them to the drop menu.
  		 *
  		 * @method add
  		 * @param {tinymce.ui.Control} menu Menu or menu item to add to the drop menu.
  		 * @return {tinymce.ui.Control} Same as the input control, the menu or menu item.
  		 */
      add: function (menu) {
        if (!menu.settings) {
          menu = new tinymce.ui.MenuItem(menu.id || DOM.uniqueId(), menu);
        }

        this.onAddItem.dispatch(this, menu);

        return this.items[menu.id] = menu;
      },

      /**
  		 * Adds a menu separator between the menu items.
  		 *
  		 * @method addSeparator
  		 * @return {tinymce.ui.MenuItem} Menu item instance for the separator.
  		 */
      addSeparator: function () {
        return this.add({
          separator: true
        });
      },

      /**
  		 * Adds a sub menu to the menu.
  		 *
  		 * @method addMenu
  		 * @param {Object} menu Menu control or a object with settings to be created into an control.
  		 * @return {tinymce.ui.Menu} Menu control instance passed in or created.
  		 */
      addMenu: function (menu) {
        if (!menu.collapse) {
          menu = this.createMenu(menu);
        }

        this.menuCount++;

        return this.add(menu);
      },

      /**
  		 * Returns true/false if the menu has sub menus or not.
  		 *
  		 * @method hasMenus
  		 * @return {Boolean} True/false state if the menu has sub menues or not.
  		 */
      hasMenus: function () {
        return this.menuCount !== 0;
      },

      /**
  		 * Removes a specific sub menu or menu item from the menu.
  		 *
  		 * @method remove
  		 * @param {tinymce.ui.Control} menu Menu item or menu to remove from menu.
  		 * @return {tinymce.ui.Control} Control instance or null if it wasn't found.
  		 */
      remove: function (menu) {
        delete this.items[menu.id];
      },

      /**
  		 * Removes all menu items and sub menu items from the menu.
  		 *
  		 * @method removeAll
  		 */
      removeAll: function () {
        var self = this;

        walk(self, function (menu) {
          if (menu.removeAll) {
            menu.removeAll();
          } else {
            menu.remove();
          }

          menu.destroy();
        }, 'items', self);

        this.items = {};
      },

      /**
  		 * Created a new sub menu for the menu control.
  		 *
  		 * @method createMenu
  		 * @param {Object} settings Optional name/value settings object.
  		 * @return {tinymce.ui.Menu} New drop menu instance.
  		 */
      createMenu: function (settings) {
        var menu = new tinymce.ui.Menu(settings.id || DOM.uniqueId(), settings);

        menu.onAddItem.add(this.onAddItem.dispatch, this.onAddItem);

        return menu;
      }
    });
  })(tinymce);

  /**
   * DropMenu.js
   *
   * Copyright, Moxiecode Systems AB
   * Released under LGPL License.
   *
   * License: http://www.tinymce.com/license - Inactive
   * Licence: GNU/LGPL 2.1 or later - http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
   * Contributing: http://www.tinymce.com/contributing - Inactive
   */

  (function (tinymce) {
    var DOM = tinymce.DOM,
      each = tinymce.each,
      Event = tinymce.dom.Event,
      undef;

    // http://stackoverflow.com/a/6969486
    function escapeRegExChars(str) {
      return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, '\\$&');
    }

    function nodeIndex(nodes, node) {
      for (var i = 0; i < nodes.length; i++) {
        if (nodes[i] === node) {
          return i;
        }
      }

      return -1;
    }

    var specialKeyCodeMap = {
      9: 'tab',
      17: 'ctrl',
      18: 'alt',
      27: 'esc',
      //32: 'space',
      37: 'left',
      39: 'right',
      13: 'enter',
      91: 'cmd',
      38: 'up',
      40: 'down'
    };

    /**
     * This class is used to create drop menus, a drop menu can be a
     * context menu, or a menu for a list box or a menu bar.
     *
     * @class tinymce.ui.DropMenu
     * @extends tinymce.ui.Menu
     * @example
     * // Adds a menu to the currently active editor instance
     * var dm = tinymce.activeEditor.controlManager.createDropMenu('somemenu');
     *
     * // Add some menu items
     * dm.add({title : 'Menu 1', onclick : function() {
     *     alert('Item 1 was clicked.');
     * }});
     *
     * dm.add({title : 'Menu 2', onclick : function() {
     *     alert('Item 2 was clicked.');
     * }});
     *
     * // Adds a submenu
     * var sub1 = dm.addMenu({title : 'Menu 3'});
     * sub1.add({title : 'Menu 1.1', onclick : function() {
     *     alert('Item 1.1 was clicked.');
     * }});
     *
     * // Adds a horizontal separator
     * sub1.addSeparator();
     *
     * sub1.add({title : 'Menu 1.2', onclick : function() {
     *     alert('Item 1.2 was clicked.');
     * }});
     *
     * // Adds a submenu to the submenu
     * var sub2 = sub1.addMenu({title : 'Menu 1.3'});
     *
     * // Adds items to the sub sub menu
     * sub2.add({title : 'Menu 1.3.1', onclick : function() {
     *     alert('Item 1.3.1 was clicked.');
     * }});
     *
     * sub2.add({title : 'Menu 1.3.2', onclick : function() {
     *     alert('Item 1.3.2 was clicked.');
     * }});
     *
     * dm.add({title : 'Menu 4', onclick : function() {
     *     alert('Item 3 was clicked.');
     * }});
     *
     * // Display the menu at position 100, 100
     * dm.showMenu(100, 100);
     */
    tinymce.create('tinymce.ui.DropMenu:tinymce.ui.Menu', {
      /**
       * Constructs a new drop menu control instance.
       *
       * @constructor
       * @method DropMenu
       * @param {String} id Button control id for the button.
       * @param {Object} s Optional name/value settings object.
       */
      DropMenu: function (id, s) {
        s = s || {};
        s.container = s.container || DOM.doc.body;
        s.offset_x = s.offset_x || 0;
        s.offset_y = s.offset_y || 0;
        s.vp_offset_x = s.vp_offset_x || 0;
        s.vp_offset_y = s.vp_offset_y || 0;

        this._super(id, s);
        this.onShowMenu = new tinymce.util.Dispatcher(this);
        this.onHideMenu = new tinymce.util.Dispatcher(this);
        this.onFilterInput = new tinymce.util.Dispatcher(this);
        this.classPrefix = 'mceMenu';

        // array of selected items
        this.selected = [];
      },

      /**
       * Created a new sub menu for the drop menu control.
       *
       * @method createMenu
       * @param {Object} s Optional name/value settings object.
       * @return {tinymce.ui.DropMenu} New drop menu instance.
       */
      createMenu: function (s) {
        var self = this,
          cs = self.settings,
          m;

        s.container = s.container || cs.container;
        s.parent = self;
        s.constrain = s.constrain || cs.constrain;
        s['class'] = s['class'] || cs['class'];
        s.vp_offset_x = s.vp_offset_x || cs.vp_offset_x;
        s.vp_offset_y = s.vp_offset_y || cs.vp_offset_y;
        s.keyboard_focus = cs.keyboard_focus;
        m = new tinymce.ui.DropMenu(s.id || DOM.uniqueId(), s);

        m.onAddItem.add(self.onAddItem.dispatch, self.onAddItem);

        return m;
      },

      focus: function () {
        var self = this;
        if (self.keyboardNav) {
          self.keyboardNav.focus();
        }
      },

      /**
       * Repaints the menu after new items have been added dynamically.
       *
       * @method update
       */
      update: function () {
        var self = this,
          s = self.settings,
          m = DOM.get('menu_' + self.id);

        if (s.max_width) {
          DOM.setStyle(m, 'width', s.max_width);
        }

        if (s.max_height) {
          DOM.setStyle(m, 'height', s.max_height);
        }
      },

      scrollTo: function (el) {
        var p = el.parentNode;
        p.scrollTop = el.offsetTop;
      },

      deselectAll: function () {
        var self = this;

        each(self.items, function (item) {
          item.setSelected(0);
        });
      },

      selectItem: function (item, state) {
        var self = this;

        if (!item) {
          return false;
        }

        item.setSelected(state);

        if (state) {
          self.selected.push(item);
        } else {
          var idx = tinymce.inArray(self.selected, item);

          if (idx >= 0) {
            self.selected.splice(idx, 1);
          }
        }

        return item;
      },

      findItem: function (val) {
        var self = this, found;

        each(self.items, function (item) {
          if (item.settings.title === val) {
            found = item;

            // break
            return false;
          }
        });

        return found;
      },

      clearFilterInput: function () {
        var self = this, filter = DOM.get('menu_' + self.id + '_filter'), input = DOM.select('input', 'menu_' + self.id + '_filter_input')[0];

        if (!filter) {
          return;
        }

        // find and clear input element
        input.value = '';
        input.focus();

        self.clearFilteredItems();
      },

      /**
       * Displays the menu at the specified cordinate.
       *
       * @method showMenu
       * @param {Number} x Horizontal position of the menu.
       * @param {Number} y Vertical position of the menu.
       * @param {Numner} px Optional parent X position used when menus are cascading.
       */
      showMenu: function (x, y, px, py) {
        var self = this,
          s = self.settings,
          co, vp = DOM.getViewPort(),
          w, h, mx, my, ot = 0, cp = self.classPrefix;

        self.collapse(1);

        if (self.isMenuVisible) {
          return;
        }

        // clear selection
        self.selected = [];

        if (!self.rendered) {
          co = DOM.add(self.settings.container, self.renderNode());

          each(self.items, function (o) {
            o.postRender();
          });

          self.postRender();

        } else {
          co = DOM.get('menu_' + self.id);
        }

        if (!co) {
          return;
        }

        DOM.show(co);
        self.update();

        x += s.offset_x || 0;
        y += s.offset_y || 0;

        // Move inside viewport if not submenu
        if (s.constrain) {
          w = co.clientWidth - ot;
          h = co.clientHeight - ot;
          mx = vp.x + vp.w;
          my = vp.y + vp.h;

          if ((x + s.vp_offset_x + w) > mx) {
            x = px ? px - w : Math.max(0, (mx - s.vp_offset_x) - w);
          }

          if ((y + s.vp_offset_y + h) > my) {
            y = py ? py - h - 8 : Math.max(0, (my - s.vp_offset_y) - h);
          }
        }

        DOM.setStyles(co, {
          left: x,
          top: y
        });

        self.isMenuVisible = 1;

        self.mouseClickFunc = Event.add(co, 'click', function (e) {
          var n;

          n = e.target;

          // cancel on input click
          if (n.nodeName == "INPUT" || n.nodeName == 'TEXTAREA') {
            return;
          }

          if (n && (n = DOM.getParent(n, '.mceMenuItem')) && !DOM.hasClass(n, cp + 'ItemSub')) {
            var item = self.items[n.id];

            if (!item || item.isDisabled()) {
              return false;
            }

            if (item.settings.onAction) {
              item.settings.onAction(e);
            }

            if (item.settings.onclick) {
              item.settings.onclick(e);
              self.close();
            }

            self.clearFilterInput();

            return false; // Cancel to fix onbeforeunload problem
          }
        });

        self.mouseOverFunc = Event.add(co, 'mouseover', function (e) {
          var m, r, n;

          n = e.target;

          if (n && (n = DOM.getParent(n, '.mceMenuItem'))) {
            m = self.items[n.id];

            if (self.hasMenus()) {
              if (self.lastMenu) {
                self.lastMenu.collapse(1);
              }

              if (m.isDisabled()) {
                return;
              }

              if (n && DOM.hasClass(n, cp + 'ItemSub')) {
                r = DOM.getRect(n);
                m.showMenu((r.x + r.w - ot), r.y - ot, r.x);
                self.lastMenu = m;
                //DOM.addClass(DOM.get(m.id).firstChild, cp + 'ItemActive');
              }
            }

            if (m.settings.onmouseover) {
              m.settings.onmouseover(e);
            }
          }
        });

        Event.add(co, 'keydown', self._keyDownHandler, self);

        if (s.filter) {
          Event.add(co, 'keyup', self._keyUpHandler, self);
        }

        self.onShowMenu.dispatch(self);

        // scroll to selected item
        each(self.items, function (o) {
          if (o.selected) {
            if (tinymce.inArray(self.selected, o) === -1) {
              self.selected.push(o);
            }
          }
        });

        if (self.selected.length) {
          var el = DOM.get(self.selected[0].id);
          self.scrollTo(el);
        } else {
          // reset scroll position
          DOM.get('menu_' + self.id + '_items').scrollTop = 0;
        }

        if (s.keyboard_focus) {
          self._setupKeyboardNav();
        }

        if (s.filter) {
          // focus input
          var input = DOM.select('input', 'menu_' + self.id + '_filter_input');

          if (input) {
            input[0].focus();
          }
        }
      },

      /**
       * Hides the displayed menu.
       *
       * @method hideMenu
       */
      hideMenu: function (c) {
        var self = this,
          co = DOM.get('menu_' + self.id),
          e;

        if (!self.isMenuVisible) {
          return;
        }

        // reset filter
        if (self.settings.filter) {
          self.clearFilterInput(true);
        }

        Event.remove(co, 'click', self.mouseClickFunc);
        Event.remove(co, 'keydown', self._keyDownHandler);
        Event.remove(co, 'keyup', self._keyUpHandler);

        DOM.hide(co);

        self.isMenuVisible = 0;

        if (!c) {
          self.collapse(1);
        }

        e = DOM.get('menu_' + self.id);

        if (e) {
          DOM.removeClass(e.firstChild, self.classPrefix + 'ItemActive');
        }

        // trigger event
        self.onHideMenu.dispatch(self);
      },

      /**
       * Adds a new menu, menu item or sub classes of them to the drop menu.
       *
       * @method add
       * @param {tinymce.ui.Control} o Menu or menu item to add to the drop menu.
       * @return {tinymce.ui.Control} Same as the input control, the menu or menu item.
       */
      add: function (o) {
        var self = this,
          co;

        o = self._super(o);

        if (self.isRendered && (co = DOM.get('menu_' + self.id + '_items'))) {
          self._add(co, o);
        }

        return o;
      },

      /**
       * Collapses the menu, this will hide the menu and all menu items.
       *
       * @method collapse
       * @param {Boolean} d Optional deep state. If this is set to true all children will be collapsed as well.
       */
      collapse: function (d) {
        this._super(d);
        this.hideMenu(1);
      },

      close: function () {
        var self = this, dm = self;

        while (dm) {
          if (dm.hideMenu) {
            dm.hideMenu();
          }

          dm = dm.settings.parent;
        }
      },  

      /**
       * Removes a specific sub menu or menu item from the drop menu.
       *
       * @method remove
       * @param {tinymce.ui.Control} o Menu item or menu to remove from drop menu.
       * @return {tinymce.ui.Control} Control instance or null if it wasn't found.
       */
      remove: function (o) {
        DOM.remove(o.id);
        this.destroy();

        return this._super(o);
      },

      /**
       * Destroys the menu. This will remove the menu from the DOM and any events added to it etc.
       *
       * @method destroy
       */
      destroy: function () {
        var self = this,
          co = DOM.get('menu_' + self.id);

        if (self.keyboardNav) {
          self.keyboardNav.destroy();
        }

        Event.remove(co, 'mouseover', self.mouseOverFunc);
        Event.remove(DOM.select('a', co), 'focus', self.mouseOverFunc);
        Event.remove(co, 'click', self.mouseClickFunc);
        Event.remove(co, 'keyup', self._keyUpHandler);
        Event.remove(co, 'keydown', self._keyDownHandler);

        DOM.remove(co);
      },

      /**
       * Renders the specified menu node to the dom.
       *
       * @method renderNode
       * @return {Element} Container element for the drop menu.
       */
      renderNode: function () {
        var self = this,
          s = self.settings, menu, items;

        menu = DOM.create('div', {
          role: 'menu',
          id: 'menu_' + self.id,
          'class': s['class'] + ' ' + self.classPrefix
        });

        if (self.settings.parent) {
          DOM.setAttrib(menu, 'aria-parent', self.settings.parent.id);
        }

        // create autocomplete filter
        if (s.filter) {
          var filter = DOM.add(menu, 'div', {
            id: 'menu_' + self.id + '_filter',
            'class': self.classPrefix + 'Filter'
          }, '');

          var filterInput = DOM.add(filter, 'div', {
            id: 'menu_' + self.id + '_filter_input',
            'class': self.classPrefix + 'FilterInput'
          }, '<input type="text" autocomplete="off" autocapitalize="off" spellcheck="false" placeholder="..." />');

          self.onHideMenu.add(function () {
            filterInput.firstChild.value = "";
          });
        }

        items = DOM.add(menu, 'div', {
          role: 'presentation',
          id: 'menu_' + self.id + '_items',
          'class': self.classPrefix + 'Items'
        });

        each(self.items, function (o) {
          self._add(items, o);
        });

        self.rendered = true;

        return menu;
      },

      selectAndClear : function (value) {
        var self = this;

        self.settings.onselect.call(self, value);
        self.clearFilterInput();
      },

      // Internal functions
      _setupKeyboardNav: function () {
        var contextMenu, menuItems, self = this;
        contextMenu = DOM.get('menu_' + self.id);

        menuItems = DOM.select('div[role="option"]', 'menu_' + self.id);
        menuItems.splice(0, 0, contextMenu);

        self.keyboardNav = new tinymce.ui.KeyboardNavigation({
          root: 'menu_' + self.id,
          items: menuItems,
          onCancel: function () {
            self.hideMenu();
          },
          onAction: function (e, id) {          
            // process filter value
            if (menuItems.length > 1) {
              if (e.target && e.target.nodeName === "INPUT") {
                var val = e.target.value;

                if (val !== '') {
                  var item = self.findItem(val);

                  if (item) {
                    id = item.id;
                  } else {
                    id = DOM.uniqueId();
                    
                    item = self.add({
                      id: id,
                      role: 'option',
                      title: val,
                      onclick: function () {
                        self.selectAndClear(this.settings.value);
                      }
                    });
                  }
                }

                // clear input
                e.target.value = '';
              }
            } else {
              if (self.settings.onselect) {
                self.settings.onselect.call(self, e.target);
              }
              
              self.hideMenu();
            }

            item = item || self.items[id];

            if (item && item.settings.value) {
              self.selectAndClear(item.settings.value);
            }
          },
          enableUpDown: true
        });

        contextMenu.focus();
      },

      _updateKeyboardNav: function () {
        // update keyboard nav with new list
        var items = DOM.select('div[role="option"]:not(.mceMenuItemHidden)', this.id + '');
        this.keyboardNav.update(items);
      },

      clearFilteredItems: function () {
        each(this.items, function (o, id) {
          DOM.removeClass(id, 'mceMenuItemHidden');
        });

        if (this.keyboardNav) {
          this._updateKeyboardNav();
        }
      },

      filterItems: function (value) {
        var self = this;

        if (value === '') {
          self.clearFilteredItems();
          return;
        }

        var matcher = new RegExp('' + escapeRegExChars(value), "i");

        each(self.items, function (o, id) {
          var s = o.settings,
            state;

          if (!value || value === undef) {
            state = true;
          } else {
            state = matcher.test(s.title);
          }

          if (state) {
            DOM.removeClass(id, 'mceMenuItemHidden');
          } else {
            DOM.addClass(id, 'mceMenuItemHidden');
          }
        });

        this._updateKeyboardNav();
      },

      _keyDownHandler: function (evt) {
        var self = this, tabIndex = 0;

        if (evt.keyCode == 9) {
          var nodes = DOM.select('input, button, select, textarea', DOM.get('menu_' + self.id));

          nodes = tinymce.grep(nodes, function (node) {
            return !node.disabled && !DOM.isHidden(node) && node.getAttribute('tabindex') >= 0;
          });

          if (!nodes.length) {
            return;
          }

          DOM.setAttrib(nodes, 'tabindex', 0);

          if (evt.shiftKey) {
            nodes.reverse();
          }

          var endIndex = Math.max(0, nodes.length - 1);
          tabIndex = nodeIndex(nodes, evt.target);

          tabIndex++;

          tabIndex = Math.max(tabIndex, 0);

          if (tabIndex > endIndex) {
            tabIndex = 0;
          }

          nodes[tabIndex].focus();
          DOM.setAttrib(nodes[tabIndex], 'tabindex', 1);

          evt.preventDefault();
          evt.stopImmediatePropagation();
        }
      },

      _keyUpHandler: function (evt) {
        var self = this;

        if (evt.target && evt.target.nodeName === "INPUT") {
          var input = evt.target;

          setTimeout(function () {
            if (evt.keyCode === 32) {
              var item = self.findItem(input.value);

              if (item) {
                self.selectItem(item);
              }

              // clear input
              input.value = '';
            }

            if (!specialKeyCodeMap[evt.keyCode]) {
              self.filterItems(input.value);
            }

            self.onFilterInput.dispatch(self, evt);
          }, 0);
        }
      },

      _add: function (menu, o) {
        var s = o.settings,
          cp = this.classPrefix,
          icon;

        if (s.separator) {
          DOM.add(menu, 'div', {
            id: o.id,
            'class': cp + 'Item ' + cp + 'ItemSeparator'
          });

          return;
        }

        var item = DOM.add(menu, 'div', {
          id: o.id,
          'class': cp + 'Item ' + cp + 'ItemEnabled',
          title: o.settings.title || '',
          'aria-label': o.settings.title || ''
        });

        if (s.html) {
          DOM.addClass(item, 'mceMenuHtml');
          DOM.setHTML(item, s.html);
        } else {
          DOM.setAttrib(item, 'role', 'option');

          if ((s.icon || s.icon_src) && (!s.svg && !s.image)) {
            icon = DOM.add(item, 'span', {
              'class': 'mceIcon' + (s.icon ? ' mce_' + s.icon : '')
            });

            if (s.icon_src) {
              DOM.add(icon, 'img', {
                src: s.icon_src
              });
            }

            DOM.addClass(item, 'mceHasIcon');
          }
          
          if (s.image) {
            DOM.add(item, 'span', {
              'class': 'mceImage',
              style: 'background-image:url("' + s.image + '")'
            });
          }

          if (s.svg) {
            DOM.add(item, 'span', {
              'class': 'mceIcon mceIconSvg'
            }, s.svg);
          }

          var txt = DOM.add(item, s.element || 'span', {
            'class': 'mceText',
            role: 'presentation'
          }, o.settings.title);

          if (o.settings.style) {
            if (typeof o.settings.style == "function") {
              o.settings.style = o.settings.style();
            }

            DOM.setAttrib(txt, 'style', o.settings.style);
          }

          if (s.parent) {
            DOM.setAttrib(txt, 'aria-haspopup', 'true');
            DOM.setAttrib(txt, 'aria-owns', o.id);
          }
        }

        DOM.addClass(item, s['class']);

        if (o.onmouseover) {
          Event.add(item, 'mouseover', o.onmouseover);
        }

        if (o.collapse) {
          DOM.addClass(item, cp + 'ItemSub');
        }
      }
    });
  })(tinymce);

  /**
   * Button.js
   *
   * Copyright, Moxiecode Systems AB
   * Released under LGPL License.
   *
   * License: http://www.tinymce.com/license - Inactive
   * Licence: GNU/LGPL 2.1 or later - http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
   * Contributing: http://www.tinymce.com/contributing - Inactive
   */

  (function (tinymce) {
    var DOM = tinymce.DOM,
      Event = tinymce.dom.Event,
      Dispatcher = tinymce.util.Dispatcher;

    /**
  	 * This class is used to create a UI button. A button is basically a link
  	 * that is styled to look like a button or icon.
  	 *
  	 * @class tinymce.ui.Button
  	 * @extends tinymce.ui.Control
  	 */
    tinymce.create('tinymce.ui.Button:tinymce.ui.Control', {
      /**
  		 * Constructs a new button control instance.
  		 *
  		 * @constructor
  		 * @method Button
  		 * @param {String} id Control id for the button.
  		 * @param {Object} s Optional name/value settings object.
  		 * @param {Editor} ed Optional the editor instance this button is for.
  		 */
      Button: function (id, s, ed) {
        this._super(id, s, ed);
        this.classPrefix = 'mceButton';

        /**
  			 * Fires after the element has been rendered to DOM.
  			 *
  			 * @event onPostRender
  			 */
        this.onPostRender = new Dispatcher(this);
      },

      /**
  		 * Renders the button as a HTML string. This method is much faster than using the DOM and when
  		 * creating a whole toolbar with buttons it does make a lot of difference.
  		 *
  		 * @method renderHTML
  		 * @return {String} HTML for the button control element.
  		 */
      renderHTML: function () {
        var cp = this.classPrefix,
          s = this.settings,
          h, l;

        l = DOM.encode(s.label || '');
        h = '<button type="button" id="' + this.id + '" class="' + cp + ' ' + s['class'] + (l ? ' ' + cp + 'Labeled' : '') + '" title="' + DOM.encode(s.title) + '" aria-label="' + DOM.encode(s.title) + '">';

        if (s['class']) {
          s['class'] = ' ' + tinymce.trim(s['class']);
        }

        s.icon = s.icon || '';

        if (s.image) {
          h += '<span role="presentation" class="mceIcon mceIconImage' + s['class'] + '"><img class="mceIcon" src="' + s.image + '" alt="' + DOM.encode(s.title) + '" /></span>' + (l ? '<span class="' + cp + 'Label">' + l + '</span>' : '');
        } else {
          if (s.icon) {
            s.icon = ' mce_' + s.icon;
          }

          h += '<span role="presentation" class="mceIcon' + s['class'] + '' + s.icon + '"></span>' + (l ? '<span class="' + cp + 'Label">' + l + '</span>' : '');
        }

        h += '</button>';

        return h;
      },

      /**
  		 * Post render handler. This function will be called after the UI has been
  		 * rendered so that events can be added.
  		 *
  		 * @method postRender
  		 */
      postRender: function () {
        var self = this,
          s = self.settings,
          imgBookmark;

        // In IE a large image that occupies the entire editor area will be deselected when a button is clicked, so
        // need to keep the selection in case the selection is lost
        if (tinymce.isIE && self.editor) {
          Event.add(self.id, 'mousedown', function () {
            var nodeName = self.editor.selection.getNode().nodeName;
            imgBookmark = nodeName === 'IMG' ? self.editor.selection.getBookmark() : null;
          });
        }

        Event.add(self.id, 'click', function (e) {
          Event.cancel(e);

          if (!self.isDisabled()) {
            // restore the selection in case the selection is lost in IE
            if (tinymce.isIE && self.editor && imgBookmark !== null) {
              self.editor.selection.moveToBookmark(imgBookmark);
            }

            return s.onclick.call(s.scope, e);
          }
        });

        Event.add(self.id, 'keydown', function (e) {
          if (!self.isDisabled() && e.keyCode == tinymce.VK.SPACEBAR) {
            Event.cancel(e);
            return s.onclick.call(s.scope, e);
          }
        });

        this.rendered = true;

        this.onPostRender.dispatch(this, DOM.get(this.id));
      }
    });
  })(tinymce);

  /**
   * ListBox.js
   *
   * Copyright, Moxiecode Systems AB
   * Released under LGPL License.
   *
   * License: http://www.tinymce.com/license - Inactive
   * Licence: GNU/LGPL 2.1 or later - http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
   * Contributing: http://www.tinymce.com/contributing - Inactive
   */

  (function (tinymce) {
    var DOM = tinymce.DOM,
      Event = tinymce.dom.Event,
      each = tinymce.each,
      Dispatcher = tinymce.util.Dispatcher,
      undef;

    /**
     * This class is used to create list boxes/select list. This one will generate
     * a non native control. This one has the benefits of having visual items added.
     *
     * @class tinymce.ui.ListBox
     * @extends tinymce.ui.Control
     * @example
     * // Creates a new plugin class and a custom listbox
     * tinymce.create('tinymce.plugins.ExamplePlugin', {
     *     createControl: function(n, cm) {
     *         switch (n) {
     *             case 'mylistbox':
     *                 var mlb = cm.createListBox('mylistbox', {
     *                      title : 'My list box',
     *                      onselect : function(v) {
     *                          tinymce.activeEditor.windowManager.alert('Value selected:' + v);
     *                      }
     *                 });
     *
     *                 // Add some values to the list box
     *                 mlb.add('Some item 1', 'val1');
     *                 mlb.add('some item 2', 'val2');
     *                 mlb.add('some item 3', 'val3');
     *
     *                 // Return the new listbox instance
     *                 return mlb;
     *         }
     *
     *         return null;
     *     }
     * });
     *
     * // Register plugin with a short name
     * tinymce.PluginManager.add('example', tinymce.plugins.ExamplePlugin);
     *
     * // Initialize TinyMCE with the new plugin and button
     * tinymce.init({
     *    ...
     *    plugins : '-example', // - means TinyMCE will not try to load it
     *    theme_advanced_buttons1 : 'mylistbox' // Add the new example listbox to the toolbar
     * });
     */

    var specialKeyCodeMap = {
      9: 'tab',
      17: 'ctrl',
      18: 'alt',
      27: 'esc',
      //32: 'space',
      37: 'left',
      39: 'right',
      13: 'enter',
      91: 'cmd',
      38: 'up',
      40: 'down'
    };

    tinymce.create('tinymce.ui.ListBox:tinymce.ui.Control', {
      /**
       * Constructs a new listbox control instance.
       *
       * @constructor
       * @method ListBox
       * @param {String} id Control id for the list box.
       * @param {Object} s Optional name/value settings object.
       * @param {Editor} ed Optional the editor instance this button is for.
       */
      ListBox: function (id, s, ed) {
        this._super(id, s, ed);

        /**
         * Array of ListBox items.
         *
         * @property items
         * @type Array
         */
        this.items = s.items || [];

        /**
         * Fires when the selection has been changed.
         *
         * @event onChange
         */
        this.onChange = new Dispatcher(this);

        /**
         * Fires after the element has been rendered to DOM.
         *
         * @event onPostRender
         */
        this.onPostRender = new Dispatcher(this);

        /**
         * Fires when a new item is added.
         *
         * @event onAdd
         */
        this.onAdd = new Dispatcher(this);

        /**
         * Fires before the menu gets rendered.
         *
         * @event onBeforeRenderMenu
         */
        this.onBeforeRenderMenu = new Dispatcher(this);

        /**
         * Fires when the menu gets rendered.
         *
         * @event onRenderMenu
         */
        this.onRenderMenu = new Dispatcher(this);

        /**
         * Class prefix to identify and style control.
         * 
         * @type String
         */
        this.classPrefix = 'mceListBox';
      },

      deselectAll: function () {
        var self = this;

        each(self.items, function (item) {
          item.selected = false;
        });

        if (self.menu) {
          self.menu.deselectAll();
        }
      },

      /**
       * Selects a item/option by value. This will both add a visual selection to the
       * item and change the title of the control to the title of the option.
       *
       * @method select
       * @param {String/function} value Value to look for inside the list box or a function selector.
       */
      select: function (values) {
        var self = this, fv;

        if (values == null || values == undef) {
          return this.selectByIndex(-1);
        }

        if (!values.length) {
          this.deselectAll();
          return this.selectByIndex(-1);
        }

        // reset
        if (!this.settings.multiple) {
          this.deselectAll();
        }

        // used by fontselect etc.
        if (typeof values == "function") {
          each(self.items, function (item, i) {
            if (values(item.value)) {
              self.selectByIndex(i);
              fv = true;
            }
          });

          if (!fv) {
            self.selectByIndex(-1);
          }

          return;
        }

        if (tinymce.is(values, 'string')) {
          if (self.settings.multiple && self.settings.seperator) {
            values = values.split(self.settings.seperator);
          } else {
            values = [values];
          }
        }

        each(values, function (value) {
          var i = self.findItem(value);

          if (i == -1) {
            // add a new custom combobox value
            if (self.settings.combobox) {
              i = self.add(value, value);
            }
          }

          self.selectByIndex(i);
        });

        // clear combobox and add a tag for each selected item
        if (this.settings.combobox) {
          this.clearComboBox(true);

          if (this.settings.multiple) {
            each(this.items, function (item) {
              if (item.selected) {
                self.addTag(item.value);
              }
            });
          }
        }
      },

      value: function (val) {
        if (!arguments.length) {
          val = [];

          each(this.items, function (item) {
            if (item.selected) {
              val.push(item.value);
            }
          });

          return val.join(' ').trim();
        }

        this.select(val);
        this.settings.onselect.call(this, val);
      },

      /**
       * Selects a item/option by index. This will both add a visual selection to the
       * item and change the title of the control to the title of the option.
       *
       * @method selectByIndex
       * @param {String} idx Index to select, pass -1 to select menu/title of select box.
       */
      selectByIndex: function (idx) {
        var self = this, elm, item;

        elm = DOM.get(this.id + '_text');
        item = this.items[idx];

        if (item) {
          item.selected = !item.selected;

          if (item.selected) {
            this.selectedValue = item.value;
          } else {
            this.selectedValue = null;
          }

          if (!this.settings.combobox) {
            DOM.setHTML(elm, DOM.encode(item.title));
            DOM.removeClass(elm, 'mceTitle');
            DOM.setAttrib(this.id, 'aria-valuenow', item.title);
          }

          if (self.menu) {          
            self.menu.selectItem(self.menu.items[item.id], item.selected);
          }

        } else {
          DOM.setHTML(elm, DOM.encode(this.settings.title));
          DOM.addClass(elm, 'mceTitle');
          this.selectedValue = null;

          DOM.setAttrib(this.id, 'aria-valuenow', this.settings.title);

          if (self.settings.multiple) {
            self.deselectAll();
          }
        }
      },

      /**
       * Adds a option item to the list box.
       *
       * @method add
       * @param {String} name Title for the new option.
       * @param {String} value Value for the new option.
       * @param {Object} settings Optional object with settings like for example class.
       */
      add: function (name, value, settings) {
        settings = settings || {};

        // don't add if it already exists
        if (this.findItem(value) != -1) {
          return;
        }

        settings = tinymce.extend(settings, {
          title: name,
          value: value
        });

        var len = this.items.push(settings);
        this.onAdd.dispatch(this, settings);

        return len - 1;
      },

      findItem: function (value) {
        var idx = -1;

        for (var i = 0, len = this.items.length; i < len; i++) {
          if (this.items[i].value === value) {
            idx = i;
          }
        }

        return idx;
      },

      /**
       * Returns the number of items inside the list box.
       *
       * @method getLength
       * @param {Number} Number of items inside the list box.
       */
      getLength: function () {
        return this.items.length;
      },

      /**
       * Renders the list box as a HTML string. This method is much faster than using the DOM and when
       * creating a whole toolbar with buttons it does make a lot of difference.
       *
       * @method renderHTML
       * @return {String} HTML for the list box control element.
       */
      renderHTML: function () {
        var html = '',
          prefix = this.classPrefix;

        if (this.settings.combobox) {

          var inp = DOM.createHTML('input', {
            type: 'text',
            id: this.id + '_input',
            tabindex: -1,
            autocomplete: 'off',
            spellcheck: false,
            autocapitalize: 'off',
            class: 'mceText',
            placeholder: '...'
          });

          html += DOM.createHTML('div', {
            class: 'mceComboBox'
          }, inp);

        } else {
          html += DOM.createHTML('button', {
            type: 'button',
            id: this.id + '_text',
            tabindex: -1,
            class: 'mceText'
          }, DOM.encode(this.settings.title));
        }

        html += DOM.createHTML('button', {
          type: 'button',
          id: this.id + '_open',
          tabindex: -1,
          class: 'mceOpen'
        });

        return DOM.createHTML('div', {
          id: this.id,
          role: this.settings.combobox ? 'combobox' : 'listbox',
          tabindex: 0,
          'class': prefix + ' ' + this.settings['class'],
          title: this.settings.title,
          'aria-label': this.settings.title,
          'aria-haspopup': 'true',
          'aria-expanded': false
        }, html);
      },

      clearComboBox: function (removetags) {
        var self = this, input = DOM.get(self.id + '_input');

        // find and clear input element
        input.value = '';
        input.focus();

        if (removetags) {
          DOM.remove(DOM.select('.mceButtonTag', this.id));
        }
      },

      removeTag: function (btn) {
        var self = this;

        each(self.items, function (item, i) {
          if (item.value === btn.value) {
            item.selected = false;

            if (self.selectedValue == item.value) {
              self.selectedValue = null;
            }
          }
        });

        Event.clear(btn);
        DOM.remove(btn);
      },

      addTag: function (value) {
        var self = this, btn, inp;

        inp = DOM.get(self.id + '_input');

        btn = DOM.create('button', {
          'class': 'mceButton mceButtonTag',
          'value': value
        }, '<label>' + value + '</label>');

        DOM.insertBefore(btn, inp);

        Event.add(btn, 'click', function (evt) {
          evt.preventDefault();

          if (evt.target.nodeName == 'LABEL') {
            return;
          }

          self.removeTag(btn);
        });
      },

      /**
       * Displays the drop menu with all items.
       *
       * @method showMenu
       */
      showMenu: function () {
        var self = this,
          pos, elm = DOM.get(this.id),
          menu;

        if (this.isDisabled()) {
          return;
        }

        if (!this.isMenuRendered) {
          this.renderMenu();
          this.isMenuRendered = true;
        }

        if (this.items.length === 0) {
          return;
        }

        pos = DOM.getPos(elm);

        menu = this.menu;
        menu.settings.offset_x = pos.x;
        menu.settings.offset_y = pos.y;

        if (!this.settings.max_width) {
          menu.settings.max_width = elm.offsetWidth;
        }

        // Select in menu
        each(this.items, function (item) {
          if (menu.items[item.id]) {
            // deselect all items
            menu.items[item.id].setSelected(0);

            // select if value match or selected
            if (item.value === self.selectedValue || item.selected) {
              menu.items[item.id].setSelected(1);
            }
          }
        });

        menu.showMenu(0, elm.clientHeight, 0, pos.y);

        Event.add(DOM.doc, 'mousedown', this.hideMenu, this);

        DOM.addClass(this.id, this.classPrefix + 'Selected');

        this.setAriaProperty('expanded', true);
      },

      /**
       * Hides the drop menu.
       *
       * @method hideMenu
       */
      hideMenu: function (e) {
        if (!this.menu) {
          return;
        }

        // Prevent double toggles by canceling the mouse click event to the button
        if (e && e.type == "mousedown" && (e.target.id == this.id + '_text' || e.target.id == this.id + '_open')) {
          return;
        }

        if (!e || !DOM.getParent(e.target, '.mceMenu')) {
          DOM.removeClass(this.id, this.classPrefix + 'Selected');
          Event.remove(DOM.doc, 'mousedown', this.hideMenu, this);

          this.menu.hideMenu();
        }

        this.setAriaProperty('expanded', false);
      },

      /**
       * Renders the menu to the DOM.
       *
       * @method renderMenu
       */
      renderMenu: function () {
        var self = this,
          menu;

          var cls = this.classPrefix + 'Menu' + (this.settings.menu_class ? ' ' + this.settings.menu_class : '');

        menu = this.settings.control_manager.createDropMenu(this.id + '_menu', {
          class: cls,
          max_width: this.settings.max_width || 250,
          max_height: this.settings.max_height || '',
          filter: !!this.settings.filter,
          keyboard_focus: true,
          onselect: function (value) {
            if (self.settings.onselect(value) !== false) {
              self.select(value);
              menu.close();
            }
          }
        });

        menu.onHideMenu.add(function () {
          self.hideMenu();

          if (self.settings.combobox) {
            menu.clearFilteredItems();
            self.focus();
          }

        });

        // fire onBeforeRenderMenu, which allows list items to be added before display
        this.onBeforeRenderMenu.dispatch(this, menu);

        each(this.items, function (item) {
          // No value then treat it as a title
          if (item.value === undef) {
            menu.add({
              title: item.title,
              role: "option",
              onAction: function (e) {
                if (self.settings.onselect('') !== false) {
                  self.select('');
                }

                menu.close();
              }
            });
          } else {
            item.id = DOM.uniqueId();
            item.role = "option";
            item.onAction = function (e) {
              if (self.settings.onselect(item.value) !== false) {
                self.select(item.value);
              }

              if (!self.settings.multiple && !self.settings.keepopen) {
                menu.close();
              }
            };

            menu.add(item);
          }
        });

        this.onRenderMenu.dispatch(this, menu);
        this.menu = menu;
      },

      /**
       * Post render event. This will be executed after the control has been rendered and can be used to
       * set states, add events to the control etc. It's recommended for subclasses of the control to call this method by using this._super().
       *
       * @method postRender
       */
      postRender: function () {
        var self = this;

        // clean up
        self.destroy();

        Event.add(this.id, 'click', function (evt) {
          if (evt.target.nodeName == "INPUT" || DOM.hasClass(evt.target, 'mceButtonTag')) {
            return;
          }

          if (self.menu && self.menu.isMenuVisible) {
            self.hideMenu(evt);
          } else {
            self.showMenu(evt);
          }

          Event.cancel(evt);
        });

        Event.add(this.id, 'keydown', function (evt) {
          if (evt.target.nodeName === "INPUT") {
            return;
          }

          if (evt.keyCode == 32) { // Space
            if (self.menu && self.menu.isMenuVisible) {
              self.hideMenu(evt);
            } else {
              self.showMenu(evt);
            }

            Event.cancel(evt);
          }
        });

        Event.add(this.id + '_input', 'keyup', function (evt) {

          setTimeout(function () {
            var value = evt.target.value;

            if (!value) {
              Event.cancel(evt);
              self.hideMenu();
              return;
            }

            if (!specialKeyCodeMap[evt.keyCode]) {
              if (!self.menu || !self.menu.isMenuVisible) {
                self.showMenu();
              }

              evt.target.focus();

              self.menu.filterItems(value);
            }
          }, 0);
        });

        Event.add(this.id + '_input', 'keydown', function (evt) {
          switch (evt.keyCode) {
            // enter
            case 13:
              Event.cancel(evt);

              if (this.value === "") {
                self.showMenu();
              } else {
                if (self.settings.onselect(this.value) !== false) {
                  self.select(this.value);
                }

                self.hideMenu();

                this.value = "";
              }
              break;
            // down arrow
            case 40:
            case 38:
              self.showMenu();
              Event.cancel(evt);
              self.menu.focus();
              break;
            // backspace
            case 8:
              // keep normal behaviour while input has a value
              if (this.value) {
                return;
              }

              var tags = DOM.select('button', evt.target.parentNode);

              if (tags.length) {
                var tag = tags.pop(), val = tag.value;

                // remove tag
                self.removeTag(tag);

                Event.cancel(evt);

                // update value with tag value and focus
                this.value = val;
                this.focus();
              }

              break;
          }
        });

        Event.add(this.id, 'focus', function () {
          if (!this._focused) {

            this.keyDownHandler = Event.add(this.id, 'keydown', function (e) {
              if (e.keyCode == 40) {
                self.showMenu();
                Event.cancel(e);
              }
            });

            this.keyPressHandler = Event.add(this.id, 'keypress', function (e) {
              var value;
              if (e.keyCode == 13) {
                // Fake select on enter
                value = self.selectedValue;
                self.selectedValue = null; // Needs to be null to fake change
                Event.cancel(e);
                self.settings.onselect(value);
              }
            });
          }

          this._focused = 1;
        });

        Event.add(this.id, 'blur', function () {
          Event.remove(this.id, 'keydown', this.keyDownHandler);
          Event.remove(this.id, 'keypress', this.keyPressHandler);
          this._focused = 0;
        });

        this.onPostRender.dispatch(this, DOM.get(this.id));

        this.rendered = true;
      },

      /**
       * Destroys the ListBox i.e. clear memory and events.
       *
       * @method destroy
       */
      destroy: function () {
        this._super();

        Event.clear(this.id + '_text');
        Event.clear(this.id + '_open');

        each(this.items, function (item) {
          item.selected = false;
        });

        this.selectedValue = null;
      }
    });
  })(tinymce);

  /**
   * NativeListBox.js
   *
   * Copyright, Moxiecode Systems AB
   * Released under LGPL License.
   *
   * License: http://www.tinymce.com/license - Inactive
   * Licence: GNU/LGPL 2.1 or later - http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
   * Contributing: http://www.tinymce.com/contributing - Inactive
   */

  (function (tinymce) {
    var DOM = tinymce.DOM,
      Event = tinymce.dom.Event,
      each = tinymce.each,
      undef;

    /**
  	 * This class is used to create list boxes/select list. This one will generate
  	 * a native control the way that the browser produces them by default.
  	 *
  	 * @class tinymce.ui.NativeListBox
  	 * @extends tinymce.ui.ListBox
  	 */
    tinymce.create('tinymce.ui.NativeListBox:tinymce.ui.ListBox', {
      /**
  		 * Constructs a new button control instance.
  		 *
  		 * @constructor
  		 * @method NativeListBox
  		 * @param {String} id Button control id for the button.
  		 * @param {Object} settings Optional name/value settings object.
  		 */
      NativeListBox: function (id, settings) {
        this._super(id, settings);
      },

      /**
  		 * Sets the disabled state for the control. This will add CSS classes to the
  		 * element that contains the control. So that it can be disabled visually.
  		 *
  		 * @method setDisabled
  		 * @param {Boolean} s Boolean state if the control should be disabled or not.
  		 */
      setDisabled: function (settings) {
        DOM.get(this.id).disabled = settings;
        this.setAriaProperty('disabled', settings);
      },

      /**
  		 * Returns true/false if the control is disabled or not. This is a method since you can then
  		 * choose to check some class or some internal bool state in subclasses.
  		 *
  		 * @method isDisabled
  		 * @return {Boolean} true/false if the control is disabled or not.
  		 */
      isDisabled: function () {
        return DOM.get(this.id).disabled;
      },

      /**
  		 * Selects a item/option by value. This will both add a visual selection to the
  		 * item and change the title of the control to the title of the option.
  		 *
  		 * @method select
  		 * @param {String/function} value Value to look for inside the list box or a function selector.
  		 */
      select: function (value) {
        var self = this,
          fv, fn;

        if (value == undef) {
          return this.selectByIndex(-1);
        }

        // Is string or number make function selector
        if (value && typeof (value) == "function") {
          fn = value;
        } else {
          fn = function (val) {
            return val == value;
          };
        }

        // Do we need to do something?
        if (value != this.selectedValue) {
          // Find item
          each(this.items, function (o, i) {
            if (fn(o.value)) {
              fv = 1;
              self.selectByIndex(i);
              return false;
            }
          });

          if (!fv) {
            this.selectByIndex(-1);
          }
        }
      },

      /**
  		 * Selects a item/option by index. This will both add a visual selection to the
  		 * item and change the title of the control to the title of the option.
  		 *
  		 * @method selectByIndex
  		 * @param {String} idx Index to select, pass -1 to select menu/title of select box.
  		 */
      selectByIndex: function (idx) {
        DOM.get(this.id).selectedIndex = idx + 1;
        this.selectedValue = this.items[idx] ? this.items[idx].value : null;
      },

      /**
  		 * Adds a option item to the list box.
  		 *
  		 * @method add
  		 * @param {String} name Title for the new option.
  		 * @param {String} value Value for the new option.
  		 * @param {Object} attribs Optional object with settings like for example class.
  		 */
      add: function (name, value, attribs) {
        var obj;

        attribs = attribs || {};
        attribs.value = value;

        if (this.isRendered()) {
          DOM.add(DOM.get(this.id), 'option', attribs, name);
        }

        obj = {
          title: name,
          value: value,
          attribs: attribs
        };

        this.items.push(obj);
        this.onAdd.dispatch(this, obj);
      },

      /**
  		 * Executes the specified callback function for the menu item. In this case when the user clicks the menu item.
  		 *
  		 * @method getLength
  		 */
      getLength: function () {
        return this.items.length;
      },

      /**
  		 * Renders the list box as a HTML string. This method is much faster than using the DOM and when
  		 * creating a whole toolbar with buttons it does make a lot of difference.
  		 *
  		 * @method renderHTML
  		 * @return {String} HTML for the list box control element.
  		 */
      renderHTML: function () {
        var html;

        html = DOM.createHTML('option', {
          value: ''
        }, '-- ' + this.settings.title + ' --');

        each(this.items, function (item) {
          html += DOM.createHTML('option', {
            value: item.value
          }, item.title);
        });

        html = DOM.createHTML('select', {
          id: this.id,
          'class': 'mceNativeListBox',
          'aria-labelledby': this.id + '_aria'
        }, html);

        html += DOM.createHTML('span', {
          id: this.id + '_aria',
          'style': 'display: none'
        }, this.settings.title);

        return html;
      },

      /**
  		 * Post render handler. This function will be called after the UI has been
  		 * rendered so that events can be added.
  		 *
  		 * @method postRender
  		 */
      postRender: function () {
        var self = this,
          ch, changeListenerAdded = true;

        this.rendered = true;

        function onChange(e) {
          var value = self.items[e.target.selectedIndex - 1];

          if (value && (value = value.value)) {
            self.onChange.dispatch(self, value);

            if (self.settings.onselect) {
              self.settings.onselect(value);
            }
          }
        }

        Event.add(this.id, 'change', onChange);

        // Accessibility keyhandler
        Event.add(this.id, 'keydown', function (e) {
          var blur, DOM_VK_UP = 38,
            DOM_VK_DOWN = 40,
            DOM_VK_RETURN = 13,
            DOM_VK_SPACE = 32;

          Event.remove(self.id, 'change', ch);
          changeListenerAdded = false;

          blur = Event.add(this.id, 'blur', function () {
            if (changeListenerAdded) {
              return;
            }

            changeListenerAdded = true;
            Event.add(self.id, 'change', onChange);
            Event.remove(self.id, 'blur', blur);
          });

          if (e.keyCode == DOM_VK_RETURN || e.keyCode == DOM_VK_SPACE) {
            onChange(e);
            return Event.cancel(e);
          } else if (e.keyCode == DOM_VK_DOWN || e.keyCode == DOM_VK_UP) {
            // allow native implementation (navigate select element options)
            e.stopImmediatePropagation();
          }
        });

        this.onPostRender.dispatch(this, DOM.get(this.id));
      }
    });
  })(tinymce);

  /**
   * TextBox.js
   */

  (function (tinymce) {
    var DOM = tinymce.DOM,
      Event = tinymce.dom.Event,
      Dispatcher = tinymce.util.Dispatcher;

    /**
     * This class is used to create text / input boxes.
     *
     * @class tinymce.ui.TextBox
     * @extends tinymce.ui.Control
     * @example
     */
    tinymce.create('tinymce.ui.TextBox:tinymce.ui.Control', {
      /**
       * Constructs a new textbox control instance.
       *
       * @constructor
       * @method TextBox
       * @param {String} id Control id for the list box.
       * @param {Object} s Optional name/value settings object.
       * @param {Editor} ed Optional the editor instance this button is for.
       */
      TextBox: function (id, s, ed) {

        s = tinymce.extend({
          class: '',
          title: ''
        }, s);

        this._super(id, s, ed);

        /**
         * Fires when the selection has been changed.
         *
         * @event onChange
         */
        this.onChange = new Dispatcher(this);

        /**
         * Fires after the element has been rendered to DOM.
         *
         * @event onPostRender
         */
        this.onPostRender = new Dispatcher(this);

        this.classPrefix = 'mceTextBox';
      },

      /**
       * Sets / gets the input value.
       *
       * @method select
       * @param {String/function} val Value to set for the textbox.
       */
      value: function (val) {
        if (!arguments.length) {
          return DOM.getValue(this.id);
        }

        DOM.setValue(this.id, val);
      },

      /**
       * Renders the text box as a HTML string. This method is much faster than using the DOM and when
       * creating a whole toolbar with buttons it does make a lot of difference.
       *
       * @method renderHTML
       * @return {String} HTML for the text control element.
       */
      renderHTML: function () {
        var html = '',
          prefix = this.classPrefix, s = this.settings;

        var type = s.subtype ? s.subtype : 'text';

        var attribs = {
          type: type,
          id: this.id,
          class: prefix + ' ' + s['class'],
          title: DOM.encode(s.title),
          tabindex: 0,
          autofocus: true
        };

        attribs = tinymce.extend(attribs, s.attributes || {});

        if (s.multiline) {
          html += DOM.createHTML('textarea', attribs, '');
        } else {
          html += DOM.createHTML('input', attribs);
        }

        if (s.button) {
          html += DOM.createHTML('button', {
            id: this.id + '_button',
            class: 'mceButton',
            title: DOM.encode(s.button.label || '')
          }, '<span role="presentation" class="mceIcon mce_' + s.button.icon + '"></span>');
        }

        return html;
      },

      /**
       * Post render event. This will be executed after the control has been rendered and can be used to
       * set states, add events to the control etc. It's recommended for subclasses of the control to call this method by using this._super().
       *
       * @method postRender
       */
      postRender: function () {
        var self = this, s = this.settings;

        if (typeof s.value !== 'undefined') {
          this.value(s.value);
        }

        if (s.onchange && typeof s.onchange === 'function') {
          this.onChange.add(s.onchange);
        }

        Event.add(this.id, 'change', function () {
          self.onChange.dispatch(this, DOM.get(self.id));
        });

        if (s.button) {
          Event.add(this.id + '_button', 'click', function (e) {
            e.preventDefault();

            s.button.click.apply(self);
          });
        }
        
        this.onPostRender.dispatch(this, DOM.get(this.id));
      },

      /**
       * Sets the disabled state for the control. This will add CSS classes to the
       * element that contains the control. So that it can be disabled visually.
       *
       * @method setDisabled
       * @param {Boolean} state Boolean state if the control should be disabled or not.
       */
      setDisabled: function (state) {
        this._super(state);

        var elm = DOM.get(this.id);

        if (elm) {
          elm.disabled = state;
        }
      },

      /**
       * Destroys the TextBox i.e. clear memory and events.
       *
       * @method destroy
       */
      destroy: function () {
        this._super();

        Event.clear(this.id);
      }
    });
  })(tinymce);

  /**
   * UrlBox.js
   */

  (function (tinymce) {
    var DOM = tinymce.DOM, Event = tinymce.dom.Event;

    /**
     * This class is used to create text / input boxes.
     *
     * @class tinymce.ui.TextBox
     * @extends tinymce.ui.Control
     * @example
     */
    tinymce.create('tinymce.ui.UrlBox:tinymce.ui.TextBox', {
      /**
       * Constructs a new textbox control instance.
       *
       * @constructor
       * @method TextBox
       * @param {String} id Control id for the list box.
       * @param {Object} s Optional name/value settings object.
       * @param {Editor} ed Optional the editor instance this button is for.
       */
      UrlBox: function (id, s, ed) {
        s.multiline = false;

        s.onpick = s.onpick || function () { };

        s["class"] = 'mceUrlBox';

        this._super(id, s, ed);
      },

      /**
       * Renders the text box as a HTML string. This method is much faster than using the DOM and when
       * creating a whole toolbar with buttons it does make a lot of difference.
       *
       * @method renderHTML
       * @return {String} HTML for the text control element.
       */
      renderHTML: function () {
        var html = this._super(),
          s = this.settings;

        if (s.picker) {
          var icon = s.picker_icon || 'file';
          html += '<button type="button" class="mceButton mceButtonPicker" id="' + this.id + '_picker" title="' + DOM.encode(s.picker_label || '') + '"><span role="presentation" class="mceIcon mce_' + icon + '"></span></button>';
        }

        if (s.upload) {
          var accept = tinymce.map(s.upload_accept || [], function (val) {
            if (val.indexOf('/') == -1 && val.charAt(0) != '.') {
              val = '.' + val;
            }

            return val;
          });

          html += '<a class="mceButton mceButtonUpload" role="button" aria-label="' + DOM.encode(s.upload_label || '') + '"><span role="presentation" class="mceIcon mce_upload"></span><span role="presentation" class="mceIcon mce_spinner"></span><input id="' + this.id + '_upload" type="file" aria-hidden="true" title="' + DOM.encode(s.upload_label || '') + '" accept="' + accept.join(',') + '" /></a>';
        }

        return html;
      },

      /**
       * Sets the loading state for the control. This will add an aria-busy property to the
       * element that contains the control and set the disable state.
       *
       * @method setLoading
       * @param {Boolean} state Boolean state if the control should be set loading or not.
       */
      setLoading: function (state) {
        this.setAriaProperty('busy', state);
        this.setDisabled(state);
      },

      /**
       * Sets the disabled state for the control. This will add CSS classes to the
       * element that contains the control. So that it can be disabled visually.
       *
       * @method setDisabled
       * @param {Boolean} state Boolean state if the control should be disabled or not.
       */
      setDisabled: function (state) {
        this._super(state);
        DOM.get(this.id + '_upload').disabled = state;
      },

      /**
       * Post render event. This will be executed after the control has been rendered and can be used to
       * set states, add events to the control etc. It's recommended for subclasses of the control to call this method by using this._super().
       *
       * @method postRender
       */
      postRender: function () {
        var self = this, s = this.settings;

        this._super();

        if (s.picker) {
          DOM.addClass(this.id, 'mceUrlBoxPicker');

          Event.add(this.id + '_picker', 'click', function (e) {          
            
            e.preventDefault();
            s.onpick.call(self);
          });
        }

        if (s.upload) {
          DOM.addClass(this.id, 'mceUrlBoxUpload');

          Event.add(this.id + '_upload', 'change', function (e) {
            if (this.files && this.files.length) {
              s.upload.call(self, e, this.files[0]);
            }

            e.preventDefault();
          });

          DOM.bind(this.id, 'drag dragstart dragend dragover dragenter dragleave', function (e) {
            e.preventDefault();
          });

          DOM.bind(this.id, 'dragover dragenter', function () {
            DOM.addClass(this.id, 'mceUrlBoxUploadHover');
          });

          DOM.bind(this.id, 'dragleave', function () {
            DOM.removeClass(this.id, 'mceUrlBoxUploadHover');
          });

          DOM.bind(this.id, 'drop', function (e) {
            var dataTransfer = e.dataTransfer;

            // Add dropped files
            if (dataTransfer && dataTransfer.files && dataTransfer.files.length) {
              var file = dataTransfer.files[0];

              if (file) {
                s.upload.call(self, e, file);
              }
            }

            e.preventDefault();
          });
        }
      }
    });
  })(tinymce);

  /**
   * TextBox.js
   */

  (function (tinymce) {
    var DOM = tinymce.DOM,
      Event = tinymce.dom.Event,
      each = tinymce.each,
      Dispatcher = tinymce.util.Dispatcher;

    /**
  	 * This class is used to create text / input boxes.
  	 *
  	 * @class tinymce.ui.TextBox
  	 * @extends tinymce.ui.Control
  	 * @example
  	 */
    tinymce.create('tinymce.ui.CheckBox:tinymce.ui.Control', {
      /**
  		 * Constructs a new textbox control instance.
  		 *
  		 * @constructor
  		 * @method TextBox
  		 * @param {String} id Control id for the list box.
  		 * @param {Object} s Optional name/value settings object.
  		 * @param {Editor} ed Optional the editor instance this button is for.
  		 */
      CheckBox: function (id, s, ed) {

        this._super(id, s, ed);

        if (typeof s.value === 'undefined') {
          s.value = '';
        }

        /**
  			 * Fires when the selection has been changed.
  			 *
  			 * @event onChange
  			 */
        this.onChange = new Dispatcher(this);

        /**
  			 * Fires after the element has been rendered to DOM.
  			 *
  			 * @event onPostRender
  			 */
        this.onPostRender = new Dispatcher(this);

        this.classPrefix = 'mceCheckBox';
      },

      value: function (val) {
        var elm = DOM.get(this.id);

        if (!arguments.length) {
          if (elm.checked) {
            return elm.value || 1;
          }

          return '';
        }

        elm.value = val;
      },

      /**
  		 * Sets / gets the input value.
  		 *
  		 * @method select
  		 * @param {String/function} val Value to set for the textbox.
  		 */
      checked: function (state) {
        var elm = DOM.get(this.id);

        if (!arguments.length) {
          return elm.checked;
        }

        if (this.isDisabled()) {
          return;
        }

        this.setState('checked', !!state);
        elm.checked = !!state;
      },

      /**
  		 * Renders the text box as a HTML string. This method is much faster than using the DOM and when
  		 * creating a whole toolbar with buttons it does make a lot of difference.
  		 *
  		 * @method renderHTML
  		 * @return {String} HTML for the text control element.
  		 */
      renderHTML: function () {
        var html = '',
          prefix = this.classPrefix, s = this.settings;

        html += '<input type="checkbox" id="' + this.id + '" value="' + s.value + '" class="' + prefix + ' ' + s['class'] + '" title="' + DOM.encode(s.title) + '"';

        if (s.attributes) {
          each(s.attributes, function (val, key) {
            html += ' ' + key + '="' + val + '"';
          });
        }

        html += ' />';

        return html;
      },

      /**
  		 * Post render event. This will be executed after the control has been rendered and can be used to
  		 * set states, add events to the control etc. It's recommended for subclasses of the control to call this method by using this._super().
  		 *
  		 * @method postRender
  		 */
      postRender: function () {
        var self = this, s = this.settings;

        if (s.onchange && typeof s.onchange === 'function') {
          this.onChange.add(s.onchange);
        }

        Event.add(this.id, 'click', function () {
          self.checked(self.checked());
        });

        Event.add(this.id, 'change', function () {
          self.onChange.dispatch(this, DOM.get(self.id));
        });

        this.onPostRender.dispatch(this, DOM.get(this.id));
      },

      /**
  		 * Sets the disabled state for the control. This will add CSS classes to the
  		 * element that contains the control. So that it can be disabled visually.
  		 *
  		 * @method setDisabled
  		 * @param {Boolean} state Boolean state if the control should be disabled or not.
  		 */
      setDisabled: function (state) {
        this._super(state);
        DOM.get(this.id).disabled = state;
      },

      /**
  		 * Destroys the TextBox i.e. clear memory and events.
  		 *
  		 * @method destroy
  		 */
      destroy: function () {
        this._super();

        Event.clear(this.id);
      }
    });
  })(tinymce);

  /**
   * MenuButton.js
   *
   * Copyright, Moxiecode Systems AB
   * Released under LGPL License.
   *
   * License: http://www.tinymce.com/license - Inactive
   * Licence: GNU/LGPL 2.1 or later - http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
   * Contributing: http://www.tinymce.com/contributing - Inactive
   */

  (function (tinymce) {
    var DOM = tinymce.DOM,
      Event = tinymce.dom.Event;

    /**
     * This class is used to create a UI button. A button is basically a link
     * that is styled to look like a button or icon.
     *
     * @class tinymce.ui.MenuButton
     * @extends tinymce.ui.Control
     * @example
     * // Creates a new plugin class and a custom menu button
     * tinymce.create('tinymce.plugins.ExamplePlugin', {
     *     createControl: function(n, cm) {
     *         switch (n) {
     *             case 'mymenubutton':
     *                 var c = cm.createSplitButton('mysplitbutton', {
     *                     title : 'My menu button',
     *                     image : 'some.gif'
     *                 });
     *
     *                 c.onRenderMenu.add(function(c, m) {
     *                     m.add({title : 'Some title', 'class' : 'mceMenuItemTitle'}).setDisabled(1);
     *
     *                     m.add({title : 'Some item 1', onclick : function() {
     *                         alert('Some item 1 was clicked.');
     *                     }});
     *
     *                     m.add({title : 'Some item 2', onclick : function() {
     *                         alert('Some item 2 was clicked.');
     *                     }});
     *               });
     *
     *               // Return the new menubutton instance
     *               return c;
     *         }
     *
     *         return null;
     *     }
     * });
     */
    tinymce.create('tinymce.ui.MenuButton:tinymce.ui.Button', {
      /**
       * Constructs a new split button control instance.
       *
       * @constructor
       * @method MenuButton
       * @param {String} id Control id for the split button.
       * @param {Object} s Optional name/value settings object.
       * @param {Editor} ed Optional the editor instance this button is for.
       */
      MenuButton: function (id, s, ed) {
        this._super(id, s, ed);

        /**
         * Fires when the menu is rendered.
         *
         * @event onRenderMenu
         */
        this.onRenderMenu = new tinymce.util.Dispatcher(this);

        s.menu_container = s.menu_container || DOM.doc.body;
      },

      /**
       * Shows the menu.
       *
       * @method showMenu
       */
      showMenu: function () {
        var self = this,
          pos, e = DOM.get(self.id),
          m;

        if (self.isDisabled()) {
          return;
        }

        if (!self.isMenuRendered) {
          self.renderMenu();
          self.isMenuRendered = true;
        }

        if (self.isMenuVisible) {
          return self.hideMenu();
        }

        pos = DOM.getPos(e);

        m = self.menu;
        m.settings.offset_x = pos.x;
        m.settings.offset_y = pos.y;
        m.settings.vp_offset_x = pos.x;
        m.settings.vp_offset_y = pos.y;
        m.settings.keyboard_focus = self._focused;
        m.showMenu(0, e.firstChild.clientHeight);

        Event.add(DOM.doc, 'mousedown', self.hideMenu, self);
        self.setState('Selected', 1);

        self.isMenuVisible = 1;

        self.setAriaProperty('expanded', true);
      },

      /**
       * Renders the menu to the DOM.
       *
       * @method renderMenu
       */
      renderMenu: function () {
        var self = this,
          m;

        m = self.settings.control_manager.createDropMenu(self.id + '_menu', {
          class: this.classPrefix + 'Menu',
          icons: self.settings.icons,
          max_width: this.settings.max_width,
          max_height: this.settings.max_height,
          keyboard_focus: true,
          onselect: this.settings.onselect,
          title: this.settings.title
        });

        m.onHideMenu.add(function () {
          self.hideMenu();
          self.focus();
        });

        self.onRenderMenu.dispatch(self, m);
        self.menu = m;
      },

      /**
       * Hides the menu. The optional event parameter is used to check where the event occurred so it
       * doesn'self close them menu if it was a event inside the menu.
       *
       * @method hideMenu
       * @param {Event} e Optional event object.
       */
      hideMenu: function (e) {
        var self = this;

        // Prevent double toogles by canceling the mouse click event to the button
        if (e && e.type == "mousedown" && DOM.getParent(e.target, function (e) {
          return e.id === self.id || e.id === self.id + '_open';
        })) {
          return;
        }

        if (!e || !DOM.getParent(e.target, '.mceMenu')) {
          self.setState('Selected', 0);
          Event.remove(DOM.doc, 'mousedown', self.hideMenu, self);
          if (self.menu) {
            self.menu.hideMenu();
          }
        }

        self.isMenuVisible = 0;
        self.setAriaProperty('expanded', false);
      },

      /**
       * Post render handler. This function will be called after the UI has been
       * rendered so that events can be added.
       *
       * @method postRender
       */
      postRender: function () {
        var self = this,
          s = self.settings;

        this._super();

        Event.add(self.id, 'click', function (evt) {
          if (!self.isDisabled()) {
            if (s.onclick) {
              s.onclick(evt, self.value);
            }

            self.showMenu();
          }
        });
      }
    });
  })(tinymce);

  /**
   * SplitButton.js
   *
   * Copyright, Moxiecode Systems AB
   * Released under LGPL License.
   *
   * License: http://www.tinymce.com/license - Inactive
   * Licence: GNU/LGPL 2.1 or later - http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
   * Contributing: http://www.tinymce.com/contributing - Inactive
   */

  (function (tinymce) {
    var DOM = tinymce.DOM,
      Event = tinymce.dom.Event;

    /**
  	 * This class is used to create a split button. A button with a menu attached to it.
  	 *
  	 * @class tinymce.ui.SplitButton
  	 * @extends tinymce.ui.Button
  	 * @example
  	 * // Creates a new plugin class and a custom split button
  	 * tinymce.create('tinymce.plugins.ExamplePlugin', {
  	 *     createControl: function(n, cm) {
  	 *         switch (n) {
  	 *             case 'mysplitbutton':
  	 *                 var c = cm.createSplitButton('mysplitbutton', {
  	 *                     title : 'My split button',
  	 *                     image : 'some.gif',
  	 *                     onclick : function() {
  	 *                         alert('Button was clicked.');
  	 *                     }
  	 *                 });
  	 *
  	 *                 c.onRenderMenu.add(function(c, m) {
  	 *                     m.add({title : 'Some title', 'class' : 'mceMenuItemTitle'}).setDisabled(1);
  	 *
  	 *                     m.add({title : 'Some item 1', onclick : function() {
  	 *                         alert('Some item 1 was clicked.');
  	 *                     }});
  	 *
  	 *                     m.add({title : 'Some item 2', onclick : function() {
  	 *                         alert('Some item 2 was clicked.');
  	 *                     }});
  	 *                 });
  	 *
  	 *               // Return the new splitbutton instance
  	 *               return c;
  	 *         }
  	 *
  	 *         return null;
  	 *     }
  	 * });
  	 */
    tinymce.create('tinymce.ui.SplitButton:tinymce.ui.MenuButton', {
      /**
  		 * Constructs a new split button control instance.
  		 *
  		 * @constructor
  		 * @method SplitButton
  		 * @param {String} id Control id for the split button.
  		 * @param {Object} s Optional name/value settings object.
  		 * @param {Editor} ed Optional the editor instance this button is for.
  		 */
      SplitButton: function (id, s, ed) {
        this._super(id, s, ed);
        this.classPrefix = 'mceSplitButton';
      },

      /**
  		 * Renders the split button as a HTML string. This method is much faster than using the DOM and when
  		 * creating a whole toolbar with buttons it does make a lot of difference.
  		 *
  		 * @method renderHTML
  		 * @return {String} HTML for the split button control element.
  		 */
      renderHTML: function () {
        var html = '',
          self = this,
          s = self.settings,
          icon;

        if (s.image) {
          icon = DOM.createHTML('img ', {
            src: s.image,
            role: 'presentation',
            'class': 'mceAction ' + s['class']
          });
        } else {
          icon = DOM.createHTML('span', {
            'class': 'mceAction ' + s['class'],
            role: 'presentation'
          });
        }

        html += DOM.createHTML('button', {
          type: 'button',
          id: self.id + '_action',
          tabindex: '-1',
          'class': 'mceText ' + s['class'],
          title: s.title
        }, icon);

        html += DOM.createHTML('button', {
          type: 'button',
          id: self.id + '_open',
          tabindex: '-1',
          'class': 'mceOpen ' + s['class'],
          title: s.title
        });

        return DOM.createHTML('div', {
          id: self.id,
          role: 'button',
          tabindex: 0,
          'class': 'mceSplitButton ' + s['class'],
          title: s.title,
          'aria-label': s.title,
          'aria-haspopup': 'true',
          'aria-expanded': false
        }, html);
      },

      /**
  		 * Post render handler. This function will be called after the UI has been
  		 * rendered so that events can be added.
  		 *
  		 * @method postRender
  		 */
      postRender: function () {
        var self = this,
          s = self.settings,
          activate;

        if (s.onclick) {
          activate = function (evt) {
            if (!self.isDisabled()) {
              s.onclick(evt, self.value);
              Event.cancel(evt);

              self.hideMenu();
            }
          };

          Event.add(self.id + '_action', 'click', activate);

          Event.add(self.id, ['click', 'keydown'], function (evt) {
            var DOM_VK_DOWN = 40;

            if ((evt.keyCode === 32 || evt.keyCode === 13 || evt.keyCode === 14) && !evt.altKey && !evt.ctrlKey && !evt.metaKey) {
              activate(evt);
              Event.cancel(evt);
            } else if (evt.type === 'click' || evt.keyCode === DOM_VK_DOWN) {
              self.showMenu();
              Event.cancel(evt);
            }
          });
        } else {
          Event.add(self.id + '_action', 'click', function (evt) {
            self.showMenu();
            Event.cancel(evt);
          });
        }

        Event.add(self.id + '_open', 'click', function (evt) {
          self.showMenu();
          Event.cancel(evt);
        });

        Event.add([self.id, self.id + '_open'], 'focus', function () {
          self._focused = 1;
        });

        Event.add([self.id, self.id + '_open'], 'blur', function () {
          self._focused = 0;
        });

        this.rendered = true;
      },

      destroy: function () {
        this._super();

        Event.clear(this.id + '_action');
        Event.clear(this.id + '_open');
        Event.clear(this.id);
      }
    });
  })(tinymce);

  /**
   * ColorSplitButton.js
   *
   * Copyright, Moxiecode Systems AB
   * Released under LGPL License.
   *
   * License: http://www.tinymce.com/license - Inactive
   * Licence: GNU/LGPL 2.1 or later - http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
   * Contributing: http://www.tinymce.com/contributing - Inactive
   */

  (function (tinymce) {
    var DOM = tinymce.DOM,
      Event = tinymce.dom.Event,
      is = tinymce.is,
      each = tinymce.each;

    /**
  	 * This class is used to create UI color split button. A color split button will present show a small color picker
  	 * when you press the open menu.
  	 *
  	 * @class tinymce.ui.ColorSplitButton
  	 * @extends tinymce.ui.SplitButton
  	 */
    tinymce.create('tinymce.ui.ColorSplitButton:tinymce.ui.SplitButton', {
      /**
  		 * Constructs a new color split button control instance.
  		 *
  		 * @constructor
  		 * @method ColorSplitButton
  		 * @param {String} id Control id for the color split button.
  		 * @param {Object} s Optional name/value settings object.
  		 * @param {Editor} editor The editor instance this button is for.
  		 */
      ColorSplitButton: function (id, settings, editor) {
        this._super(id, settings, editor);

        /**
  			 * Settings object.
  			 *
  			 * @property settings
  			 * @type Object
  			 */
        this.settings = tinymce.extend({
          colors: '000000,993300,333300,003300,003366,000080,333399,333333,800000,FF6600,808000,008000,008080,0000FF,666699,808080,FF0000,FF9900,99CC00,339966,33CCCC,3366FF,800080,999999,FF00FF,FFCC00,FFFF00,00FF00,00FFFF,00CCFF,993366,FFFFFF,FF99CC,FFCC99,FFFF99,CCFFCC,CCFFFF,99CCFF,CC99FF',
          grid_width: 8,
          default_color: '#888888'
        }, settings || {});

        /**
  			 * Fires when the menu is shown.
  			 *
  			 * @event onShowMenu
  			 */
        this.onShowMenu = new tinymce.util.Dispatcher(this);

        /**
  			 * Fires when the menu is hidden.
  			 *
  			 * @event onHideMenu
  			 */
        this.onHideMenu = new tinymce.util.Dispatcher(this);

        /**
  			 * Current color value.
  			 *
  			 * @property value
  			 * @type String
  			 */
        this.value = settings.default_color;
      },

      /**
  		 * Shows the color menu. The color menu is a layer places under the button
  		 * and displays a table of colors for the user to pick from.
  		 *
  		 * @method showMenu
  		 */
      showMenu: function () {
        var self = this,
          elm, pos;

        if (this.isDisabled()) {
          return;
        }

        if (!this.isMenuRendered) {
          this.renderMenu();
          this.isMenuRendered = true;
        }

        if (this.isMenuVisible) {
          return this.hideMenu();
        }

        elm = DOM.get(this.id);

        DOM.show(this.id + '_menu');
        DOM.addClass(elm, 'mceSplitButtonSelected');
        pos = DOM.getPos(elm);

        DOM.setStyles(this.id + '_menu', {
          left: pos.x,
          top: pos.y + elm.firstChild.clientHeight
        });

        elm = 0;

        Event.add(DOM.doc, 'mousedown', this.hideMenu, this);
        this.onShowMenu.dispatch(this);

        if (this._focused) {
          this._keyHandler = Event.add(this.id + '_menu', 'keydown', function (e) {
            if (e.keyCode == 27) {
              this.hideMenu();
            }
          });

          DOM.select('button', this.id + '_menu')[0].focus(); // Select first link
        }

        this.keyboardNav = new tinymce.ui.KeyboardNavigation({
          root: this.id + '_menu',
          items: DOM.select('button', this.id + '_menu'),
          onCancel: function () {
            self.hideMenu();
            self.focus();
          }
        });

        this.keyboardNav.focus();
        this.isMenuVisible = 1;
      },

      /**
  		 * Hides the color menu. The optional event parameter is used to check where the event occurred so it
  		 * doesn't close them menu if it was a event inside the menu.
  		 *
  		 * @method hideMenu
  		 * @param {Event} e Optional event object.
  		 */
      hideMenu: function (e) {
        var self = this;

        if (this.isMenuVisible) {
          // Prevent double toogles by canceling the mouse click event to the button
          if (e && e.type == "mousedown") {
            var parent = DOM.getParent(e.target, function (elm) {
              return elm.id === self.id + '_open';
            });

            if (parent) {
              return;
            }
          }

          if (!e || !DOM.getParent(e.target, '.mceSplitButtonMenu')) {
            DOM.removeClass(this.id, 'mceSplitButtonSelected');
            Event.remove(DOM.doc, 'mousedown', this.hideMenu, this);
            Event.remove(this.id + '_menu', 'keydown', this._keyHandler);
            DOM.hide(this.id + '_menu');
          }

          this.isMenuVisible = 0;
          this.onHideMenu.dispatch();
          this.keyboardNav.destroy();
        }
      },

      /**
  		 * Renders the menu to the DOM.
  		 *
  		 * @method renderMenu
  		 */
      renderMenu: function () {
        var self = this,
          menu,
          settings = this.settings,
          node, list;

        list = DOM.add(settings.menu_container, 'div', {
          role: 'listbox',
          id: this.id + '_menu',
          'class': 'mceMenu mceSplitButtonMenu ' + settings.menu_class
        });

        menu = DOM.add(list, 'div', {
          role: 'presentation',
          'class': 'mceColorSplitMenu' + ' ' + settings['class']
        });

        // Generate color grid
        each(is(settings.colors, 'array') ? settings.colors : settings.colors.split(','), function (color) {
          color = color.replace(/^#/, '');

          var val = '#' + color;

          if (color.indexOf('--') == 0) {
            val = 'var(' + color + ')';
          }

          var args = {
            style: {
              backgroundColor: val
            },
            'title': self.editor.getLang('colors.' + color, val),
            'data-mce-color': val,
            'class': 'mceColorButton'
          };

          // adding a proper ARIA role = button causes JAWS to read things incorrectly on IE.
          args.role = 'option';

          node = DOM.add(menu, 'button', args);
        });

        node = DOM.add(menu, 'button', {
          'title': this.editor.getLang('advanced.no_color', 'No Colour'),
          'data-mce-color': '',
          role: 'option',
          'class': 'mceRemoveColor'
        }, '&cross;');

        if (settings.more_colors_func) {

          node = DOM.add(menu, 'button', {
            role: 'option',
            id: this.id + '_more',
            'class': 'mceMoreColors'
          }, settings.more_colors_title);

          Event.add(node, 'click', function (e) {
            settings.more_colors_func.call(settings.more_colors_scope || self);
            self.hideMenu();
            return Event.cancel(e); // Cancel to fix onbeforeunload problem
          });
        }

        DOM.addClass(menu, 'mceColorSplitMenu');

        // Prevent IE from scrolling and hindering click to occur #4019
        Event.add(this.id + '_menu', 'mousedown', function (e) {
          return Event.cancel(e);
        });

        Event.add(this.id + '_menu', 'click', function (e) {
          var elm = DOM.getParent(e.target, 'button', menu);

          var color = elm.getAttribute('data-mce-color');

          if (elm && elm.nodeName.toLowerCase() == 'button' && typeof color !== "undefined") {
            self.setColor(color);
          }

          return false; // Prevent IE auto save warning
        });

        return list;
      },

      /**
  		 * Sets the current color for the control and hides the menu if it should be visible.
  		 *
  		 * @method setColor
  		 * @param {String} color Color code value in hex for example: #FF00FF
  		 */
      setColor: function (color) {
        this.displayColor(color);
        this.hideMenu();
        this.settings.onselect(color);
      },

      /**
  		 * Change the currently selected color for the control.
  		 *
  		 * @method displayColor
  		 * @param {String} c Color code value in hex for example: #FF00FF
  		 */
      displayColor: function (color) {
        DOM.setStyle(this.id + '_preview', 'backgroundColor', color);

        this.value = color;
      },

      /**
  		 * Post render event. This will be executed after the control has been rendered and can be used to
  		 * set states, add events to the control etc. It's recommended for subclasses of the control to call this method by using this._super().
  		 *
  		 * @method postRender
  		 */
      postRender: function () {
        this._super();

        DOM.add(this.id + '_action', 'span', {
          id: this.id + '_preview',
          role: 'presentation',
          'class': 'mceColorPreview'
        });

        DOM.setStyle(this.id + '_preview', 'backgroundColor', this.value);
      },

      /**
  		 * Destroys the control. This means it will be removed from the DOM and any
  		 * events tied to it will also be removed.
  		 *
  		 * @method destroy
  		 */
      destroy: function () {
        this._super();

        Event.clear(this.id + '_menu');
        Event.clear(this.id + '_more');
        DOM.remove(this.id + '_menu');

        if (this.keyboardNav) {
          this.keyboardNav.destroy();
        }
      }
    });
  })(tinymce);

  /**
   * ToolbarGroup.js
   *
   * Copyright, Moxiecode Systems AB
   * Released under LGPL License.
   *
   * License: http://www.tinymce.com/license - Inactive
   * Licence: GNU/LGPL 2.1 or later - http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
   * Contributing: http://www.tinymce.com/contributing - Inactive
   */

  (function (tinymce) {
    // Shorten class names
    var dom = tinymce.DOM,
      each = tinymce.each,
      Event = tinymce.dom.Event;
    /**
  	 * This class is used to group a set of toolbars together and control the keyboard navigation and focus.
  	 *
  	 * @class tinymce.ui.ToolbarGroup
  	 * @extends tinymce.ui.Container
  	 */
    tinymce.create('tinymce.ui.ToolbarGroup:tinymce.ui.Container', {
      /**
  		 * Renders the toolbar group as a HTML string.
  		 *
  		 * @method renderHTML
  		 * @return {String} HTML for the toolbar control.
  		 */
      renderHTML: function () {
        var html = [],
          controls = this.controls,
          each = tinymce.each;

        each(controls, function (toolbar) {
          html.push(toolbar.renderHTML());
        });

        var group = dom.create('div', {
          id: this.id,
          role: 'group',
          class : this.settings["class"] ? (this.classPrefix + this.settings["class"]) : ''
        }, html.join(''));

        return dom.getOuterHTML(group);
      },

      focus: function () {
        dom.get(this.id).focus();
      },

      postRender: function () {
        var editor = this.editor,
          settings = this.settings,
          id = this.id,
          items = [];

        each(this.controls, function (toolbar) {
          each(toolbar.controls, function (control) {
            if (control.id) {
              items.push(control);
            }
          });
        });

        this.keyNav = new tinymce.ui.KeyboardNavigation({
          root: id,
          items: items,
          onCancel: function () {
            //Move focus if webkit so that navigation back will read the item.
            if (tinymce.isWebKit) {
              dom.get(editor.id + "_ifr").focus();
            }
            editor.focus();
          },
          excludeFromTabOrder: !settings.tab_focus_toolbar
        });
      },

      destroy: function () {
        this._super();
        this.keyNav.destroy();
        Event.clear(this.id);
      }
    });
  })(tinymce);

  /**
   * Toolbar.js
   *
   * Copyright, Moxiecode Systems AB
   * Released under LGPL License.
   *
   * License: http://www.tinymce.com/license - Inactive
   * Licence: GNU/LGPL 2.1 or later - http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
   * Contributing: http://www.tinymce.com/contributing - Inactive
   */

  (function (tinymce) {
    // Shorten class names
    var dom = tinymce.DOM;
    /**
  	 * This class is used to create toolbars a toolbar is a container for other controls like buttons etc.
  	 *
  	 * @class tinymce.ui.Toolbar
  	 * @extends tinymce.ui.Container
  	 */
    tinymce.create('tinymce.ui.Toolbar:tinymce.ui.Container', {
      /**
  		 * Renders the toolbar as a HTML string. This method is much faster than using the DOM and when
  		 * creating a whole toolbar with buttons it does make a lot of difference.
  		 *
  		 * @method renderHTML
  		 * @return {String} HTML for the toolbar control.
  		 */
      renderHTML: function () {
        var html = '',
          settings = this.settings,
          i;

        var controls = settings.controls || this.controls;

        for (i = 0; i < controls.length; i++) {
          html += controls[i].renderHTML();
        }

        this.controls = controls;

        return dom.createHTML('div', {
          id: this.id,
          'class': 'mceToolbarRow' + (settings['class'] ? ' ' + settings['class'] : ''),
          role: 'group'
        }, html);
      }
    });
  })(tinymce);

  /**
   * Toolbar.js
   *
   * Copyright, Moxiecode Systems AB
   * Released under LGPL License.
   *
   * License: http://www.tinymce.com/license - Inactive
   * Licence: GNU/LGPL 2.1 or later - http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
   * Contributing: http://www.tinymce.com/contributing - Inactive
   */

  (function (tinymce) {
    // Shorten class names
    var dom = tinymce.DOM;
    /**
  	 * This class is used to create layouts. A layout is a container for other controls like buttons etc.
  	 *
  	 * @class tinymce.ui.Layout
  	 * @extends tinymce.ui.Container
  	 */
    tinymce.create('tinymce.ui.Layout:tinymce.ui.Container', {
      /**
  		 * Renders the toolbar as a HTML string. This method is much faster than using the DOM and when
  		 * creating a whole toolbar with buttons it does make a lot of difference.
  		 *
  		 * @method renderHTML
  		 * @return {String} HTML for the toolbar control.
  		 */
      renderHTML: function () {
        var html = '',
          settings = this.settings,
          i;

        var controls = settings.controls || this.controls;

        for (i = 0; i < controls.length; i++) {
          html += controls[i].renderHTML();
        }

        this.controls = controls;

        return dom.createHTML('div', {
          id: this.id,
          'class': 'mceFlexLayout ' + (settings['class'] ? ' ' + settings['class'] : ''),
          role: 'group'
        }, html);
      },

      postRender: function () {
        var i;
    
        this._super();
    
        for (i = 0; i < this.controls.length; i++) {
          this.controls[i].postRender();
        }
      }
    });
  })(tinymce);

  /**
   * @package   	JCE
   * @copyright 	Copyright (c) 2009-2019 Ryan Demmer. All rights reserved.
   * @license   	GNU/GPL 2 or later - http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
   * JCE is free software. This version may have been modified pursuant
   * to the GNU General Public License, and as distributed it includes or
   * is derivative of works licensed under the GNU General Public License or
   * other free or open source software licenses.
   */
  (function (tinymce) {
    var DOM = tinymce.DOM,
      Event = tinymce.dom.Event,
      each = tinymce.each,
      Dispatcher = tinymce.util.Dispatcher;

    tinymce.create('tinymce.ui.Panel:tinymce.ui.Container', {
      /**
           * Constructs a new panel container instance.
           *
           * @constructor
           * @method Panel
           * @param {String} id Control id for the panel.
           * @param {Object} s Optional name/value settings object.
           * @param {Editor} ed Optional the editor instance this button is for.
           */
      Panel: function (id, s, ed) {
        this._super(id, s, ed);

        this.settings = s = tinymce.extend({
          content: '',
          buttons: []
        }, this.settings);

        this.editor = ed;

        this.classPrefix = 'mcePanel';

        /**
               * Fires when the menu is rendered.
               *
               * @event onRenderMenu
               */
        this.onRenderPanel = new Dispatcher(this);
      },
      /**
           * Shows the menu.
           *
           * @method showMenu
           */
      showPanel: function (elm) {
        var self = this,
          s = this.settings,
          pos, x, y, mx, my, w, h, vp, panel;

        this.storeSelection();

        if (!self.isPanelRendered) {
          self.renderPanel();
        }

        if (self.isPanelVisible) {
          return self.hidePanel();
        }

        vp = DOM.getViewPort();

        panel = DOM.get(self.id);

        if (!panel) {
          return;
        }

        DOM.show(panel);

        if (s.url) {
          var iframe = DOM.get(self.id + '_iframe');
          iframe.src = s.url;
        }

        // get position of the target element
        pos = DOM.getPos(elm);

        // Move inside viewport if not submenu
        w = panel.clientWidth;
        h = panel.clientHeight;
        mx = vp.x + vp.w;
        my = vp.y + vp.h;

        if ((x + w) > mx) {
          x = Math.max(0, mx - w);
        }

        if ((y + h) > my) {
          y = Math.max(0, my - h);
        }

        x = pos.x;
        y = pos.y;

        DOM.setStyles(self.id, {
          left: x,
          top: y + elm.clientHeight + 5,
          zIndex: 200000
        });

        self.isPanelVisible = 1;

        Event.add(DOM.doc, 'mousedown', function (e) {
          if (DOM.getParents(e.target, '.mcePanel').length) {
            return;
          }

          self.hidePanel();
        });
      },

      storeSelection: function () {
        // Store bookmark
        if (tinymce.isIE) {
          this.editor.focus();
          this.bookmark = this.editor.selection.getBookmark(1);
        }
      },

      restoreSelection: function () {
        if (this.bookmark) {
          this.editor.selection.moveToBookmark(this.bookmark);
          this.editor.focus();
        }

        this.bookmark = 0;
      },

      /**
           * Renders the menu to the DOM.
           *
           * @method renderMenu
           */
      renderPanel: function () {
        var self = this, s = this.settings, prefix = this.classPrefix;

        var panel = DOM.add(DOM.doc.body, 'div', {
          role: 'presentation',
          id: self.id,
          class: s["class"] || 'defaultSkin',
          style: 'position:absolute;left:0;top:-1000px;'
        });

        panel = DOM.add(panel, 'div', { 'class': prefix });

        var content = DOM.add(panel, 'div', {
          'class': prefix + 'Content'
        });

        if (s.width) {
          DOM.setStyle(panel, 'width', s.width);
        }

        var html = [];

        if (s.html) {
          // html string, eg: '<div></div>';
          if (typeof s.html === 'string') {
            html.push(s.html);
            // html node
          } else {
            html.push(DOM.createHTML(s.html));
          }
        }

        if (s.controls) {
          each(s.controls, function (ctrl) {
            html.push(ctrl.renderHTML());

            ctrl.postRender();

            setTimeout(function () {
              if (ctrl.controls) {
                each(ctrl.controls, function (c) {
                  c.postRender();
                });
              }
            }, 0);
          });
        }

        DOM.setHTML(content, html.join(''));

        if (s.url) {
          DOM.add(content, 'iframe', {
            'id': self.id + '_iframe',
            'src': s.url,
            style: {
              'border': 0,
              'width': '100%',
              'height': '100%'
            },
            onload: function () {
              self.isPanelRendered = true;
              self.onRenderPanel.dispatch(self);
            }
          });
        }

        if (s.buttons.length) {
          var footer = DOM.add(panel, 'div', {
            'class': prefix + 'Footer'
          });

          each(s.buttons, function (o) {
            var btn = DOM.add(footer, 'button', {
              'type': 'button',
              'class': 'mceButton',
              'id': self.id + '_button_' + o.id
            }, o.title || '');

            if (o.classes) {
              DOM.addClass(btn, o.classes);
            }

            if (o.onclick) {
              Event.add(btn, 'click', function (e) {
                e.preventDefault();

                self.restoreSelection();

                var s = o.onclick.call(o.scope || self, e);

                if (s) {
                  self.hidePanel();
                }
              });
            }
          });
        }

        var navItems = tinymce.grep(DOM.select('input, select, button, textarea', panel), function (elm) {
          return elm.getAttribute('tabindex') >= 0 && elm.className.indexOf('Disabled') === -1;
        });

        if (navItems.length) {
          Event.add(panel, 'keydown', function (e) {
            if (e.keyCode === 9) {
              if (e.target === navItems[navItems.length - 1]) {
                e.preventDefault();
                navItems[0].focus();
              }
            }
          });
        }

        Event.add(panel, 'keyup', function (e) {
          if (e.keyCode === 13) {
            if (self.settings.onsubmit) {
              e.preventDefault();
              self.settings.onsubmit();
            }
          }
        });

        if (!s.url) {
          self.isPanelRendered = true;
          self.onRenderPanel.dispatch(self);
        }

        return panel;
      },

      /**
           * Hides the menu. The optional event parameter is used to check where the event occured so it
           * doesn't close them menu if it was a event inside the menu.
           *
           * @method hideMenu
           * @param {Event} e Optional event object.
           */
      hidePanel: function () {
        var self = this;

        DOM.hide(self.id);
        self.isPanelVisible = 0;
      },

      setButtonDisabled: function (button, state) {
        var id = this.id + '_button_' + button;

        if (state) {
          DOM.addClass(id, 'disabled');
        } else {
          DOM.removeClass(id, 'disabled');
        }
      },

      setButtonLabel: function (button, label) {
        DOM.setHTML(this.id + '_button_' + button, label);
      },

      destroy: function () {
        this._super();

        Event.clear(this.id);
        DOM.remove(this.id);
      }
    });
  })(tinymce);

  /**
   * @package   	JCE
   * @copyright 	Copyright (c) 2009-2019 Ryan Demmer. All rights reserved.
   * @license   	GNU/GPL 2 or later - http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
   * JCE is free software. This version may have been modified pursuant
   * to the GNU General Public License, and as distributed it includes or
   * is derivative of works licensed under the GNU General Public License or
   * other free or open source software licenses.
   */
  (function () {
    var DOM = tinymce.DOM,
      Event = tinymce.dom.Event,
      Delay = tinymce.util.Delay;

    tinymce.create('tinymce.ui.ContextPanel:tinymce.ui.Panel', {
      /**
           * Constructs a new panel container instance.
           *
           * @constructor
           * @method Panel
           * @param {String} id Control id for the panel.
           * @param {Object} s Optional name/value settings object.
           * @param {Editor} ed Optional the editor instance this button is for.
           */
      ContextPanel: function (id, s, ed) {
        this._super(id, s, ed);

        this.settings = s = tinymce.extend({
          content: '',
          buttons: []
        }, this.settings);

        this.editor = ed;
      },

      renderPanel: function () {
        var self = this;

        this._super();

        DOM.addClass(DOM.select('.mcePanel', DOM.get(this.id)), 'mceContextPanel');

        var scrollFunc = Delay.debounce(function () {
          if (self.isPanelVisible) {
            self.positionPanel();
          }
        }, 60);

        self.scrollFunc = Event.add(this.editor.getWin(), 'scroll', scrollFunc);

        this.editor.onHide.add(function () {
          self.hidePanel();
        });
      },

      /**
           * Shows the panel.
           *
           * @method showPanel
           */
      showPanel: function (elm) {
        this._super(elm);

        this.target = elm;

        this.positionPanel();
      },

      positionPanel: function () {
        var self = this, x, y, pos, w;

        var panel = DOM.get(self.id);

        if (!panel) {
          return;
        }

        var elm = this.target;

        // get editor container position
        var offset = DOM.getRect(this.editor.getContentAreaContainer());

        DOM.removeClass(panel, 'mceArrowDown');

        // get position of the target element
        pos = DOM.getPos(elm);

        if (pos.y < 0) {
          self.hidePanel();
          return;
        }

        var win = this.editor.getWin();

        var sy = win.scrollY;
        var wh = sy + win.innerHeight;

        if (pos.y > wh - elm.clientHeight) {
          self.hidePanel();
          return;
        }

        DOM.show(panel);
        self.isPanelVisible = 1;

        x = pos.x + offset.x + elm.clientWidth / 2;
        y = pos.y + offset.y;

        w = panel.clientWidth;

        // position to center of target
        x = x - w / 2;

        // add height of target and arrow
        y = y + elm.clientHeight + 10;

        if (y > offset.y + offset.h) {
          y -= (elm.clientHeight + panel.clientHeight + 10);

          DOM.addClass(panel, 'mceArrowDown');
        }

        DOM.setStyles(self.id, {
          left: x,
          top: y,
          zIndex: 200000
        });
      },

      destroy: function () {
        Event.remove(this.editor.getWin(), 'scroll', self.scrollFunc);
        this._super();
      }
    });
  })();

  /**
   * @package   	JCE
   * @copyright 	Copyright (c) 2009-2019 Ryan Demmer. All rights reserved.
   * @license   	GNU/GPL 2 or later - http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
   * JCE is free software. This version may have been modified pursuant
   * to the GNU General Public License, and as distributed it includes or
   * is derivative of works licensed under the GNU General Public License or
   * other free or open source software licenses.
   */
  (function (tinymce) {
    var DOM = tinymce.DOM,
      Event = tinymce.dom.Event,
      Dispatcher = tinymce.util.Dispatcher;

    tinymce.create('tinymce.ui.PanelButton:tinymce.ui.Button', {
      /**
           * Constructs a new split button control instance.
           *
           * @constructor
           * @method MenuButton
           * @param {String} id Control id for the split button.
           * @param {Object} s Optional name/value settings object.
           * @param {Editor} ed Optional the editor instance this button is for.
           */
      PanelButton: function (id, s, ed) {
        this._super(id, s, ed);

        this.settings = s = tinymce.extend({
        }, this.settings);

        this.editor = ed;
        this.classPrefix = 'mcePanelButton';

        this.onShowPanel = new Dispatcher(this);
        this.onHidePanel = new Dispatcher(this);
        this.onRenderPanel = new Dispatcher(this);
      },

      showPanel: function () {
        var self = this;

        if (self.isDisabled()) {
          return;
        }

        // get the target
        var elm = DOM.get(this.id);
        // show at target
        self.panel.showPanel(elm);

        self.onShowPanel.dispatch(self);

        self.setState('Selected', 1);
        self.setAriaProperty('expanded', true);
      },

      /**
           * Hides the menu. The optional event parameter is used to check where the event occured so it
           * doesn't close them menu if it was a event inside the menu.
           *
           * @method hideMenu
           * @param {Event} e Optional event object.
           */
      hidePanel: function (e) {
        var self = this;

        if (!self.panel) {
          return;
        }

        // Prevent double toogles by canceling the mouse click event to the button
        if (e && e.type == "mousedown" && DOM.getParent(e.target, function (e) {
          return e.id === self.id || e.id === self.id + '_open';
        })) {
          return;
        }

        if (!e || !DOM.getParent(e.target, '.mcePanel')) {
          self.setState('Selected', 0);
          Event.remove(DOM.doc, 'mousedown', self.hidePanel, self);

          self.panel.hidePanel();
          self.onHidePanel.dispatch(self);

          self.setAriaProperty('expanded', false);
        }
      },

      /**
           * Post render handler. This function will be called after the UI has been
           * rendered so that events can be added.
           *
           * @method postRender
           */
      postRender: function () {
        var self = this,
          s = self.settings;

        DOM.addClass(self.id, 'mceButton');

        Event.add(self.id, 'click', function (evt) {
          if (!self.isDisabled()) {

            if (s.onclick) {
              s.onclick(self.value);
            }

            self.showPanel();
          }

          Event.cancel(evt);
        });

        Event.add(self.id, 'focus', function () {
          self._focused = 1;
        });

        Event.add(self.id, 'blur', function () {
          self._focused = 0;
        });

        if (!self.panel) {
          self.panel = self.editor.controlManager.createPanel(self.id + '_panel', self.settings);
          self.editor.onMouseDown.add(self.hidePanel, self);
        }

        self.panel.onRenderPanel.add(function () {
          self.onRenderPanel.dispatch(self);
        });

        self.setAriaProperty('expanded', false);
      },

      restoreSelection: function () {
        if (self.panel) {
          self.panel.restoreSelection();
        }
      },

      destroy: function () {
        this._super();

        Event.clear(this.id + '_panel');
        DOM.remove(this.id + '_panel');
      }
    });
  })(tinymce);

  /**
   * @package   	JCE
   * @copyright 	Copyright (c) 2009-2019 Ryan Demmer. All rights reserved.
   * @license   	GNU/GPL 2 or later - http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
   * JCE is free software. This version may have been modified pursuant
   * to the GNU General Public License, and as distributed it includes or
   * is derivative of works licensed under the GNU General Public License or
   * other free or open source software licenses.
   */
  (function (tinymce) {
    var DOM = tinymce.DOM,
      Event = tinymce.dom.Event;

    tinymce.create('tinymce.ui.PanelSplitButton:tinymce.ui.PanelButton', {
      /**
           * Constructs a new split button control instance.
           *
           * @constructor
           * @method MenuButton
           * @param {String} id Control id for the split button.
           * @param {Object} s Optional name/value settings object.
           * @param {Editor} ed Optional the editor instance this button is for.
           */
      PanelSplitButton: function (id, s, ed) {
        this._super(id, s, ed);
      },

      /**
  		 * Renders the split button as a HTML string. This method is much faster than using the DOM and when
  		 * creating a whole toolbar with buttons it does make a lot of difference.
  		 *
  		 * @method renderHTML
  		 * @return {String} HTML for the split button control element.
  		 */
      renderHTML: function () {
        var html = '',
          self = this,
          s = self.settings, icon;

        if (s.image) {
          icon = DOM.createHTML('img ', {
            src: s.image,
            role: 'presentation',
            'class': 'mceAction ' + s['class']
          });
        } else {
          icon = DOM.createHTML('span', {
            'class': 'mceAction ' + s['class'],
            role: 'presentation'
          });
        }

        html += DOM.createHTML('button', {
          id: self.id + '_action',
          tabindex: '-1',
          'class': 'mceText ' + s['class'],
          title: s.title
        }, icon);

        html += DOM.createHTML('button', {
          id: self.id + '_open',
          tabindex: '-1',
          'class': 'mceOpen ' + s['class'],
          title: s.title
        });

        return DOM.createHTML('div', {
          id: self.id,
          role: 'button',
          tabindex: 0,
          'class': 'mceSplitButton ' + s['class'],
          title: s.title,
          'aria-label': s.title,
          'aria-haspopup': 'true'
        }, html);
      },

      /**
           * Post render handler. This function will be called after the UI has been
           * rendered so that events can be added.
           *
           * @method postRender
           */
      postRender: function () {
        var self = this,
          s = self.settings;

        var activate = function (evt) {
          if (!self.isDisabled()) {
            s.onclick(self.value);
            Event.cancel(evt);
          }
        };

        Event.add(self.id + '_action', 'click', activate);

        Event.add(self.id, ['click', 'keydown'], function (evt) {
          var DOM_VK_DOWN = 40;

          if ((evt.keyCode === 32 || evt.keyCode === 13 || evt.keyCode === 14) && !evt.altKey && !evt.ctrlKey && !evt.metaKey) {
            activate();
            Event.cancel(evt);
          } else if (evt.type === 'click' || evt.keyCode === DOM_VK_DOWN) {
            self.showPanel();
            Event.cancel(evt);
          }
        });

        Event.add(self.id + '_open', 'click', function (evt) {
          self.showPanel();
          Event.cancel(evt);
        });

        Event.add([self.id, self.id + '_open'], 'focus', function () {
          self._focused = 1;
        });

        Event.add([self.id, self.id + '_open'], 'blur', function () {
          self._focused = 0;
        });

        if (!self.panel) {
          self.panel = new tinymce.ui.Panel(self.id + '_panel', self.settings, self.editor);
        }

        self.panel.onRenderPanel.add(function () {
          self.onRenderPanel.dispatch(self);
          DOM.addClass(self.id + '_panel', 'mcePanelSplitButton');
        });
      }
    });
  })(tinymce);

  /**
   * @package   	JCE
   * @copyright 	Copyright (c) 2009-2019 Ryan Demmer. All rights reserved.
   * @license   	GNU/GPL 2 or later - http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
   * JCE is free software. This version may have been modified pursuant
   * to the GNU General Public License, and as distributed it includes or
   * is derivative of works licensed under the GNU General Public License or
   * other free or open source software licenses.
   */
  (function (tinymce) {
    var Dispatcher = tinymce.util.Dispatcher;

    tinymce.create('tinymce.ui.ButtonDialog:tinymce.ui.PanelButton', {
      /**
           * Constructs a new split button control instance.
           *
           * @constructor
           * @method MenuButton
           * @param {String} id Control id for the split button.
           * @param {Object} s Optional name/value settings object.
           * @param {Editor} ed Optional the editor instance this button is for.
           */
      ButtonDialog: function (id, s, ed) {
        if (s.content) {
          s.html = s.content;
        }

        if (s.buttons) {
          tinymce.each(s.buttons, function (btn) {
            btn.onclick = btn.click || function () { };
          });
        }

        this.onShowDialog = new Dispatcher(this);
        this.onHideDialog = new Dispatcher(this);

        this._super(id, s, ed);
      },

      showDialog: function () {
        this.showPanel();
        this.onShowDialog.dispatch(this);
      },

      /**
           * Hides the menu. The optional event parameter is used to check where the event occured so it
           * doesn't close them menu if it was a event inside the menu.
           *
           * @method hideMenu
           * @param {Event} e Optional event object.
           */
      hideDialog: function (e) {
        this.hidePanel(e);
        this.onHideDialog.dispatch(this);
      }
    });
  })(tinymce);

  /**
   * Form.js
   *
   * Copyright, Moxiecode Systems AB
   * Released under LGPL License.
   *
   * License: http://www.tinymce.com/license - Inactive
   * Licence: GNU/LGPL 2.1 or later - http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
   * Contributing: http://www.tinymce.com/contributing - Inactive
   */
  (function (tinymce) {
    // Shorten class names
    var DOM = tinymce.DOM, count = 0;
    /**
     * This class is used to create layouts. A layout is a container for other controls like buttons etc.
     *
     * @class tinymce.ui.Repeatable
     * @extends tinymce.ui.Container
     */
    tinymce.create('tinymce.ui.RepeatableItem:tinymce.ui.Container', {

      RepeatableItem: function (id, settings) {            
        this._super(id, settings);

        // add integer increment
        var id = settings.controls[0].id + '_' + (count++);

        delete this.lookup[id];

        this.controls[0].id = id;
      },

      /**
         * Renders the toolbar as a HTML string. This method is much faster than using the DOM and when
         * creating a whole toolbar with buttons it does make a lot of difference.
         *
         * @method renderHTML
         * @return {String} HTML for the toolbar control.
         */
      renderHTML: function () {
        var html = '';

        html += this.controls[0].renderHTML();
        html += '<button class="mceButton"><span role="presentation" class="mceIcon mce_plus"></span><span role="presentation" class="mceIcon mce_trash"></span></button>';

        return DOM.createHTML('div', {
          id: this.id,
          class: 'mceRepeatableItem mceForm mceFormRow'
        }, html);
      },

      value: function (value) {
        if (arguments.length) {

          if (Array.isArray(value)) {
            value = value.shift();
          }

          this.controls[0].value(value);

          return this;
        }

        return this.controls[0].value();
      }
    });
  })(tinymce);

  /**
   * Form.js
   *
   * Copyright, Moxiecode Systems AB
   * Released under LGPL License.
   *
   * License: http://www.tinymce.com/license - Inactive
   * Licence: GNU/LGPL 2.1 or later - http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
   * Contributing: http://www.tinymce.com/contributing - Inactive
   */
  (function (tinymce) {
    // Shorten class names
    var dom = tinymce.DOM, each = tinymce.each, count = 0;
    /**
     * This class is used to create layouts. A layout is a container for other controls like buttons etc.
     *
     * @class tinymce.ui.Repeatable
     * @extends tinymce.ui.Container
     */
    tinymce.create('tinymce.ui.Repeatable:tinymce.ui.Container', {
      /**
         * Renders the toolbar as a HTML string. This method is much faster than using the DOM and when
         * creating a whole toolbar with buttons it does make a lot of difference.
         *
         * @method renderHTML
         * @return {String} HTML for the toolbar control.
         */
      renderHTML: function () {
        var settings = this.settings, i, html = '', controls = this.controls;

        for (i = 0; i < controls.length; i++) {
          html += controls[i].renderHTML();
        }

        return dom.createHTML('div', {
          id: this.id,
          'class': 'mceForm mceRepeatable' + (settings['class'] ? ' ' + settings['class'] : ''),
          role: 'group'
        }, html);
      },

      value: function (values) {
        var self = this, i, controls = this.controls;

        if (arguments.length) {
          // update all items with values
          for (i = 0; i < controls.length; i++) {
            controls[i].value(values.shift());
          }

          // for each set of remaining values, create a repeatable item
          each(values, function (val) {
            self.addItem(val);
          });

          return this;
        }

        var values = [];

        for (i = 0; i < this.controls.length; i++) {
          var value = this.controls[i].value();

          if (value) {
            values = values.concat(value);
          }
        }

        return values;
      },

      getItemControl: function () {
        var settings = this.settings;

        var item = settings.item || { type : 'TextBox', settings : {} }, cls = tinymce.ui[item.type || 'TextBox'];

        return new cls(this.id + '_item_' + item.id, item.settings || {}, this.editor);
      },

      addItem: function (value) {
        var self = this;

        var item = this.getItemControl();

        var ctrl = new tinymce.ui.RepeatableItem(self.id + '_item_' + (count++), {
          controls: [item]
        });

        self.add(ctrl);
        ctrl.renderTo(dom.get(self.id));

        if (value) {
          ctrl.value(value);
        }

        return ctrl;
      },

      postRender: function () {
        var self = this, elm = dom.get(this.id);

        dom.bind(elm, 'click', function (e) {
          e.preventDefault();

          var btn = dom.getParent(e.target, 'button');

          if (!btn) {
            return;
          }

          var ctrlElm = btn.parentNode, index = dom.nodeIndex(ctrlElm);

          if (index == 0) {
            self.addItem();
          } else {
            self.get(ctrlElm.id).remove();
          }
        });

        this.addItem();
      },

      destroy: function () {
        this._super();
        this.controls = [];
      }
    });
  })(tinymce);

  /**
   * CustomValue.js
   */

  (function (tinymce) {
    var each = tinymce.each;

    /**
     * This class is used to create text / input boxes.
     *
     * @class tinymce.ui.CustomValue
     * @extends tinymce.ui.Control
     * @example
     */
    tinymce.create('tinymce.ui.CustomValue:tinymce.ui.Form', {
      /**
       * Constructs a new textbox control instance.
       *
       * @constructor
       * @method TextBox
       * @param {String} id Control id for the list box.
       * @param {Object} s Optional name/value settings object.
       * @param {Editor} ed Optional the editor instance this button is for.
       */
      CustomValue: function (id, settings, ed) {
        settings = tinymce.extend(settings, {
          class: 'mceFormRow'
        });

        this._super(id, settings, ed);

        var name = new tinymce.ui.TextBox(this.id + '_name', {
          name: 'name',
          label: ed.getLang('label_name', 'Name'),
          attributes: {
            autocomplete: false
          }
        });

        var value = new tinymce.ui.TextBox(this.id + '_value', {
          name: 'value',
          label: ed.getLang('label_value', 'Value'),
          attributes: {
            autocomplete: false
          }
        });

        if (settings.values && settings.values.length) {
          name = new tinymce.ui.ListBox(this.id + '_name', {
            name: 'name',
            label: ed.getLang('label_name', 'Name'),
            combobox: true
          });

          each(settings.values, function (val) {
            name.add(val, val);
          });
        }

        this.add(name);
        this.add(value);
      },

      renderHTML: function () {
        var self = this;
        
        for (var i = 0; i < this.controls.length; i++) {
          var ctrl = this.controls[i];
          ctrl.id = self.id + '_' + ctrl.name;
        }

        return this._super();
      },

      value: function (values) {
        if (arguments.length) {

          if (typeof values != "object") {
            return this;
          }

          for (var key in values) {
            this.controls[0].value(key);
            this.controls[1].value(values[key]);
          }

          return this;
        }

        var key = this.controls[0].value();

        if (key) {
          var data = {};

          data[key] = this.controls[1].value();

          return data;
        }

        return '';
      }
    });
  })(tinymce);

  /**
   * AddOnManager.js
   *
   * Copyright, Moxiecode Systems AB
   * Released under LGPL License.
   *
   * License: http://www.tinymce.com/license - Inactive
   * Licence: GNU/LGPL 2.1 or later - http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
   * Contributing: http://www.tinymce.com/contributing - Inactive
   */

  (function (tinymce) {
    var Dispatcher = tinymce.util.Dispatcher;

    tinymce.AddOnManager = function () {
      var self = this;

      self.items = [];
      self.urls = {};
      self.lookup = {};
      self.onAdd = new Dispatcher(self);
    };

    /**
  	 * This class handles the loading of themes/plugins or other add-ons and their language packs.
  	 *
  	 * @class tinymce.AddOnManager
  	 */
    tinymce.AddOnManager.prototype = {
      /**
  		 * Fires when a item is added.
  		 *
  		 * @event onAdd
  		 */

      /**
  		 * Returns the specified add on by the short name.
  		 *
  		 * @method get
  		 * @param {String} n Add-on to look for.
  		 * @return {tinymce.Theme/tinymce.Plugin} Theme or plugin add-on instance or undefined.
  		 */
      get: function (n) {
        if (this.lookup[n]) {
          return this.lookup[n].instance;
        } else {
          return undefined;
        }
      },

      dependencies: function (n) {
        var result;
        if (this.lookup[n]) {
          result = this.lookup[n].dependencies;
        }
        return result || [];
      },

      /**
  		 * Loads a language pack for the specified add-on.
  		 *
  		 * @method requireLangPack
  		 * @param {String} n Short name of the add-on.
  		 */
      requireLangPack: function (n) {
        /*var s = tinymce.settings;

        if (s && s.language && s.language_load !== false) {
          tinymce.ScriptLoader.add(this.urls[n] + '/langs/' + s.language + '.js');
        }*/
      },

      /**
  		 * Adds a instance of the add-on by it's short name.
  		 *
  		 * @method add
  		 * @param {String} id Short name/id for the add-on.
  		 * @param {tinymce.Theme/tinymce.Plugin} o Theme or plugin to add.
  		 * @return {tinymce.Theme/tinymce.Plugin} The same theme or plugin instance that got passed in.
  		 * @example
  		 * // Create a simple plugin
  		 * tinymce.create('tinymce.plugins.TestPlugin', {
  		 *     TestPlugin : function(ed, url) {
  		 *         ed.onClick.add(function(ed, e) {
  		 *             ed.windowManager.alert('Hello World!');
  		 *         });
  		 *     }
  		 * });
  		 *
  		 * // Register plugin using the add method
  		 * tinymce.PluginManager.add('test', tinymce.plugins.TestPlugin);
  		 *
  		 * // Initialize TinyMCE
  		 * tinymce.init({
  		 *    ...
  		 *    plugins : '-test' // Init the plugin but don't try to load it
  		 * });
  		 */
      add: function (id, o, dependencies) {
        this.items.push(o);
        this.lookup[id] = {
          instance: o,
          dependencies: dependencies
        };

        this.onAdd.dispatch(this, id, o);

        return o;
      },
      createUrl: function (baseUrl, dep) {
        if (typeof dep === "object") {
          return dep;
        } else {
          return {
            prefix: baseUrl.prefix,
            resource: dep,
            suffix: baseUrl.suffix
          };
        }
      },

      /**
  		 * Add a set of components that will make up the add-on. Using the url of the add-on name as the base url.
  		 * This should be used in development mode.  A new compressor/javascript munger process will ensure that the
  		 * components are put together into the editor_plugin.js file and compressed correctly.
  		 * @param pluginName {String} name of the plugin to load scripts from (will be used to get the base url for the plugins).
  		 * @param scripts {Array} Array containing the names of the scripts to load.
  		 */
      addComponents: function (pluginName, scripts) {
        var pluginUrl = this.urls[pluginName];

        tinymce.each(scripts, function (script) {
          tinymce.ScriptLoader.add(pluginUrl + "/" + script);
        });
      },

      /**
  		 * Loads an add-on from a specific url.
  		 *
  		 * @method load
  		 * @param {String} n Short name of the add-on that gets loaded.
  		 * @param {String} u URL to the add-on that will get loaded.
  		 * @param {function} cb Optional callback to execute ones the add-on is loaded.
  		 * @param {Object} s Optional scope to execute the callback in.
  		 * @example
  		 * // Loads a plugin from an external URL
  		 * tinymce.PluginManager.load('myplugin', '/some/dir/someplugin/editor_plugin.js');
  		 *
  		 * // Initialize TinyMCE
  		 * tinymce.init({
  		 *    ...
  		 *    plugins : '-myplugin' // Don't try to load it again
  		 * });
  		 */
      load: function (n, u, cb, s) {
        var self = this,
          url = u;

        function loadDependencies() {
          var dependencies = self.dependencies(n);
          tinymce.each(dependencies, function (dep) {
            var newUrl = self.createUrl(u, dep);
            self.load(newUrl.resource, newUrl, undefined, undefined);
          });

          if (cb) {
            if (s) {
              cb.call(s);
            } else {
              cb.call(tinymce.ScriptLoader);
            }
          }
        }

        if (self.urls[n]) {
          return;
        }

        if (typeof u === "object") {
          url = u.prefix + u.resource + u.suffix;
        }

        if (url.indexOf('/') !== 0 && url.indexOf('://') == -1) {
          url = tinymce.baseURL + '/' + url;
        }

        self.urls[n] = url.substring(0, url.lastIndexOf('/'));

        if (self.lookup[n]) {
          loadDependencies();
        } else {
          tinymce.ScriptLoader.add(url, loadDependencies, s);
        }
      }
    };

    // Create plugin and theme managers
    tinymce.PluginManager = new tinymce.AddOnManager();
    tinymce.ThemeManager = new tinymce.AddOnManager();

  })(tinymce);

  /**
   * TinyMCE theme class.
   *
   * @class tinymce.Theme
   */

  /**
   * Initializes the theme.
   *
   * @method init
   * @param {tinymce.Editor} editor Editor instance that created the theme instance.
   * @param {String} url Absolute URL where the theme is located.
   */

  /**
   * Meta info method, this method gets executed when TinyMCE wants to present information about the theme for example in the about/help dialog.
   *
   * @method getInfo
   * @return {Object} Returns an object with meta information about the theme the current items are longname, author, authorurl, infourl and version.
   */

  /**
   * This method is responsible for rendering/generating the overall user interface with toolbars, buttons, iframe containers etc.
   *
   * @method renderUI
   * @param {Object} obj Object parameter containing the targetNode DOM node that will be replaced visually with an editor instance.
   * @return {Object} an object with items like iframeContainer, editorContainer, sizeContainer, deltaWidth, deltaHeight.
   */

  /**
   * Plugin base class, this is a pseudo class that describes how a plugin is to be created for TinyMCE. The methods below are all optional.
   *
   * @class tinymce.Plugin
   * @example
   * // Create a new plugin class
   * tinymce.create('tinymce.plugins.ExamplePlugin', {
   *     init : function(ed, url) {
   *         // Register an example button
   *         ed.addButton('example', {
   *             title : 'example.desc',
   *             onclick : function() {
   *                  // Display an alert when the user clicks the button
   *                  ed.windowManager.alert('Hello world!');
   *             },
   *             'class' : 'bold' // Use the bold icon from the theme
   *         });
   *     }
   * });
   *
   * // Register plugin with a short name
   * tinymce.PluginManager.add('example', tinymce.plugins.ExamplePlugin);
   *
   * // Initialize TinyMCE with the new plugin and button
   * tinymce.init({
   *    ...
   *    plugins : '-example', // - means TinyMCE will not try to load it
   *    theme_advanced_buttons1 : 'example' // Add the new example button to the toolbar
   * });
   */

  /**
   * Initialization function for the plugin. This will be called when the plugin is created.
   *
   * @method init
   * @param {tinymce.Editor} editor Editor instance that created the plugin instance.
   * @param {String} url Absolute URL where the plugin is located.
   * @example
   * // Creates a new plugin class
   * tinymce.create('tinymce.plugins.ExamplePlugin', {
   *     init : function(ed, url) {
   *         // Register the command so that it can be invoked by using tinymce.activeEditor.execCommand('mceExample');
   *         ed.addCommand('mceExample', function() {
   *             ed.windowManager.open({
   *                 file : url + '/dialog.htm',
   *                 width : 320 + ed.getLang('example.delta_width', 0),
   *                 height : 120 + ed.getLang('example.delta_height', 0),
   *                 inline : 1
   *             }, {
   *                 plugin_url : url, // Plugin absolute URL
   *                 some_custom_arg : 'custom arg' // Custom argument
   *             });
   *         });
   *
   *         // Register example button
   *         ed.addButton('example', {
   *             title : 'example.desc',
   *             cmd : 'mceExample',
   *             image : url + '/img/example.gif'
   *         });
   *
   *         // Add a node change handler, selects the button in the UI when a image is selected
   *         ed.onNodeChange.add(function(ed, cm, n) {
   *             cm.setActive('example', n.nodeName == 'IMG');
   *         });
   *     }
   * });
   *
   * // Register plugin
   * tinymce.PluginManager.add('example', tinymce.plugins.ExamplePlugin);
   */

  /**
   * Meta info method, this method gets executed when TinyMCE wants to present information about the plugin for example in the about/help dialog.
   *
   * @method getInfo
   * @return {Object} Returns an object with meta information about the plugin the current items are longname, author, authorurl, infourl and version.
   * @example
   * // Creates a new plugin class
   * tinymce.create('tinymce.plugins.ExamplePlugin', {
   *     // Meta info method
   *     getInfo : function() {
   *         return {
   *             longname : 'Example plugin',
   *             author : 'Some author',
   *             authorurl : 'http://www.tinymce.com',
   *             infourl : 'http://wiki.moxiecode.com/index.php/TinyMCE:Plugins/example',
   *             version : "1.0"
   *         };
   *     }
   * });
   *
   * // Register plugin
   * tinymce.PluginManager.add('example', tinymce.plugins.ExamplePlugin);
   *
   * // Initialize TinyMCE with the new plugin
   * tinymce.init({
   *    ...
   *    plugins : '-example' // - means TinyMCE will not try to load it
   * });
   */

  /**
   * Gets called when a new control instance is created.
   *
   * @method createControl
   * @param {String} name Control name to create for example "mylistbox"
   * @param {tinymce.ControlManager} controlman Control manager/factory to use to create the control.
   * @return {tinymce.ui.Control} Returns a new control instance or null.
   * @example
   * // Creates a new plugin class
   * tinymce.create('tinymce.plugins.ExamplePlugin', {
   *     createControl: function(n, cm) {
   *         switch (n) {
   *             case 'mylistbox':
   *                 var mlb = cm.createListBox('mylistbox', {
   *                      title : 'My list box',
   *                      onselect : function(v) {
   *                          tinymce.activeEditor.windowManager.alert('Value selected:' + v);
   *                      }
   *                 });
   *
   *                 // Add some values to the list box
   *                 mlb.add('Some item 1', 'val1');
   *                 mlb.add('some item 2', 'val2');
   *                 mlb.add('some item 3', 'val3');
   *
   *                 // Return the new listbox instance
   *                 return mlb;
   *         }
   *
   *         return null;
   *     }
   * });
   *
   * // Register plugin
   * tinymce.PluginManager.add('example', tinymce.plugins.ExamplePlugin);
   *
   * // Initialize TinyMCE with the new plugin and button
   * tinymce.init({
   *    ...
   *    plugins : '-example', // - means TinyMCE will not try to load it
   *    theme_advanced_buttons1 : 'mylistbox' // Add the new mylistbox control to the toolbar
   * });
   */

  /**
   * EditorManager.js
   *
   * Copyright, Moxiecode Systems AB
   * Released under LGPL License.
   *
   * License: http://www.tinymce.com/license - Inactive
   * Licence: GNU/LGPL 2.1 or later - http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
   * Contributing: http://www.tinymce.com/contributing - Inactive
   */

  (function (tinymce) {
    /**
  	 * @class tinymce
  	 */

    // Shorten names
    var each = tinymce.each,
      extend = tinymce.extend,
      DOM = tinymce.DOM,
      Event = tinymce.dom.Event,
      explode = tinymce.explode,
      Dispatcher = tinymce.util.Dispatcher,
      undef, instanceCounter = 0;

    // Setup some URLs where the editor API is located and where the document is
    tinymce.documentBaseURL = window.location.href.replace(/[\?#].*$/, '').replace(/[\/\\][^\/]+$/, '');
    if (!/[\/\\]$/.test(tinymce.documentBaseURL)) {
      tinymce.documentBaseURL += '/';
    }

    tinymce.baseURL = new tinymce.util.URI(tinymce.documentBaseURL).toAbsolute(tinymce.baseURL);

    /**
  	 * Absolute baseURI for the installation path of TinyMCE.
  	 *
  	 * @property baseURI
  	 * @type tinymce.util.URI
  	 */
    tinymce.baseURI = new tinymce.util.URI(tinymce.baseURL);

    // Add before unload listener
    // This was required since IE was leaking memory if you added and removed beforeunload listeners
    // with attachEvent/detatchEvent so this only adds one listener and instances can the attach to the onBeforeUnload event
    tinymce.onBeforeUnload = new Dispatcher(tinymce);

    // Must be on window or IE will leak if the editor is placed in frame or iframe
    Event.add(window, 'beforeunload', function (e) {
      tinymce.onBeforeUnload.dispatch(tinymce, e);
    });

    function removeEditorFromList(targetEditor) {
      var EditorManager = tinymce.EditorManager, editors = EditorManager.editors, oldEditors = editors;

      editors = tinymce.grep(editors, function (editor) {
        return targetEditor !== editor;
      });

      // Select another editor since the active one was removed
      if (EditorManager.activeEditor === targetEditor) {
        EditorManager.activeEditor = editors.length > 0 ? editors[0] : null;
      }

      // Clear focusedEditor if necessary, so that we don't try to blur the destroyed editor
      if (EditorManager.focusedEditor === targetEditor) {
        EditorManager.focusedEditor = null;
      }

      return oldEditors.length !== editors.length;
    }

    function purgeDestroyedEditor(editor) {
      // User has manually destroyed the editor lets clean up the mess
      if (editor && editor.initialized && !(editor.getContainer() || editor.getBody()).parentNode) {
        removeEditorFromList(editor);
        editor.remove();
        editor = null;
      }

      return editor;
    }

    /**
  	 * Fires when a new editor instance is added to the tinymce collection.
  	 *
  	 * @event onAddEditor
  	 * @param {tinymce} sender TinyMCE root class/namespace.
  	 * @param {tinymce.Editor} editor Editor instance.
  	 * @example
  	 * tinymce.execCommand("mceAddControl", false, "some_textarea");
  	 * tinymce.onAddEditor.add(function(mgr,ed) {
  	 *     console.debug('A new editor is available' + ed.id);
  	 * });
  	 */
    tinymce.onAddEditor = new Dispatcher(tinymce);

    /**
  	 * Fires when an editor instance is removed from the tinymce collection.
  	 *
  	 * @event onRemoveEditor
  	 * @param {tinymce} sender TinyMCE root class/namespace.
  	 * @param {tinymce.Editor} editor Editor instance.
  	 */
    tinymce.onRemoveEditor = new Dispatcher(tinymce);

    tinymce.on = function (name, handler) {
      name = name.toLowerCase();

      var wrapped = function (ed, arg) {
        handler({ editor: tinymce.activeEditor });
      };
      
      if (name == 'addeditor') {
        tinymce.onAddEditor.add(wrapped);
      }

      if (name == 'removeeditor') {
        tinymce.onRemoveEditor.add(wrapped);
      }
    };

    tinymce.EditorManager = extend(tinymce, {
      /**
  		 * Collection of editor instances.
  		 *
  		 * @property editors
  		 * @type Object
  		 * @example
  		 * for (edId in tinymce.editors)
  		 *     tinymce.editors[edId].save();
  		 */
      editors: [],

      /**
  		 * Collection of language pack data.
  		 *
  		 * @property i18n
  		 * @type Object
  		 */
      i18n: {},

      /**
  		 * Currently active editor instance.
  		 *
  		 * @property activeEditor
  		 * @type tinymce.Editor
  		 * @example
  		 * tinymce.activeEditor.selection.getContent();
  		 * tinymce.EditorManager.activeEditor.selection.getContent();
  		 */
      activeEditor: null,

      /**
  		 * Initializes a set of editors. This method will create a bunch of editors based in the input.
  		 *
  		 * @method init
  		 * @param {Object} s Settings object to be passed to each editor instance.
  		 * @example
  		 * // Initializes a editor using the longer method
  		 * tinymce.EditorManager.init({
  		 *    some_settings : 'some value'
  		 * });
  		 *
  		 * // Initializes a editor instance using the shorter version
  		 * tinymce.init({
  		 *    some_settings : 'some value'
  		 * });
  		 */
      init: function (settings) {
        /*eslint no-unused-vars:0*/

        var self = this;

        function createId(elm) {
          var id = elm.id;

          // Use element id, or unique name or generate a unique id
          if (!id) {
            id = elm.name;

            if (id && !DOM.get(id)) {
              id = elm.name;
            } else {
              // Generate unique name
              id = DOM.uniqueId();
            }

            elm.setAttribute('id', id);
          }

          return id;
        }

        function execCallback(name) {
          var callback = settings[name];

          if (!callback) {
            return;
          }

          return callback.apply(self, Array.prototype.slice.call(arguments, 2));
        }

        function hasClass(elm, className) {
          return className.constructor === RegExp ? className.test(elm.className) : DOM.hasClass(elm, className);
        }

        function findTargets(settings) {
          var l, targets = [];

          if (settings.types) {
            each(settings.types, function (type) {
              targets = targets.concat(DOM.select(type.selector));
            });

            return targets;
          } else if (settings.selector) {
            return DOM.select(settings.selector);
          } else if (settings.target) {
            return [settings.target];
          }

          // Fallback to old setting
          switch (settings.mode) {
            case "exact":
              l = settings.elements || '';

              if (l.length > 0) {
                each(explode(l), function (id) {
                  var elm;

                  if ((elm = DOM.get(id))) {
                    targets.push(elm);
                  } else {
                    each(document.forms, function (f) {
                      each(f.elements, function (e) {
                        if (e.name === id) {
                          id = 'mce_editor_' + instanceCounter++;
                          DOM.setAttrib(e, 'id', id);
                          targets.push(e);
                        }
                      });
                    });
                  }
                });
              }
              break;

            case "textareas":
            case "specific_textareas":
              each(DOM.select('textarea'), function (elm) {
                if (settings.editor_deselector && hasClass(elm, settings.editor_deselector)) {
                  return;
                }

                if (!settings.editor_selector || hasClass(elm, settings.editor_selector)) {
                  targets.push(elm);
                }
              });
              break;
          }

          return targets;
        }

        function initEditors() {
          var initCount = 0,
            editors = [],
            targets;

          function createEditor(id, settings, targetElm) {
            var editor = new tinymce.Editor(id, settings, self);

            editors.push(editor);

            editor.onInit.add(function () {
              if (++initCount === targets.length) ;
            });

            editor.targetElm = editor.targetElm || targetElm;
            editor.render();
          }

          DOM.unbind(window, 'ready', initEditors);
          execCallback('onpageload');

          targets = DOM.unique(findTargets(settings));

          each(targets, function (elm) {
            purgeDestroyedEditor(self.get(elm.id));
          });

          targets = tinymce.grep(targets, function (elm) {
            return !self.get(elm.id);
          });

          if (targets.length === 0) ; else {
            each(targets, function (elm) {
              createEditor(createId(elm), settings, elm);
            });
          }
        }

        self.settings = settings;
        DOM.bind(window, 'ready', initEditors);
      },

      /**
  		 * Returns a editor instance by id.
  		 *
  		 * @method get
  		 * @param {String/Number} id Editor instance id or index to return.
  		 * @return {tinymce.Editor} Editor instance to return.
  		 * @example
  		 * // Adds an onclick event to an editor by id (shorter version)
  		 * tinymce.get('mytextbox').onClick.add(function(ed, e) {
  		 *    ed.windowManager.alert('Hello world!');
  		 * });
  		 *
  		 * // Adds an onclick event to an editor by id (longer version)
  		 * tinymce.EditorManager.get('mytextbox').onClick.add(function(ed, e) {
  		 *    ed.windowManager.alert('Hello world!');
  		 * });
  		 */
      get: function (id) {
        if (id === undef) {
          return this.editors;
        }

        // eslint-disable-next-line no-prototype-builtins
        if (!this.editors.hasOwnProperty(id)) {
          return undef;
        }

        return this.editors[id];
      },

      /**
  		 * Returns a editor instance by id. This method was added for compatibility with the 2.x branch.
  		 *
  		 * @method getInstanceById
  		 * @param {String} id Editor instance id to return.
  		 * @return {tinymce.Editor} Editor instance to return.
  		 * @deprecated Use get method instead.
  		 * @see #get
  		 */
      getInstanceById: function (id) {
        return this.get(id);
      },

      /**
  		 * Adds an editor instance to the editor collection. This will also set it as the active editor.
  		 *
  		 * @method add
  		 * @param {tinymce.Editor} editor Editor instance to add to the collection.
  		 * @return {tinymce.Editor} The same instance that got passed in.
  		 */
      add: function (editor) {
        var self = this,
          editors = self.editors;

        // Add named and index editor instance
        editors[editor.id] = editor;
        editors.push(editor);

        self.setActive(editor);
        self.onAddEditor.dispatch(self, editor);

        return editor;
      },

      /**
  		 * Removes a editor instance from the collection.
  		 *
  		 * @method remove
  		 * @param {tinymce.Editor} e Editor instance to remove.
  		 * @return {tinymce.Editor} The editor that got passed in will be return if it was found otherwise null.
  		 */
      remove: function (editor) {
        var i, editors = this.editors;

        // no value given
        if (!editor) {
          return null;
        }

        // Not in the collection
        if (!editors[editor.id]) {
          return null;
        }

        delete editors[editor.id];

        for (i = 0; i < editors.length; i++) {
          if (editors[i] == editor) {
            editors.splice(i, 1);
            break;
          }
        }

        // Select another editor since the active one was removed
        if (this.activeEditor == editor) {
          this.setActive(editors[0]);
        }

        editor.destroy();
        this.onRemoveEditor.dispatch(this, editor);

        return editor;
      },

      /**
  		 * Executes a specific command on the currently active editor.
  		 *
  		 * @method execCommand
  		 * @param {String} c Command to perform for example Bold.
  		 * @param {Boolean} u Optional boolean state if a UI should be presented for the command or not.
  		 * @param {String} v Optional value parameter like for example an URL to a link.
  		 * @return {Boolean} true/false if the command was executed or not.
  		 */
      execCommand: function (c, u, v) {
        var ed = this.get(v),
          win;

        // Manager commands
        switch (c) {
          case "mceFocus":
            ed.focus();
            return true;

          case "mceAddEditor":
          case "mceAddControl":
            if (!this.get(v)) {
              new tinymce.Editor(v, this.settings).render();
            }

            return true;

          case "mceAddFrameControl":
            win = v.window;

            // Add tinyMCE global instance and tinymce namespace to specified window
            win.tinyMCE = tinyMCE;
            win.tinymce = tinymce;

            tinymce.DOM.doc = win.document;
            tinymce.DOM.win = win;

            ed = new tinymce.Editor(v.element_id, v);
            ed.render();

            v.page_window = null;

            return true;

          case "mceRemoveEditor":
          case "mceRemoveControl":
            if (ed) {
              ed.remove();
            }
            return true;

          case 'mceToggleEditor':
            if (!ed) {
              this.execCommand('mceAddControl', 0, v);
              return true;
            }

            if (ed.isHidden()) {
              ed.show();
            } else {
              ed.hide();
            }

            return true;
        }

        // Run command on active editor
        if (this.activeEditor) {
          return this.activeEditor.execCommand(c, u, v);
        }

        return false;
      },

      /**
  		 * Executes a command on a specific editor by id. This method was added for compatibility with the 2.x branch.
  		 *
  		 * @deprecated Use the execCommand method of a editor instance instead.
  		 * @method execInstanceCommand
  		 * @param {String} id Editor id to perform the command on.
  		 * @param {String} c Command to perform for example Bold.
  		 * @param {Boolean} u Optional boolean state if a UI should be presented for the command or not.
  		 * @param {String} v Optional value parameter like for example an URL to a link.
  		 * @return {Boolean} true/false if the command was executed or not.
  		 */
      execInstanceCommand: function (id, c, u, v) {
        var ed = this.get(id);

        if (ed) {
          return ed.execCommand(c, u, v);
        }

        return false;
      },

      /**
  		 * Calls the save method on all editor instances in the collection. This can be useful when a form is to be submitted.
  		 *
  		 * @method triggerSave
  		 * @example
  		 * // Saves all contents
  		 * tinymce.triggerSave();
  		 */
      triggerSave: function () {
        each(this.editors, function (e) {
          e.save();
        });
      },

      /**
  		 * Adds a language pack, this gets called by the loaded language files like en.js.
  		 *
  		 * @method addI18n
  		 * @param {String} p Prefix for the language items. For example en.myplugin
  		 * @param {Object} o Name/Value collection with items to add to the language group.
  		 */
      addI18n: function (p, o) {
        var i18n = this.i18n;

        if (!tinymce.is(p, 'string')) {
          each(p, function (o, lc) {
            each(o, function (o, g) {
              each(o, function (o, k) {
                if (g === 'common') {
                  i18n[lc + '.' + k] = o;
                } else {
                  i18n[lc + '.' + g + '.' + k] = o;
                }
              });
            });
          });
        } else {
          each(o, function (o, k) {
            i18n[p + '.' + k] = o;
          });
        }
      },

      // Private methods

      setActive: function (editor) {
        this.selectedInstance = this.activeEditor = editor;
      }
    });

    tinymce.FocusManager = new tinymce.dom.FocusManager(tinymce.EditorManager);

  })(tinymce);

  /**
   * Alternative name for tinymce added for 2.x compatibility.
   *
   * @member
   * @property tinyMCE
   * @type tinymce
   * @example
   * // To initialize editor instances
   * tinymce.init({
   *    ...
   * });
   */

  /**
   * Alternative name for tinymce added for compatibility.
   *
   * @member tinymce
   * @property EditorManager
   * @type tinymce
   * @example
   * // To initialize editor instances
   * tinymce.EditorManager.get('editor');
   */

  /**
   * NodeChange.js
   *
   * Released under LGPL License.
   * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
   *
   * License: http://www.tinymce.com/license - Inactive
   * Licence: GNU/LGPL 2.1 or later - http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
   * Contributing: http://www.tinymce.com/contributing - Inactive
   */

  /**
   * This class handles the nodechange event dispatching both manual and through selection change events.
   *
   * @class tinymce.NodeChange
   * @private
   */

  (function (tinymce) {
      var lastPath = [];

      var timer;

      function nodeChanged(ed, e) {
          if (timer) {
              clearTimeout(timer);
          }

          // Normalize selection for example <b>a</b><i>|a</i> becomes <b>a|</b><i>a</i> except for Ctrl+A since it selects everything
          if (e.keyCode != 65 || !tinymce.VK.metaKeyPressed(e)) {
              ed.selection.normalize();
          }

          ed.nodeChanged();
      }

      /**
       * Returns true/false if the current element path has been changed or not.
       *
       * @private
       * @return {Boolean} True if the element path is the same false if it's not.
       */
      function isSameElementPath(ed, startElm) {
          var i, currentPath;

          currentPath = ed.dom.getParents(startElm, '*', ed.getBody());
          currentPath.reverse();

          if (currentPath.length === lastPath.length) {
              for (i = currentPath.length; i >= 0; i--) {
                  if (currentPath[i] !== lastPath[i]) {
                      break;
                  }
              }

              if (i === -1) {
                  lastPath = currentPath;
                  return true;
              }
          }

          lastPath = currentPath;

          return false;
      }

      tinymce.NodeChange = function (editor) {

          // Selection change is delayed ~200ms on IE when you click inside the current range
          editor.onSelectionChange.add(function (ed, e) {
              var startElm = ed.selection.getStart(true);

              lastPath = [startElm];

              if (!isSameElementPath(ed, startElm) && ed.dom.isChildOf(startElm, ed.getBody())) {
                  nodeChanged(ed, e);
              }
          });

          /*var keyCodeMap = tinymce.makeMap([8, 13, 33, 34, 35, 36, 37, 38, 39, 40, 45, 46]);
      
          self.onKeyUp.add(function (ed, e) {
              var keyCode = e.keyCode;
      
              if (keyCodeMap[keyCode] || (tinymce.isMac && (keyCode == 91 || keyCode == 93)) || e.ctrlKey) {
                  nodeChanged(ed, e);
              }
          });*/

          // Fire an extra nodeChange on mouseup for compatibility reasons
          editor.onMouseUp.add(function (ed, e) {
              if (!e.isDefaultPrevented()) {
                  // Delay nodeChanged call for WebKit edge case issue where the range
                  // isn't updated until after you click outside a selected image
                  if (ed.selection.getNode().nodeName == 'IMG') {
                      timer = setTimeout(function () {
                          nodeChanged(ed, e);
                      }, 0);
                  } else {
                      nodeChanged(ed, e);
                  }
              }
          });

          /**
           * Dispatches out a onNodeChange event to all observers. This method should be called when you
           * need to update the UI states or element path etc.
           *
           * @method nodeChanged
           * @param {Object} args Optional args to pass to NodeChange event handlers.
           */
          this.nodeChanged = function (args) {
              var selection = editor.selection,
                  node, root, parents;

              // Fix for bug #1896577 it seems that this can not be fired while the editor is loading
              if (editor.initialized && selection && !editor.settings.disable_nodechange && !editor.readonly) {
                  // Get start node
                  root = editor.getBody();
                  node = selection.getStart(true) || root;

                  // Make sure the node is within the editor root or is the editor root
                  if (node.ownerDocument != editor.getDoc() || !editor.dom.isChildOf(node, root)) {
                      node = root;
                  }

                  if (node.nodeType !== 1 || node.getAttribute('data-mce-bogus')) {
                      node = node.parentNode;
                  }

                  // Get parents and add them to object
                  parents = [];

                  editor.dom.getParent(node, function (node) {
                      if (node === root) {
                          return true;
                      }

                      parents.push(node);
                  });

                  args = args || {};
                  args.element = node;
                  args.parents = parents;
                  args.contenteditable = !node.hasAttribute('contenteditable') || tinymce.dom.NodeType.isContentEditableTrue(node);

                  editor.onNodeChange.dispatch(
                      editor,
                      args ? args.controlManager || editor.controlManager : editor.controlManager,
                      node,
                      selection.isCollapsed(),
                      args
                  );
              }
          };
      };
  })(tinymce);

  /**
   * EditorFocus.js
   *
   * Released under LGPL License.
   * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
   *
   * License: http://www.tinymce.com/license - Inactive
   * Licence: GNU/LGPL 2.1 or later - http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
   * Contributing: http://www.tinymce.com/contributing - Inactive
   */


  (function (tinymce) {

    var getContentEditableHost = function (editor, node) {
      return editor.dom.getParent(node, function (node) {
        return editor.dom.getContentEditable(node) === "true";
      });
    };

    var normalizeSelection = function (editor) {
      editor.selection.normalize();
    };

    var focusBody = function (body) {
      if (body.setActive) {
        // IE 11 sometimes throws "Invalid function" then fallback to focus
        // setActive is better since it doesn't scroll to the element being focused
        try {
          body.setActive();
        } catch (ex) {
          body.focus();
        }
      } else {
        body.focus();
      }
    };
    /*eslint no-unused-vars:0*/
    var focusEditor = function (editor) {
      var contentEditableHost, rng; editor.getDoc();
        var body = editor.getBody(),
        contentEditable = editor.settings.content_editable,
        selection = editor.selection;

      // Get selected control element
      rng = selection.getRng();

      if (rng.item) {
        rng.item(0);
      }

      // Move focus to contentEditable=true child if needed
      contentEditableHost = getContentEditableHost(editor, selection.getNode());

      if (editor.dom.contains(body, contentEditableHost)) {
        focusBody(contentEditableHost);
        normalizeSelection(editor);
        activateEditor(editor);
        return;
      }

      // Focus the window iframe
      if (!contentEditable) {
        // WebKit needs this call to fire focusin event properly see #5948
        editor.getWin().focus();
      }

      // Focus the body as well since it's contentEditable
      if (tinymce.isGecko || contentEditable) {
        // Restore previous selection before focus to prevent Chrome from
        // jumping to the top of the document in long inline editors
        if (contentEditable && document.activeElement !== body) {
          editor.selection.setRng(editor.lastRng);
        }

        focusBody(body);
        normalizeSelection(editor);
      }

      // Restore selected control element
      // This is needed when for example an image is selected within a
      // layer a call to focus will then remove the control selection
      // This appears to cause an issue with Chrome etc. with image selection in a contenteditable=false parent
      /*if (controlElm && controlElm.ownerDocument == doc) {
        rng = doc.body.createControlRange();
        rng.addElement(controlElm);
        rng.select();
      }*/
    };

    var activateEditor = function (editor) {
      tinymce.setActive(editor);
    };

    var focus = function (editor, skipFocus) {
      if (editor.removed) {
        return;
      }

      skipFocus ? activateEditor(editor) : focusEditor(editor);
    };

    tinymce.EditorFocus = {
      focus: focus
    };

  })(tinymce);

  /**
   * Editor.js
   *
   * Copyright, Moxiecode Systems AB
   * Released under LGPL License.
   *
   * License: http://www.tinymce.com/license - Inactive
   * Licence: GNU/LGPL 2.1 or later - http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
   * Contributing: http://www.tinymce.com/contributing - Inactive
   */

  (function (tinymce) {
    
    // Shorten these names
    var DOM = tinymce.DOM,
      Event = tinymce.dom.Event,
      extend = tinymce.extend,
      each = tinymce.each,
      isGecko = tinymce.isGecko,
      isIE = tinymce.isIE,
      is = tinymce.is,
      ThemeManager = tinymce.ThemeManager,
      PluginManager = tinymce.PluginManager,
      EditorFocus = tinymce.EditorFocus,
      explode = tinymce.explode,
      Zwsp = tinymce.text.Zwsp,
      TrimBody = tinymce.dom.TrimBody;

    /**
     * This class contains the core logic for a TinyMCE editor.
     *
     * @class tinymce.Editor
     * @example
     * // Add a class to all paragraphs in the editor.
     * tinymce.activeEditor.dom.addClass(tinymce.activeEditor.dom.select('p'), 'someclass');
     *
     * // Gets the current editors selection as text
     * tinymce.activeEditor.selection.getContent({format : 'text'});
     *
     * // Creates a new editor instance
     * var ed = new tinymce.Editor('textareaid', {
     *     some_setting : 1
     * });
     *
     * // Select each item the user clicks on
     * ed.onClick.add(function(ed, e) {
     *     ed.selection.select(e.target);
     * });
     *
     * ed.render();
     */
    tinymce.Editor = function (id, settings) {
      var self = this,
        TRUE = true;

      /**
       * Name/value collection with editor settings.
       *
       * @property settings
       * @type Object
       * @example
       * // Get the value of the theme setting
       * tinymce.activeEditor.windowManager.alert("You are using the " + tinymce.activeEditor.settings.theme + " theme");
       */
      self.settings = settings = extend({
        id: id,
        language: 'en',
        theme: 'advanced',
        skin: 'modern',
        delta_width: 0,
        delta_height: 0,
        popup_css: '',
        plugins: '',
        document_base_url: tinymce.documentBaseURL,
        add_form_submit_trigger: TRUE,
        submit_patch: TRUE,
        add_unload_trigger: TRUE,
        convert_urls: TRUE,
        relative_urls: TRUE,
        remove_script_host: TRUE,
        table_inline_editing: false,
        object_resizing: TRUE,
        accessibility_focus: TRUE,
        doctype: '<!DOCTYPE html>',
        visual: TRUE,
        font_size_style_values: 'xx-small,x-small,small,medium,large,x-large,xx-large',
        font_size_legacy_values: 'xx-small,small,medium,large,x-large,xx-large,300%', // See: http://www.w3.org/TR/CSS2/fonts.html#propdef-font-size
        apply_source_formatting: TRUE,
        directionality: 'ltr',
        forced_root_block: 'p',
        hidden_input: TRUE,
        padd_empty_editor: TRUE,
        render_ui: TRUE,
        indentation: '30px',
        fix_table_elements: TRUE,
        inline_styles: TRUE,
        convert_fonts_to_spans: TRUE,
        indent: 'simple',
        indent_before: 'p,h1,h2,h3,h4,h5,h6,blockquote,div,title,style,pre,script,td,ul,li,area,table,thead,tfoot,tbody,tr,section,article,hgroup,aside,figure,option,optgroup,datalist',
        indent_after: 'p,h1,h2,h3,h4,h5,h6,blockquote,div,title,style,pre,script,td,ul,li,area,table,thead,tfoot,tbody,tr,section,article,hgroup,aside,figure,option,optgroup,datalist',
        validate: TRUE,
        entity_encoding: 'named',
        url_converter: self.convertURL,
        url_converter_scope: self,
        validate_styles: TRUE
      }, settings);

      /**
       * Editor instance id, normally the same as the div/textarea that was replaced.
       *
       * @property id
       * @type String
       */
      self.id = self.editorId = id;

      /**
       * State to force the editor to return false on a isDirty call.
       *
       * @property isNotDirty
       * @type Boolean
       * @example
       * function ajaxSave() {
       *     var ed = tinymce.get('elm1');
       *
       *     // Save contents using some XHR call
       *     alert(ed.getContent());
       *
       *     ed.isNotDirty = 1; // Force not dirty state
       * }
       */
      self.isNotDirty = false;

      /**
       * Name/Value object containting plugin instances.
       *
       * @property plugins
       * @type Object
       * @example
       * // Execute a method inside a plugin directly
       * tinymce.activeEditor.plugins.someplugin.someMethod();
       */
      self.plugins = {};

      /**
       * URI object to document configured for the TinyMCE instance.
       *
       * @property documentBaseURI
       * @type tinymce.util.URI
       * @example
       * // Get relative URL from the location of document_base_url
       * tinymce.activeEditor.documentBaseURI.toRelative('/somedir/somefile.htm');
       *
       * // Get absolute URL from the location of document_base_ur\
       * tinymce.activeEditor.documentBaseURI.toAbsolute('somefile.htm');
       */
      self.documentBaseURI = new tinymce.util.URI(settings.document_base_url || tinymce.documentBaseURL, {
        base_uri: tinymce.baseURI
      });

      /**
       * URI object to current document that holds the TinyMCE editor instance.
       *
       * @property baseURI
       * @type tinymce.util.URI
       * @example
       * // Get relative URL from the location of the API
       * tinymce.activeEditor.baseURI.toRelative('/somedir/somefile.htm');
       *
       * // Get absolute URL from the location of the API
       * tinymce.activeEditor.baseURI.toAbsolute('somefile.htm');
       */
      self.baseURI = tinymce.baseURI;

      /**
       * Array with CSS files to load into the iframe.
       *
       * @property contentCSS
       * @type Array
       */
      self.contentCSS = [];

      /**
       * Array of CSS styles to add to head of document when the editor loads.
       *
       * @property contentStyles
       * @type Array
       */
      self.contentStyles = [];

      // Creates all events like onClick, onSetContent etc see Editor.Events.js for the actual logic
      self.setupEvents();

      // Internal command handler objects
      self.execCommands = {};
      self.queryStateCommands = {};
      self.queryValueCommands = {};

      // Call setup
      self.execCallback('setup', self);
    };

    tinymce.Editor.prototype = {
      /**
       * Renderes the editor/adds it to the page.
       *
       * @method render
       */
      render: function () {
        var self = this,
          s = self.settings,
          id = self.id,
          sl = tinymce.ScriptLoader;

        // Page is not loaded yet, wait for it
        if (!Event.domLoaded) {
          Event.add(window, 'ready', function () {
            self.render();
          });
          return;
        }

        tinymce.settings = s;

        // Element not found, then skip initialization
        if (!self.getElement()) {
          return;
        }

        // Is a iPad/iPhone and not on iOS5, then skip initialization. We need to sniff
        // here since the browser says it has contentEditable support but there is no visible caret.
        if (tinymce.isIDevice && !tinymce.isIOS5) {
          return;
        }

        // Add hidden input for non input elements inside form elements
        if (!/TEXTAREA|INPUT/i.test(self.getElement().nodeName) && s.hidden_input && DOM.getParent(id, 'form')) {
          DOM.insertAfter(DOM.create('input', {
            type: 'hidden',
            name: id
          }), id);
        }

        // Hide target element early to prevent content flashing
        if (!s.content_editable) {
          self.orgVisibility = self.getElement().style.visibility;
          self.getElement().style.visibility = 'hidden';
        }

        /**
         * Window manager reference, use this to open new windows and dialogs.
         *
         * @property windowManager
         * @type tinymce.WindowManager
         * @example
         * // Shows an alert message
         * tinymce.activeEditor.windowManager.alert('Hello world!');
         *
         * // Opens a new dialog with the file.htm file and the size 320x240
         * // It also adds a custom parameter this can be retrieved by using tinyMCEPopup.getWindowArg inside the dialog.
         * tinymce.activeEditor.windowManager.open({
         *    url : 'file.htm',
         *    width : 320,
         *    height : 240
         * }, {
         *    custom_param : 1
         * });
         */
        if (tinymce.WindowManager) {
          self.windowManager = new tinymce.WindowManager(self);
        }

        if (s.encoding == 'xml') {
          self.onGetContent.add(function (ed, o) {
            if (o.save) {
              o.content = DOM.encode(o.content);
            }
          });
        }

        if (s.add_form_submit_trigger) {
          self.onSubmit.addToTop(function () {
            if (self.initialized) {
              self.save();
              self.isNotDirty = 1;
            }
          });
        }

        if (s.add_unload_trigger) {
          self._beforeUnload = tinymce.onBeforeUnload.add(function () {
            if (self.initialized && !self.destroyed && !self.isHidden()) {
              self.save({
                format: 'raw',
                no_events: true
              });
            }
          });
        }

        tinymce.addUnload(self.destroy, self);

        if (s.submit_patch) {
          self.onBeforeRenderUI.add(function () {
            var n = self.getElement().form;

            if (!n) {
              return;
            }

            // Already patched
            if (n._mceOldSubmit) {
              return;
            }

            // Check page uses id="submit" or name="submit" for it's submit button
            if (!n.submit.nodeType && !n.submit.length) {
              self.formElement = n;
              n._mceOldSubmit = n.submit;
              n.submit = function () {
                // Save all instances
                tinymce.triggerSave();
                self.isNotDirty = 1;

                return self.formElement._mceOldSubmit(self.formElement);
              };
            }

            n = null;
          });
        }

        // Load scripts
        function loadScripts() {
          if (s.theme && typeof s.theme != "function" && s.theme.charAt(0) != '-' && !ThemeManager.urls[s.theme]) {
            ThemeManager.load(s.theme, 'themes/' + s.theme + '/theme' + tinymce.suffix + '.js');
          }

          each(explode(s.plugins), function (p) {
            if (p && !PluginManager.urls[p]) {
              if (p.charAt(0) == '-') {
                p = p.substr(1, p.length);
                var dependencies = PluginManager.dependencies(p);
                each(dependencies, function (dep) {
                  var defaultSettings = {
                    prefix: 'plugins/',
                    resource: dep,
                    suffix: '/plugin' + tinymce.suffix + '.js'
                  };
                  dep = PluginManager.createUrl(defaultSettings, dep);
                  PluginManager.load(dep.resource, dep);
                });
              } else {
                PluginManager.load(p, {
                  prefix: 'plugins/',
                  resource: p,
                  suffix: '/plugin' + tinymce.suffix + '.js'
                });
              }
            }
          });

          each(s.external_plugins, function (url, name) {
            if (url) {
              PluginManager.load(name, url);
              s.plugins += ',' + name;
            }
          });

          // Init when que is loaded
          sl.loadQueue(function () {
            if (!self.removed) {
              self.init();
            }
          });
        }

        loadScripts();
      },

      /**
       * Initializes the editor this will be called automatically when
       * all plugins/themes and language packs are loaded by the rendered method.
       * This method will setup the iframe and create the theme and plugin instances.
       *
       * @method init
       */
      init: function () {
        var self = this,
          s = self.settings,
          w, h, mh, e = self.getElement(),
          o, url, bi, bc, re, initializedPlugins = [];

        tinymce.add(self);

        s.aria_label = s.aria_label || DOM.getAttrib(e, 'aria-label', self.getLang('aria.rich_text_area'));

        /**
         * Reference to the theme instance that was used to generate the UI.
         *
         * @property theme
         * @type tinymce.Theme
         * @example
         * // Executes a method on the theme directly
         * tinymce.activeEditor.theme.someMethod();
         */
        if (s.theme) {
          if (typeof s.theme != "function") {
            s.theme = s.theme.replace(/-/, '');
            o = ThemeManager.get(s.theme);
            self.theme = new o();

            if (self.theme.init) {
              self.theme.init(self, ThemeManager.urls[s.theme] || tinymce.documentBaseURL.replace(/\/$/, ''));
            }
          } else {
            self.theme = s.theme;
          }
        }


        function initPlugin(p) {                
          var c = PluginManager.get(p),
            u = PluginManager.urls[p] || tinymce.documentBaseURL.replace(/\/$/, ''),
            po;

          if (c && tinymce.inArray(initializedPlugins, p) === -1) {
            each(PluginManager.dependencies(p), function (dep) {
              initPlugin(dep);
            });

            po = new c(self, u);

            self.plugins[p] = po;

            if (po.init) {
              po.init(self, u);
            }

            initializedPlugins.push(p);
          }
        }

        // Create all plugins
        if (Array.isArray(s.plugins)) {
          s.plugins = s.plugins.join(',');
        }

        each(explode(s.plugins.replace(/\-/g, '')), initPlugin);

        /**
         * Control manager instance for the editor. Will enables you to create new UI elements and change their states etc.
         *
         * @property controlManager
         * @type tinymce.ControlManager
         * @example
         * // Disables the bold button
         * tinymce.activeEditor.controlManager.setDisabled('bold', true);
         */
        self.controlManager = new tinymce.ControlManager(self);

        // Enables users to override the control factory
        self.onBeforeRenderUI.dispatch(self, self.controlManager);

        // Measure box
        if (s.render_ui && self.theme) {
          self.orgDisplay = e.style.display;

          if (typeof s.theme != "function") {
            w = s.width; // || e.style.width || e.offsetWidth;
            h = s.height || e.style.height || e.offsetHeight;

            mh = s.min_height || 100;
            re = /^[0-9\.]+(|px)$/i;

            if (re.test('' + w)) {
              w = Math.max(parseInt(w, 10) + (o.deltaWidth || 0), 100);
            }

            if (re.test('' + h)) {
              h = Math.max(parseInt(h, 10) + (o.deltaHeight || 0), mh);
            }

            // Render UI
            o = self.theme.renderUI({
              targetNode: e,
              width: w,
              height: h,
              deltaWidth: s.delta_width,
              deltaHeight: s.delta_height
            });

            if (w) {
              // Resize editor
              DOM.setStyles(o.sizeContainer || o.editorContainer, {
                width: w
              });
            }

            h = (o.iframeHeight || h) + (typeof (h) == 'number' ? (o.deltaHeight || 0) : '');

            if (h < mh) {
              h = mh;
            }
          } else {
            o = s.theme(self, e);

            // Convert element type to id:s
            if (o.editorContainer.nodeType) {
              o.editorContainer = o.editorContainer.id = o.editorContainer.id || self.id + "_parent";
            }

            // Convert element type to id:s
            if (o.iframeContainer.nodeType) {
              o.iframeContainer = o.iframeContainer.id = o.iframeContainer.id || self.id + "_iframecontainer";
            }

            // Use specified iframe height or the targets offsetHeight
            h = o.iframeHeight || e.offsetHeight;

            // Store away the selection when it's changed to it can be restored later with a editor.focus() call
            if (isIE) {
              self.onInit.add(function (ed) {
                ed.dom.bind(ed.getBody(), 'beforedeactivate keydown keyup', function () {
                  ed.bookmark = ed.selection.getBookmark(1);
                });
              });

              self.onNodeChange.add(function (ed) {
                if (document.activeElement.id == ed.id + "_ifr") {
                  ed.bookmark = ed.selection.getBookmark(1);
                }
              });
            }
          }

          self.editorContainer = o.editorContainer;
        }

        // Load specified content CSS last
        if (s.content_css) {
          each(explode(s.content_css), function (u) {
            self.contentCSS.push(self.documentBaseURI.toAbsolute(u));
          });
        }

        // Load specified content CSS last
        if (s.content_style) {
          self.contentStyles.push(s.content_style);
        }

        // Content editable mode ends here
        if (s.content_editable) {
          e = o = null; // Fix IE leak
          return self.initContentBody();
        }

        // User specified a document.domain value
        if (document.domain && location.hostname != document.domain) {
          tinymce.relaxedDomain = document.domain;
        }

        self.iframeHTML = s.doctype + '<html dir="' + s.directionality + '"><head xmlns="http://www.w3.org/1999/xhtml">';

        // We only need to override paths if we have to
        // IE has a bug where it remove site absolute urls to relative ones if this is specified
        if (s.document_base_url != tinymce.documentBaseURL) {
          self.iframeHTML += '<base href="' + self.documentBaseURI.getURI() + '" />';
        }

        self.iframeHTML += '<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />';

        // Load the CSS by injecting them into the HTML this will reduce "flicker"
        /*for (i = 0; i < self.contentCSS.length; i++) {
          var cssUrl = tinymce._addVer(self.contentCSS[i]);
          self.iframeHTML += '<link type="text/css" data-cfasync="false" rel="stylesheet" href="' + cssUrl + '" />';
        }

        self.contentCSS = [];*/

        bi = s.body_id || 'tinymce';

        if (bi.indexOf('=') != -1) {
          bi = self.getParam('body_id', '', 'hash');
          bi = bi[self.id] || bi;
        }

        bc = s.body_class || '';

        if (bc.indexOf('=') != -1) {
          bc = self.getParam('body_class', '', 'hash');
          bc = bc[self.id] || '';
        }

        self.iframeHTML += '</head><body id="' + bi + '" class="mceContentBody ' + bc + '"><br></body></html>';

        // Domain relaxing enabled, then set document domain
        if (tinymce.relaxedDomain) {
          // We need to write the contents here in IE since multiple writes messes up refresh button and back button
          url = 'javascript:(function(){document.open();document.domain="' + document.domain + '";var ed = window.parent.tinymce.get("' + self.id + '");document.write(ed.iframeHTML);document.close();ed.initContentBody();})()';
        }

        // Create iframe
        var ifr = DOM.add(o.iframeContainer, 'iframe', {
          id: self.id + "_ifr",
          frameBorder: '0',
          allowTransparency: "true",
          title: s.aria_label,
          style: {
            height: h
          }
        });

        ifr.onload = function () {
          ifr.onload = null;
          self.onLoad.dispatch();
        };

        // remove src attribute
        //DOM.setAttrib(ifr, "src", url || '');

        self.contentAreaContainer = o.iframeContainer;

        if (o.editorContainer) {
          DOM.get(o.editorContainer).style.display = self.orgDisplay;
        }

        // Restore visibility on target element
        e.style.visibility = self.orgVisibility;

        DOM.get(self.id).style.display = 'none';
        DOM.setAttrib(self.id, 'aria-hidden', true);

        if (!tinymce.relaxedDomain || !url) {
          self.initContentBody();
        }

        e = o = null; // Cleanup
      },

      /**
       * This method get called by the init method ones the iframe is loaded.
       * It will fill the iframe with contents, setups DOM and selection objects for the iframe.
       * This method should not be called directly.
       *
       * @method initContentBody
       */
      initContentBody: function () {
        var self = this,
          settings = self.settings,
          targetElm = DOM.get(self.id),
          doc = self.getDoc(),
          body, contentCssText;

        // Setup iframe body
        if ((!isIE || !tinymce.relaxedDomain) && !settings.content_editable) {
          doc.open();
          doc.write(self.iframeHTML);
          doc.close();

          if (tinymce.relaxedDomain) {
            doc.domain = tinymce.relaxedDomain;
          }
        }

        if (settings.content_editable) {
          DOM.addClass(targetElm, 'mceContentBody');
          self.contentDocument = doc = settings.content_document || document;
          self.contentWindow = settings.content_window || window;
          self.bodyElement = targetElm;

          // Prevent leak in IE
          settings.content_document = settings.content_window = null;
        }

        // It will not steal focus while setting contentEditable
        body = self.getBody();
        body.disabled = true;

        if (!settings.readonly) {
          body.contentEditable = self.getParam('content_editable_state', true);
        }

        body.disabled = false;

        /**
         * Schema instance, enables you to validate elements and it's children.
         *
         * @property schema
         * @type tinymce.html.Schema
         */
        self.schema = new tinymce.html.Schema(settings);

        /**
         * DOM instance for the editor.
         *
         * @property dom
         * @type tinymce.dom.DOMUtils
         * @example
         * // Adds a class to all paragraphs within the editor
         * tinymce.activeEditor.dom.addClass(tinymce.activeEditor.dom.select('p'), 'someclass');
         */
        self.dom = new tinymce.dom.DOMUtils(doc, {
          keep_values: true,
          url_converter: self.convertURL,
          url_converter_scope: self,
          hex_colors: settings.force_hex_style_colors,
          class_filter: settings.class_filter,
          update_styles: true,
          root_element: settings.content_editable ? self.id : null,
          schema: self.schema
        });

        /**
         * HTML parser will be used when contents is inserted into the editor.
         *
         * @property parser
         * @type tinymce.html.DomParser
         */
        self.parser = new tinymce.html.DomParser(settings, self.schema);

        // Convert src and href into data-mce-src, data-mce-href and data-mce-style
        self.parser.addAttributeFilter('src,href,style', function (nodes, name) {
          var i = nodes.length,
            node, dom = self.dom,
            value, internalName;

          while (i--) {
            node = nodes[i];
            value = node.attr(name);
            internalName = 'data-mce-' + name;

            // Add internal attribute if we need to we don't on a refresh of the document
            if (!node.attributes.map[internalName]) {
              if (name === "style") {

                // validate style value by parsing and serializing
                if (settings.validate_styles) {
                  value = dom.serializeStyle(dom.parseStyle(value), node.name);
                }

                node.attr(internalName, value);
              } else {
                node.attr(internalName, self.convertURL(value, name, node.name));
              }
            }
          }
        });

        // Keep scripts from executing - removed as this is handled by the Code plugin by placeholder conversion
        /*self.parser.addNodeFilter('script', function (nodes) {
          var i = nodes.length,
            node;

          while (i--) {
            node = nodes[i];
            node.attr('type', 'mce-' + (node.attr('type') || 'text/javascript'));
          }
        });*/

        self.parser.addNodeFilter('#cdata', function (nodes) {
          var i = nodes.length,
            node;

          while (i--) {
            node = nodes[i];
            node.type = 8;
            node.name = '#comment';
            node.value = '[CDATA[' + node.value + ']]';
          }
        });

        self.parser.addNodeFilter('p,h1,h2,h3,h4,h5,h6,div', function (nodes) {
          var i = nodes.length,
            node, nonEmptyElements = self.schema.getNonEmptyElements();

          while (i--) {
            node = nodes[i];

            if (node.isEmpty(nonEmptyElements)) {
              node.empty().append(new tinymce.html.Node('br', 1)).shortEnded = true;
            }
          }
        });

        /**
         * DOM serializer for the editor. Will be used when contents is extracted from the editor.
         *
         * @property serializer
         * @type tinymce.dom.Serializer
         * @example
         * // Serializes the first paragraph in the editor into a string
         * tinymce.activeEditor.serializer.serialize(tinymce.activeEditor.dom.select('p')[0]);
         */
        self.serializer = new tinymce.dom.Serializer(settings, self.dom, self.schema);

        /**
         * Selection instance for the editor.
         *
         * @property selection
         * @type tinymce.dom.Selection
         * @example
         * // Sets some contents to the current selection in the editor
         * tinymce.activeEditor.selection.setContent('Some contents');
         *
         * // Gets the current selection
         * alert(tinymce.activeEditor.selection.getContent());
         *
         * // Selects the first paragraph found
         * tinymce.activeEditor.selection.select(tinymce.activeEditor.dom.select('p')[0]);
         */
        self.selection = new tinymce.dom.Selection(self.dom, self.getWin(), self.serializer, self);

        /**
         * Formatter instance.
         *
         * @property formatter
         * @type tinymce.Formatter
         */
        self.formatter = new tinymce.Formatter(self);

        /**
        * Textpattern instance.
        *
        * @property textpattern
        * @type tinymce.Textpattern
        */
        self.textpattern = new tinymce.TextPattern(self);

        /**
         * Undo manager instance, responsible for handling undo levels.
         /
         * @property undoManager
         * @type tinymce.UndoManager
         * @example
         * // Undoes the last modification to the editor
         * tinymce.activeEditor.undoManager.undo();
         */
        self.undoManager = new tinymce.UndoManager(self);

        self.forceBlocks = new tinymce.ForceBlocks(self);
        self.enterKey = new tinymce.EnterKey(self);
        // internal with no external interface
        self._nodeChangeDispatcher = new tinymce.NodeChange(self);
        self.editorCommands = new tinymce.EditorCommands(self);
        // internal with no external interface
        self._selectionOverrides = new tinymce.SelectionOverrides(self);
        // internal with no external interface
        self._clipBoard = new tinymce.Clipboard(self);

        self.onExecCommand.add(function (editor, command) {
          // Don't refresh the select lists until caret move
          if (!/^(FontName|FontSize)$/.test(command)) {
            self.nodeChanged();
          }
        });

        // Pass through
        self.serializer.onPreProcess.add(function (se, o) {
          return self.onPreProcess.dispatch(self, o, se);
        });

        self.serializer.onPostProcess.add(function (se, o) {
          return self.onPostProcess.dispatch(self, o, se);
        });

        self.onPreInit.dispatch(self);

        if (!settings.browser_spellcheck && !settings.gecko_spellcheck) {
          doc.body.spellcheck = false;
        }

        if (!settings.readonly) {
          self.bindNativeEvents();
        }

        self.controlManager.onPostRender.dispatch(self, self.controlManager);
        self.onPostRender.dispatch(self);

        self.quirks = tinymce.util.Quirks(self);

        if (settings.directionality) {
          body.dir = settings.directionality;
        }

        if (settings.nowrap) {
          body.style.whiteSpace = "nowrap";
        }

        if (settings.protect) {
          self.onBeforeSetContent.add(function (ed, o) {
            each(settings.protect, function (pattern) {
              o.content = o.content.replace(pattern, function (str) {
                return '<!--mce:protected ' + escape(str) + '-->';
              });
            });
          });
        }

        // Add visual aids when new contents is added
        self.onSetContent.add(function () {
          self.addVisual(self.getBody());
        });

        // Remove empty contents
        if (settings.padd_empty_editor) {
          self.onPostProcess.add(function (ed, o) {
            o.content = o.content.replace(/^(<p[^>]*>(&nbsp;|&#160;|\s|\u00a0|)<\/p>[\r\n]*|<br \/>[\r\n]*)$/, '');
          });
        }

        self.load({
          initial: true,
          format: 'html'
        });

        self.startContent = self.getContent({
          format: 'raw'
        });

        /**
         * Is set to true after the editor instance has been initialized
         *
         * @property initialized
         * @type Boolean
         * @example
         * function isEditorInitialized(editor) {
         *     return editor && editor.initialized;
         * }
         */
        function initEditor() {
          self.initialized = true;

          self.onInit.dispatch(self);
          self.execCallback('setupcontent_callback', self.id, body, doc);
          self.execCallback('init_instance_callback', self);
          self.focus(true);
          self.nodeChanged({
            initial: true
          });

          // Handle auto focus
          if (settings.auto_focus) {
            setTimeout(function () {

              var focusEditor;

              if (settings.auto_focus === true) {
                focusEditor = self;
              } else {
                focusEditor = tinymce.get(settings.auto_focus);
              }

              if (!focusEditor.destroyed) {
                focusEditor.focus();
              }
            }, 100);
          }
        }

        // Add editor specific CSS styles
        if (self.contentStyles.length > 0) {
          contentCssText = '';

          each(self.contentStyles, function (style) {
            contentCssText += style + "\r\n";
          });

          self.dom.addStyle(contentCssText);
        }

        var styleLoader = new tinymce.dom.StyleSheetLoader(self.getDoc());

        // Load specified content CSS last
        each(self.contentCSS, function (url) {
          styleLoader.add(url);
        });

        styleLoader.loadQueue(function () {
          initEditor();
        });

        // Clean up references for IE
        targetElm = doc = body = null;
      },

      /**
       * Focuses/activates the editor. This will set this editor as the activeEditor in the tinymce collection
       * it will also place DOM focus inside the editor.
       *
       * @method focus
       * @param {Boolean} skip_focus Skip DOM focus. Just set is as the active editor.
       */
      focus: function (skip_focus) {
        EditorFocus.focus(this, skip_focus);
      },

      /**
       * Executes a legacy callback. This method is useful to call old 2.x option callbacks.
       * There new event model is a better way to add callback so this method might be removed in the future.
       *
       * @method execCallback
       * @param {String} n Name of the callback to execute.
       * @return {Object} Return value passed from callback function.
       */
      execCallback: function (n) {
        var self = this,
          f = self.settings[n],
          s;

        if (!f) {
          return;
        }

        // Look through lookup
        if (self.callbackLookup && (s = self.callbackLookup[n])) {
          f = s.func;
          s = s.scope;
        }

        if (is(f, 'string')) {
          s = f.replace(/\.\w+$/, '');
          s = s ? tinymce.resolve(s) : 0;
          f = tinymce.resolve(f);
          self.callbackLookup = self.callbackLookup || {};
          self.callbackLookup[n] = {
            func: f,
            scope: s
          };
        }

        return f.apply(s || self, Array.prototype.slice.call(arguments, 1));
      },

      /**
       * Translates the specified string by replacing variables with language pack items it will also check if there is
       * a key mathcin the input.
       *
       * @method translate
       * @param {String} s String to translate by the language pack data.
       * @return {String} Translated string.
       */
      translate: function (s) {
        var c = this.settings.language || 'en',
          i18n = tinymce.i18n;

        if (!s) {
          return '';
        }

        return i18n[c + '.' + s] || s.replace(/\{\#([^\}]+)\}/g, function (a, b) {
          return i18n[c + '.' + b] || '{#' + b + '}';
        });
      },

      /**
       * Returns a language pack item by name/key.
       *
       * @method getLang
       * @param {String} n Name/key to get from the language pack.
       * @param {String} dv Optional default value to retrive.
       */
      getLang: function (n, dv) {
        return tinymce.i18n[(this.settings.language || 'en') + '.' + n] || (is(dv) ? dv : '{#' + n + '}');
      },

      /**
       * Returns a configuration parameter by name.
       *
       * @method getParam
       * @param {String} n Configruation parameter to retrive.
       * @param {String} dv Optional default value to return.
       * @param {String} ty Optional type parameter.
       * @return {String} Configuration parameter value or default value.
       * @example
       * // Returns a specific config value from the currently active editor
       * var someval = tinymce.activeEditor.getParam('myvalue');
       *
       * // Returns a specific config value from a specific editor instance by id
       * var someval2 = tinymce.get('my_editor').getParam('myvalue');
       */
      getParam: function (n, dv, ty) {
        var tr = tinymce.trim,
          v = is(this.settings[n]) ? this.settings[n] : dv,
          o;

        if (ty === 'hash') {
          o = {};

          if (is(v, 'string')) {
            each(v.indexOf('=') > 0 ? v.split(/[;,](?![^=;,]*(?:[;,]|$))/) : v.split(','), function (v) {
              v = v.split('=');

              if (v.length > 1) {
                o[tr(v[0])] = tr(v[1]);
              } else {
                o[tr(v[0])] = tr(v);
              }
            });
          } else {
            o = v;
          }

          return o;
        }

        return v;
      },

      /**
       * Distpaches out a onNodeChange event to all observers. This method should be called when you
       * need to update the UI states or element path etc.
       *
       * @method nodeChanged
       * @param {Object} args Optional object to pass along for the node changed event.
       */
      nodeChanged: function (args) {
        this._nodeChangeDispatcher.nodeChanged(args);
      },

      /**
       * Adds a button that later gets created by the ControlManager. This is a shorter and easier method
       * of adding buttons without the need to deal with the ControlManager directly. But it's also less
       * powerfull if you need more control use the ControlManagers factory methods instead.
       *
       * @method addButton
       * @param {String} name Button name to add.
       * @param {Object} settings Settings object with title, cmd etc.
       * @example
       * // Adds a custom button to the editor and when a user clicks the button it will open
       * // an alert box with the selected contents as plain text.
       * tinymce.init({
       *    ...
       *
       *    theme_advanced_buttons1 : 'example,..'
       *
       *    setup : function(ed) {
       *       // Register example button
       *       ed.addButton('example', {
       *          title : 'example.desc',
       *          image : '../jscripts/tiny_mce/plugins/example/img/example.gif',
       *          onclick : function() {
       *             ed.windowManager.alert('Hello world!! Selection: ' + ed.selection.getContent({format : 'text'}));
       *          }
       *       });
       *    }
       * });
       */
      addButton: function (name, settings) {
        var self = this;

        self.buttons = self.buttons || {};
        self.buttons[name] = settings;
      },

      /**
       * Adds a custom command to the editor, you can also override existing commands with this method.
       * The command that you add can be executed with execCommand.
       *
       * @method addCommand
       * @param {String} name Command name to add/override.
       * @param {addCommandCallback} callback Function to execute when the command occurs.
       * @param {Object} scope Optional scope to execute the function in.
       * @example
       * // Adds a custom command that later can be executed using execCommand
       * tinymce.init({
       *    ...
       *
       *    setup : function(ed) {
       *       // Register example command
       *       ed.addCommand('mycommand', function(ui, v) {
       *          ed.windowManager.alert('Hello world!! Selection: ' + ed.selection.getContent({format : 'text'}));
       *       });
       *    }
       * });
       */
      addCommand: function (name, callback, scope) {
        /**
         * Callback function that gets called when a command is executed.
         *
         * @callback addCommandCallback
         * @param {Boolean} ui Display UI state true/false.
         * @param {Object} value Optional value for command.
         * @return {Boolean} True/false state if the command was handled or not.
         */
        this.execCommands[name] = {
          func: callback,
          scope: scope || this
        };
      },

      /**
       * Adds a custom query state command to the editor, you can also override existing commands with this method.
       * The command that you add can be executed with queryCommandState function.
       *
       * @method addQueryStateHandler
       * @param {String} name Command name to add/override.
       * @param {addQueryStateHandlerCallback} callback Function to execute when the command state retrival occurs.
       * @param {Object} scope Optional scope to execute the function in.
       */
      addQueryStateHandler: function (name, callback, scope) {
        /**
         * Callback function that gets called when a queryCommandState is executed.
         *
         * @callback addQueryStateHandlerCallback
         * @return {Boolean} True/false state if the command is enabled or not like is it bold.
         */
        this.queryStateCommands[name] = {
          func: callback,
          scope: scope || this
        };
      },

      /**
       * Adds a custom query value command to the editor, you can also override existing commands with this method.
       * The command that you add can be executed with queryCommandValue function.
       *
       * @method addQueryValueHandler
       * @param {String} name Command name to add/override.
       * @param {addQueryValueHandlerCallback} callback Function to execute when the command value retrival occurs.
       * @param {Object} scope Optional scope to execute the function in.
       */
      addQueryValueHandler: function (name, callback, scope) {
        /**
         * Callback function that gets called when a queryCommandValue is executed.
         *
         * @callback addQueryValueHandlerCallback
         * @return {Object} Value of the command or undefined.
         */
        this.queryValueCommands[name] = {
          func: callback,
          scope: scope || this
        };
      },

      /**
       * Returns true/false if the command is supported or not.
       *
       * @method queryCommandSupported
       * @param {String} cmd Command that we check support for.
       * @return {Boolean} true/false if the command is supported or not.
       */
      queryCommandSupported: function (cmd) {
        return this.editorCommands.queryCommandSupported(cmd);
      },

      /**
       * Adds a keyboard shortcut for some command or function.
       *
       * @method addShortcut
       * @param {String} pa Shortcut pattern. Like for example: ctrl+alt+o.
       * @param {String} desc Text description for the command.
       * @param {String/Function} cmd_func Command name string or function to execute when the key is pressed.
       * @param {Object} sc Optional scope to execute the function in.
       * @return {Boolean} true/false state if the shortcut was added or not.
       */
      addShortcut: function (pattern, desc, cmdFunc, scope) {
        var self = this;

        if (self.settings.custom_shortcuts === false) {
          return false;
        }

        self.shortcuts = self.shortcuts || {};

        var keyCodeLookup = {
          "f9": 120,
          "f10": 121,
          "f11": 122
        };

        var modifierNames = tinymce.makeMap('alt,ctrl,shift,meta,access');

        function parseShortcut(pattern) {
          var id, key, shortcut = {};

          // Parse modifiers and keys ctrl+alt+b for example
          each(explode(pattern, '+'), function (value) {
            if (value in modifierNames) {
              shortcut[value] = true;
            } else {
              // Allow numeric keycodes like ctrl+219 for ctrl+[
              if (/^[0-9]{2,}$/.test(value)) {
                shortcut.keyCode = parseInt(value, 10);
              } else {
                shortcut.charCode = value.charCodeAt(0);
                shortcut.keyCode = keyCodeLookup[value] || value.toUpperCase().charCodeAt(0);
              }
            }
          });

          // Generate unique id for modifier combination and set default state for unused modifiers
          id = [shortcut.keyCode];
          for (key in modifierNames) {
            if (shortcut[key]) {
              id.push(key);
            } else {
              shortcut[key] = false;
            }
          }
          shortcut.id = id.join(',');

          // Handle special access modifier differently depending on Mac/Win
          if (shortcut.access) {
            shortcut.alt = true;

            if (tinymce.isMac) {
              shortcut.ctrl = true;
            } else {
              shortcut.shift = true;
            }
          }

          // Handle special meta modifier differently depending on Mac/Win
          if (shortcut.meta) {
            if (tinymce.isMac) {
              shortcut.meta = true;
            } else {
              shortcut.ctrl = true;
              shortcut.meta = false;
            }
          }

          return shortcut;
        }

        function createShortcut(pattern, desc, cmdFunc, scope) {
          var shortcuts;

          shortcuts = tinymce.map(explode(pattern, '>'), parseShortcut);
          shortcuts[shortcuts.length - 1] = extend(shortcuts[shortcuts.length - 1], {
            func: cmdFunc,
            scope: scope || self
          });

          return extend(shortcuts[0], {
            desc: self.translate(desc),
            subpatterns: shortcuts.slice(1)
          });
        }

        /*if (is(cmd_func, 'string')) {
          c = cmd_func;

          cmd_func = function () {
            self.execCommand(c, false, null);
          };
        }

        if (is(cmd_func, 'object')) {
          c = cmd_func;

          cmd_func = function () {
            self.execCommand(c[0], c[1], c[2]);
          };
        }

        each(explode(pa), function (pa) {
          var o = {
            func: cmd_func,
            scope: sc || this,
            desc: self.translate(desc),
            alt: false,
            ctrl: false,
            shift: false
          };

          each(explode(pa, '+'), function (v) {
            switch (v) {
              case 'alt':
              case 'ctrl':
              case 'shift':
                o[v] = true;
                break;

              default:
                o.charCode = v.charCodeAt(0);
                o.keyCode = v.toUpperCase().charCodeAt(0);
            }
          });

          self.shortcuts[(o.ctrl ? 'ctrl' : '') + ',' + (o.alt ? 'alt' : '') + ',' + (o.shift ? 'shift' : '') + ',' + o.keyCode] = o;
        });*/

        var cmd;

        cmd = cmdFunc;

        if (typeof cmdFunc === 'string') {
          cmdFunc = function () {
            self.execCommand(cmd, false, null);
          };
        } else if (tinymce.isArray(cmd)) {
          cmdFunc = function () {
            self.execCommand(cmd[0], cmd[1], cmd[2]);
          };
        }

        each(explode(tinymce.trim(pattern.toLowerCase())), function (pattern) {
          var shortcut = createShortcut(pattern, desc, cmdFunc, scope);
          self.shortcuts[shortcut.id] = shortcut;
        });

        return true;
      },

      /**
       * Executes a command on the current instance. These commands can be TinyMCE internal commands prefixed with "mce" or
       * they can be build in browser commands such as "Bold". A compleate list of browser commands is available on MSDN or Mozilla.org.
       * This function will dispatch the execCommand function on each plugin, theme or the execcommand_callback option if none of these
       * return true it will handle the command as a internal browser command.
       *
       * @method execCommand
       * @param {String} cmd Command name to execute, for example mceLink or Bold.
       * @param {Boolean} ui True/false state if a UI (dialog) should be presented or not.
       * @param {mixed} val Optional command value, this can be anything.
       * @param {Object} a Optional arguments object.
       * @return {Boolean} True/false if the command was executed or not.
       */
      execCommand: function (cmd, ui, val, a) {
        var self = this,
          s = 0,
          o, st;

        if (!/^(mceAddUndoLevel|mceEndUndoLevel|mceBeginUndoLevel|mceRepaint|SelectAll)$/.test(cmd) && (!a || !a.skip_focus)) {
          self.focus();
        }

        a = extend({}, a);
        self.onBeforeExecCommand.dispatch(self, cmd, ui, val, a);

        if (a.terminate) {
          return false;
        }

        // Command callback
        if (self.execCallback('execcommand_callback', self.id, self.selection.getNode(), cmd, ui, val)) {
          self.onExecCommand.dispatch(self, cmd, ui, val, a);
          return true;
        }

        // Registred commands
        o = self.execCommands[cmd];

        if (o) {
          st = o.func.call(o.scope, ui, val);

          // Fall through on true
          if (st !== true) {
            self.onExecCommand.dispatch(self, cmd, ui, val, a);
            return st;
          }
        }

        // Plugin commands
        each(self.plugins, function (p) {
          if (p.execCommand && p.execCommand(cmd, ui, val)) {
            self.onExecCommand.dispatch(self, cmd, ui, val, a);
            s = 1;
            return false;
          }
        });

        if (s) {
          return true;
        }

        // Theme commands
        if (self.theme && self.theme.execCommand && self.theme.execCommand(cmd, ui, val)) {
          self.onExecCommand.dispatch(self, cmd, ui, val, a);
          return true;
        }

        // Editor commands
        if (self.editorCommands.execCommand(cmd, ui, val)) {
          self.onExecCommand.dispatch(self, cmd, ui, val, a);
          return true;
        }

        // Browser commands
        self.getDoc().execCommand(cmd, ui, val);
        self.onExecCommand.dispatch(self, cmd, ui, val, a);
      },

      /**
       * Returns a command specific state, for example if bold is enabled or not.
       *
       * @method queryCommandState
       * @param {string} cmd Command to query state from.
       * @return {Boolean} Command specific state, for example if bold is enabled or not.
       */
      queryCommandState: function (cmd) {
        var self = this,
          o, s;

        // Is hidden then return undefined
        if (self._isHidden()) {
          return;
        }

        // Registred commands
        o = self.queryStateCommands[cmd];

        if (o) {
          s = o.func.call(o.scope);

          // Fall though on true
          if (s !== true) {
            return s;
          }
        }

        // Registred commands
        o = self.editorCommands.queryCommandState(cmd);

        if (o !== -1) {
          return o;
        }

        // Browser commands
        try {
          return this.getDoc().queryCommandState(cmd);
        } catch (ex) {
          // Fails sometimes see bug: 1896577
        }
      },

      /**
       * Returns a command specific value, for example the current font size.
       *
       * @method queryCommandValue
       * @param {string} c Command to query value from.
       * @return {Object} Command specific value, for example the current font size.
       */
      queryCommandValue: function (c) {
        var self = this,
          o, s;

        // Is hidden then return undefined
        if (self._isHidden()) {
          return;
        }

        // Registred commands
        o = self.queryValueCommands[c];

        if (o) {
          s = o.func.call(o.scope);

          // Fall though on true
          if (s !== true) {
            return s;
          }
        }

        // Registred commands
        o = self.editorCommands.queryCommandValue(c);

        if (is(o)) {
          return o;
        }

        // Browser commands
        try {
          return this.getDoc().queryCommandValue(c);
        } catch (ex) {
          // Fails sometimes see bug: 1896577
        }
      },

      /**
       * Shows the editor and hides any textarea/div that the editor is supposed to replace.
       *
       * @method show
       */
      show: function () {
        var self = this;

        DOM.show(self.getContainer());
        DOM.hide(self.id);
        self.load();

        self.onShow.dispatch(self);
      },

      /**
       * Hides the editor and shows any textarea/div that the editor is supposed to replace.
       *
       * @method hide
       */
      hide: function () {
        var self = this,
          doc = self.getDoc();

        // Fixed bug where IE has a blinking cursor left from the editor
        if (isIE && doc) {
          doc.execCommand('SelectAll');
        }

        // We must save before we hide so Safari doesn't crash
        self.save();

        // defer the call to hide to prevent an IE9 crash #4921
        DOM.hide(self.getContainer());
        DOM.setStyle(self.id, 'display', self.orgDisplay);

        self.onHide.dispatch(self);
      },

      /**
       * Returns true/false if the editor is hidden or not.
       *
       * @method isHidden
       * @return {Boolean} True/false if the editor is hidden or not.
       */
      isHidden: function () {
        return !DOM.isHidden(this.id);
      },

      /**
       * Sets the progress state, this will display a throbber/progess for the editor.
       * This is ideal for asycronous operations like an AJAX save call.
       *
       * @method setProgressState
       * @param {Boolean} b Boolean state if the progress should be shown or hidden.
       * @param {Number} ti Optional time to wait before the progress gets shown.
       * @param {Object} o Optional object to pass to the progress observers.
       * @return {Boolean} Same as the input state.
       * @example
       * // Show progress for the active editor
       * tinymce.activeEditor.setProgressState(true);
       *
       * // Hide progress for the active editor
       * tinymce.activeEditor.setProgressState(false);
       *
       * // Show progress after 3 seconds
       * tinymce.activeEditor.setProgressState(true, 3000);
       */
      setProgressState: function (b, ti, o) {
        this.onSetProgressState.dispatch(this, b, ti, o);

        return b;
      },

      /**
       * Loads contents from the textarea or div element that got converted into an editor instance.
       * This method will move the contents from that textarea or div into the editor by using setContent
       * so all events etc that method has will get dispatched as well.
       *
       * @method load
       * @param {Object} o Optional content object, this gets passed around through the whole load process.
       * @return {String} HTML string that got set into the editor.
       */
      load: function (o) {
        var self = this,
          e = self.getElement(),
          h;

        if (e) {
          o = o || {};
          o.load = true;

          // Double encode existing entities in the value
          h = self.setContent(is(e.value) ? e.value : e.innerHTML, o);
          o.element = e;

          if (!o.no_events) {
            self.onLoadContent.dispatch(self, o);
          }

          o.element = e = null;

          return h;
        }
      },

      /**
       * Saves the contents from a editor out to the textarea or div element that got converted into an editor instance.
       * This method will move the HTML contents from the editor into that textarea or div by getContent
       * so all events etc that method has will get dispatched as well.
       *
       * @method save
       * @param {Object} o Optional content object, this gets passed around through the whole save process.
       * @return {String} HTML string that got set into the textarea/div.
       */
      save: function (o) {
        var self = this,
          e = self.getElement(),
          h, f;

        if (!e || !self.initialized) {
          return;
        }

        o = o || {};
        o.save = true;

        o.element = e;
        h = o.content = self.getContent(o);

        if (!o.no_events) {
          self.onSaveContent.dispatch(self, o);
        }

        h = o.content;

        if (!/TEXTAREA|INPUT/i.test(e.nodeName)) {
          e.innerHTML = h;

          // Update hidden form element
          f = DOM.getParent(self.id, 'form');

          if (f) {
            each(f.elements, function (e) {
              if (e.name == self.id) {
                e.value = h;
                return false;
              }
            });
          }
        } else {
          e.value = h;
        }

        o.element = e = null;

        return h;
      },

      /**
       * Sets the specified content to the editor instance, this will cleanup the content before it gets set using
       * the different cleanup rules options.
       *
       * @method setContent
       * @param {String} content Content to set to editor, normally HTML contents but can be other formats as well.
       * @param {Object} args Optional content object, this gets passed around through the whole set process.
       * @return {String} HTML string that got set into the editor.
       * @example
       * // Sets the HTML contents of the activeEditor editor
       * tinymce.activeEditor.setContent('<span>some</span> html');
       *
       * // Sets the raw contents of the activeEditor editor
       * tinymce.activeEditor.setContent('<span>some</span> html', {format : 'raw'});
       *
       * // Sets the content of a specific editor (my_editor in this example)
       * tinymce.get('my_editor').setContent(data);
       *
       * // Sets the bbcode contents of the activeEditor editor if the bbcode plugin was added
       * tinymce.activeEditor.setContent('[b]some[/b] html', {format : 'bbcode'});
       */
      setContent: function (content, args) {
        var self = this,
          body = self.getBody(),
          forcedRootBlockName;

        // Setup args object
        args = args || {};
        args.format = args.format || 'html';
        args.set = true;
        args.content = content;

        // Do preprocessing
        if (!args.no_events) {
          self.onBeforeSetContent.dispatch(self, args);
        }

        content = args.content;

        // Padd empty content in Gecko and Safari. Commands will otherwise fail on the content
        // It will also be impossible to place the caret in the editor unless there is a BR element present
        if (content.length === 0 || /^\s+$/.test(content)) {
          forcedRootBlockName = self.settings.forced_root_block;

          // Check if forcedRootBlock is configured and that the block is a valid child of the body
          if (forcedRootBlockName && self.schema.isValidChild(body.nodeName.toLowerCase(), forcedRootBlockName.toLowerCase())) {
            if (isIE) {
              // IE renders BR elements in blocks so lets just add an empty block
              content = '<' + forcedRootBlockName + '></' + forcedRootBlockName + '>';
            } else {
              content = '<' + forcedRootBlockName + '><br data-mce-bogus="1"></' + forcedRootBlockName + '>';
            }
          } else if (!isIE) {
            // We need to add a BR when forced_root_block is disabled on non IE browsers to place the caret
            content = '<br data-mce-bogus="1">';
          }

          self.dom.setHTML(body, content);
          self.onSetContent.dispatch(self, args);
        } else {
          // Parse and serialize the html
          if (args.format !== 'raw') {
            content = new tinymce.html.Serializer({}, self.schema).serialize(
              self.parser.parse(content)
            );
          }

          // Set the new cleaned contents to the editor
          args.content = tinymce.trim(content);
          self.dom.setHTML(body, args.content);

          // Do post processing
          if (!args.no_events) {
            self.onSetContent.dispatch(self, args);
          }

          // Don't normalize selection if the focused element isn't the body in content editable mode since it will steal focus otherwise
          /*if (!self.settings.content_editable || document.activeElement === self.getBody()) {
            self.selection.normalize();
          }*/
        }

        return args.content;
      },

      insertContent: function (value) {
        this.execCommand('mceInsertContent', false, value);
      },

      getSelection: function () {
        return this.selection.getContent();
      },

      /**
       * Gets the content from the editor instance, this will cleanup the content before it gets returned using
       * the different cleanup rules options.
       *
       * @method getContent
       * @param {Object} args Optional content object, this gets passed around through the whole get process.
       * @return {String} Cleaned content string, normally HTML contents.
       * @example
       * // Get the HTML contents of the currently active editor
       * console.debug(tinymce.activeEditor.getContent());
       *
       * // Get the raw contents of the currently active editor
       * tinymce.activeEditor.getContent({format : 'raw'});
       *
       * // Get content of a specific editor:
       * tinymce.get('content id').getContent()
       */
      getContent: function (args) {
        var self = this,
          content, body = self.getBody();

        // Setup args object
        args = args || {};
        args.format = args.format || 'html';
        args.get = true;
        args.getInner = true;

        self._selectionOverrides.hideFakeCaret();
        self._selectionOverrides.destroy();

        // Do preprocessing
        if (!args.no_events) {
          self.onBeforeGetContent.dispatch(self, args);
        }

        // Get raw contents or by default the cleaned contents
        if (args.format == 'raw') {
          content = tinymce.trim(Zwsp.trim(TrimBody.trim(body, self.serializer.getTempAttrs()).innerHTML));
        } else if (args.format == 'text') {
          content = body.innerText || body.textContent;
        } else {
          content = self.serializer.serialize(body, args);
        }

        // Trim whitespace in beginning/end of HTML
        if (args.format != 'text') {
          args.content = tinymce.trim(content);
        } else {
          args.content = content;
        }

        // Do post processing
        if (!args.no_events) {
          self.onGetContent.dispatch(self, args);
        }

        return args.content;
      },

      /**
       * Returns true/false if the editor is dirty or not. It will get dirty if the user has made modifications to the contents.
       *
       * @method isDirty
       * @return {Boolean} True/false if the editor is dirty or not. It will get dirty if the user has made modifications to the contents.
       * @example
       * if (tinymce.activeEditor.isDirty())
       *     alert("You must save your contents.");
       */
      isDirty: function () {
        var self = this;

        return tinymce.trim(self.startContent) !== tinymce.trim(self.getContent({
          format: 'raw'
        })) && !self.isNotDirty;
      },

      /**
       * Returns the editors container element. The container element wrappes in
       * all the elements added to the page for the editor. Such as UI, iframe etc.
       *
       * @method getContainer
       * @return {Element} HTML DOM element for the editor container.
       */
      getContainer: function () {
        var self = this;

        if (!self.container) {
          self.container = DOM.get(self.editorContainer || self.id + '_parent');
        }

        return self.container;
      },

      /**
       * Returns the editors content area container element. The this element is the one who
       * holds the iframe or the editable element.
       *
       * @method getContentAreaContainer
       * @return {Element} HTML DOM element for the editor area container.
       */
      getContentAreaContainer: function () {
        return this.contentAreaContainer;
      },

      /**
       * Returns the target element/textarea that got replaced with a TinyMCE editor instance.
       *
       * @method getElement
       * @return {Element} HTML DOM element for the replaced element.
       */
      getElement: function () {
        return DOM.get(this.settings.content_element || this.id);
      },

      /**
       * Returns the iframes window object.
       *
       * @method getWin
       * @return {Window} Iframe DOM window object.
       */
      getWin: function () {
        var self = this,
          elm;

        if (!self.contentWindow) {
          elm = DOM.get(self.id + "_ifr");

          if (elm) {
            self.contentWindow = elm.contentWindow;
          }
        }

        return self.contentWindow;
      },

      /**
       * Returns the iframes document object.
       *
       * @method getDoc
       * @return {Document} Iframe DOM document object.
       */
      getDoc: function () {
        var self = this,
          win;

        if (!self.contentDocument) {
          win = self.getWin();

          if (win) {
            self.contentDocument = win.document;
          }
        }

        return self.contentDocument;
      },

      /**
       * Returns the iframes body element.
       *
       * @method getBody
       * @return {Element} Iframe body element.
       */
      getBody: function () {
        return this.bodyElement || this.getDoc().body;
      },

      /**
       * URL converter function this gets executed each time a user adds an img, a or
       * any other element that has a URL in it. This will be called both by the DOM and HTML
       * manipulation functions.
       *
       * @method convertURL
       * @param {string} url URL to convert.
       * @param {string} name Attribute name src, href etc.
       * @param {string/HTMLElement} elm Tag name or HTML DOM element depending on HTML or DOM insert.
       * @return {string} Converted URL string.
       */
      convertURL: function (url, name, elm) {
        var self = this,
          settings = self.settings;

        // Use callback instead
        if (settings.urlconverter_callback) {
          return self.execCallback('urlconverter_callback', url, elm, true, name);
        }

        // Don't convert link href since thats the CSS files that gets loaded into the editor also skip local file URLs
        if (!settings.convert_urls || (elm && elm.nodeName == 'LINK') || url.indexOf('file:') === 0) {
          return url;
        }

        // Convert to relative
        if (settings.relative_urls) {
          return self.documentBaseURI.toRelative(url);
        }

        // Convert to absolute
        url = self.documentBaseURI.toAbsolute(url, settings.remove_script_host);

        return url;
      },

      /**
       * Adds visual aid for tables, anchors etc so they can be more easily edited inside the editor.
       *
       * @method addVisual
       * @param {Element} elm Optional root element to loop though to find tables etc that needs the visual aid.
       */
      addVisual: function (elm) {
        var self = this,
          settings = self.settings,
          dom = self.dom,
          cls;

        elm = elm || self.getBody();

        if (!is(self.hasVisual)) {
          self.hasVisual = settings.visual;
        }

        // add visualaid class to editor body
        if (self.hasVisual) {
          dom.addClass(self.getBody(), 'mce-visualaid');
        } else {
          dom.removeClass(self.getBody(), 'mce-visualaid');
        }

        each(dom.select('table,a', elm), function (elm) {
          var value;

          switch (elm.nodeName) {
            case 'TABLE':
              cls = settings.visual_table_class || 'mce-item-table';
              value = dom.getAttrib(elm, 'border');

              if (!value || value == '0') {
                if (self.hasVisual) {
                  dom.addClass(elm, cls);
                } else {
                  dom.removeClass(elm, cls);
                }
              }

              return;

            case 'A':
              if (!dom.getAttrib(elm, 'href', false)) {
                value = dom.getAttrib(elm, 'name') || elm.id;
                cls = 'mce-item-anchor';

                if (value) {
                  if (self.hasVisual) {
                    dom.addClass(elm, cls);
                  } else {
                    dom.removeClass(elm, cls);
                  }
                }
              }

              return;
          }
        });

        self.onVisualAid.dispatch(self, elm, self.hasVisual);
      },


      /**
       * Removes the editor from the dom and tinymce collection.
       *
       * @method remove
       */
      remove: function () {
        var self = this,
          elm = self.getContainer(),
          doc = self.getDoc();

        if (!self.removed) {
          self.removed = 1; // Cancels post remove event execution

          // Fixed bug where IE has a blinking cursor left from the editor
          if (isIE && doc) {
            doc.execCommand('SelectAll');
          }

          // We must save before we hide so Safari doesn't crash
          self.save();

          DOM.setStyle(self.id, 'display', self.orgDisplay);
          self.getBody().onload = null; // Prevent #6816

          // Don't clear the window or document if content editable
          // is enabled since other instances might still be present
          if (!self.settings.content_editable) {
            Event.unbind(self.getWin());
            Event.unbind(self.getDoc());
          }

          Event.unbind(self.getBody());
          Event.clear(elm);

          self.execCallback('remove_instance_callback', self);
          self.onRemove.dispatch(self);

          // Clear all execCommand listeners this is required to avoid errors if the editor was removed inside another command
          self.onExecCommand.listeners = [];

          self._selectionOverrides.destroy();

          tinymce.remove(self);
          DOM.remove(elm);
        }
      },

      /**
       * Destroys the editor instance by removing all events, element references or other resources
       * that could leak memory. This method will be called automatically when the page is unloaded
       * but you can also call it directly if you know what you are doing.
       *
       * @method destroy
       * @param {Boolean} s Optional state if the destroy is an automatic destroy or user called one.
       */
      destroy: function (s) {
        var self = this;

        // One time is enough
        if (self.destroyed) {
          return;
        }

        // We must unbind on Gecko since it would otherwise produce the pesky "attempt to run compile-and-go script on a cleared scope" message
        if (isGecko) {
          Event.unbind(self.getDoc());
          Event.unbind(self.getWin());
          Event.unbind(self.getBody());
        }

        if (!s) {
          tinymce.removeUnload(self.destroy);
          tinymce.onBeforeUnload.remove(self._beforeUnload);

          // Manual destroy
          if (self.theme && self.theme.destroy) {
            self.theme.destroy();
          }

          // Destroy controls, selection and dom
          self.controlManager.destroy();
          self.selection.destroy();
          self.dom.destroy();
        }

        if (self.formElement) {
          self.formElement.submit = self.formElement._mceOldSubmit;
          self.formElement._mceOldSubmit = null;
        }

        self.contentAreaContainer = self.formElement = self.container = self.settings.content_element = self.bodyElement = self.contentDocument = self.contentWindow = null;

        if (self.selection) {
          self.selection = self.selection.win = self.selection.dom = self.selection.dom.doc = null;
        }

        self.destroyed = 1;
      },

      setMode: function (disabled) {
        // It will not steal focus while setting contentEditable
        var body = self.getBody();
        body.contentEditable = disabled;
        body.disabled = disabled;
      },

      _isHidden: function () {
        var s;

        if (!isGecko) {
          return 0;
        }

        // Weird, wheres that cursor selection?
        s = this.selection.getSel();
        return (!s || !s.rangeCount || s.rangeCount === 0);
      }
    };
  })(tinymce);

  /**
   * Editor.Events.js
   *
   * Copyright, Moxiecode Systems AB
   * Released under LGPL License.
   *
   * License: http://www.tinymce.com/license - Inactive
   * Licence: GNU/LGPL 2.1 or later - http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
   * Contributing: http://www.tinymce.com/contributing - Inactive
   */

  (function (tinymce) {
  	var each = tinymce.each;

  	var legacyEventMap = {
  		preinit: 'onPreInit',
  		beforerenderui: 'onBeforeRenderUI',
  		postrender: 'onPostRender',
  		load: 'onLoad',
  		init: 'onInit',
  		remove: 'onRemove',
  		activate: 'onActivate',
  		deactivate: 'onDeactivate',
  		show: 'onShow',
  		hide: 'onHide',
  		click: 'onClick',
  		event: 'onEvent',
  		mouseup: 'onMouseUp',
  		mousedown: 'onMouseDown',
  		dblclick: 'onDblClick',
  		keydown: 'onKeyDown',
  		keyup: 'onKeyUp',
  		keypress: 'onKeyPress',
  		contextmenu: 'onContextMenu',
  		submit: 'onSubmit',
  		reset: 'onReset',
  		paste: 'onPaste',
  		cut: 'onCut',
  		copy: 'onCopy',
  		preprocess: 'onPreProcess',
  		postprocess: 'onPostProcess',
  		beforesetcontent: 'onBeforeSetContent',
  		beforegetcontent: 'onBeforeGetContent',
  		setcontent: 'onSetContent',
  		getcontent: 'onGetContent',
  		loadcontent: 'onLoadContent',
  		savecontent: 'onSaveContent',
  		nodechange: 'onNodeChange',
  		change: 'onChange',
  		beforeexeccmd: 'onBeforeExecCommand',
  		execcmd: 'onExecCommand',
  		undo: 'onUndo',
  		redo: 'onRedo',
  		visualaid: 'onVisualAid',
  		setprogressstate: 'onSetProgressState',
  		setattrib: 'onSetAttrib',
  		selectionchange: 'onSelectionChange',
  		blur: 'onBlur',
  		focus: 'onFocus',
  		focusin: 'onFocusIn',
  		focusout: 'onFocusOut',
  		input: 'onInput'
  	};

  	/**
  	 * Creates all event dispatcher instances for the editor instance and also adds
  	 * passthoughs for legacy callback handlers.
  	 */
  	tinymce.Editor.prototype.setupEvents = function () {
  		var self = this,
  			settings = self.settings;

  		// Add events to the editor
  		each([
  			/**
  			 * Fires before the initialization of the editor.
  			 *
  			 * @event onPreInit
  			 * @param {tinymce.Editor} sender Editor instance.
  			 * @see #onInit
  			 * @example
  			 * // Adds an observer to the onPreInit event using tinymce.init
  			 * tinymce.init({
  			 *    ...
  			 *    setup : function(ed) {
  			 *       ed.onPreInit.add(function(ed) {
  			 *           console.debug('PreInit: ' + ed.id);
  			 *       });
  			 *    }
  			 * });
  			 */
  			'onPreInit',

  			/**
  			 * Fires before the initialization of the editor.
  			 *
  			 * @event onBeforeRenderUI
  			 * @param {tinymce.Editor} sender Editor instance.
  			 * @example
  			 * // Adds an observer to the onBeforeRenderUI event using tinymce.init
  			 * tinymce.init({
  			 *    ...
  			 *    setup : function(ed) {
  			 *      ed.onBeforeRenderUI.add(function(ed, cm) {
  			 *          console.debug('Before render: ' + ed.id);
  			 *      });
  			 *    }
  			 * });
  			 */
  			'onBeforeRenderUI',

  			/**
  			 * Fires after the rendering has completed.
  			 *
  			 * @event onPostRender
  			 * @param {tinymce.Editor} sender Editor instance.
  			 * @example
  			 * // Adds an observer to the onPostRender event using tinymce.init
  			 * tinymce.init({
  			 *    ...
  			 *    setup : function(ed) {
  			 *       ed.onPostRender.add(function(ed, cm) {
  			 *           console.debug('After render: ' + ed.id);
  			 *       });
  			 *    }
  			 * });
  			 */
  			'onPostRender',

  			/**
  			 * Fires when the onload event on the body occurs.
  			 *
  			 * @event onLoad
  			 * @param {tinymce.Editor} sender Editor instance.
  			 * @example
  			 * // Adds an observer to the onLoad event using tinymce.init
  			 * tinymce.init({
  			 *    ...
  			 *    setup : function(ed) {
  			 *       ed.onLoad.add(function(ed, cm) {
  			 *           console.debug('Document loaded: ' + ed.id);
  			 *       });
  			 *    }
  			 * });
  			 */
  			'onLoad',

  			/**
  			 * Fires after the initialization of the editor is done.
  			 *
  			 * @event onInit
  			 * @param {tinymce.Editor} sender Editor instance.
  			 * @see #onPreInit
  			 * @example
  			 * // Adds an observer to the onInit event using tinymce.init
  			 * tinymce.init({
  			 *    ...
  			 *    setup : function(ed) {
  			 *       ed.onInit.add(function(ed) {
  			 *           console.debug('Editor is done: ' + ed.id);
  			 *       });
  			 *    }
  			 * });
  			 */
  			'onInit',

  			/**
  			 * Fires when the editor instance is removed from page.
  			 *
  			 * @event onRemove
  			 * @param {tinymce.Editor} sender Editor instance.
  			 * @example
  			 * // Adds an observer to the onRemove event using tinymce.init
  			 * tinymce.init({
  			 *    ...
  			 *    setup : function(ed) {
  			 *       ed.onRemove.add(function(ed) {
  			 *           console.debug('Editor was removed: ' + ed.id);
  			 *       });
  			 *    }
  			 * });
  			 */
  			'onRemove',

  			/**
  			 * Fires when the editor is activated.
  			 *
  			 * @event onActivate
  			 * @param {tinymce.Editor} sender Editor instance.
  			 * @example
  			 * // Adds an observer to the onActivate event using tinymce.init
  			 * tinymce.init({
  			 *    ...
  			 *    setup : function(ed) {
  			 *       ed.onActivate.add(function(ed) {
  			 *           console.debug('Editor was activated: ' + ed.id);
  			 *       });
  			 *    }
  			 * });
  			 */
  			'onActivate',

  			/**
  			 * Fires when the editor is deactivated.
  			 *
  			 * @event onDeactivate
  			 * @param {tinymce.Editor} sender Editor instance.
  			 * @example
  			 * // Adds an observer to the onDeactivate event using tinymce.init
  			 * tinymce.init({
  			 *    ...
  			 *    setup : function(ed) {
  			 *       ed.onDeactivate.add(function(ed) {
  			 *           console.debug('Editor was deactivated: ' + ed.id);
  			 *       });
  			 *    }
  			 * });
  			 */
  			'onDeactivate',

  			/**
  			 * Fires when the editor is shown.
  			 *
  			 * @event onShow
  			 * @param {tinymce.Editor} sender Editor instance.
  			 * @example
  			 * // Adds an observer to the onShow event using tinymce.init
  			 * tinymce.init({
  			 *    ...
  			 *    setup : function(ed) {
  			 *       ed.onShow.add(function(ed) {
  			 *           console.debug('Editor was shown: ' + ed.id);
  			 *       });
  			 *    }
  			 * });
  			 */
  			'onShow',

  			/**
  			 * Fires when the editor is hidden.
  			 *
  			 * @event onHide
  			 * @param {tinymce.Editor} sender Editor instance.
  			 * @example
  			 * // Adds an observer to the onHide event using tinymce.init
  			 * tinymce.init({
  			 *    ...
  			 *    setup : function(ed) {
  			 *       ed.onHide.add(function(ed) {
  			 *           console.debug('Editor was hidden: ' + ed.id);
  			 *       });
  			 *    }
  			 * });
  			 */
  			'onHide',

  			/**
  			 * Fires when something in the body of the editor is clicked.
  			 *
  			 * @event onClick
  			 * @param {tinymce.Editor} sender Editor instance.
  			 * @param {Event} evt W3C DOM Event instance.
  			 * @example
  			 * // Adds an observer to the onClick event using tinymce.init
  			 * tinymce.init({
  			 *    ...
  			 *    setup : function(ed) {
  			 *       ed.onClick.add(function(ed, e) {
  			 *           console.debug('Editor was clicked: ' + e.target.nodeName);
  			 *       });
  			 *    }
  			 * });
  			 */
  			'onClick',

  			/**
  			 * Fires when a registered event is intercepted.
  			 *
  			 * @event onEvent
  			 * @param {tinymce.Editor} sender Editor instance.
  			 * @param {Event} evt W3C DOM Event instance.
  			 * @example
  			 * // Adds an observer to the onEvent event using tinymce.init
  			 * tinymce.init({
  			 *    ...
  			 *    setup : function(ed) {
  			 *       ed.onEvent.add(function(ed, e) {
  			 *          console.debug('Editor event occurred: ' + e.target.nodeName);
  			 *       });
  			 *    }
  			 * });
  			 */
  			'onEvent',

  			/**
  			 * Fires when a mouseup event is intercepted inside the editor.
  			 *
  			 * @event onMouseUp
  			 * @param {tinymce.Editor} sender Editor instance.
  			 * @param {Event} evt W3C DOM Event instance.
  			 * @example
  			 * // Adds an observer to the onMouseUp event using tinymce.init
  			 * tinymce.init({
  			 *    ...
  			 *    setup : function(ed) {
  			 *       ed.onMouseUp.add(function(ed, e) {
  			 *           console.debug('Mouse up event: ' + e.target.nodeName);
  			 *       });
  			 *    }
  			 * });
  			 */
  			'onMouseUp',

  			/**
  			 * Fires when a mousedown event is intercepted inside the editor.
  			 *
  			 * @event onMouseDown
  			 * @param {tinymce.Editor} sender Editor instance.
  			 * @param {Event} evt W3C DOM Event instance.
  			 * @example
  			 * // Adds an observer to the onMouseDown event using tinymce.init
  			 * tinymce.init({
  			 *    ...
  			 *    setup : function(ed) {
  			 *       ed.onMouseDown.add(function(ed, e) {
  			 *           console.debug('Mouse down event: ' + e.target.nodeName);
  			 *       });
  			 *    }
  			 * });
  			 */
  			'onMouseDown',

  			/**
  			 * Fires when a dblclick event is intercepted inside the editor.
  			 *
  			 * @event onDblClick
  			 * @param {tinymce.Editor} sender Editor instance.
  			 * @param {Event} evt W3C DOM Event instance.
  			 * @example
  			 * // Adds an observer to the onDblClick event using tinymce.init
  			 * tinymce.init({
  			 *    ...
  			 *    setup : function(ed) {
  			 *       ed.onDblClick.add(function(ed, e) {
  			 *          console.debug('Double click event: ' + e.target.nodeName);
  			 *       });
  			 *    }
  			 * });
  			 */
  			'onDblClick',

  			/**
  			 * Fires when a keydown event is intercepted inside the editor.
  			 *
  			 * @event onKeyDown
  			 * @param {tinymce.Editor} sender Editor instance.
  			 * @param {Event} evt W3C DOM Event instance.
  			 * @example
  			 * // Adds an observer to the onKeyDown event using tinymce.init
  			 * tinymce.init({
  			 *    ...
  			 *    setup : function(ed) {
  			 *       ed.onKeyDown.add(function(ed, e) {
  			 *           console.debug('Key down event: ' + e.keyCode);
  			 *       });
  			 *    }
  			 * });
  			 */
  			'onKeyDown',

  			/**
  			 * Fires when a keydown event is intercepted inside the editor.
  			 *
  			 * @event onKeyUp
  			 * @param {tinymce.Editor} sender Editor instance.
  			 * @param {Event} evt W3C DOM Event instance.
  			 * @example
  			 * // Adds an observer to the onKeyUp event using tinymce.init
  			 * tinymce.init({
  			 *    ...
  			 *    setup : function(ed) {
  			 *       ed.onKeyUp.add(function(ed, e) {
  			 *           console.debug('Key up event: ' + e.keyCode);
  			 *       });
  			 *    }
  			 * });
  			 */
  			'onKeyUp',

  			/**
  			 * Fires when a keypress event is intercepted inside the editor.
  			 *
  			 * @event onKeyPress
  			 * @param {tinymce.Editor} sender Editor instance.
  			 * @param {Event} evt W3C DOM Event instance.
  			 * @example
  			 * // Adds an observer to the onKeyPress event using tinymce.init
  			 * tinymce.init({
  			 *    ...
  			 *    setup : function(ed) {
  			 *       ed.onKeyPress.add(function(ed, e) {
  			 *           console.debug('Key press event: ' + e.keyCode);
  			 *       });
  			 *    }
  			 * });
  			 */
  			'onKeyPress',

  			/**
  			 * Fires when a contextmenu event is intercepted inside the editor.
  			 *
  			 * @event onContextMenu
  			 * @param {tinymce.Editor} sender Editor instance.
  			 * @param {Event} evt W3C DOM Event instance.
  			 * @example
  			 * // Adds an observer to the onContextMenu event using tinymce.init
  			 * tinymce.init({
  			 *    ...
  			 *    setup : function(ed) {
  			 *       ed.onContextMenu.add(function(ed, e) {
  			 *            console.debug('Context menu event:' + e.target);
  			 *       });
  			 *    }
  			 * });
  			 */
  			'onContextMenu',

  			/**
  			 * Fires when a form submit event is intercepted.
  			 *
  			 * @event onSubmit
  			 * @param {tinymce.Editor} sender Editor instance.
  			 * @param {Event} evt W3C DOM Event instance.
  			 * @example
  			 * // Adds an observer to the onSubmit event using tinymce.init
  			 * tinymce.init({
  			 *    ...
  			 *    setup : function(ed) {
  			 *       ed.onSubmit.add(function(ed, e) {
  			 *            console.debug('Form submit:' + e.target);
  			 *       });
  			 *    }
  			 * });
  			 */
  			'onSubmit',

  			/**
  			 * Fires when a form reset event is intercepted.
  			 *
  			 * @event onReset
  			 * @param {tinymce.Editor} sender Editor instance.
  			 * @param {Event} evt W3C DOM Event instance.
  			 * @example
  			 * // Adds an observer to the onReset event using tinymce.init
  			 * tinymce.init({
  			 *    ...
  			 *    setup : function(ed) {
  			 *       ed.onReset.add(function(ed, e) {
  			 *            console.debug('Form reset:' + e.target);
  			 *       });
  			 *    }
  			 * });
  			 */
  			'onReset',

  			/**
  			 * Fires when a paste event is intercepted inside the editor.
  			 *
  			 * @event onPaste
  			 * @param {tinymce.Editor} sender Editor instance.
  			 * @param {Event} evt W3C DOM Event instance.
  			 * @example
  			 * // Adds an observer to the onPaste event using tinymce.init
  			 * tinymce.init({
  			 *    ...
  			 *    setup : function(ed) {
  			 *       ed.onPaste.add(function(ed, e) {
  			 *            console.debug('Pasted plain text');
  			 *       });
  			 *    }
  			 * });
  			 */
  			'onPaste',

  			/**
  			 * Fires when a cut event is intercepted inside the editor.
  			 *
  			 * @event onCut
  			 * @param {tinymce.Editor} sender Editor instance.
  			 * @param {Event} evt W3C DOM Event instance.
  			 * @example
  			 * // Adds an observer to the onCut event using tinymce.init
  			 * tinymce.init({
  			 *    ...
  			 *    setup : function(ed) {
  			 *       ed.onCut.add(function(ed, e) {
  			 *            console.debug('Cut plain text');
  			 *       });
  			 *    }
  			 * });
  			 */
  			'onCut',

  			/**
  			 * Fires when a copy event is intercepted inside the editor.
  			 *
  			 * @event onCopy
  			 * @param {tinymce.Editor} sender Editor instance.
  			 * @param {Event} evt W3C DOM Event instance.
  			 * @example
  			 * // Adds an observer to the onCopy event using tinymce.init
  			 * tinymce.init({
  			 *    ...
  			 *    setup : function(ed) {
  			 *       ed.onCopy.add(function(ed, e) {
  			 *            console.debug('copy plain text');
  			 *       });
  			 *    }
  			 * });
  			 */
  			'onCopy',

  			/**
  			 * Fires when the Serializer does a preProcess on the contents.
  			 *
  			 * @event onPreProcess
  			 * @param {tinymce.Editor} sender Editor instance.
  			 * @param {Object} obj PreProcess object.
  			 * @option {Node} node DOM node for the item being serialized.
  			 * @option {String} format The specified output format normally "html".
  			 * @option {Boolean} get Is true if the process is on a getContent operation.
  			 * @option {Boolean} set Is true if the process is on a setContent operation.
  			 * @option {Boolean} cleanup Is true if the process is on a cleanup operation.
  			 * @example
  			 * // Adds an observer to the onPreProcess event using tinymce.init
  			 * tinymce.init({
  			 *    ...
  			 *    setup : function(ed) {
  			 *       ed.onPreProcess.add(function(ed, o) {
  			 *            // Add a class to each paragraph in the editor
  			 *            ed.dom.addClass(ed.dom.select('p', o.node), 'myclass');
  			 *       });
  			 *    }
  			 * });
  			 */
  			'onPreProcess',

  			/**
  			 * Fires when the Serializer does a postProcess on the contents.
  			 *
  			 * @event onPostProcess
  			 * @param {tinymce.Editor} sender Editor instance.
  			 * @param {Object} obj PreProcess object.
  			 * @example
  			 * // Adds an observer to the onPostProcess event using tinymce.init
  			 * tinymce.init({
  			 *    ...
  			 *    setup : function(ed) {
  			 *       ed.onPostProcess.add(function(ed, o) {
  			 *            // Remove all paragraphs and replace with BR
  			 *            o.content = o.content.replace(/<p[^>]+>|<p>/g, '');
  			 *            o.content = o.content.replace(/<\/p>/g, '<br />');
  			 *       });
  			 *    }
  			 * });
  			 */
  			'onPostProcess',

  			/**
  			 * Fires before new contents is added to the editor. Using for example setContent.
  			 *
  			 * @event onBeforeSetContent
  			 * @param {tinymce.Editor} sender Editor instance.
  			 * @example
  			 * // Adds an observer to the onBeforeSetContent event using tinymce.init
  			 * tinymce.init({
  			 *    ...
  			 *    setup : function(ed) {
  			 *       ed.onBeforeSetContent.add(function(ed, o) {
  			 *            // Replaces all a characters with b characters
  			 *            o.content = o.content.replace(/a/g, 'b');
  			 *       });
  			 *    }
  			 * });
  			 */
  			'onBeforeSetContent',

  			/**
  			 * Fires before contents is extracted from the editor using for example getContent.
  			 *
  			 * @event onBeforeGetContent
  			 * @param {tinymce.Editor} sender Editor instance.
  			 * @param {Event} evt W3C DOM Event instance.
  			 * @example
  			 * // Adds an observer to the onBeforeGetContent event using tinymce.init
  			 * tinymce.init({
  			 *    ...
  			 *    setup : function(ed) {
  			 *       ed.onBeforeGetContent.add(function(ed, o) {
  			 *            console.debug('Before get content.');
  			 *       });
  			 *    }
  			 * });
  			 */
  			'onBeforeGetContent',

  			/**
  			 * Fires after the contents has been added to the editor using for example onSetContent.
  			 *
  			 * @event onSetContent
  			 * @param {tinymce.Editor} sender Editor instance.
  			 * @example
  			 * // Adds an observer to the onSetContent event using tinymce.init
  			 * tinymce.init({
  			 *    ...
  			 *    setup : function(ed) {
  			 *       ed.onSetContent.add(function(ed, o) {
  			 *            // Replaces all a characters with b characters
  			 *            o.content = o.content.replace(/a/g, 'b');
  			 *       });
  			 *    }
  			 * });
  			 */
  			'onSetContent',

  			/**
  			 * Fires after the contents has been extracted from the editor using for example getContent.
  			 *
  			 * @event onGetContent
  			 * @param {tinymce.Editor} sender Editor instance.
  			 * @example
  			 * // Adds an observer to the onGetContent event using tinymce.init
  			 * tinymce.init({
  			 *    ...
  			 *    setup : function(ed) {
  			 *       ed.onGetContent.add(function(ed, o) {
  			 *           // Replace all a characters with b
  			 *           o.content = o.content.replace(/a/g, 'b');
  			 *       });
  			 *    }
  			 * });
  			 */
  			'onGetContent',

  			/**
  			 * Fires when the editor gets loaded with contents for example when the load method is executed.
  			 *
  			 * @event onLoadContent
  			 * @param {tinymce.Editor} sender Editor instance.
  			 * @example
  			 * // Adds an observer to the onLoadContent event using tinymce.init
  			 * tinymce.init({
  			 *    ...
  			 *    setup : function(ed) {
  			 *       ed.onLoadContent.add(function(ed, o) {
  			 *           // Output the element name
  			 *           console.debug(o.element.nodeName);
  			 *       });
  			 *    }
  			 * });
  			 */
  			'onLoadContent',

  			/**
  			 * Fires when the editor contents gets saved for example when the save method is executed.
  			 *
  			 * @event onSaveContent
  			 * @param {tinymce.Editor} sender Editor instance.
  			 * @example
  			 * // Adds an observer to the onSaveContent event using tinymce.init
  			 * tinymce.init({
  			 *    ...
  			 *    setup : function(ed) {
  			 *       ed.onSaveContent.add(function(ed, o) {
  			 *           // Output the element name
  			 *           console.debug(o.element.nodeName);
  			 *       });
  			 *    }
  			 * });
  			 */
  			'onSaveContent',

  			/**
  			 * Fires when the user changes node location using the mouse or keyboard.
  			 *
  			 * @event onNodeChange
  			 * @param {tinymce.Editor} sender Editor instance.
  			 * @example
  			 * // Adds an observer to the onNodeChange event using tinymce.init
  			 * tinymce.init({
  			 *    ...
  			 *    setup : function(ed) {
  			 *       ed.onNodeChange.add(function(ed, cm, e) {
  			 *           // Activates the link button when the caret is placed in a anchor element
  			 *           if (e.nodeName == 'A')
  			 *              cm.setActive('link', true);
  			 *       });
  			 *    }
  			 * });
  			 */
  			'onNodeChange',

  			/**
  			 * Fires when a new undo level is added to the editor.
  			 *
  			 * @event onChange
  			 * @param {tinymce.Editor} sender Editor instance.
  			 * @example
  			 * // Adds an observer to the onChange event using tinymce.init
  			 * tinymce.init({
  			 *    ...
  			 *    setup : function(ed) {
  			 *       ed.onChange.add(function(ed, l) {
  			 *          console.debug('Editor contents was modified. Contents: ' + l.content);
  			 *       });
  			 *    }
  			 * });
  			 */
  			'onChange',

  			/**
  			 * Fires before a command gets executed for example "Bold".
  			 *
  			 * @event onBeforeExecCommand
  			 * @param {tinymce.Editor} sender Editor instance.
  			 * @example
  			 * // Adds an observer to the onBeforeExecCommand event using tinymce.init
  			 * tinymce.init({
  			 *    ...
  			 *    setup : function(ed) {
  			 *       ed.onBeforeExecCommand.add(function(ed, cmd, ui, val) {
  			 *           console.debug('Command is to be executed: ' + cmd);
  			 *       });
  			 *    }
  			 * });
  			 */
  			'onBeforeExecCommand',

  			/**
  			 * Fires after a command is executed for example "Bold".
  			 *
  			 * @event onExecCommand
  			 * @param {tinymce.Editor} sender Editor instance.
  			 * @example
  			 * // Adds an observer to the onExecCommand event using tinymce.init
  			 * tinymce.init({
  			 *    ...
  			 *    setup : function(ed) {
  			 *       ed.onExecCommand.add(function(ed, cmd, ui, val) {
  			 *           console.debug('Command was executed: ' + cmd);
  			 *       });
  			 *    }
  			 * });
  			 */
  			'onExecCommand',

  			/**
  			 * Fires when the contents is undo:ed.
  			 *
  			 * @event onUndo
  			 * @param {tinymce.Editor} sender Editor instance.
  			 * @param {Object} level Undo level object.
  			 * @ example
  			 * // Adds an observer to the onUndo event using tinymce.init
  			 * tinymce.init({
  			 *    ...
  			 *    setup : function(ed) {
  			 *       ed.onUndo.add(function(ed, level) {
  			 *           console.debug('Undo was performed: ' + level.content);
  			 *       });
  			 *    }
  			 * });
  			 */
  			'onUndo',

  			/**
  			 * Fires when the contents is redo:ed.
  			 *
  			 * @event onRedo
  			 * @param {tinymce.Editor} sender Editor instance.
  			 * @param {Object} level Undo level object.
  			 * @example
  			 * // Adds an observer to the onRedo event using tinymce.init
  			 * tinymce.init({
  			 *    ...
  			 *    setup : function(ed) {
  			 *       ed.onRedo.add(function(ed, level) {
  			 *           console.debug('Redo was performed: ' +level.content);
  			 *       });
  			 *    }
  			 * });
  			 */
  			'onRedo',

  			/**
  			 * Fires when visual aids is enabled/disabled.
  			 *
  			 * @event onVisualAid
  			 * @param {tinymce.Editor} sender Editor instance.
  			 * @example
  			 * // Adds an observer to the onVisualAid event using tinymce.init
  			 * tinymce.init({
  			 *    ...
  			 *    setup : function(ed) {
  			 *       ed.onVisualAid.add(function(ed, e, s) {
  			 *           console.debug('onVisualAid event: ' + ed.id + ", State: " + s);
  			 *       });
  			 *    }
  			 * });
  			 */
  			'onVisualAid',

  			/**
  			 * Fires when the progress throbber is shown above the editor.
  			 *
  			 * @event onSetProgressState
  			 * @param {tinymce.Editor} sender Editor instance.
  			 * @example
  			 * // Adds an observer to the onSetProgressState event using tinymce.init
  			 * tinymce.init({
  			 *    ...
  			 *    setup : function(ed) {
  			 *       ed.onSetProgressState.add(function(ed, b) {
  			 *            if (b)
  			 *                 console.debug('SHOW!');
  			 *            else
  			 *                 console.debug('HIDE!');
  			 *       });
  			 *    }
  			 * });
  			 */
  			'onSetProgressState',

  			/**
  			 * Fires after an attribute is set using setAttrib.
  			 *
  			 * @event onSetAttrib
  			 * @param {tinymce.Editor} sender Editor instance.
  			 * @example
  			 * // Adds an observer to the onSetAttrib event using tinymce.init
  			 *tinymce.init({
  			 *    ...
  			 *    setup : function(ed) {
  			 *       ed.onSetAttrib.add(function(ed, node, attribute, attributeValue) {
  			 *            console.log('onSetAttrib tag');
  			 *       });
  			 *    }
  			 * });
  			 */
  			'onSetAttrib',

  			/**
  			 * Fires when  when the current text selection in the editor is changed.
  			 *
  			 * @event onSelectionChange
  			 * @param {tinymce.Editor} sender Editor instance.
  			 * @example
  			 * // Adds an observer to the onSelectionChange event using tinymce.init
  			 * tinymce.init({
  			 *    ...
  			 *    setup : function(ed) {
  			 *       ed.onSelectionChange.add(function(ed, e) {
  			 *          console.debug('Editor contents was modified. Contents: ' + e.content);
  			 *       });
  			 *    }
  			 * });
  			 */
  			'onSelectionChange',

  			/**
  			 * Fires when the editor loses focus.
  			 *
  			 * @event onBlur
  			 * @param {tinymce.Editor} sender Editor instance.
  			 */
  			'onBlur',

  			/**
  			 * Fires after the editor is focused.
  			 *
  			 * @event onFocus
  			 * @param {tinymce.Editor} sender Editor instance.
  			 */
  			'onFocus',

  			/**
  			 * Fires when focus is moved to the editor.
  			 *
  			 * @event onFocusIn
  			 * @param {tinymce.Editor} sender Editor instance.
  			 */
  			'onFocusIn',

  			/**
  			 * Fires when focus is moved from the editor.
  			 *
  			 * @event onFocusOut
  			 * @param {tinymce.Editor} sender Editor instance.
  			 */
  			'onFocusOut',

  			/**
  			 * Fires when the editor input is changed.
  			 *
  			 * @event onInput
  			 * @param {tinymce.Editor} sender Editor instance.
  			 */
  			'onInput'

  		], function (name) {
  			self[name] = new tinymce.util.Dispatcher(self);
  		});

  		// Handle legacy cleanup_callback option
  		if (settings.cleanup_callback) {
  			self.onBeforeSetContent.add(function (ed, o) {
  				o.content = ed.execCallback('cleanup_callback', 'insert_to_editor', o.content, o);
  			});

  			self.onPreProcess.add(function (ed, o) {
  				if (o.set) {
  					ed.execCallback('cleanup_callback', 'insert_to_editor_dom', o.node, o);
  				}

  				if (o.get) {
  					ed.execCallback('cleanup_callback', 'get_from_editor_dom', o.node, o);
  				}
  			});

  			self.onPostProcess.add(function (ed, o) {
  				if (o.set) {
  					o.content = ed.execCallback('cleanup_callback', 'insert_to_editor', o.content, o);
  				}

  				if (o.get) {
  					o.content = ed.execCallback('cleanup_callback', 'get_from_editor', o.content, o);
  				}
  			});
  		}

  		// proxy "on" function for legacy code
  		self.on = function (name, handler, prepend) {
  			// split into an array by space
  			var names = name.split(' ');

  			var names = name.toLowerCase().split(' ');
  			var i = names.length;

  			while (i--) {
  				name = names[i];

  				var evt = legacyEventMap[name] || name;

  				// Wrap the handler so it receives a modern-style event object
  				var wrapped = function (ed, arg) {
  					var eventObj = (typeof arg === 'object' && arg !== null) ? tinymce.extend({ editor: ed }, arg) : { editor: ed, data: arg };
  					handler(eventObj);
  				};

  				if (prepend) {
  					self[evt].addToTop(wrapped);
  				} else {
  					self[evt].add(wrapped);
  				}
  			}
  		};

  		self.fire = function (name, arg) {
  			name = name.toLocaleLowerCase();

  			var evt = legacyEventMap[name] || name;

  			// Wrap the arg to simulate modern signature
  			var eventObj = (typeof arg === 'object' && arg !== null) ? tinymce.extend({ editor: self }, arg) : { editor: self, data: arg };

  			self[evt].dispatch(self, eventObj);
  		};

  		self.off = function (name, handler) {
  			name = name.toLocaleLowerCase();

  			var evt = legacyEventMap[name] || name;

  			if (handler) {
  				self[evt].remove(handler);
  			} else {
  				self[evt].removeAll();
  			}
  		};
  	};

  	/**
  	 * Binds native DOM events and sends these out to the dispatchers.
  	 */
  	tinymce.Editor.prototype.bindNativeEvents = function () {
  		// 'focus', 'blur', 'dblclick', 'beforedeactivate', submit, reset
  		var self = this,
  			settings = self.settings,
  			dom = self.dom,
  			nativeToDispatcherMap;

  		nativeToDispatcherMap = {
  			mouseup: 'onMouseUp',
  			mousedown: 'onMouseDown',
  			click: 'onClick',
  			keyup: 'onKeyUp',
  			keydown: 'onKeyDown',
  			keypress: 'onKeyPress',
  			submit: 'onSubmit',
  			reset: 'onReset',
  			contextmenu: 'onContextMenu',
  			dblclick: 'onDblClick',
  			paste: 'onPaste',
  			cut: 'onCut',
  			copy: 'onCopy',
  			selectionchange: 'onSelectionChange',
  			focusin: 'onFocusIn',
  			focusout: 'onFocusOut',
  			input: 'onInput'
  		};

  		// Handler that takes a native event and sends it out to a dispatcher like onKeyDown
  		function eventHandler(evt, args) {
  			// Don't fire events when it's removed
  			if (self.removed) {
  				return;
  			}

  			// Sends the native event out to a global dispatcher then to the specific event dispatcher
  			if (self.onEvent.dispatch(self, evt, args) !== false) {
  				self[nativeToDispatcherMap[evt.fakeType || evt.type]].dispatch(self, evt, args);
  			}
  		}

  		// Add DOM events
  		each(nativeToDispatcherMap, function (dispatcherName, nativeName) {
  			var root = settings.content_editable ? self.getBody() : self.getDoc();

  			switch (nativeName) {
  				case 'contextmenu':
  					dom.bind(root, nativeName, eventHandler);
  					break;

  				case 'paste':
  				case 'cut':
  				case 'copy':
  					dom.bind(self.getBody(), nativeName, eventHandler);
  					break;

  				case 'submit':
  				case 'reset':
  					dom.bind(self.getElement().form || tinymce.DOM.getParent(self.id, 'form'), nativeName, eventHandler);
  					break;

  				default:
  					dom.bind(root, nativeName, eventHandler);
  			}
  		});

  		function getFocusTarget() {
  			if (settings.content_editable) {
  				return self.getBody();
  			}

  			if (tinymce.isGecko) {
  				return self.getDoc();
  			}

  			return self.getWin();
  		}

  		// Set the editor as active when focused
  		dom.bind(getFocusTarget(), 'focus', function () {
  			self.focus(true);
  		});

  		// Add reset handler
  		self.onReset.add(function () {
  			self.setContent(self.startContent, {
  				format: 'raw'
  			});
  		});

  		function hasModifier(e) {
  			return e.altKey || e.ctrlKey || e.metaKey;
  		}

  		function isFunctionKey(e) {
  			return e.type === "keydown" && e.keyCode >= 112 && e.keyCode <= 123;
  		}

  		function matchShortcut(e, shortcut) {
  			if (!shortcut) {
  				return false;
  			}

  			/*var ctrlState = tinymce.isMac ? e.metaKey : e.ctrlKey;
  	  
  				  if (shortcut.ctrl != ctrlState) {
  					  return false;
  				  }*/

  			if (shortcut.ctrl != e.ctrlKey || shortcut.meta != e.metaKey) {
  				return false;
  			}

  			if (shortcut.alt != e.altKey || shortcut.shift != e.shiftKey) {
  				return false;
  			}

  			if (e.keyCode == shortcut.keyCode || (e.charCode && e.charCode == shortcut.charCode)) {
  				e.preventDefault();
  				return true;
  			}

  			return false;
  		}

  		function executeShortcutAction(shortcut) {
  			return shortcut.func ? shortcut.func.call(shortcut.scope) : null;
  		}

  		var pendingPatterns = [];

  		// Add shortcuts
  		function handleShortcut(e) {
  			if ((hasModifier(e) || isFunctionKey(e)) && !e.isDefaultPrevented()) {
  				each(self.shortcuts, function (shortcut) {
  					if (matchShortcut(e, shortcut)) {
  						pendingPatterns = shortcut.subpatterns.slice(0);

  						if (e.type == "keydown") {
  							executeShortcutAction(shortcut);
  						}

  						return true;
  					}
  				});

  				if (matchShortcut(e, pendingPatterns[0])) {
  					if (pendingPatterns.length === 1) {
  						if (e.type == "keydown") {
  							executeShortcutAction(pendingPatterns[0]);
  						}
  					}

  					pendingPatterns.shift();
  				}
  			}
  		}

  		self.onKeyUp.add(function (ed, e) {
  			handleShortcut(e);
  		});

  		self.onKeyPress.add(function (ed, e) {
  			handleShortcut(e);
  		});

  		self.onKeyDown.add(function (ed, e) {
  			handleShortcut(e);
  		});
  	};
  })(tinymce);

  /**
   * InsertList.js
   *
   * Released under LGPL License.
   * Copyright (c) 1999-2016 Ephox Corp. All rights reserved
   *
   * License: http://www.tinymce.com/license - Inactive
   * Licence: GNU/LGPL 2.1 or later - http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
   * Contributing: http://www.tinymce.com/contributing - Inactive
   */

  /**
   * Handles inserts of lists into the editor instance.
   *
   * @class tinymce.InsertList
   * @private
   */
  (function (tinymce) {

    var CaretWalker = tinymce.caret.CaretWalker,
      CaretPosition = tinymce.caret.CaretPosition;

    var isListFragment = function (fragment) {
      var firstChild = fragment.firstChild;
      var lastChild = fragment.lastChild;

      // Skip meta since it's likely <meta><ul>..</ul>
      if (firstChild && firstChild.name === 'meta') {
        firstChild = firstChild.next;
      }

      // Skip mce_marker since it's likely <ul>..</ul><span id="mce_marker"></span>
      if (lastChild && lastChild.attr('id') === 'mce_marker') {
        lastChild = lastChild.prev;
      }

      if (!firstChild || firstChild !== lastChild) {
        return false;
      }

      return firstChild.name === 'ul' || firstChild.name === 'ol';
    };

    var cleanupDomFragment = function (domFragment) {
      var firstChild = domFragment.firstChild;
      var lastChild = domFragment.lastChild;

      // TODO: remove the meta tag from paste logic
      if (firstChild && firstChild.nodeName === 'META') {
        firstChild.parentNode.removeChild(firstChild);
      }

      if (lastChild && lastChild.id === 'mce_marker') {
        lastChild.parentNode.removeChild(lastChild);
      }

      return domFragment;
    };

    var toDomFragment = function (dom, serializer, fragment) {
      var html = serializer.serialize(fragment);
      var domFragment = dom.createFragment(html);

      return cleanupDomFragment(domFragment);
    };

    var listItems = function (elm) {
      return tinymce.grep(elm.childNodes, function (child) {
        return child.nodeName === 'LI';
      });
    };

    var isEmpty = function (elm) {
      return !elm.firstChild;
    };

    var trimListItems = function (elms) {
      return elms.length > 0 && isEmpty(elms[elms.length - 1]) ? elms.slice(0, -1) : elms;
    };

    var getParentLi = function (dom, node) {
      var parentBlock = dom.getParent(node, dom.isBlock);
      return parentBlock && parentBlock.nodeName === 'LI' ? parentBlock : null;
    };

    var isParentBlockLi = function (dom, node) {
      return !!getParentLi(dom, node);
    };

    var getSplit = function (parentNode, rng) {
      var beforeRng = rng.cloneRange();
      var afterRng = rng.cloneRange();

      beforeRng.setStartBefore(parentNode);
      afterRng.setEndAfter(parentNode);

      return [
        beforeRng.cloneContents(),
        afterRng.cloneContents()
      ];
    };

    var findFirstIn = function (node, rootNode) {
      var caretPos = CaretPosition.before(node);
      var caretWalker = new CaretWalker(rootNode);
      var newCaretPos = caretWalker.next(caretPos);

      return newCaretPos ? newCaretPos.toRange() : null;
    };

    var findLastOf = function (node, rootNode) {
      var caretPos = CaretPosition.after(node);
      var caretWalker = new CaretWalker(rootNode);
      var newCaretPos = caretWalker.prev(caretPos);

      return newCaretPos ? newCaretPos.toRange() : null;
    };

    var insertMiddle = function (target, elms, rootNode, rng) {
      var parts = getSplit(target, rng);
      var parentElm = target.parentNode;

      parentElm.insertBefore(parts[0], target);
      tinymce.each(elms, function (li) {
        parentElm.insertBefore(li, target);
      });
      parentElm.insertBefore(parts[1], target);
      parentElm.removeChild(target);

      return findLastOf(elms[elms.length - 1], rootNode);
    };

    var insertBefore = function (target, elms, rootNode) {
      var parentElm = target.parentNode;

      tinymce.each(elms, function (elm) {
        parentElm.insertBefore(elm, target);
      });

      return findFirstIn(target, rootNode);
    };

    var insertAfter = function (target, elms, rootNode, dom) {
      dom.insertAfter(elms.reverse(), target);
      return findLastOf(elms[0], rootNode);
    };

    var insertAtCaret = function (serializer, dom, rng, fragment) {
      var domFragment = toDomFragment(dom, serializer, fragment);
      var liTarget = getParentLi(dom, rng.startContainer);
      var liElms = trimListItems(listItems(domFragment.firstChild));
      var BEGINNING = 1,
        END = 2;
      var rootNode = dom.getRoot();

      var isAt = function (location) {
        var caretPos = CaretPosition.fromRangeStart(rng);
        var caretWalker = new CaretWalker(dom.getRoot());
        var newPos = location === BEGINNING ? caretWalker.prev(caretPos) : caretWalker.next(caretPos);

        return newPos ? getParentLi(dom, newPos.getNode()) !== liTarget : true;
      };

      if (isAt(BEGINNING)) {
        return insertBefore(liTarget, liElms, rootNode);
      } else if (isAt(END)) {
        return insertAfter(liTarget, liElms, rootNode, dom);
      }

      return insertMiddle(liTarget, liElms, rootNode, rng);
    };

    tinymce.InsertList = {
      isListFragment: isListFragment,
      insertAtCaret: insertAtCaret,
      isParentBlockLi: isParentBlockLi,
      trimListItems: trimListItems,
      listItems: listItems
    };

  })(tinymce);

  /**
   * InsertContent.js
   *
   * Released under LGPL License.
   * Copyright (c) 1999-2016 Ephox Corp. All rights reserved
   *
   * License: http://www.tinymce.com/license - Inactive
   * Licence: GNU/LGPL 2.1 or later - http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
   * Contributing: http://www.tinymce.com/contributing - Inactive
   */

  /**
   * Handles inserts of contents into the editor instance.
   *
   * @class tinymce.InsertContent
   * @private
   */
  (function (tinymce) {

    var CaretWalker = tinymce.caret.CaretWalker,
      CaretPosition = tinymce.caret.CaretPosition,
      NodeType = tinymce.dom.NodeType,
      Serializer = tinymce.html.Serializer,
      InsertList = tinymce.InsertList;

    var isTableCell = NodeType.matchNodeNames('td th');

    var validInsertion = function (editor, value, parentNode) {
      // Should never insert content into bogus elements, since these can
      // be resize handles or similar
      if (parentNode.getAttribute('data-mce-bogus') === 'all') {
        parentNode.parentNode.insertBefore(editor.dom.createFragment(value), parentNode);
      } else {
        // Check if parent is empty or only has one BR element then set the innerHTML of that parent
        var node = parentNode.firstChild;
        var node2 = parentNode.lastChild;
        if (!node || (node === node2 && node.nodeName === 'BR')) { ///
          editor.dom.setHTML(parentNode, value);
        } else {
          editor.selection.setContent(value);
        }
      }
    };

    var insertHtmlAtCaret = function (editor, value, details) {
      var parser, serializer, parentNode, rootNode, fragment, args;
      var marker, rng, node, node2, bookmarkHtml, merge;
      var textInlineElements = editor.schema.getTextInlineElements();
      var selection = editor.selection,
        dom = editor.dom;

      function trimOrPaddLeftRight(html) {
        var rng, container, offset;

        rng = selection.getRng(true);
        container = rng.startContainer;
        offset = rng.startOffset;

        function hasSiblingText(siblingName) {
          return container[siblingName] && container[siblingName].nodeType == 3;
        }

        if (container.nodeType == 3) {
          if (offset > 0) {
            html = html.replace(/^&nbsp;/, ' ');
          } else if (!hasSiblingText('previousSibling')) {
            html = html.replace(/^ /, '&nbsp;');
          }

          if (offset < container.length) {
            html = html.replace(/&nbsp;(<br>|)$/, ' ');
          } else if (!hasSiblingText('nextSibling')) {
            html = html.replace(/(&nbsp;| )(<br>|)$/, '&nbsp;');
          }
        }

        return html;
      }

      // Removes &nbsp; from a [b] c -> a &nbsp;c -> a c
      function trimNbspAfterDeleteAndPaddValue() {
        var rng, container, offset;

        rng = selection.getRng(true);
        container = rng.startContainer;
        offset = rng.startOffset;

        if (container.nodeType == 3 && rng.collapsed) {
          if (container.data[offset] === '\u00a0') {
            container.deleteData(offset, 1);

            if (!/[\u00a0| ]$/.test(value)) {
              value += ' ';
            }
          }
          // Not sure about this - removes existing space at the beginning of content, which may be intentional
          /*else if (container.data[offset - 1] === '\u00a0') {
            container.deleteData(offset - 1, 1);
            if (!/[\u00a0| ]$/.test(value)) {
              value = ' ' + value;
            }
          }*/
        }
      }

      function reduceInlineTextElements() {
        if (merge) {
          var root = editor.getBody();

          tinymce.each(dom.select('*[data-mce-fragment]'), function (node) {
            for (var testNode = node.parentNode; testNode && testNode != root; testNode = testNode.parentNode) {
              if (textInlineElements[node.nodeName.toLowerCase()] && testNode === node) {
                dom.remove(node, true);
              }
            }
          });
        }
      }

      function markFragmentElements(fragment) {
        var node = fragment;

        while ((node = node.walk())) {
          if (node.type === 1) {
            node.attr('data-mce-fragment', '1');
          }
        }
      }

      function umarkFragmentElements(elm) {
        tinymce.each(elm.getElementsByTagName('*'), function (elm) {
          elm.removeAttribute('data-mce-fragment');
        });
      }

      function isPartOfFragment(node) {
        return !!node.getAttribute('data-mce-fragment');
      }

      function canHaveChildren(node) {
        return node && !editor.schema.getShortEndedElements()[node.nodeName];
      }

      function moveSelectionToMarker(marker) {
        var parentEditableFalseElm, parentBlock, nextRng;

        function getContentEditableFalseParent(node) {
          var root = editor.getBody();

          for (; node && node !== root; node = node.parentNode) {
            if (editor.dom.getContentEditable(node) === 'false') {
              return node;
            }
          }

          return null;
        }

        if (!marker) {
          return;
        }

        selection.scrollIntoView(marker);

        // If marker is in cE=false then move selection to that element instead
        parentEditableFalseElm = getContentEditableFalseParent(marker);
        if (parentEditableFalseElm) {
          dom.remove(marker);
          selection.select(parentEditableFalseElm);
          return;
        }

        // Move selection before marker and remove it
        rng = dom.createRng();

        // If previous sibling is a text node set the selection to the end of that node
        node = marker.previousSibling;
        if (node && node.nodeType == 3) {
          rng.setStart(node, node.nodeValue.length);

          node2 = marker.nextSibling;
          if (node2 && node2.nodeType == 3) {
            node.appendData(node2.data);
            node2.parentNode.removeChild(node2);
          }
        } else {
          // If the previous sibling isn't a text node or doesn't exist set the selection before the marker node
          rng.setStartBefore(marker);
          rng.setEndBefore(marker);
        }

        function findNextCaretRng(rng) {
          var caretPos = CaretPosition.fromRangeStart(rng);
          var caretWalker = new CaretWalker(editor.getBody());

          caretPos = caretWalker.next(caretPos);
          if (caretPos) {
            return caretPos.toRange();
          }
        }

        // Remove the marker node and set the new range
        parentBlock = dom.getParent(marker, dom.isBlock);
        dom.remove(marker);

        if (parentBlock && dom.isEmpty(parentBlock)) {
          dom.empty(parentBlock);

          rng.setStart(parentBlock, 0);
          rng.setEnd(parentBlock, 0);

          if (!isTableCell(parentBlock) && !isPartOfFragment(parentBlock) && (nextRng = findNextCaretRng(rng))) {
            rng = nextRng;
            dom.remove(parentBlock);
          } else {
            dom.add(parentBlock, dom.create('br', {
              'data-mce-bogus': '1'
            }));
          }
        }

        selection.setRng(rng);
      }

      // Check for whitespace before/after value
      if (/^ | $/.test(value)) {
        value = trimOrPaddLeftRight(value);
      }

      // Setup parser and serializer
      parser = editor.parser;
      merge = details.merge;

      serializer = new Serializer({
        validate: editor.settings.validate
      }, editor.schema);
      bookmarkHtml = '<span id="mce_marker" data-mce-type="bookmark">&#xFEFF;&#x200B;</span>';

      // Run beforeSetContent handlers on the HTML to be inserted
      args = {
        content: value,
        format: 'html',
        selection: true
      };

      editor.onBeforeSetContent.dispatch(editor, args);
      value = args.content;

      // Add caret at end of contents if it's missing
      if (value.indexOf('{$caret}') == -1) {
        value += '{$caret}';
      }

      // Replace the caret marker with a span bookmark element
      value = value.replace(/\{\$caret\}/, bookmarkHtml);

      // If selection is at <body>|<p></p> then move it into <body><p>|</p>
      rng = selection.getRng();
      var caretElement = rng.startContainer || (rng.parentElement ? rng.parentElement() : null);
      var body = editor.getBody();
      if (caretElement === body && selection.isCollapsed()) {
        if (dom.isBlock(body.firstChild) && canHaveChildren(body.firstChild) && dom.isEmpty(body.firstChild)) {
          rng = dom.createRng();
          rng.setStart(body.firstChild, 0);
          rng.setEnd(body.firstChild, 0);
          selection.setRng(rng);
        }
      }

      // Insert node maker where we will insert the new HTML and get it's parent
      if (!selection.isCollapsed()) {
        // Fix for #2595 seems that delete removes one extra character on
        // WebKit for some odd reason if you double click select a word
        editor.selection.setRng(editor.selection.getRng());
        editor.getDoc().execCommand('Delete', false, null);
        trimNbspAfterDeleteAndPaddValue();
      }

      parentNode = selection.getNode();

      // Parse the fragment within the context of the parent node
      var parserArgs = {
        context: parentNode.nodeName.toLowerCase(),
        data: details.data
      };
      fragment = parser.parse(value, parserArgs);

      // Custom handling of lists
      if (details.paste === true && InsertList.isListFragment(fragment) && InsertList.isParentBlockLi(dom, parentNode)) {
        rng = InsertList.insertAtCaret(serializer, dom, editor.selection.getRng(true), fragment);
        editor.selection.setRng(rng);
        //editor.fire('SetContent', args);
        editor.onSetContent.dispatch(editor, args);
        return;
      }

      markFragmentElements(fragment);

      // Move the caret to a more suitable location
      node = fragment.lastChild;
      if (node.attr('id') == 'mce_marker') {
        marker = node;

        for (node = node.prev; node; node = node.walk(true)) {
          if (node.type == 3 || !dom.isBlock(node.name)) {
            if (editor.schema.isValidChild(node.parent.name, 'span')) {
              node.parent.insert(marker, node, node.name === 'br');
            }
            break;
          }
        }
      }

      editor._selectionOverrides.showBlockCaretContainer(parentNode);

      // If parser says valid we can insert the contents into that parent
      if (!parserArgs.invalid) {
        value = serializer.serialize(fragment);
        validInsertion(editor, value, parentNode);
      } else {
        // If the fragment was invalid within that context then we need
        // to parse and process the parent it's inserted into

        // Insert bookmark node and get the parent
        selection.setContent(bookmarkHtml, { no_events : true });
        parentNode = selection.getNode();
        rootNode = editor.getBody();

        // Opera will return the document node when selection is in root
        if (parentNode.nodeType == 9) {
          parentNode = node = rootNode;
        } else {
          node = parentNode;
        }

        // Find the ancestor just before the root element
        while (node !== rootNode) {
          parentNode = node;
          node = node.parentNode;
        }

        // Get the outer/inner HTML depending on if we are in the root and parser and serialize that
        value = parentNode == rootNode ? rootNode.innerHTML : dom.getOuterHTML(parentNode);

        value = serializer.serialize(
          parser.parse(
            // Need to replace by using a function since $ in the contents would otherwise be a problem
            value.replace(/<span (id="mce_marker"|id=mce_marker).+?<\/span>/i, function () {
              return serializer.serialize(fragment);
            })
          )
        );

        // Set the inner/outer HTML depending on if we are in the root or not
        if (parentNode == rootNode) {
          dom.setHTML(rootNode, value);
        } else {
          dom.setOuterHTML(parentNode, value);
        }
      }

      reduceInlineTextElements();
      moveSelectionToMarker(dom.get('mce_marker'));
      umarkFragmentElements(editor.getBody());

      args.selection = true;
      editor.onSetContent.dispatch(editor, args);

      editor.addVisual();
    };

    var processValue = function (value) {
      var details;

      if (value && typeof value !== 'string') {      
        details = tinymce.extend({
          paste: value.paste,
          data: {
            paste: value.paste
          }
        }, value);

        return {
          content: value.content,
          details: details
        };
      }

      return {
        content: value,
        details: {}
      };
    };

    var insertAtCaret = function (editor, value) {
      var result = processValue(value);
      insertHtmlAtCaret(editor, result.content, result.details);
    };

    tinymce.InsertContent = {
      insertAtCaret: insertAtCaret
    };

  })(tinymce);

  /**
   * EditorCommands.js
   *
   * Copyright, Moxiecode Systems AB
   * Released under LGPL License.
   *
   * License: http://www.tinymce.com/license - Inactive
   * Licence: GNU/LGPL 2.1 or later - http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
   * Contributing: http://www.tinymce.com/contributing - Inactive
   */

  (function (tinymce) {
    // Added for compression purposes
    var each = tinymce.each,
      undef, TRUE = true,
      FALSE = false;
    var TreeWalker = tinymce.dom.TreeWalker;

    /**
     * This class enables you to add custom editor commands and it contains
     * overrides for native browser commands to address various bugs and issues.
     *
     * @class tinymce.EditorCommands
     */
    tinymce.EditorCommands = function (editor) {
      var dom = editor.dom,
        selection = editor.selection,
        commands = {
          state: {},
          exec: {},
          value: {}
        },
        settings = editor.settings,
        formatter = editor.formatter,
        bookmark;

      /**
       * Executes the specified command.
       *
       * @method execCommand
       * @param {String} command Command to execute.
       * @param {Boolean} ui Optional user interface state.
       * @param {Object} value Optional value for command.
       * @return {Boolean} true/false if the command was found or not.
       */
      function execCommand(command, ui, value) {
        var func;

        command = command.toLowerCase();
        func = commands.exec[command];

        if (func) {
          func(command, ui, value);
          return TRUE;
        }

        return FALSE;
      }

      /**
       * Queries the current state for a command for example if the current selection is "bold".
       *
       * @method queryCommandState
       * @param {String} command Command to check the state of.
       * @return {Boolean/Number} true/false if the selected contents is bold or not, -1 if it's not found.
       */
      function queryCommandState(command) {
        var func;

        command = command.toLowerCase();
        func = commands.state[command];

        if (func) {
          return func(command);
        }

        return -1;
      }

      /**
       * Queries the command value for example the current fontsize.
       *
       * @method queryCommandValue
       * @param {String} command Command to check the value of.
       * @return {Object} Command value of false if it's not found.
       */
      function queryCommandValue(command) {
        var func;

        command = command.toLowerCase();
        func = commands.value[command];

        if (func) {
          return func(command);
        }

        return FALSE;
      }

      /**
       * Adds commands to the command collection.
       *
       * @method addCommands
       * @param {Object} command_list Name/value collection with commands to add, the names can also be comma separated.
       * @param {String} type Optional type to add, defaults to exec. Can be value or state as well.
       */
      function addCommands(command_list, type) {
        type = type || 'exec';

        each(command_list, function (callback, command) {
          each(command.toLowerCase().split(','), function (command) {
            commands[type][command] = callback;
          });
        });
      }

      /**
       * Returns true/false if the command is supported or not.
       *
       * @method queryCommandSupported
       * @param {String} command Command that we check support for.
       * @return {Boolean} true/false if the command is supported or not.
       */
      function queryCommandSupported(command) {
        command = command.toLowerCase();

        if (commands.exec[command]) {
          return true;
        }

        // Browser commands
        try {
          return editor.getDoc().queryCommandSupported(command);
        } catch (ex) {
          // Fails sometimes see bug: 1896577
        }

        return false;
      }

      // Expose public methods
      tinymce.extend(this, {
        execCommand: execCommand,
        queryCommandState: queryCommandState,
        queryCommandValue: queryCommandValue,
        addCommands: addCommands,
        queryCommandSupported: queryCommandSupported
      });

      // Private methods

      function execNativeCommand(command, ui, value) {
        if (ui === undef) {
          ui = FALSE;
        }

        if (value === undef) {
          value = null;
        }

        return editor.getDoc().execCommand(command, ui, value);
      }

      function isFormatMatch(name) {
        return formatter.match(name);
      }

      function toggleFormat(name, value) {
        formatter.toggle(name, value ? {
          value: value
        } : undef);
      }

      function storeSelection(type) {
        bookmark = selection.getBookmark(type);
      }

      function restoreSelection() {
        selection.moveToBookmark(bookmark);
      }

      // Add execCommand overrides
      addCommands({
        // Ignore these, added for compatibility
        'mceResetDesignMode,mceBeginUndoLevel': function () { },

        // Add undo manager logic
        'mceEndUndoLevel,mceAddUndoLevel': function () {
          editor.undoManager.add();
        },

        'Cut,Copy,Paste': function (command) {
          // Try executing the native command
          try {
            execNativeCommand(command);
          } catch (ex) {
            // Command failed
          }
        },

        // Override unlink command
        unlink: function () {
          if (selection.isCollapsed()) {
            var elm = editor.dom.getParent(selection.getStart(), 'a');

            if (elm) {
              editor.dom.remove(elm, true);
            }

            return;
          }

          formatter.remove("link");
        },

        // Override justify commands to use the text formatter engine
        'JustifyLeft,JustifyCenter,JustifyRight,JustifyFull': function (command) {
          var align = command.substring(7);

          // Remove all other alignments first
          each('left,center,right,full'.split(','), function (name) {
            if (align != name) {
              formatter.remove('align' + name);
            }
          });

          toggleFormat('align' + align);
          execCommand('mceRepaint');
        },

        // Override list commands to fix WebKit bug
        'InsertUnorderedList,InsertOrderedList': function (command) {
          var listElm, listParent;

          execNativeCommand(command);

          // WebKit produces lists within block elements so we need to split them
          // we will replace the native list creation logic to custom logic later on
          // TODO: Remove this when the list creation logic is removed
          listElm = dom.getParent(selection.getNode(), 'ol,ul');
          if (listElm) {
            listParent = listElm.parentNode;

            // If list is within a text block then split that block
            if (/^(H[1-6]|P|ADDRESS|PRE)$/.test(listParent.nodeName)) {
              storeSelection();
              dom.split(listParent, listElm);
              restoreSelection();
            }
          }
        },

        // Override commands to use the text formatter engine
        'Bold,Italic,Underline,Strikethrough,Superscript,Subscript': function (command) {
          toggleFormat(command);
        },

        // Override commands to use the text formatter engine
        'ForeColor,HiliteColor,FontName': function (command, ui, value) {
          toggleFormat(command, value);
        },

        FontSize: function (command, ui, value) {
          var fontClasses, fontSizes;

          // Convert font size 1-7 to styles
          if (value >= 1 && value <= 7) {
            fontSizes = tinymce.explode(settings.font_size_style_values);
            fontClasses = tinymce.explode(settings.font_size_classes);

            if (fontClasses) {
              value = fontClasses[value - 1] || value;
            } else {
              value = fontSizes[value - 1] || value;
            }
          }

          toggleFormat(command, value);
        },

        ApplyFormat: function (command, ui, value) {
          formatter.apply(value.name, value.args || {}, value.node || null);
        },

        RemoveFormat: function (command, ui, value) {
          value = value || { name: command };
          formatter.remove(value.name, value.args || {}, value.node || null);
        },

        ToggleFormat: function (command, ui, value) {
          value = value || { name: command };
          formatter.toggle(value.name, value.args || {}, value.node || null);
        },

        mceBlockQuote: function () {
          toggleFormat('blockquote');
        },

        FormatBlock: function (command, ui, value) {
          return toggleFormat(value || 'p');
        },

        mceCleanup: function () {
          var bookmark = selection.getBookmark();

          editor.setContent(editor.getContent({
            cleanup: TRUE
          }), {
            cleanup: TRUE
          });

          selection.moveToBookmark(bookmark);
        },

        mceRemoveNode: function (command, ui, value) {
          var node = value || selection.getNode();

          // Make sure that the body node isn't removed
          if (node != editor.getBody()) {
            storeSelection();
            editor.dom.remove(node, TRUE);
            restoreSelection();
          }
        },

        mceSelectNodeDepth: function (command, ui, value) {
          var counter = 0;

          value = parseInt(value, 10);

          dom.getParent(selection.getNode(), function (node) {          
            if (node.nodeType == 1 && counter++ == value) {            
              selection.select(node);
              return FALSE;
            }
          }, editor.getBody());
        },

        mceSelectNode: function (command, ui, value) {
          selection.select(value);
        },
        /*
        mceInsertContent: function (command, ui, value) {
          var parser, serializer, parentNode, rootNode, fragment, args;
          var marker, rng, node, node2, bookmarkHtml, merge;
          var textInlineElements = editor.schema.getTextInlineElements();

          function trimOrPaddLeftRight(html) {
            var rng, container, offset;

            rng = selection.getRng(true);
            container = rng.startContainer;
            offset = rng.startOffset;

            function hasSiblingText(siblingName) {
              return container[siblingName] && container[siblingName].nodeType == 3;
            }

            if (container.nodeType == 3) {
              if (offset > 0) {
                html = html.replace(/^&nbsp;/, ' ');
              } else if (!hasSiblingText('previousSibling')) {
                html = html.replace(/^ /, '&nbsp;');
              }

              if (offset < container.length) {
                html = html.replace(/&nbsp;(<br>|)$/, ' ');
              } else if (!hasSiblingText('nextSibling')) {
                html = html.replace(/(&nbsp;| )(<br>|)$/, '&nbsp;');
              }
            }

            return html;
          }

          // Removes &nbsp; from a [b] c -> a &nbsp;c -> a c
          function trimNbspAfterDeleteAndPaddValue() {
            var rng, container, offset;

            rng = selection.getRng(true);
            container = rng.startContainer;
            offset = rng.startOffset;

            if (container.nodeType == 3 && rng.collapsed) {
              if (container.data[offset] === '\u00a0') {
                container.deleteData(offset, 1);

                if (!/[\u00a0| ]$/.test(value)) {
                  value += ' ';
                }
              } else if (container.data[offset - 1] === '\u00a0') {
                container.deleteData(offset - 1, 1);

                if (!/[\u00a0| ]$/.test(value)) {
                  value = ' ' + value;
                }
              }
            }
          }

          function markInlineFormatElements(fragment) {
            if (merge) {
              for (node = fragment.firstChild; node; node = node.walk(true)) {
                if (textInlineElements[node.name]) {
                  node.attr('data-mce-new', "true");
                }
              }
            }
          }

          if (typeof value != 'string') {
            merge = value.merge;
            value = value.content;
          }

          // Check for whitespace before/after value
          if (/^ | $/.test(value)) {
            value = trimOrPaddLeftRight(value);
          }

          // Setup parser and serializer
          parser = editor.parser;
          serializer = new tinymce.html.Serializer({}, editor.schema);
          bookmarkHtml = '<span id="mce_marker" data-mce-type="bookmark">&#xFEFF;&#x200B;</span>';

          // Run beforeSetContent handlers on the HTML to be inserted
          args = {
            content: value,
            format: 'html'
          };
          selection.onBeforeSetContent.dispatch(selection, args);
          value = args.content;

          // Add caret at end of contents if it's missing
          if (value.indexOf('{$caret}') == -1) {
            value += '{$caret}';
          }

          // Replace the caret marker with a span bookmark element
          value = value.replace(/\{\$caret\}/, bookmarkHtml);

          // If selection is at <body>|<p></p> then move it into <body><p>|</p>
          rng = selection.getRng();
          var caretElement = rng.startContainer || (rng.parentElement ? rng.parentElement() : null);
          var body = editor.getBody();
          if (caretElement === body && selection.isCollapsed()) {
            if (dom.isBlock(body.firstChild) && dom.isEmpty(body.firstChild)) {
              rng = dom.createRng();
              rng.setStart(body.firstChild, 0);
              rng.setEnd(body.firstChild, 0);
              selection.setRng(rng);
            }
          }

          // Insert node maker where we will insert the new HTML and get it's parent
          if (!selection.isCollapsed()) {
            editor.getDoc().execCommand('Delete', false, null);
            trimNbspAfterDeleteAndPaddValue();
          }

          parentNode = selection.getNode();

          // Parse the fragment within the context of the parent node
          var parserArgs = {
            context: parentNode.nodeName.toLowerCase()
          };
          fragment = parser.parse(value, parserArgs);

          markInlineFormatElements(fragment);

          // Move the caret to a more suitable location
          node = fragment.lastChild;
          if (node.attr('id') == 'mce_marker') {
            marker = node;

            for (node = node.prev; node; node = node.walk(true)) {
              if (node.type == 3 || !dom.isBlock(node.name)) {
                if (editor.schema.isValidChild(node.parent.name, 'span')) {
                  node.parent.insert(marker, node, node.name === 'br');
                }
                break;
              }
            }
          }

          editor._selectionOverrides.showBlockCaretContainer(parentNode);

          // If parser says valid we can insert the contents into that parent
          if (!parserArgs.invalid) {
            value = serializer.serialize(fragment);

            // Check if parent is empty or only has one BR element then set the innerHTML of that parent
            node = parentNode.firstChild;
            node2 = parentNode.lastChild;
            if (!node || (node === node2 && node.nodeName === 'BR')) {
              dom.setHTML(parentNode, value);
            } else {
              selection.setContent(value);
            }
          } else {
            // If the fragment was invalid within that context then we need
            // to parse and process the parent it's inserted into

            // Insert bookmark node and get the parent
            selection.setContent(bookmarkHtml);
            parentNode = selection.getNode();
            rootNode = editor.getBody();

            // Opera will return the document node when selection is in root
            if (parentNode.nodeType == 9) {
              parentNode = node = rootNode;
            } else {
              node = parentNode;
            }

            // Find the ancestor just before the root element
            while (node !== rootNode) {
              parentNode = node;
              node = node.parentNode;
            }

            // Get the outer/inner HTML depending on if we are in the root and parser and serialize that
            value = parentNode == rootNode ? rootNode.innerHTML : dom.getOuterHTML(parentNode);
            value = serializer.serialize(
              parser.parse(
                // Need to replace by using a function since $ in the contents would otherwise be a problem
                value.replace(/<span (id="mce_marker"|id=mce_marker).+?<\/span>/i, function () {
                  return serializer.serialize(fragment);
                })
              )
            );

            // Set the inner/outer HTML depending on if we are in the root or not
            if (parentNode == rootNode) {
              dom.setHTML(rootNode, value);
            } else {
              dom.setOuterHTML(parentNode, value);
            }
          }

          marker = dom.get('mce_marker');

          if (marker) {
            selection.scrollIntoView(marker);

            // Move selection before marker and remove it
            rng = dom.createRng();

            // If previous sibling is a text node set the selection to the end of that node
            node = marker.previousSibling;
            if (node && node.nodeType == 3) {
              rng.setStart(node, node.nodeValue.length);

              // TODO: Why can't we normalize on IE
              if (!tinymce.isIE) {
                node2 = marker.nextSibling;
                if (node2 && node2.nodeType == 3) {
                  node.appendData(node2.data);
                  node2.parentNode.removeChild(node2);
                }
              }
            } else {
              // If the previous sibling isn't a text node or doesn't exist set the selection before the marker node
              rng.setStartBefore(marker);
              rng.setEndBefore(marker);
            }

            // Remove the marker node and set the new range
            dom.remove(marker);
            selection.setRng(rng);
          }

          // Dispatch after event and add any visual elements needed
          selection.onSetContent.dispatch(selection, args);
          editor.addVisual();
        },
        */
        mceInsertContent: function (command, ui, value) {
          tinymce.InsertContent.insertAtCaret(editor, value);
        },

        mceInsertRawHTML: function (command, ui, value) {
          selection.setContent('tiny_mce_marker');
          editor.setContent(editor.getContent().replace(/tiny_mce_marker/g, function () {
            return value;
          }));
        },

        mceToggleFormat: function (command, ui, value) {
          toggleFormat(value);
        },

        mceSetContent: function (command, ui, value) {
          editor.setContent(value);
        },

        'Indent,Outdent': function (command) {
          var intentValue, indentUnit, value;

          // Setup indent level
          intentValue = settings.indentation;
          indentUnit = /[a-z%]+$/i.exec(intentValue);
          intentValue = parseInt(intentValue, 10);

          if (!queryCommandState('InsertUnorderedList') && !queryCommandState('InsertOrderedList')) {
            // If forced_root_blocks is set to false we don't have a block to indent so lets create a div
            if (!settings.forced_root_block && !dom.getParent(selection.getNode(), dom.isBlock)) {
              formatter.apply('div');
            }

            each(selection.getSelectedBlocks(), function (element) {
              if (element.nodeName != "LI") {
                var indentStyleName = editor.getParam('indent_use_margin', false) ? 'margin' : 'padding';

                indentStyleName += dom.getStyle(element, 'direction', true) == 'rtl' ? 'Right' : 'Left';

                if (command == 'outdent') {
                  value = Math.max(0, parseInt(element.style[indentStyleName] || 0, 10) - intentValue);
                  dom.setStyle(element, indentStyleName, value ? value + indentUnit : '');
                } else {
                  value = (parseInt(element.style[indentStyleName] || 0, 10) + intentValue) + indentUnit;
                  dom.setStyle(element, indentStyleName, value);
                }
              }
            });
          } else {
            execNativeCommand(command);
          }
        },

        mceRepaint: function () {
          if (tinymce.isGecko) {
            try {
              storeSelection(TRUE);

              if (selection.getSel()) {
                selection.getSel().selectAllChildren(editor.getBody());
              }

              selection.collapse(TRUE);
              restoreSelection();
            } catch (ex) {
              // Ignore
            }
          }
        },

        InsertHorizontalRule: function () {
          editor.execCommand('mceInsertContent', false, '<hr />');
        },

        mceToggleVisualAid: function () {
          editor.hasVisual = !editor.hasVisual;
          editor.addVisual();
        },

        mceReplaceContent: function (command, ui, value) {
          editor.execCommand('mceInsertContent', false, value.replace(/\{\$selection\}/g, selection.getContent({
            format: 'text'
          })));
        },

        mceInsertLink: function (command, ui, value) {
          var anchor;

          if (typeof value == 'string') {
            value = {
              href: value
            };
          }

          anchor = dom.getParent(selection.getNode(), 'a');

          // Spaces are never valid in URLs and it's a very common mistake for people to make so we fix it here.
          value.href = value.href.replace(' ', '%20');

          // Remove existing links if there could be child links or that the href isn't specified
          if (!anchor || !value.href) {
            formatter.remove('link');
          }

          // Apply new link to selection
          if (value.href) {
            formatter.apply('link', value, anchor);
          }
        },

        selectAll: function () {
          var root = dom.getRoot(),
            rng = dom.createRng();

          // Old IE does a better job with selectall than new versions
          if (selection.getRng().setStart) {
            rng = dom.createRng();
            rng.setStart(root, 0);
            rng.setEnd(root, root.childNodes.length);
            selection.setRng(rng);
          } else {
            // IE will render it's own root level block elements and sometimes
            // even put font elements in them when the user starts typing. So we need to
            // move the selection to a more suitable element from this:
            // <body>|<p></p></body> to this: <body><p>|</p></body>
            rng = selection.getRng();
            if (!rng.item) {
              rng.moveToElementText(root);
              rng.select();
            }
          }
        },

        "delete": function () {
          execNativeCommand("Delete");

          // Check if body is empty after the delete call if so then set the contents
          // to an empty string and move the caret to any block produced by that operation
          // this fixes the issue with root blocks not being properly produced after a delete call on IE
          var body = editor.getBody();

          if (dom.isEmpty(body)) {
            editor.setContent('');

            if (body.firstChild && dom.isBlock(body.firstChild)) {
              editor.selection.setCursorLocation(body.firstChild, 0);
            } else {
              editor.selection.setCursorLocation(body, 0);
            }
          }
        },

        mceNewDocument: function () {
          editor.setContent('');
        },

        InsertLineBreak: function (command, ui, value) {
          // We load the current event in from EnterKey.js when appropriate to heed
          // certain event-specific variations such as ctrl-enter in a list
          var evt = value;
          var brElm, extraBr, marker;
          var rng = selection.getRng(true);

          new tinymce.dom.RangeUtils(dom).normalize(rng);

          var offset = rng.startOffset;
          var container = rng.startContainer;

          // Resolve node index
          if (container.nodeType == 1 && container.hasChildNodes()) {
            var isAfterLastNodeInContainer = offset > container.childNodes.length - 1;

            container = container.childNodes[Math.min(offset, container.childNodes.length - 1)] || container;
            if (isAfterLastNodeInContainer && container.nodeType == 3) {
              offset = container.nodeValue.length;
            } else {
              offset = 0;
            }
          }

          var parentBlock = dom.getParent(container, dom.isBlock);
          //var parentBlockName = parentBlock ? parentBlock.nodeName.toUpperCase() : ''; // IE < 9 & HTML5
          var containerBlock = parentBlock ? dom.getParent(parentBlock.parentNode, dom.isBlock) : null;
          var containerBlockName = containerBlock ? containerBlock.nodeName.toUpperCase() : ''; // IE < 9 & HTML5

          // Enter inside block contained within a LI then split or insert before/after LI
          var isControlKey = evt && evt.ctrlKey;
          if (containerBlockName == 'LI' && !isControlKey) {
            parentBlock = containerBlock;
            //parentBlockName = containerBlockName;
          }

          // Walks the parent block to the right and look for BR elements
          function hasRightSideContent() {
            var walker = new TreeWalker(container, parentBlock),
              node;
            var nonEmptyElementsMap = editor.schema.getNonEmptyElements();

            while ((node = walker.next())) {
              if (nonEmptyElementsMap[node.nodeName.toLowerCase()] || node.length > 0) {
                return true;
              }
            }
          }

          if (container && container.nodeType == 3 && offset >= container.nodeValue.length) {
            // Insert extra BR element at the end block elements
            if (!hasRightSideContent()) {
              brElm = dom.create('br');
              rng.insertNode(brElm);
              rng.setStartAfter(brElm);
              rng.setEndAfter(brElm);
              extraBr = true;
            }
          }

          brElm = dom.create('br');
          rng.insertNode(brElm);

          // Insert temp marker and scroll to that
          marker = dom.create('span', {}, '&nbsp;');
          brElm.parentNode.insertBefore(marker, brElm);
          selection.scrollIntoView(marker);
          dom.remove(marker);

          if (!extraBr) {
            rng.setStartAfter(brElm);
            rng.setEndAfter(brElm);
          } else {
            rng.setStartBefore(brElm);
            rng.setEndBefore(brElm);
          }

          selection.setRng(rng);
          editor.undoManager.add();

          return TRUE;
        }
      });

      // Add queryCommandState overrides
      addCommands({
        // Override justify commands
        'JustifyLeft,JustifyCenter,JustifyRight,JustifyFull': function (command) {
          var name = 'align' + command.substring(7);
          var node = selection.getNode(), nodes = selection.isCollapsed() ? [dom.getParent(node, dom.isBlock)] : selection.getSelectedBlocks();

          // special case for figcaption
          if (node.nodeName == 'FIGCAPTION') {
            nodes = [node];
          }

          var matches = tinymce.map(nodes, function (node) {
            return !!formatter.matchNode(node, name);
          });
          return tinymce.inArray(matches, TRUE) !== -1;
        },

        'Bold,Italic,Underline,Strikethrough,Superscript,Subscript': function (command) {
          return isFormatMatch(command);
        },

        mceBlockQuote: function () {
          return isFormatMatch('blockquote');
        },

        Outdent: function () {
          var node;

          if (settings.inline_styles) {
            if ((node = dom.getParent(selection.getStart(), dom.isBlock)) && parseInt(node.style.paddingLeft, 10) > 0) {
              return TRUE;
            }

            if ((node = dom.getParent(selection.getEnd(), dom.isBlock)) && parseInt(node.style.paddingLeft, 10) > 0) {
              return TRUE;
            }
          }

          return (
            queryCommandState('InsertUnorderedList') ||
            queryCommandState('InsertOrderedList') ||
            (!settings.inline_styles && !!dom.getParent(selection.getNode(), 'BLOCKQUOTE'))
          );
        },

        'InsertUnorderedList,InsertOrderedList': function (command) {
          var list = dom.getParent(selection.getNode(), 'ul,ol,dl');

          return list && (command === 'insertunorderedlist' && list.tagName === 'UL' || command === 'insertorderedlist' && list.tagName === 'OL');
        }
      }, 'state');

      // Add queryCommandValue overrides
      addCommands({
        'FontSize,FontName': function (command) {
          var value = 0,
            parent;

          if ((parent = dom.getParent(selection.getNode(), 'span'))) {
            if (command == 'fontsize') {
              value = parent.style.fontSize;
            } else {
              value = parent.style.fontFamily.replace(/, /g, ',').replace(/[\'\"]/g, '').toLowerCase();
            }
          }

          return value;
        }
      }, 'value');

      // Add undo manager logic
      addCommands({
        Undo: function () {
          editor.undoManager.undo();
        },

        Redo: function () {
          editor.undoManager.redo();
        }
      });
    };
  })(tinymce);

  /**
   * UndoManager.js
   *
   * Copyright, Moxiecode Systems AB
   * Released under LGPL License.
   *
   * License: http://www.tinymce.com/license - Inactive
   * Licence: GNU/LGPL 2.1 or later - http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
   * Contributing: http://www.tinymce.com/contributing - Inactive
   */

  (function (tinymce) {
    var Dispatcher = tinymce.util.Dispatcher;

    /**
  	 * This class handles the undo/redo history levels for the editor. Since the build in undo/redo has major drawbacks a custom one was needed.
  	 *
  	 * @class tinymce.UndoManager
  	 */
    tinymce.UndoManager = function (editor) {
      var um, index = 0,
        data = [],
        beforeBookmark, onBeforeAdd, onAdd, onUndo, onRedo;

      function getContent() {
        // Remove whitespace before/after and remove pure bogus nodes
        return tinymce.trim(editor.getContent({
          format: 'raw',
          no_events: 1,
          undo: true
        }));
      }

      function addNonTypingUndoLevel() {
        um.typing = false;
        um.add();
      }

      // Create event instances
      onBeforeAdd = new Dispatcher(um);
      onAdd = new Dispatcher(um);
      onUndo = new Dispatcher(um);
      onRedo = new Dispatcher(um);

      // Pass though onAdd event from um to Editor as onChange
      onAdd.add(function (undoman, level) {
        if (undoman.hasUndo()) {
          return editor.onChange.dispatch(editor, level, undoman);
        }
      });

      // Pass though onUndo event from um to Editor
      onUndo.add(function (undoman, level) {
        return editor.onUndo.dispatch(editor, level, undoman);
      });

      // Pass though onRedo event from um to Editor
      onRedo.add(function (undoman, level) {
        return editor.onRedo.dispatch(editor, level, undoman);
      });

      // Add initial undo level when the editor is initialized
      editor.onInit.add(function () {
        um.add();
      });

      // Get position before an execCommand is processed
      editor.onBeforeExecCommand.add(function (ed, cmd, ui, val, args) {
        if (cmd != 'Undo' && cmd != 'Redo' && cmd != 'mceRepaint' && (!args || !args.skip_undo)) {
          um.beforeChange();
        }
      });

      // Add undo level after an execCommand call was made
      editor.onExecCommand.add(function (ed, cmd, ui, val, args) {
        if (cmd != 'Undo' && cmd != 'Redo' && cmd != 'mceRepaint' && (!args || !args.skip_undo)) {
          um.add();
        }
      });

      // Add undo level on save contents, drag end and blur/focusout
      editor.onSaveContent.add(addNonTypingUndoLevel);
      editor.dom.bind(editor.dom.getRoot(), 'dragend', addNonTypingUndoLevel);
      editor.dom.bind(editor.getBody(), 'focusout', function () {
        if (!editor.removed && um.typing) {
          addNonTypingUndoLevel();
        }
      });

      editor.onKeyUp.add(function (editor, e) {
        var keyCode = e.keyCode;

        // If key is prevented then don't add undo level
        // This would happen on keyboard shortcuts for example
        if (e.isDefaultPrevented()) {
          return;
        }

        if ((keyCode >= 33 && keyCode <= 36) || (keyCode >= 37 && keyCode <= 40) || keyCode == 45 || keyCode == 13 || e.ctrlKey) {
          addNonTypingUndoLevel();
        }
      });

      editor.onKeyDown.add(function (editor, e) {
        var keyCode = e.keyCode;

        // If key is prevented then don't add undo level
        // This would happen on keyboard shortcuts for example
        if (e.isDefaultPrevented()) {
          return;
        }

        // Is caracter positon keys left,right,up,down,home,end,pgdown,pgup,enter
        if ((keyCode >= 33 && keyCode <= 36) || (keyCode >= 37 && keyCode <= 40) || keyCode == 45) {
          if (um.typing) {
            addNonTypingUndoLevel();
          }

          return;
        }

        // If key isn't Ctrl+Alt/AltGr
        var modKey = (e.ctrlKey && !e.altKey) || e.metaKey;
        if ((keyCode < 16 || keyCode > 20) && keyCode !== 224 && keyCode !== 91 && !um.typing && !modKey) {
          um.beforeChange();
          um.typing = true;
          um.add();
        }
      });

      editor.onMouseDown.add(function () {
        if (um.typing) {
          addNonTypingUndoLevel();
        }
      });

      // Add keyboard shortcuts for undo/redo keys
      editor.addShortcut('meta+z', '', 'Undo');
      editor.addShortcut('meta+y,meta+shift+z', '', 'Redo');

      um = {
        // Explose for debugging reasons
        data: data,

        /**
  			 * State if the user is currently typing or not. This will add a typing operation into one undo
  			 * level instead of one new level for each keystroke.
  			 *
  			 * @field {Boolean} typing
  			 */
        typing: false,

        /**
  			 * This event will fire before a new undo level is added to the undo manager
  			 *
  			 * @event onBeforeAdd
  			 * @param {tinymce.um} sender um instance that is going to add the new level
  			 * @param {Object} level The new level object containing a bookmark and contents
  			 */
        onBeforeAdd: onBeforeAdd,

        /**
  			 * This event will fire each time a new undo level is added to the undo manager.
  			 *
  			 * @event onAdd
  			 * @param {tinymce.um} sender um instance that got the new level.
  			 * @param {Object} level The new level object containing a bookmark and contents.
  			 */
        onAdd: onAdd,

        /**
  			 * This event will fire when the user make an undo of a change.
  			 *
  			 * @event onUndo
  			 * @param {tinymce.um} sender um instance that got the new level.
  			 * @param {Object} level The old level object containing a bookmark and contents.
  			 */
        onUndo: onUndo,

        /**
  			 * This event will fire when the user make an redo of a change.
  			 *
  			 * @event onRedo
  			 * @param {tinymce.um} sender um instance that got the new level.
  			 * @param {Object} level The old level object containing a bookmark and contents.
  			 */
        onRedo: onRedo,

        /**
  			 * Stores away a bookmark to be used when performing an undo action so that the selection is before
  			 * the change has been made.
  			 *
  			 * @method beforeChange
  			 */
        beforeChange: function () {
          beforeBookmark = editor.selection.getBookmark(2, true);
        },

        /**
  			 * Adds a new undo level/snapshot to the undo list.
  			 *
  			 * @method add
  			 * @param {Object} l Optional undo level object to add.
  			 * @return {Object} Undo level that got added or null it a level wasn't needed.
  			 */
        add: function (level) {
          var i, settings = editor.settings,
            lastLevel;

          level = level || {};
          level.content = getContent();

          um.onBeforeAdd.dispatch(um, level);

          // Add undo level if needed
          lastLevel = data[index];

          if (lastLevel && lastLevel.content == level.content) {          
            return null;
          }

          // Set before bookmark on previous level
          if (data[index]) {
            data[index].beforeBookmark = beforeBookmark;
          }

          // Time to compress
          if (settings.custom_undo_redo_levels) {
            if (data.length > settings.custom_undo_redo_levels) {

              for (i = 0; i < data.length - 1; i++) {
                data[i] = data[i + 1];
              }

              data.length--;
              index = data.length;
            }
          }

          // Get a non intrusive normalized bookmark
          level.bookmark = editor.selection.getBookmark(2, true);

          // Crop array if needed
          if (index < data.length - 1) {
            data.length = index + 1;
          }

          data.push(level);
          index = data.length - 1;

          um.onAdd.dispatch(um, level);
          editor.isNotDirty = 0;

          return level;
        },

        /**
  			 * Undoes the last action.
  			 *
  			 * @method undo
  			 * @return {Object} Undo level or null if no undo was performed.
  			 */
        undo: function () {
          var level;

          if (um.typing) {
            um.add();
            um.typing = false;
          }

          if (index > 0) {
            level = data[--index];

            editor.setContent(level.content, {
              format: 'raw',
              undo: true
            });

            editor.selection.moveToBookmark(level.beforeBookmark);

            um.onUndo.dispatch(um, level);
          }

          return level;
        },

        /**
  			 * Redoes the last action.
  			 *
  			 * @method redo
  			 * @return {Object} Redo level or null if no redo was performed.
  			 */
        redo: function () {
          var level;

          if (index < data.length - 1) {
            level = data[++index];

            editor.setContent(level.content, {
              format: 'raw',
              undo: true
            });

            editor.selection.moveToBookmark(level.bookmark);

            um.onRedo.dispatch(um, level);
          }

          return level;
        },

        /**
  			 * Removes all undo levels.
  			 *
  			 * @method clear
  			 */
        clear: function () {
          data = [];
          index = 0;
          um.typing = false;
        },

        /**
  			 * Returns true/false if the undo manager has any undo levels.
  			 *
  			 * @method hasUndo
  			 * @return {Boolean} true/false if the undo manager has any undo levels.
  			 */
        hasUndo: function () {
          return index > 0 || this.typing;
        },

        /**
  			 * Returns true/false if the undo manager has any redo levels.
  			 *
  			 * @method hasRedo
  			 * @return {Boolean} true/false if the undo manager has any redo levels.
  			 */
        hasRedo: function () {
          return index < data.length - 1 && !this.typing;
        }
      };

      return um;
    };
  })(tinymce);

  /**
   * ForceBlocks.js
   *
   * Copyright, Moxiecode Systems AB
   * Released under LGPL License.
   *
   * License: http://www.tinymce.com/license - Inactive
   * Licence: GNU/LGPL 2.1 or later - http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
   * Contributing: http://www.tinymce.com/contributing - Inactive
   */

  tinymce.ForceBlocks = function (editor) {
    var settings = editor.settings,
      dom = editor.dom,
      selection = editor.selection;
    var schema = editor.schema,
      blockElements = schema.getBlockElements();

    function addRootBlocks() {
      var node = selection.getStart(),
        rootNode = editor.getBody(),
        rng;
      var startContainer, startOffset, endContainer, endOffset, rootBlockNode;
      var tempNode, offset = -0xFFFFFF,
        wrapped, restoreSelection;
      var tmpRng, rootNodeName, forcedRootBlock;

      forcedRootBlock = settings.forced_root_block;

      if (!node || node.nodeType !== 1 || !forcedRootBlock) {
        return;
      }

      if (node.getAttribute('data-mce-type')) {
        return;
      }

      // Check if node is wrapped in block
      while (node && node != rootNode) {
        if (blockElements[node.nodeName]) {
          return;
        }

        node = node.parentNode;
      }

      // Get current selection
      rng = selection.getRng();
      if (rng.setStart) {
        startContainer = rng.startContainer;
        startOffset = rng.startOffset;
        endContainer = rng.endContainer;
        endOffset = rng.endOffset;

        try {
          restoreSelection = editor.getDoc().activeElement === rootNode;
        } catch (ex) {
          // IE throws unspecified error here sometimes
        }
      } else {
        // Force control range into text range
        if (rng.item) {
          node = rng.item(0);
          rng = editor.getDoc().body.createTextRange();
          rng.moveToElementText(node);
        }

        restoreSelection = rng.parentElement().ownerDocument === editor.getDoc();
        tmpRng = rng.duplicate();
        tmpRng.collapse(true);
        startOffset = tmpRng.move('character', offset) * -1;

        if (!tmpRng.collapsed) {
          tmpRng = rng.duplicate();
          tmpRng.collapse(false);
          endOffset = (tmpRng.move('character', offset) * -1) - startOffset;
        }
      }

      // Wrap non block elements and text nodes
      node = rootNode.firstChild;
      rootNodeName = rootNode.nodeName.toLowerCase();
      while (node) {
        // TODO: Break this up, too complex
        if (((node.nodeType === 3 || (node.nodeType == 1 && !blockElements[node.nodeName]))) &&
                  schema.isValidChild(rootNodeName, forcedRootBlock.toLowerCase())) {
          // Remove empty text nodes
          if (node.nodeType === 3 && node.nodeValue.length === 0) {
            tempNode = node;
            node = node.nextSibling;
            dom.remove(tempNode);
            continue;
          }

          if (!rootBlockNode) {
            rootBlockNode = dom.create(forcedRootBlock, editor.settings.forced_root_block_attrs);
            node.parentNode.insertBefore(rootBlockNode, node);
            wrapped = true;
          }

          tempNode = node;
          node = node.nextSibling;
          rootBlockNode.appendChild(tempNode);
        } else {
          rootBlockNode = null;
          node = node.nextSibling;
        }
      }

      if (wrapped && restoreSelection) {
        if (rng.setStart) {
          rng.setStart(startContainer, startOffset);
          rng.setEnd(endContainer, endOffset);
          selection.setRng(rng);
        } else {
          // Only select if the previous selection was inside the document to prevent auto focus in quirks mode
          try {
            rng = editor.getDoc().body.createTextRange();
            rng.moveToElementText(rootNode);
            rng.collapse(true);
            rng.moveStart('character', startOffset);

            if (endOffset > 0) {
              rng.moveEnd('character', endOffset);
            }

            rng.select();
          } catch (ex) {
            // Ignore
          }
        }

        editor.nodeChanged();
      }
    }

    // Force root blocks
    if (settings.forced_root_block) {
      editor.onKeyUp.add(addRootBlocks);
      editor.onNodeChange.add(addRootBlocks);
    }
  };

  /**
   * ControlManager.js
   *
   * Copyright, Moxiecode Systems AB
   * Released under LGPL License.
   *
   * License: http://www.tinymce.com/license - Inactive
    * Licence: GNU/LGPL 2.1 or later - http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
    * Contributing: http://www.tinymce.com/contributing - Inactive
   */

  (function (tinymce) {
    // Shorten names
    var Event = tinymce.dom.Event,
      each = tinymce.each,
      extend = tinymce.extend,
      PreviewCss = tinymce.util.PreviewCss;

    tinymce.ControlManager = function (ed, s) {
      var self = this;

      s = s || {};
      self.editor = ed;
      self.controls = {};
      self.onAdd = new tinymce.util.Dispatcher(self);
      self.onPostRender = new tinymce.util.Dispatcher(self);
      self.prefix = s.prefix || ed.id + '_';
      self._cls = {};

      self.classPrefix = 'mce';

      self.onPostRender.add(function () {
        each(self.controls, function (c) {
          c.postRender();
        });
      });
    };

    /**
     * This class is responsible for managing UI control instances. It's both a factory and a collection for the controls.
     * @class tinymce.ControlManager
     */
    tinymce.ControlManager.prototype = {
      /**
       * Returns a control by id or undefined it it wasn't found.
       *
       * @method get
       * @param {String} id Control instance name.
       * @return {tinymce.ui.Control} Control instance or undefined.
       */
      get: function (id) {
        return this.controls[this.prefix + id] || this.controls[id];
      },

      /**
       * Sets the active state of a control by id.
       *
       * @method setActive
       * @param {String} id Control id to set state on.
       * @param {Boolean} s Active state true/false.
       * @return {tinymce.ui.Control} Control instance that got activated or null if it wasn't found.
       */
      setActive: function (id, s) {
        var c = this.get(id);

        if (c) {
          c.setActive(s);
        }

        return c;
      },

      /**
       * Sets the dsiabled state of a control by id.
       *
       * @method setDisabled
       * @param {String} id Control id to set state on.
       * @param {Boolean} s Active state true/false.
       * @return {tinymce.ui.Control} Control instance that got disabled or null if it wasn't found.
       */
      setDisabled: function (id, s) {
        var c = this.get(id);

        if (c) {
          c.setDisabled(s);
        }

        return c;
      },

      /**
       * Adds a control to the control collection inside the manager.
       *
       * @method add
       * @param {tinymce.ui.Control} Control instance to add to collection.
       * @return {tinymce.ui.Control} Control instance that got passed in.
       */
      add: function (c) {
        var self = this;

        if (c) {
          self.controls[c.id] = c;
          self.onAdd.dispatch(c, self);
        }

        return c;
      },

      /**
       * Creates a control by name, when a control is created it will automatically add it to the control collection.
       * It first ask all plugins for the specified control if the plugins didn't return a control then the default behavior
       * will be used.
       *
       * @method createControl
       * @param {String} name Control name to create for example "separator".
       * @return {tinymce.ui.Control} Control instance that got created and added.
       */
      createControl: function (name) {
        var ctrl, i, l, self = this,
          editor = self.editor,
          factories;

        // Build control factory cache
        if (!self.controlFactories) {
          self.controlFactories = [];
          each(editor.plugins, function (plugin) {
            if (plugin.createControl) {
              self.controlFactories.push(plugin);
            }
          });
        }

        // Create controls by asking cached factories
        factories = self.controlFactories;
        for (i = 0, l = factories.length; i < l; i++) {
          ctrl = factories[i].createControl(name, self);

          if (ctrl) {
            return self.add(ctrl);
          }
        }

        // Create sepearator
        if (name === "|" || name === "separator") {
          return self.createSeparator();
        }

        // Create control from button collection
        if (editor.buttons && (ctrl = editor.buttons[name])) {
          return self.createButton(name, ctrl);
        }

        return self.add(ctrl);
      },

      /**
       * Creates a drop menu control instance by id.
       *
       * @method createDropMenu
       * @param {String} id Unique id for the new dropdown instance. For example "some menu".
       * @param {Object} s Optional settings object for the control.
       * @param {Object} cc Optional control class to use instead of the default one.
       * @return {tinymce.ui.Control} Control instance that got created and added.
       */
      createDropMenu: function (id, s, cc) {
        var self = this,
          ed = self.editor,
          c, bm, cls;

        s = extend({
          'class': 'mceDropDown',
          constrain: ed.settings.constrain_menus
        }, s);

        s["class"] += ' ' + (ed.settings.skin_class || 'mceDefaultSkin');

        if (id.indexOf(self.prefix) == -1) {
          id = self.prefix + id;
        }

        cls = cc || self._cls.dropmenu || tinymce.ui.DropMenu;
        c = self.controls[id] = new cls(id, s);

        c.onAddItem.add(function (c, o) {
          var s = o.settings;

          if (s.title) {
            s.title = ed.getLang(s.title, s.title);
          }

          if (!s.onclick && s.cmd) {
            s.onclick = function () {
              ed.execCommand(s.cmd, s.ui || false, s.value);
            };
          }
        });

        // Fix for bug #1897785, #1898007
        if (tinymce.isIE) {
          c.onShowMenu.add(function () {
            // IE 8 needs focus in order to store away a range with the current collapsed caret location
            ed.focus();
            bm = ed.selection.getBookmark(1);
          });

          c.onHideMenu.add(function () {
            if (bm) {
              ed.selection.moveToBookmark(bm);
              bm = 0;
            }
          });
        }

        ed.onRemove.add(function () {
          c.destroy();
        });

        return self.add(c);
      },

      /**
       * Creates a list box control instance by id. A list box is either a native select element or a DOM/JS based list box control. This
       * depends on the use_native_selects settings state.
       *
       * @method createListBox
       * @param {String} id Unique id for the new listbox instance. For example "styles".
       * @param {Object} s Optional settings object for the control.
       * @param {Object} cc Optional control class to use instead of the default one.
       * @return {tinymce.ui.Control} Control instance that got created and added.
       */
      createListBox: function (id, s, cc) {
        var self = this,
          ed = self.editor,
          c, cls;

        c = self.get(id);

        if (c) {
          return c;
        }

        s.title = ed.translate(s.title);
        s.scope = s.scope || ed;

        if (!s.onselect) {
          s.onselect = function (v) {
            if (!s.cmd) {
              return false;
            }

            ed.execCommand(s.cmd, s.ui || false, v || s.value);
          };
        }

        s = extend({
          title: s.title,
          'class': 'mce_' + id,
          scope: s.scope,
          control_manager: self
        }, s);

        id = self.prefix + id;

        cls = cc || self._cls.listbox || tinymce.ui.ListBox;
        c = new cls(id, s, ed);

        self.controls[id] = c;

        // Fix focus problem in Safari
        if (tinymce.isWebKit) {
          c.onPostRender.add(function (c, n) {
            // Store bookmark on mousedown
            Event.add(n, 'mousedown', function () {
              ed.bookmark = ed.selection.getBookmark(1);
            });

            // Restore on focus, since it might be lost
            Event.add(n, 'focus', function () {
              ed.selection.moveToBookmark(ed.bookmark);
              ed.bookmark = null;
            });
          });
        }

        if (Array.isArray(s.items)) {
          c.onRenderMenu.add(function (c, m) {
            each(s.items, function (item) {
              m.add(item);
            });
          });
        }

        if (c.hideMenu) {
          ed.onMouseDown.add(c.hideMenu, c);
        }

        return self.add(c);
      },

      /**
       * Creates a list box control instance by id. A list box is either a native select element or a DOM/JS based list box control. This
       * depends on the use_native_selects settings state.
       *
       * @method createListBox
       * @param {String} id Unique id for the new listbox instance. For example "styles".
       * @param {Object} s Optional settings object for the control.
       * @param {Object} cc Optional control class to use instead of the default one.
       * @return {tinymce.ui.Control} Control instance that got created and added.
       */
      createStylesBox: function (id, s, cc) {
        var self = this,
          ed = self.editor;

        s = tinymce.extend({
          max_height: 384,
          combobox: true,
          multiple: true,
          seperator: ' ',
          menu_class: 'mceStylesBoxMenu'
        }, s || {});

        function loadClasses(ctrl) {
          if (!Array.isArray(ed.settings.importcss_classes)) {
            return;
          }

          if (ctrl.hasClasses) {
            return;
          }

          each(ed.settings.importcss_classes, function (item) {
            // Parse simple element.class1, .class1
            var selector = /^(?:([a-z0-9\-_]+))?(\.[a-z0-9_\-\.]+)$/i.exec(item.selector || item);

            // no match
            if (!selector) {
              return;
            }

            // skip element assignments
            if (selector[1]) {
              return;
            }

            var classes = selector[2].substr(1).split('.');

            each(classes, function (cls) {
              ctrl.add(cls, cls, {
                style: function () {
                  return item.style || PreviewCss.getCssText(ed, { classes: cls });
                }
              });
            });

            PreviewCss.reset();

          });

          if (Array.isArray(ed.settings.importcss_classes)) {
            ctrl.hasClasses = true;
          }
        }

        var c = this.createListBox(id, s, cc);

        c.onPostRender.add(function (c, n) {
          loadClasses(c);
        });

        return c;
      },

      /**
       * Creates a button control instance by id.
       *
       * @method createButton
       * @param {String} id Unique id for the new button instance. For example "bold".
       * @param {Object} s Optional settings object for the control.
       * @param {Object} cc Optional control class to use instead of the default one.
       * @return {tinymce.ui.Control} Control instance that got created and added.
       */
      createButton: function (id, s, cc) {
        var self = this,
          ed = self.editor,
          c, cls;

        if (self.get(id)) {
          return null;
        }
        s.title = ed.translate(s.title);
        s.label = ed.translate(s.label);
        s.scope = s.scope || ed;

        if (!s.onclick && !s.menu_button) {
          s.onclick = function () {
            ed.execCommand(s.cmd, s.ui || false, s.value);
          };
        }

        s = extend({
          title: s.title,
          'class': 'mce_' + id,
          scope: s.scope,
          control_manager: self
        }, s);

        id = self.prefix + id;

        if (s.menu_button) {
          cls = cc || self._cls.menubutton || tinymce.ui.MenuButton;
          c = new cls(id, s, ed);
          ed.onMouseDown.add(c.hideMenu, c);
        } else {
          cls = self._cls.button || tinymce.ui.Button;
          c = new cls(id, s, ed);
        }

        return self.add(c);
      },

      /**
       * Creates a menu button control instance by id.
       *
       * @method createMenuButton
       * @param {String} id Unique id for the new menu button instance. For example "menu1".
       * @param {Object} s Optional settings object for the control.
       * @param {Object} cc Optional control class to use instead of the default one.
       * @return {tinymce.ui.Control} Control instance that got created and added.
       */
      createMenuButton: function (id, s, cc) {
        s = s || {};
        s.menu_button = 1;

        return this.createButton(id, s, cc);
      },

      /**
       * Creates a split button control instance by id.
       *
       * @method createSplitButton
       * @param {String} id Unique id for the new split button instance. For example "spellchecker".
       * @param {Object} s Optional settings object for the control.
       * @param {Object} cc Optional control class to use instead of the default one.
       * @return {tinymce.ui.Control} Control instance that got created and added.
       */
      createSplitButton: function (id, s, cc) {
        var self = this,
          ed = self.editor,
          c, cls;

        if (self.get(id)) {
          return null;
        }

        s.title = ed.translate(s.title);
        s.scope = s.scope || ed;

        if (!s.onclick && s.cmd) {
          s.onclick = function (v) {
            ed.execCommand(s.cmd, s.ui || false, v || s.value);
          };
        }

        if (!s.onselect && s.cmd) {
          s.onselect = function (v) {
            ed.execCommand(s.cmd, s.ui || false, v || s.value);
          };
        }

        s = extend({
          title: s.title,
          'class': 'mce_' + id,
          scope: s.scope,
          control_manager: self
        }, s);

        id = self.prefix + id;
        cls = cc || self._cls.splitbutton || tinymce.ui.SplitButton;
        c = self.add(new cls(id, s, ed));
        ed.onMouseDown.add(c.hideMenu, c);

        c.onRenderMenu.add(function (e, m) {
          if (Array.isArray(s.items)) {
            each(s.items, function (item) {
              m.add(item);
            });
          }

          m.onHideMenu.add(function () {
            ed.nodeChanged();
            ed.focus();
          });
        });

        return self.add(c);
      },

      /**
       * Creates a color split button control instance by id.
       *
       * @method createColorSplitButton
       * @param {String} id Unique id for the new color split button instance. For example "forecolor".
       * @param {Object} s Optional settings object for the control.
       * @param {Object} cc Optional control class to use instead of the default one.
       * @return {tinymce.ui.Control} Control instance that got created and added.
       */
      createColorSplitButton: function (id, s, cc) {
        var self = this,
          ed = self.editor,
          c, cls, bm;

        if (self.get(id)) {
          return null;
        }

        s.title = ed.translate(s.title);
        s.scope = s.scope || ed;

        if (!s.onclick) {
          s.onclick = function (v) {
            if (tinymce.isIE) {
              bm = ed.selection.getBookmark(1);
            }

            ed.execCommand(s.cmd, s.ui || false, v || s.value);
          };
        }

        if (!s.onselect) {
          s.onselect = function (v) {
            ed.execCommand(s.cmd, s.ui || false, v || s.value);
          };
        }

        s = extend({
          title: s.title,
          'class': 'mce_' + id,
          'menu_class': ed.settings.skin_class || 'mceDefaultSkin',
          scope: s.scope,
          more_colors_title: ed.getLang('more_colors')
        }, s);

        id = self.prefix + id;
        cls = cc || self._cls.colorsplitbutton || tinymce.ui.ColorSplitButton;
        c = new cls(id, s, ed);
        ed.onMouseDown.add(c.hideMenu, c);

        // Remove the menu element when the editor is removed
        ed.onRemove.add(function () {
          c.destroy();
        });

        c.onShowMenu.add(function () {
          bm = ed.selection.getBookmark(1);
        });

        c.onHideMenu.add(function () {
          if (bm) {
            ed.selection.moveToBookmark(bm);
            bm = 0;
          }
        });

        return self.add(c);
      },

      createTextBox: function (id, s, cc) {
        var self = this,
          ed = self.editor,
          c, cls;

        id = self.prefix + id;

        c = self.get(id);

        if (c) {
          return c;
        }

        s.title = ed.translate(s.title);
        s.label = ed.translate(s.label);
        s.scope = s.scope || ed;

        s = extend({
          title: s.title,
          'class': 'mce_' + id,
          scope: s.scope,
          control_manager: self
        }, s);

        cls = cc || tinymce.ui.TextBox;
        c = new cls(id, s, ed);

        return self.add(c);
      },

      createUrlBox: function (id, s) {
        var ed = this.editor;

        s.upload_label = ed.getLang(s.upload_label, 'Upload');
        s.picker_label = ed.getLang(s.picker_label, 'Browse');

        return this.createTextBox(id, s, tinymce.ui.UrlBox);
      },

      createCheckBox: function (id, s) {
        var self = this,
          ed = self.editor,
          c, cls;

        c = self.get(id);

        if (c) {
          return c;
        }

        s.title = ed.translate(s.title);
        s.label = ed.translate(s.label);
        s.scope = s.scope || ed;

        s = extend({
          title: s.title,
          'class': 'mce_' + id,
          scope: s.scope,
          control_manager: self
        }, s);

        id = self.prefix + id;

        cls = tinymce.ui.CheckBox;
        c = new cls(id, s, ed);

        return self.add(c);
      },

      createCustomValue: function (id, s) {
        var self = this,
          ed = self.editor,
          c;

        id = self.prefix + id;

        c = new tinymce.ui.CustomValue(id, s, ed);

        return self.add(c);
      },

      createRepeatable: function (id, s) {
        var self = this,
          ed = self.editor,
          c, cls;

        id = self.prefix + id;

        c = self.get(id);

        if (c) {
          return c;
        }

        s.scope = s.scope || ed;

        s = extend({
          'class': 'mce_' + id,
          scope: s.scope,
          control_manager: self
        }, s);

        cls = tinymce.ui.Repeatable;
        c = new cls(id, s, ed);

        return self.add(c);
      },

      /**
       * Creates a panel container control instance by id.
       *
       * @method createPanel
       * @param {String} id Unique id for the new panel container control instance. For example "panel1".
       * @param {Object} s Optional settings object for the control.
       * @param {Object} cc Optional control class to use instead of the default one.
       * @return {tinymce.ui.Control} Control instance that got created and added.
       */
      createPanel: function (id, s, cc) {
        var c, self = this, ed = self.editor,
          cls;

        s["class"] += ' ' + (ed.settings.skin_class || 'mceDefaultSkin');

        //id = self.prefix + id;
        cls = cc || self._cls.panel || tinymce.ui.Panel;
        c = new cls(id, s, self.editor);

        if (self.get(id)) {
          return null;
        }

        return self.add(c);
      },

      createContextPanel: function (id, s) {
        var cc = tinymce.ui.ContextPanel;
        return this.createPanel(id, s, cc);
      },

      /**
       * Creates a toolbar container control instance by id.
       *
       * @method createToolbar
       * @param {String} id Unique id for the new toolbar container control instance. For example "toolbar1".
       * @param {Object} s Optional settings object for the control.
       * @param {Object} cc Optional control class to use instead of the default one.
       * @return {tinymce.ui.Control} Control instance that got created and added.
       */
      createToolbar: function (id, s, cc) {
        var c, self = this,
          cls;

        id = self.prefix + id;
        cls = cc || self._cls.toolbar || tinymce.ui.Toolbar;
        c = new cls(id, s, self.editor);

        if (self.get(id)) {
          return null;
        }

        return self.add(c);
      },

      createToolbarGroup: function (id, s, cc) {
        var c, self = this,
          cls;
        id = self.prefix + id;
        cls = cc || this._cls.toolbarGroup || tinymce.ui.ToolbarGroup;
        c = new cls(id, s, self.editor);

        if (self.get(id)) {
          return null;
        }

        return self.add(c);
      },

      /**
       * Creates a layout container control instance by id.
       *
       * @method createLayout
       * @param {String} id Unique id for the new toolbar container control instance. For example "toolbar1".
       * @param {Object} s Optional settings object for the control.
       * @param {Object} cc Optional control class to use instead of the default one.
       * @return {tinymce.ui.Control} Control instance that got created and added.
       */
      createLayout: function (id, s, cc) {
        var c, self = this,
          cls;

        id = self.prefix + id;
        cls = cc || self._cls.layout || tinymce.ui.Layout;
        c = new cls(id, s, self.editor);

        if (self.get(id)) {
          return null;
        }

        return self.add(c);
      },

      /**
       * Creates a form container control instance by id.
       *
       * @method createLayout
       * @param {String} id Unique id for the new toolbar container control instance. For example "toolbar1".
       * @param {Object} s Optional settings object for the control.
       * @return {tinymce.ui.Control} Control instance that got created and added.
       */
      createForm: function (id, s) {
        var c, self = this,
          cls;

        id = self.prefix + id;
        cls = tinymce.ui.Form;
        c = new cls(id, s, self.editor);

        return self.add(c);
      },

      /**
       * Creates a separator control instance.
       *
       * @method createSeparator
       * @param {Object} cc Optional control class to use instead of the default one.
       * @return {tinymce.ui.Control} Control instance that got created and added.
       */
      createSeparator: function (cc) {
        var cls = cc || this._cls.separator || tinymce.ui.Separator;

        return new cls();
      },

      /**
       * Overrides a specific control type with a custom class.
       *
       * @method setControlType
       * @param {string} n Name of the control to override for example button or dropmenu.
       * @param {function} c Class reference to use instead of the default one.
       * @return {function} Same as the class reference.
       */
      setControlType: function (n, c) {
        return this._cls[n.toLowerCase()] = c;
      },

      /**
       * Destroy.
       *
       * @method destroy
       */
      destroy: function () {
        each(this.controls, function (c) {
          c.destroy();
        });

        this.controls = null;
      }
    };
  })(tinymce);

  /**
   * WindowManager.js
   *
   * Copyright, Moxiecode Systems AB
   * Released under LGPL License.
   *
   * License: http://www.tinymce.com/license - Inactive
   * Licence: GNU/LGPL 2.1 or later - http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
   * Contributing: http://www.tinymce.com/contributing - Inactive
   */

  (function (tinymce) {
    var DOM = tinymce.DOM,
      Event = tinymce.dom.Event,
      each = tinymce.each,
      Dispatcher = tinymce.util.Dispatcher;

    function ucfirst(s) {
      return s.substring(0, 1).toUpperCase() + s.substring(1);
    }

    function updateWithTouchData(e) {
      var keys, i;

      if (e.changedTouches) {
        keys = "screenX screenY pageX pageY clientX clientY".split(' ');
        for (i = 0; i < keys.length; i++) {
          e[keys[i]] = e.changedTouches[0][keys[i]];
        }
      }
    }

    /**
     * This class handles the creation of native windows and dialogs. This class can be extended to provide for example inline dialogs.
     *
     * @class tinymce.WindowManager
     * @example
     * // Opens a new dialog with the file.htm file and the size 320x240
     * // It also adds a custom parameter this can be retrieved by using tinyMCEPopup.getWindowArg inside the dialog.
     * tinyMCE.activeEditor.windowManager.open({
     *    url : 'file.htm',
     *    width : 320,
     *    height : 240
     * }, {
     *    custom_param : 1
     * });
     * // Displays an alert box using the active editors window manager instance
     * tinyMCE.activeEditor.windowManager.alert('Hello world!');
     *
     * // Displays an confirm box and an alert message will be displayed depending on what you choose in the confirm
     * tinyMCE.activeEditor.windowManager.confirm("Do you want to do something", function(s) {
     *    if (s)
     *       tinyMCE.activeEditor.windowManager.alert("Ok");
     *    else
     *       tinyMCE.activeEditor.windowManager.alert("Cancel");
     * });
     */
    tinymce.create('tinymce.WindowManager', {
      /**
       * Constructs a new window manager instance.
       *
       * @constructor
       * @method WindowManager
       * @param {tinymce.Editor} ed Editor instance that the windows are bound to.
       */
      WindowManager: function (ed) {
        this.editor = ed;
        this.onOpen = new Dispatcher(this);
        this.onClose = new Dispatcher(this);
        this.params = {};
        this.features = {};

        this.zIndex = 700002;
        this.count = 0;
        this.windows = {};
      },

      /**
       * Creates a instance of a class. This method was needed since IE can't create instances
       * of classes from a parent window due to some reference problem. Any arguments passed after the class name
       * will be passed as arguments to the constructor.
       *
       * @method createInstance
       * @param {String} cl Class name to create an instance of.
       * @return {Object} Instance of the specified class.
       * @example
       * var uri = tinyMCEPopup.editor.windowManager.createInstance('tinymce.util.URI', 'http://www.somesite.com');
       * alert(uri.getURI());
       */
      createInstance: function (cl, a, b, c, d, e) {
        var fn = tinymce.resolve(cl);
        return new fn(a, b, c, d, e);
      },

      /**
       * Opens a new window.
       *
       * @method open
       * @param {Object} s Optional name/value settings collection contains things like width/height/url etc.
       * @option {String} title Window title.
       * @option {String} file URL of the file to open in the window.
       * @option {Number} width Width in pixels.
       * @option {Number} height Height in pixels.
       * @option {Boolean} resizable Specifies whether the popup window is resizable or not.
       * @option {Boolean} maximizable Specifies whether the popup window has a "maximize" button and can get maximized or not.
       * @option {Boolean} inline Specifies whether to display in-line (set to 1 or true for in-line display; requires inlinepopups plugin).
       * @option {Boolean} translate_i18n Specifies whether translation should occur or not of i18 key strings. Default is true.
       * @option {String/bool} close_previous Specifies whether a previously opened popup window is to be closed or not (like when calling the file browser window over the advlink popup).
       * @option {String/bool} scrollbars Specifies whether the popup window can have scrollbars if required (i.e. content larger than the popup size specified).
       * @param {Object} p Optional parameters/arguments collection can be used by the dialogs to retrive custom parameters.
       * @option {String} plugin_url url to plugin if opening plugin window that calls tinyMCEPopup.requireLangPack() and needs access to the plugin language js files
       */
      open: function (f, p) {
        var self = this,
          id,
          ed = self.editor,
          dw = 0,
          dh = 0,
          win, url;

        f = f || {};
        p = p || {};

        // Only store selection if the type is a normal window
        if (!f.type) {
          self.bookmark = ed.selection.getBookmark(1);
        }

        id = DOM.uniqueId("mce_window_"); // Use a prefix so this can't conflict with other ids

        f.width = parseInt(f.width || 0, 10);
        f.height = parseInt(f.height || 0, 10);

        p.mce_window_id = id;

        self.features = f;
        self.params = p;

        self.onOpen.dispatch(self, f, p);

        // modal html
        var html = '' +
          '<div class="mceModalBody" id="' + id + '" dir="' + ed.settings.skin_directionality + '">' +
          '   <div class="mceModalContainer">' +
          '       <div class="mceModalHeader" id="' + id + '_header">' + 
          //'            <div class="mceModalLogo">' + (ed.settings.logo || '') + '</div>' +
          '           <h5 class="mceModalTitle" id="' + id + '_title">' + (f.title || "") + '</h5>' +
          '           <button class="mceModalClose" type="button" title="' + ed.getLang('close', 'Close') + '" aria-label="' + ed.getLang('close', 'Close') + '"></button>' +
          '       </div>' +
          '       <div class="mceModalContent" id="' + id + '_content"></div>' +
          '   </div>' +
          '</div>';

        // find modal
        var modal = DOM.select('.mceModal');

        // create modal
        if (!modal.length) {
          modal = DOM.add(DOM.doc.body, 'div', { 'class': ed.settings.skin_class + ' mceModal', role: 'dialog', 'aria-labelledby': id + '_title' }, '');

          if (f.overlay !== false) {
            DOM.add(modal, 'div', { 'class': 'mceModalOverlay' });
          }
        }

        DOM.add(modal, 'div', { 'class': 'mceModalFrame', id: id + '_frame' }, html);

        if (!f.fixed) {
          DOM.addClass(DOM.select('.mceModalHeader', modal), 'mceModalMove');
        } else {
          DOM.addClass(modal, 'mceModalFixed');

          Event.add(id, 'blur', function () {
            self.close(null, id);
          });
        }

        f.buttons = f.buttons || [];

        url = f.url || f.file;

        if (url) {
          if (f.addver !== false) {
            url = tinymce._addVer(url);
          }

          // add loader
          DOM.addClass(id, 'mceLoading');

          DOM.addClass(id + '_content', 'mceModalContentIframe');

          var iframe = DOM.add(id + '_content', 'iframe', { id: id + '_ifr', src: 'about:blank', frameBorder: 0, 'aria-label': 'Dialog Content Iframe' });
          DOM.setAttrib(iframe, 'src', url);

          Event.add(iframe, 'load', function () {
            DOM.removeClass(id, 'mceLoading');
          });
        } else {
          if (f.type) {
            DOM.addClass(id, 'mceModal' + ucfirst(f.type));
          }

          if (!f.buttons.length) {
            f.buttons.push({
              id: 'cancel',
              title: self.editor.getLang('cancel', 'Cancel'),
              onclick: function (e) {
                Event.cancel(e);
                self.close(null, id);
              }
            });
          }

          if (f.content) {
            // HTML string
            if (typeof f.content === "string") {
              DOM.setHTML(id + '_content', '<div>' + f.content.replace('\n', '') + '</div>');
            }

            // HTML node collection
            if (f.content.nodeType) {
              DOM.add(id + '_content', DOM.create('div', {}, f.content));
            }
          }

          // controlManager UI items
          if (f.items) {
            if (!tinymce.is(f.items, 'array')) {
              f.items = [f.items];
            }

            each(f.items, function (ctrl) {
              var form = DOM.add(id + '_content', 'div');

              ctrl.renderTo(form);

              // add onClose event to destroy controls
              self.onClose.add(function (e, win) {              
                if (win.id == id) {
                  ctrl.destroy();
                }
              });
            });
          }

          function nodeIndex(nodes, node) {
            for (var i = 0; i < nodes.length; i++) {
              if (nodes[i] === node) {
                return i;
              }
            }

            return -1;
          }

          // restrict tabbing to within the form elements of the dialog
          Event.add(id, 'keydown', function (e) {
            var tabIndex = 0;

            if (e.keyCode === 9) {
              var nodes = DOM.select('input, button, select, textarea, .mceListBox', DOM.get(id));

              nodes = tinymce.grep(nodes, function (node) {
                return !node.disabled && !DOM.isHidden(node) && node.getAttribute('tabindex') >= 0;
              });

              if (!nodes.length) {
                return;
              }

              DOM.setAttrib(nodes, 'tabindex', 0);

              if (e.shiftKey) {
                nodes.reverse();
              }

              var endIndex = Math.max(0, nodes.length - 1), tabIndex = nodeIndex(nodes, e.target);

              tabIndex++;

              tabIndex = Math.max(tabIndex, 0);

              if (tabIndex > endIndex) {
                tabIndex = 0;
              }

              nodes[tabIndex].focus();
              DOM.setAttrib(nodes[tabIndex], 'tabindex', 1);

              e.preventDefault();
              e.stopImmediatePropagation();
            }
          });
        }

        if (f.buttons.length) {
          // add footer
          DOM.add(DOM.select('.mceModalContainer', id), 'div', { 'class': 'mceModalFooter', id: id + '_footer' });

          // add buttons
          each(f.buttons, function (button) {

            // patch in close function for cancel button
            if (button.id === 'cancel') {
              button.onclick = function (e) {
                self.close(null, id);
              };
            }

            var attribs = {
              id: id + '_' + button.id,
              'class': 'mceButton',
              type: 'button'
            };

            if (button.autofocus) {
              attribs.autofocus = true;
            }

            button.title = button.title || 'OK';

            var btn = DOM.add(id + '_footer', 'button', attribs, button.title);

            if (button.icon) {
              DOM.add(btn, 'span', { 'class': 'mceIcon mce_' + button.icon, 'role': 'presentation' });
            }

            each(tinymce.explode(button.classes), function (cls) {
              DOM.addClass(btn, 'mceButton' + ucfirst(cls));
            });

            // process passed in onclick
            if (button.onclick) {
              Event.add(btn, 'click', function (e) {
                Event.cancel(e);
                button.onclick.call(self, e);
              });
            }

            // a submit is simply an onclick with a built in close
            if (button.onsubmit) {
              Event.add(btn, 'click', function (e) {
                Event.cancel(e);
                button.onsubmit.call(self, e);

                if (e.cancelSubmit) {
                  return;
                }

                self.close(null, id);
              });
            }
          });
        }

        Event.add(id, 'keydown', function (evt) {
          // Close on escape
          if (evt.keyCode === 27) {
            self.close(null, id);

            evt.preventDefault();
            evt.stopImmediatePropagation();

            return;
          }

          // enter triggers focused button
          if (evt.keyCode === 13) {
            if (evt.target) {
              if (evt.target.nodeName === "TEXTAREA") {
                return;
              }

              if (evt.target.nodeName === "BUTTON") {
                Event.fire(evt.target, 'click');
              }
            }

            // or cancel
            evt.preventDefault();
            evt.stopImmediatePropagation();
          }
        });

        Event.add(DOM.select('button.mceModalClose', DOM.get(id)), 'click', function (evt) {
          self.close(null, id);

          evt.preventDefault();
          evt.stopImmediatePropagation();

          return;
        });

        // Measure borders
        if (!f.type) {
          dh += DOM.get(id + '_header').clientHeight;
        }

        // set size classes
        if (f.size) {
          DOM.addClass(id, f.size);
        } else {
          if (f.width) {
            DOM.setStyle(id, 'width', f.width + dw);
          }

          if (f.height) {
            DOM.setStyle(id, 'height', f.height + dh);
          }
        }

        if (!f.fixed) {
          Event.add(DOM.win, 'resize orientationchange', function () {
            if (DOM.get(id)) {
              self.position(id);
            }
          });
        }

        // Register events
        Event.add(id, 'mousedown', function (e) {
          var n = e.target;

          if (/(input|select|textarea|button|label)/i.test(n.nodeName)) {
            return;
          }

          self.focus(id);

          // ignore if the target is the close button, as this has it's own onclick event
          if (DOM.hasClass(n, '.mceModalClose')) {
            return;
          }

          if (f.fixed) {
            return;
          }

          if (DOM.hasClass(n, 'mceModalMove') || DOM.hasClass(n.parentNode, 'mceModalMove')) {
            return self._startDrag(id, e, 'Move');
          }
        });

        // Add window
        self.windows[id] = win = {
          id: id,
          features: f,
          elm: DOM.get(id),
          moveTo: function (x, y) {
            return self.moveTo(id, x, y);
          },
          close: function () {
            return self.close(null, id);
          },
          focus: function () {
            return self.focus(id);
          }
        };

        if (f.open && typeof f.open === "function") {
          f.open.call(win || self, win);
        }

        DOM.setAttrib(id, 'aria-hidden', 'false');

        // position modal
        self.position(id);

        // focus modal
        self.focus(id);

        self.count++;

        return win;
      },

      /**
       * Closes the specified window. This will also dispatch out a onClose event.
       *
       * @method close
       * @param {Window} win Window object to close.
       * @param {String} id Id of window to close.
       */
      close: function (win, id) {
        var self = this, id;

        id = self._findId(id || win);

        win = self.windows[id] || self._frontWindow();

        // Probably not inline
        if (!win) {
          return false;
        }

        self.count--;

        // only 1 window open, so remove modal structure
        if (self.count === 0) {
          DOM.remove(DOM.select('.mceModal'));
          DOM.setAttrib(DOM.doc.body, 'aria-hidden', 'false');
          self.editor.focus();
        }

        self.onClose.dispatch(self, win);

        var f = win.features || {};

        if (f.close && typeof f.close === "function") {
          f.close.call(win || self, win);
        }

        Event.clear(id);
        Event.clear(id + '_ifr');
        //DOM.setAttrib(id + '_ifr', 'src', 'about:blank'); // Prevent leak

        // remove frame
        DOM.remove(id + '_frame');
        DOM.remove(id);

        delete this.windows[id];

        if (self.count > 0) {
          var fw = this._frontWindow();

          if (fw) {
            fw.focus();
          }
        }

        return true;
      },

      setTitle: function (win, title) {
        var elm, id;

        id = this._findId(win);

        elm = DOM.get(id + '_title');

        if (elm && !elm.innerHTML) {
          elm.innerHTML = DOM.encode(title);
        }
      },

      /**
       * Creates a confirm dialog
       *
       * @method confirm
       * @param {String} t Title for the new confirm dialog.
       * @param {function} cb Callback function to be executed after the user has selected ok or cancel.
       * @param {Object} s Optional scope to execute the callback in.
       * @example
       * // Displays an confirm box and an alert message will be displayed depending on what you choose in the confirm
       * tinyMCE.activeEditor.windowManager.confirm("Do you want to do something", function(s) {
       *    if (s)
       *       tinyMCE.activeEditor.windowManager.alert("Ok");
       *    else
       *       tinyMCE.activeEditor.windowManager.alert("Cancel");
       * });
       */
      confirm: function (options, cb, s) {
        var self = this;

        if (tinymce.is(options, 'string')) {
          options = { text: options };
        }

        options = tinymce.extend({
          title: ''
        }, options);

        self.open({
          title: self.editor.getLang(options.title, options.title),
          type: 'confirm',
          buttons: [
            {
              title: self.editor.getLang('no', 'No'),
              id: 'cancel'
            },
            {
              title: self.editor.getLang('yes', 'Yes'),
              id: 'ok',
              classes: 'primary',
              autofocus: true,
              onsubmit: function (s) {
                if (cb) {
                  cb.call(s || self, s);
                }
              }
            }
          ],
          content: '<p>' + DOM.encode(self.editor.getLang(options.text, options.text)) + '</p>'
        });
      },

      /**
       * Creates a alert dialog
       *
       * @method alert
       * @param {String} options Text of options object.
       * @param {function} cb Callback function to be executed after the user has selected ok.
       * @param {Object} s Optional scope to execute the callback in.
       * @example
       * // Displays an alert box using the active editors window manager instance
       * tinyMCE.activeEditor.windowManager.alert('Hello world!');
       */
      alert: function (options, cb, s) {
        var self = this;

        if (tinymce.is(options, 'string')) {
          options = { text: options };
        }

        options = tinymce.extend({
          title: ''
        }, options);

        self.open({
          title: self.editor.getLang(options.title, options.title),
          type: 'alert',
          buttons: [
            {
              title: self.editor.getLang('cancel', 'Cancel'),
              id: 'cancel'
            },
            {
              title: self.editor.getLang('ok', 'Ok'),
              id: 'ok',
              classes: 'primary',
              autofocus: true,
              onsubmit: function (s) {
                if (cb) {
                  cb.call(s || self, s);
                }
              }
            }
          ],
          content: '<p>' + DOM.encode(self.editor.getLang(options.text, options.text)) + '</p>'
        });
      },

      prompt: function (options, cb, s) {
        var self = this;

        if (tinymce.is(options, 'string')) {
          options = { text: options };
        }

        options = tinymce.extend({
          title: ''
        }, options);

        var html = '<div class="mceModalRow">' +
          '   <div class="mceModalControl">' +
          '       <input type="text" id="' + self.editor.id + '_prompt_input" autofocus />' +
          '   </div>' +
          '</div>';

        self.open({
          title: self.editor.getLang(options.title, options.title),
          type: 'prompt',
          buttons: [
            {
              title: self.editor.getLang('cancel', 'Cancel'),
              id: 'cancel'
            },
            {
              title: self.editor.getLang('ok', 'Ok'),
              id: 'ok',
              classes: 'primary',
              autofocus: true,
              onsubmit: function () {
                var value = DOM.getValue(self.editor.id + '_prompt_input');
                // encode
                value = DOM.encode(value);

                if (cb) {
                  cb.call(s || self, value);
                }
              }
            }
          ],
          content: html
        });
      },

      /**
       * Resizes the specified window or id.
       *
       * @param {Number} dw Delta width.
       * @param {Number} dh Delta height.
       * @param {window/id} win Window if the dialog isn't inline. Id if the dialog is inline.
       */
      resizeBy: function (dw, dh, id) {
      },

      moveTo: function (id, x, y) {
        DOM.setStyles(id, { 'left': x, 'top': y });
      },

      position: function (id) {
        var p = DOM.getRect(id),
          vp = DOM.getViewPort();

        var top = Math.round(Math.max(vp.y + 10, vp.y + (vp.h / 2.0) - (p.h / 2.0)));
        var left = Math.round(Math.max(vp.x + 10, vp.x + (vp.w / 2.0) - (p.w / 2.0)));

        left = Math.max(0, left - 10);

        DOM.setStyles(id, { 'left': left, 'top': top });
      },

      focus: function (id) {
        var win = this.windows[id];

        if (!win) {
          return;
        }

        win.zIndex = this.zIndex++;
        DOM.setStyle(id + '_frame', 'zIndex', win.zIndex);

        DOM.removeClass(this.lastId, 'mceFocus');
        DOM.addClass(id + '_frame', 'mceFocus');

        this.lastId = id + '_frame';

        DOM.get(id).focus();

        if (DOM.get(id + '_ifr')) {
          DOM.get(id + '_ifr').focus();
        } else {
          var nodes = DOM.select('input, select, button, textarea', DOM.get(id));

          nodes[0].focus();

          for (var i = 0; i < nodes.length; i++) {
            var node = nodes[i];

            if (node.getAttribute('tabindex') >= 0) {
              if (node.getAttribute('autofocus')) {
                node.focus();
                break;
              }
            }
          }
        }
      },

      // Internal functions
      _startDrag: function (id, se, ac) {
        var mu, mm, d = DOM.doc,
          sx, sy;

        if (DOM.hasClass(id, 'dragging')) {
          end();
          return;
        }

        updateWithTouchData(se);

        var p = DOM.getRect(id);
        var vp = DOM.getViewPort();

        // Reduce viewport size to avoid scrollbars while dragging
        vp.w -= 2;
        vp.h -= 2;

        DOM.addClass(id, 'dragging');

        sx = se.screenX;
        sy = se.screenY;

        function end() {
          Event.remove(d, 'mouseup touchend', mu);
          Event.remove(d, 'mousemove touchmove', mm);

          DOM.removeClass(id, 'dragging');
        }

        // Handle mouse up
        mu = Event.add(d, 'mouseup touchend', function (e) {
          updateWithTouchData(e);

          end();

          return Event.cancel(e);
        });

        // Handle mouse move/drag
        mm = Event.add(d, 'mousemove touchmove', function (e) {
          var x, y;

          updateWithTouchData(e);

          x = e.screenX - sx; // - vp.x;
          y = e.screenY - sy; // - vp.y;

          var dx = Math.max(p.x + x, 10);
          var dy = Math.max(p.y + y, 10);

          DOM.setStyles(id, { 'left': dx, 'top': dy });

          return Event.cancel(e);
        });
      },

      // Find front most window
      _frontWindow: function () {
        var fw, ix = 0;

        /*for (var i = 0; i < this.windows.length; i++) {
            var win = this.windows[i];
            if (win.zIndex > ix) {
                fw = win;
                ix = win.zIndex;
            }
        }*/

        tinymce.each(this.windows, function (win) {
          if (win.zIndex > ix) {
            fw = win;
            ix = win.zIndex;
          }
        });

        return fw;
      },

      _findId: function (w) {
        var self = this;

        if (typeof (w) == 'string') {
          return w;
        }

        each(self.windows, function (wo) {
          var ifr = DOM.get(wo.id + '_ifr');

          if (ifr && w == ifr.contentWindow) {
            w = wo.id;
            return false;
          }
        });

        return w;
      }
    });
  })(tinymce);

  /**
   * Formatter.js
   *
   * Copyright, Moxiecode Systems AB
   * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
   * Released under LGPL License.
   *
   * License: http://www.tinymce.com/license - Inactive
   * Licence: GNU/LGPL 2.1 or later - http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
   * Contributing: http://www.tinymce.com/contributing - Inactive
   */

  (function (tinymce) {
    /**
     * Text formatter engine class. This class is used to apply formats like bold, italic, font size
     * etc to the current selection or specific nodes. This engine was build to replace the browsers
     * default formatting logic for execCommand due to it's inconsistant and buggy behavior.
     *
     * @class tinymce.Formatter
     * @example
     *  tinymce.activeEditor.formatter.register('mycustomformat', {
     *    inline : 'span',
     *    styles : {color : '#ff0000'}
     *  });
     *
     *  tinymce.activeEditor.formatter.apply('mycustomformat');
     */

    /**
     * Constructs a new formatter instance.
     *
     * @constructor Formatter
     * @param {tinymce.Editor} ed Editor instance to construct the formatter engine to.
     */
    tinymce.Formatter = function (ed) {
      var formats = {},
        each = tinymce.each,
        dom = ed.dom,
        selection = ed.selection,
        TreeWalker = tinymce.dom.TreeWalker,
        rangeUtils = new tinymce.dom.RangeUtils(dom),
        isValidChild = ed.schema.isValidChild,
        isBlock = dom.isBlock,
        forcedRootBlock = ed.settings.forced_root_block,
        nodeIndex = dom.nodeIndex,
        INVISIBLE_CHAR = '\uFEFF',
        MCE_ATTR_RE = /^(src|href|style)$/,
        FALSE = false,
        TRUE = true,
        formatChangeData,
        undef,
        getContentEditable = dom.getContentEditable;

      var hasCaretNodeSibling = function (node) {
        var sibling = node.parentNode.firstChild;

        while (sibling) {
          if (sibling !== node && isCaretNode(sibling)) {
            return true;
          }

          sibling = sibling.nextSibling;
        }

        return false;
      };

      var canFormatBR = function (editor, format, node, parentName) {
        // TINY-6483: Can format 'br' if it is contained in a valid empty block and an inline format is being applied
        if (editor.settings.format_empty_lines !== false && format.inline && node.parentNode) {
          
          // allow links to wrap br tags
          if (format.inline == 'a') {
            return true;
          }

          var validBRParentElements = editor.schema.getTextRootBlockElements();

          // If a caret node is present, the format should apply to that, not the br (applicable to collapsed selections)
          return validBRParentElements[parentName] && !editor.dom.isEmpty(node.parentNode) && !hasCaretNodeSibling(node);
        }

        return false;
      };

      function isTextBlock(name) {
        if (name.nodeType) {
          name = name.nodeName;
        }

        return !!ed.schema.getTextBlockElements()[name.toLowerCase()];
      }

      function isShortEnded(node) {
        return !!ed.schema.getShortEndedElements()[node.nodeName.toLowerCase()];
      }

      function isTableCell(node) {
        return /^(TH|TD)$/.test(node.nodeName);
      }

      function isInlineBlock(node) {
        return node && /^(IMG)$/.test(node.nodeName);
      }

      function getParents(node, selector) {
        return dom.getParents(node, selector, dom.getRoot());
      }

      function isCaretNode(node) {
        return node.nodeType === 1 && node.id === '_mce_caret';
      }

      function isBogusBr(node) {
        return node.nodeName == "BR" && node.getAttribute('data-mce-bogus') && !node.nextSibling;
      }

      function isFigure(node) {
        return getParents(node, 'FIGURE') && node.nodeName != 'FIGURE';
      }

      function defaultFormats() {
        register({
          valigntop: [
            {
              selector: 'td,th',
              styles: {
                'verticalAlign': 'top'
              }
            }
          ],

          valignmiddle: [
            {
              selector: 'td,th',
              styles: {
                'verticalAlign': 'middle'
              }
            }
          ],

          valignbottom: [
            {
              selector: 'td,th',
              styles: {
                'verticalAlign': 'bottom'
              }
            }
          ],

          alignleft: [
            {
              selector: 'figure,figcaption,p,h1,h2,h3,h4,h5,h6,td,th,tr,div,ul,ol,li',
              styles: {
                textAlign: 'left'
              },
              defaultBlock: 'div',
              inherit: false
            },
            {
              selector: 'figure[data-mce-image]',
              collapsed: false,
              ceFalseOverride: true,
              styles: {
                'float': 'left'
              }
            },
            {
              selector: 'img,table',
              collapsed: false,
              styles: {
                'float': 'left'
              }
            }
          ],

          aligncenter: [
            {
              selector: 'figure,figcaption,p,h1,h2,h3,h4,h5,h6,td,th,tr,div,ul,ol,li',
              styles: {
                textAlign: 'center'
              },
              defaultBlock: 'div',
              inherit: false
            },
            {
              selector: 'figure[data-mce-image]',
              collapsed: false,
              ceFalseOverride: true,
              styles: {
                marginLeft: 'auto',
                marginRight: 'auto',
                display: 'table'
              }
            },
            {
              selector: 'img',
              collapsed: false,
              styles: {
                display: 'block',
                marginLeft: 'auto',
                marginRight: 'auto'
              }
            },
            {
              selector: 'table',
              collapsed: false,
              styles: {
                marginLeft: 'auto',
                marginRight: 'auto'
              }
            }
          ],

          alignright: [
            {
              selector: 'figure,figcaption,p,h1,h2,h3,h4,h5,h6,td,th,tr,div,ul,ol,li',
              styles: {
                textAlign: 'right'
              },
              defaultBlock: 'div',
              inherit: false
            },
            {
              selector: 'figure[data-mce-image]',
              collapsed: false,
              ceFalseOverride: true,
              styles: {
                'float': 'right'
              }
            },
            {
              selector: 'img,table',
              collapsed: false,
              styles: {
                'float': 'right'
              }
            }
          ],

          alignfull: [
            {
              selector: 'figure,figcaption,p,h1,h2,h3,h4,h5,h6,td,th,div,ul,ol,li',
              styles: {
                textAlign: 'justify'
              },
              defaultBlock: 'div',
              inherit: false
            }
          ],

          bold: [
            {
              inline: 'strong',
              remove: 'all'
            },
            {
              inline: 'span',
              styles: {
                fontWeight: 'bold'
              }
            },
            {
              inline: 'b',
              remove: 'all'
            }
          ],

          italic: [
            {
              inline: 'em',
              remove: 'all'
            },
            {
              inline: 'span',
              styles: {
                fontStyle: 'italic'
              }
            },
            {
              inline: 'i',
              remove: 'all'
            }
          ],

          underline: [
            {
              inline: 'span',
              styles: {
                textDecoration: 'underline'
              },
              exact: true
            },
            {
              inline: 'u',
              remove: 'all'
            }
          ],

          strikethrough: [
            {
              inline: 'span',
              styles: {
                textDecoration: 'line-through'
              },
              exact: true
            },
            {
              inline: 'strike',
              remove: 'all'
            }
          ],

          forecolor: {
            inline: 'span',
            styles: {
              color: '%value'
            },
            links: true,
            remove_similar: true
          },

          hilitecolor: {
            inline: 'span',
            styles: {
              backgroundColor: '%value'
            },
            links: true,
            remove_similar: true
          },

          fontname: {
            inline: 'span',
            styles: {
              fontFamily: '%value'
            }
          },

          fontsize: {
            inline: 'span',
            styles: {
              fontSize: '%value'
            }
          },

          fontsize_class: {
            inline: 'span',
            attributes: {
              'class': '%value'
            }
          },

          blockquote: {
            block: 'blockquote',
            wrapper: true,
            remove: 'all'
          },

          subscript: {
            inline: 'sub'
          },

          superscript: {
            inline: 'sup'
          },

          code: {
            inline: 'code'
          },

          link: {
            inline: 'a',
            selector: 'a',
            remove: 'all',
            split: true,
            deep: true,
            onmatch: function () {
              return true;
            },

            onformat: function (elm, fmt, vars) {
              each(vars, function (value, key) {
                dom.setAttrib(elm, key, value);
              });
            }
          },

          removeformat: [
            {
              selector: 'b,strong,em,i,font,u,strike,sub,sup,dfn,code,samp,kbd,var,cite,mark,q,del,ins',
              remove: 'all',
              split: true,
              expand: false,
              block_expand: true,
              deep: true
            },
            {
              selector: 'span',
              attributes: ['style', 'class'],
              remove: 'empty',
              split: true,
              expand: false,
              deep: true
            },
            {
              selector: '*',
              attributes: ['style', 'class'],
              split: false,
              expand: false,
              deep: true
            }
          ]
        });

        // Register default block formats
        each('p h1 h2 h3 h4 h5 h6 div address pre div code samp dt dd dl'.split(/\s/), function (name) {
          register(name, {
            block: name,
            remove: 'all'
          });
        });

        // Register user defined formats
        register(ed.settings.formats);
      }

      function addKeyboardShortcuts() {
        // Add some inline shortcuts
        ed.addShortcut('meta+b', 'bold_desc', 'Bold');
        ed.addShortcut('meta+i', 'italic_desc', 'Italic');
        ed.addShortcut('meta+u', 'underline_desc', 'Underline');

        // BlockFormat shortcuts keys
        for (var i = 1; i <= 6; i++) {
          ed.addShortcut('access+' + i, '', ['FormatBlock', false, 'h' + i]);
        }

        ed.addShortcut('access+7', '', ['FormatBlock', false, 'p']);
        ed.addShortcut('access+8', '', ['FormatBlock', false, 'div']);
        ed.addShortcut('access+9', '', ['FormatBlock', false, 'address']);
      }

      // Public functions

      /**
       * Returns the format by name or all formats if no name is specified.
       *
       * @method get
       * @param {String} name Optional name to retrive by.
       * @return {Array/Object} Array/Object with all registred formats or a specific format.
       */
      function get(name) {
        return name ? formats[name] : formats;
      }

      /**
       * Registers a specific format by name.
       *
       * @method register
       * @param {Object/String} name Name of the format for example "bold".
       * @param {Object/Array} format Optional format object or array of format variants can only be omitted if the first arg is an object.
       */
      function register(name, format) {
        if (name) {
          if (typeof (name) !== 'string') {
            each(name, function (format, name) {
              register(name, format);
            });
          } else {
            // Force format into array and add it to internal collection
            format = format.length ? format : [format];

            each(format, function (format) {
              // Set deep to false by default on selector formats this to avoid removing
              // alignment on images inside paragraphs when alignment is changed on paragraphs
              if (format.deep === undef) {
                format.deep = !format.selector;
              }

              // Default to true
              if (format.split === undef) {
                format.split = !format.selector || format.inline;
              }

              // Default to true
              if (format.remove === undef && format.selector && !format.inline) {
                format.remove = 'none';
              }

              // Mark format as a mixed format inline + block level
              if (format.selector && format.inline) {
                format.mixed = true;
                format.block_expand = true;
              }

              // Split classes if needed
              if (typeof (format.classes) === 'string') {
                format.classes = format.classes.split(/\s+/);
              }
            });

            if (formats[name]) {
              var current = formats[name];

              // Force collection into array
              current = current.length ? current : [current];

              formats[name] = current.concat(format);
            } else {
              formats[name] = format;
            }
          }
        }
      }

      /**
       * Unregister a specific format by name.
       *
       * @method unregister
       * @param {String} name Name of the format for example "bold".
       */
      function unregister(name) {
        if (name && formats[name]) {
          delete formats[name];
        }

        return formats;
      }

      function matchesUnInheritedFormatSelector(node, name) {
        var formatList = get(name);

        if (formatList) {
          for (var i = 0; i < formatList.length; i++) {
            if (formatList[i].inherit === false && formatList[i].selector && dom.is(node, formatList[i].selector)) {
              return true;
            }
          }
        }

        return false;
      }

      function getTextDecoration(node) {
        var decoration;

        ed.dom.getParent(node, function (n) {
          decoration = ed.dom.getStyle(n, 'text-decoration');
          return decoration && decoration !== 'none';
        });

        return decoration;
      }

      function processUnderlineAndColor(node) {
        var textDecoration;
        if (node.nodeType === 1 && node.parentNode && node.parentNode.nodeType === 1) {
          textDecoration = getTextDecoration(node.parentNode);
          if (ed.dom.getStyle(node, 'color') && textDecoration) {
            ed.dom.setStyle(node, 'text-decoration', textDecoration);
          } else if (ed.dom.getStyle(node, 'text-decoration') === textDecoration) {
            ed.dom.setStyle(node, 'text-decoration', null);
          }
        }
      }

      /**
       * Applies the specified format to the current selection or specified node.
       *
       * @method apply
       * @param {String} name Name of format to apply.
       * @param {Object} vars Optional list of variables to replace within format before applying it.
       * @param {Node} node Optional node to apply the format to defaults to current selection.
       */
      function apply(name, vars, node) {
        var formatList = get(name),
          format = formatList[0],
          bookmark, rng, isCollapsed = !node && selection.isCollapsed();

        function setElementFormat(elm, fmt) {
          fmt = fmt || format;

          if (elm) {
            each(fmt.styles, function (value, name) {
              dom.setStyle(elm, name, replaceVars(value, vars));
            });

            // Needed for the WebKit span spam bug
            // TODO: Remove this once WebKit/Blink fixes this
            if (fmt.styles) {
              var styleVal = dom.serializeStyle(dom.parseStyle(elm.style.cssText), elm.nodeName);

              if (styleVal) {
                elm.setAttribute('data-mce-style', styleVal);
              }
            }

            each(fmt.attributes, function (value, name) {
              dom.setAttrib(elm, name, replaceVars(value, vars));
            });

            each(fmt.classes, function (value) {
              value = replaceVars(value, vars);

              if (!dom.hasClass(elm, value)) {
                dom.addClass(elm, value);
              }
            });

            if (fmt.onformat) {
              fmt.onformat(elm, fmt, vars, node);
            }
          }
        }

        function applyNodeStyle(formatList, node) {
          var found = false;

          if (!format.selector) {
            return false;
          }

          // Look for matching formats
          each(formatList, function (format) {
            // Check collapsed state if it exists
            if ('collapsed' in format && format.collapsed !== isCollapsed) {
              return;
            }

            // apply format to element, but not caret node
            if (dom.is(node, format.selector) && !isCaretNode(node) && !isBogusBr(node)) {
              setElementFormat(node, format);
              found = true;
              return false;
            }
          });

          return found;
        }

        // This converts: <p>[a</p><p>]b</p> -> <p>[a]</p><p>b</p>
        function adjustSelectionToVisibleSelection() {
          function findSelectionEnd(start, end) {
            var walker = new TreeWalker(end);
            for (node = walker.prev2(); node; node = walker.prev2()) {
              if (node.nodeType == 3 && node.data.length > 0) {
                return node;
              }

              if (node.childNodes.length > 1 || node == start || node.tagName == 'BR') {
                return node;
              }
            }
          }

          // Adjust selection so that a end container with a end offset of zero is not included in the selection
          // as this isn't visible to the user.
          var rng = selection.getRng();
          var start = rng.startContainer;
          var end = rng.endContainer;

          if (start != end && rng.endOffset === 0) {
            var newEnd = findSelectionEnd(start, end);
            var endOffset = newEnd.nodeType == 3 ? newEnd.data.length : newEnd.childNodes.length;

            rng.setEnd(newEnd, endOffset);
          }

          return rng;
        }

        function applyRngStyle(rng, bookmark, node_specific) {
          var newWrappers = [],
            wrapName, wrapElm, contentEditable = true;

          // Setup wrapper element
          wrapName = format.inline || format.block;
          wrapElm = dom.create(wrapName);

          setElementFormat(wrapElm);

          rangeUtils.walk(rng, function (nodes) {
            var currentWrapElm;

            /**
             * Process a list of nodes wrap them.
             */
            function process(node) {
              var nodeName, parentName, found, hasContentEditableState, lastContentEditable;

              if (isBogusBr(node) || isBookmarkNode(node)) {
                return;
              }

              lastContentEditable = contentEditable;
              nodeName = node.nodeName.toLowerCase();
              parentName = node.parentNode.nodeName.toLowerCase();

              // Node has a contentEditable value
              if (node.nodeType === 1 && getContentEditable(node)) {
                lastContentEditable = contentEditable;
                contentEditable = getContentEditable(node) === "true";
                hasContentEditableState = !isShortEnded(node); // We don't want to wrap the container only it's children
              }

              // Stop wrapping on br elements, but skip links
              if (isEq(nodeName, 'br') && !canFormatBR(ed, format, node, parentName)) {
                currentWrapElm = 0;

                // Remove any br elements when we wrap things
                if (format.block) {
                  dom.remove(node);
                }

                return;
              }

              // If node is wrapper type
              if (format.wrapper && matchNode(node, name, vars)) {
                currentWrapElm = 0;
                return;
              }

              // Can we rename the block
              // TODO: Break this if up, too complex
              if (contentEditable && !hasContentEditableState && format.block &&
                !format.wrapper && isTextBlock(nodeName) && isValidChild(parentName, wrapName)) {
                node = dom.rename(node, wrapName);
                setElementFormat(node);
                newWrappers.push(node);
                currentWrapElm = 0;
                return;
              }

              // Handle selector patterns
              if (format.selector) {
                // Look for matching formats
                found = applyNodeStyle(formatList, node);

                // Continue processing if a selector match wasn't found and a inline element is defined
                if (!format.inline || found) {
                  currentWrapElm = 0;
                  return;
                }
              }

              function isBOM(node) {
                return !node_specific && node.nodeType === 3 && node.nodeValue.length === 1 && node.nodeValue.charCodeAt(0) === 65279;
              }

              // Is it valid to wrap this item
              // TODO: Break this if up, too complex
              if (contentEditable && !hasContentEditableState && isValidChild(wrapName, nodeName) && isValidChild(parentName, wrapName) &&
                !isBOM(node) &&
                !isCaretNode(node) &&
                !isBogusBr(node) &&
                !isBookmarkNode(node) &&
                (!format.inline || !isBlock(node))) {

                // Start wrapping
                if (!currentWrapElm) {
                  // Wrap the node
                  currentWrapElm = dom.clone(wrapElm, FALSE);
                  node.parentNode.insertBefore(currentWrapElm, node);
                  newWrappers.push(currentWrapElm);
                }

                currentWrapElm.appendChild(node);
              } else {
                // Start a new wrapper for possible children
                currentWrapElm = 0;

                each(tinymce.grep(node.childNodes), process);

                if (hasContentEditableState) {
                  contentEditable = lastContentEditable; // Restore last contentEditable state from stack
                }

                // End the last wrapper
                currentWrapElm = 0;
              }
            }

            // Process siblings from range
            each(nodes, process);
          });

          // Apply formats to links as well to get the color of the underline to change as well
          if (format.links === true || format.wrap_links === false) {
            each(newWrappers, function (node) {
              function process(node) {
                if (node.nodeName === 'A') {
                  setElementFormat(node, format);
                }

                each(tinymce.grep(node.childNodes), process);
              }

              process(node);
            });
          }

          // Cleanup
          each(newWrappers, function (node) {
            var childCount;

            function getChildCount(node) {
              var count = 0;

              each(node.childNodes, function (node) {
                if (!isWhiteSpaceNode(node) && !isBookmarkNode(node)) {
                  count++;
                }
              });

              return count;
            }

            function getChildElementNode(root) {
              var child = false;
              each(root.childNodes, function (node) {
                if (isElementNode(node)) {
                  child = node;
                  return false; // break loop
                }
              });
              return child;
            }

            function mergeStyles(node) {
              var child, clone;

              child = getChildElementNode(node);

              // If child was found and of the same type as the current node
              if (child && !isBookmarkNode(child) && matchName(child, format)) {
                clone = dom.clone(child, FALSE);
                setElementFormat(clone);

                dom.replace(clone, node, TRUE);
                dom.remove(child, 1);
              }

              return clone || node;
            }

            childCount = getChildCount(node);

            // Remove empty nodes but only if there is multiple wrappers and they are not block
            // elements so never remove single <h1></h1> since that would remove the currrent empty block element where the caret is at
            if ((newWrappers.length > 1 || !isBlock(node)) && childCount === 0) {
              dom.remove(node, 1);
              return;
            }

            // remove leading linebreak, eg: <div><br />Some text</div>
            if (childCount > 1 && isEq(node.firstChild.nodeName, 'BR')) {
              dom.remove(node.firstChild);
            }

            // fontSize defines the line height for the whole branch of nested style wrappers,
            // therefore it should be set on the outermost wrapper
            /*if (!isBlock(node) && !getStyle(node, 'fontSize')) {
              var styleNode = matchNestedWrapper(node, hasStyle('fontSize'));
              if (styleNode) {
                apply('fontsize', {value: getStyle(styleNode, 'fontSize')}, node);
              }
            }*/

            if (format.inline || format.wrapper) {
              // Merges the current node with it's children of similar type to reduce the number of elements
              if (!format.exact && childCount === 1) {
                node = mergeStyles(node);
              }

              // Remove/merge children
              each(formatList, function (format) {
                // Merge all children of similar type will move styles from child to parent
                // this: <span style="color:red"><b><span style="color:red; font-size:10px">text</span></b></span>
                // will become: <span style="color:red"><b><span style="font-size:10px">text</span></b></span>
                each(dom.select(format.inline, node), function (child) {
                  if (isBookmarkNode(child)) {
                    return;
                  }

                  removeFormat(format, vars, child, format.exact ? child : null);
                });
              });

              // Remove child if direct parent is of same type
              if (matchNode(node.parentNode, name, vars)) {
                dom.remove(node, 1);
                node = 0;
                return TRUE;
              }

              // Look for parent with similar style format
              if (format.merge_with_parents) {
                dom.getParent(node.parentNode, function (parent) {
                  if (matchNode(parent, name, vars)) {
                    dom.remove(node, 1);
                    node = 0;
                    return TRUE;
                  }
                });
              }

              // Merge next and previous siblings if they are similar <b>text</b><b>text</b> becomes <b>texttext</b>
              if (node && format.merge_siblings !== false) {
                node = mergeSiblings(getNonWhiteSpaceSibling(node), node);
                node = mergeSiblings(node, getNonWhiteSpaceSibling(node, TRUE));
              }
            }
          });
        }

        if (getContentEditable(selection.getNode()) === "false") {
          node = selection.getNode();

          for (var i = 0, l = formatList.length; i < l; i++) {
            if ((formatList[i].ceFalseOverride) && formatList[i].selector && dom.is(node, formatList[i].selector)) {
              setElementFormat(node, formatList[i]);
              return true;
            }
          }

          return;
        }

        if (format) {
          // check for parent node for active node?
          if (node && node.parentNode) {
            if (node.nodeType) {
              if (!applyNodeStyle(formatList, node)) {
                rng = dom.createRng();
                rng.setStartBefore(node);
                rng.setEndAfter(node);
                applyRngStyle(expandRng(rng, formatList), null, true);
              }
            } else {
              applyRngStyle(node, null, true);
            }
          } else {
            if (!isCollapsed || !format.inline || dom.select('td.mceSelected,th.mceSelected,div.mceSelected').length) {
              // Obtain selection node before selection is unselected by applyRngStyle()
              var curSelNode = selection.getNode();

              // If the formats have a default block and we can't find a parent block then start wrapping it with a DIV this is for forced_root_blocks: false
              // It's kind of a hack but people should be using the default block type P since all desktop editors work that way
              if (!forcedRootBlock && formatList[0].defaultBlock && !dom.getParent(curSelNode, dom.isBlock)) {
                apply(formatList[0].defaultBlock);
              }

              // Apply formatting to selection
              selection.setRng(adjustSelectionToVisibleSelection());
              bookmark = selection.getBookmark();
              applyRngStyle(expandRng(selection.getRng(TRUE), formatList));

              // Colored nodes should be underlined so that the color of the underline matches the text color.
              if (format.styles && (format.styles.color || format.styles.textDecoration)) {
                tinymce.walk(curSelNode, processUnderlineAndColor, 'childNodes');
                processUnderlineAndColor(curSelNode);
              }

              selection.moveToBookmark(bookmark);
              moveStart(selection.getRng(TRUE));
              ed.nodeChanged();
            } else {
              performCaretAction('apply', name, vars);
            }
          }
        }
      }

      /**
       * Removes the specified format from the current selection or specified node.
       *
       * @method remove
       * @param {String} name Name of format to remove.
       * @param {Object} vars Optional list of variables to replace within format before removing it.
       * @param {Node/Range} node Optional node or DOM range to remove the format from defaults to current selection.
       */
      function remove(name, vars, node, similar) {
        var formatList = get(name),
          format = formatList[0],
          bookmark, rng, contentEditable = true;

        // Merges the styles for each node
        function process(node) {
          var children, i, l;

          // Node has a contentEditable value
          if (node.nodeType === 1 && getContentEditable(node)) {
            contentEditable = getContentEditable(node) === "true";
          }

          // Grab the children first since the nodelist might be changed
          children = tinymce.grep(node.childNodes);

          // Process current node
          if (contentEditable || format.ceFalseOverride || isFigure(node)) {
            for (i = 0, l = formatList.length; i < l; i++) {
              if (removeFormat(formatList[i], vars, node, node)) {
                break;
              }
            }
          }

          // Process the children
          if (format.deep) {
            if (children.length) {
              for (i = 0, l = children.length; i < l; i++) {
                process(children[i]);
              }
            }
          }
        }

        function findFormatRoot(container) {
          var formatRoot;

          // Find format root
          each(getParents(container.parentNode).reverse(), function (parent) {
            var format;

            // Find format root element
            if (!formatRoot && parent.id != '_start' && parent.id != '_end') {
              // Is the node matching the format we are looking for
              format = matchNode(parent, name, vars, similar);
              if (format && format.split !== false) {
                formatRoot = parent;
              }
            }
          });

          return formatRoot;
        }

        function wrapAndSplit(formatRoot, container, target, split) {
          var parent, clone, lastClone, firstClone, i, formatRootParent;

          // Format root found then clone formats and split it
          if (formatRoot) {
            formatRootParent = formatRoot.parentNode;

            for (parent = container.parentNode; parent && parent != formatRootParent; parent = parent.parentNode) {
              clone = dom.clone(parent, FALSE);

              for (i = 0; i < formatList.length; i++) {
                if (removeFormat(formatList[i], vars, clone, clone)) {
                  clone = 0;
                  break;
                }
              }

              // Build wrapper node
              if (clone) {
                if (lastClone) {
                  clone.appendChild(lastClone);
                }

                if (!firstClone) {
                  firstClone = clone;
                }

                lastClone = clone;
              }
            }

            // Never split block elements if the format is mixed
            if ((!format.mixed || !isBlock(formatRoot))) {
              container = dom.split(formatRoot, container);
            }

            // Wrap container in cloned formats
            if (lastClone) {
              target.parentNode.insertBefore(lastClone, target);
              firstClone.appendChild(target);
            }
          }

          return container;
        }

        function splitToFormatRoot(container) {
          return wrapAndSplit(findFormatRoot(container), container, container);
        }

        function unwrap(start) {
          var node = dom.get(start ? '_start' : '_end'),
            out = node[start ? 'firstChild' : 'lastChild'];

          // If the end is placed within the start the result will be removed
          // So this checks if the out node is a bookmark node if it is it
          // checks for another more suitable node
          if (isBookmarkNode(out)) {
            out = out[start ? 'firstChild' : 'lastChild'];
          }

          // Since dom.remove removes empty text nodes then we need to try to find a better node
          if (out.nodeType == 3 && out.data.length === 0) {
            out = start ? node.previousSibling || node.nextSibling : node.nextSibling || node.previousSibling;
          }

          dom.remove(node, true);

          return out;
        }

        function removeRngStyle(rng) {
          var startContainer, endContainer;
          var commonAncestorContainer = rng.commonAncestorContainer;

          rng = expandRng(rng, formatList, TRUE);

          if (format.split) {
            startContainer = getContainer(rng, TRUE);
            endContainer = getContainer(rng);

            if (startContainer != endContainer) {
              // WebKit will render the table incorrectly if we wrap a TH or TD in a SPAN
              // so let's see if we can use the first child instead
              // This will happen if you triple click a table cell and use remove formatting

              /*if (/^(TR|TH|TD)$/.test(startContainer.nodeName) && startContainer.firstChild) {
                if (startContainer.nodeName == "TR") {
                  startContainer = startContainer.firstChild.firstChild || startContainer;
                } else {
                  startContainer = startContainer.firstChild || startContainer;
                }
              }*/

              // Try to adjust endContainer as well if cells on the same row were selected - bug #6410
              if (commonAncestorContainer &&
                /^T(HEAD|BODY|FOOT|R)$/.test(commonAncestorContainer.nodeName) &&
                /^(TH|TD)$/.test(endContainer.nodeName) && endContainer.firstChild) {
                endContainer = endContainer.firstChild || endContainer;
              }

              if (dom.isChildOf(startContainer, endContainer) && !isBlock(endContainer) &&
                !isTableCell(startContainer) && !isTableCell(endContainer)) {
                startContainer = wrap(startContainer, 'span', {
                  id: '_start',
                  'data-mce-type': 'bookmark'
                });
                splitToFormatRoot(startContainer);
                startContainer = unwrap(TRUE);
              } else {
                // Wrap start/end nodes in span element since these might be cloned/moved
                startContainer = wrap(startContainer, 'span', {
                  id: '_start',
                  'data-mce-type': 'bookmark'
                });

                endContainer = wrap(endContainer, 'span', {
                  id: '_end',
                  'data-mce-type': 'bookmark'
                });

                // Split start/end
                splitToFormatRoot(startContainer);
                splitToFormatRoot(endContainer);

                // Unwrap start/end to get real elements again
                startContainer = unwrap(TRUE);
                endContainer = unwrap();
              }

            } else {
              startContainer = endContainer = splitToFormatRoot(startContainer);
            }

            // Update range positions since they might have changed after the split operations
            rng.startContainer = startContainer.parentNode ? startContainer.parentNode : startContainer;
            rng.startOffset = nodeIndex(startContainer);
            rng.endContainer = endContainer.parentNode ? endContainer.parentNode : endContainer;
            rng.endOffset = nodeIndex(endContainer) + 1;
          }

          // Remove items between start/end
          rangeUtils.walk(rng, function (nodes) {
            each(nodes, function (node) {
              process(node);

              // Remove parent span if it only contains text-decoration: underline, yet a parent node is also underlined.
              if (node.nodeType === 1 && ed.dom.getStyle(node, 'text-decoration') === 'underline' &&
                node.parentNode && getTextDecoration(node.parentNode) === 'underline') {
                removeFormat({
                  'deep': false,
                  'exact': true,
                  'inline': 'span',
                  'styles': {
                    'textDecoration': 'underline'
                  }
                }, null, node);
              }
            });
          });
        }

        // Handle node
        if (node) {
          if (node.nodeType) {
            rng = dom.createRng();
            rng.setStartBefore(node);
            rng.setEndAfter(node);
            removeRngStyle(rng);
          } else {
            removeRngStyle(node);
          }

          return;
        }

        if (getContentEditable(selection.getNode()) === "false") {
          node = selection.getNode();

          for (var i = 0, l = formatList.length; i < l; i++) {
            if (formatList[i].ceFalseOverride) {
              if (removeFormat(formatList[i], vars, node, node)) {
                break;
              }
            }
          }

          return;
        }

        if (!selection.isCollapsed() || !format.inline || dom.select('td.mceSelected,th.mceSelected,div.mceSelected').length) {
          bookmark = selection.getBookmark();
          removeRngStyle(selection.getRng(TRUE));
          selection.moveToBookmark(bookmark);

          // Check if start element still has formatting then we are at: "<b>text|</b>text" and need to move the start into the next text node
          if (format.inline && match(name, vars, selection.getStart())) {
            moveStart(selection.getRng(true));
          }

          ed.nodeChanged();
        } else {
          performCaretAction('remove', name, vars, similar);
        }
      }

      /**
       * Toggles the specified format on/off.
       *
       * @method toggle
       * @param {String} name Name of format to apply/remove.
       * @param {Object} vars Optional list of variables to replace within format before applying/removing it.
       * @param {Node} node Optional node to apply the format to or remove from. Defaults to current selection.
       */
      function toggle(name, vars, node) {
        var fmt = get(name);

        if (match(name, vars, node) && (!('toggle' in fmt[0]) || fmt[0].toggle)) {
          remove(name, vars, node);
        } else {
          apply(name, vars, node);
        }
      }

      /**
       * Return true/false if the specified node has the specified format.
       *
       * @method matchNode
       * @param {Node} node Node to check the format on.
       * @param {String} name Format name to check.
       * @param {Object} vars Optional list of variables to replace before checking it.
       * @param {Boolean} similar Match format that has similar properties.
       * @return {Object} Returns the format object it matches or undefined if it doesn't match.
       */
      function matchNode(node, name, vars, similar) {
        var formatList = get(name),
          format, i, classes;

        function matchItems(node, format, item_name) {
          var key, value, items = format[item_name],
            i;

          // Custom match
          if (format.onmatch) {
            return format.onmatch(node, format, item_name);
          }

          // Check all items
          if (items) {
            // Non indexed object
            if (items.length === undef) {
              for (key in items) {
                // eslint-disable-next-line no-prototype-builtins
                if (items.hasOwnProperty(key)) {
                  if (item_name === 'attributes') {
                    value = dom.getAttrib(node, key);
                  } else {
                    value = getStyle(node, key);
                  }

                  if (similar && !value && !format.exact) {
                    return;
                  }

                  if ((!similar || format.exact) && !isEq(value, normalizeStyleValue(replaceVars(items[key], vars), key))) {
                    return;
                  }
                }
              }
            } else {
              // Only one match needed for indexed arrays
              for (i = 0; i < items.length; i++) {
                if (item_name === 'attributes' ? dom.getAttrib(node, items[i]) : getStyle(node, items[i])) {
                  return format;
                }
              }
            }
          }

          return format;
        }

        if (formatList && node) {
          // Check each format in list
          for (i = 0; i < formatList.length; i++) {
            format = formatList[i];

            // Name name, attributes, styles and classes
            if (matchName(node, format) && matchItems(node, format, 'attributes') && matchItems(node, format, 'styles')) {
              // Match classes
              if ((classes = format.classes)) {
                for (i = 0; i < classes.length; i++) {
                  if (!dom.hasClass(node, classes[i])) {
                    return;
                  }
                }
              }

              return format;
            }
          }
        }
      }

      /**
       * Matches the current selection or specified node against the specified format name.
       *
       * @method match
       * @param {String} name Name of format to match.
       * @param {Object} vars Optional list of variables to replace before checking it.
       * @param {Node} node Optional node to check.
       * @return {boolean} true/false if the specified selection/node matches the format.
       */
      function match(name, vars, node) {
        var startNode;

        function matchParents(node) {
          var root = dom.getRoot();

          if (node === root) {
            return false;
          }

          // Find first node with similar format settings
          node = dom.getParent(node, function (node) {
            if (matchesUnInheritedFormatSelector(node, name)) {
              return true;
            }

            return node.parentNode === root || !!matchNode(node, name, vars, true);
          });

          // Do an exact check on the similar format element
          return matchNode(node, name, vars);
        }

        // Check specified node
        if (node) {
          return matchParents(node);
        }

        // Check selected node
        node = selection.getNode();

        if (matchParents(node)) {
          return TRUE;
        }

        // Check start node if it's different
        startNode = selection.getStart();

        if (startNode != node) {
          if (matchParents(startNode)) {
            return TRUE;
          }
        }

        return FALSE;
      }

      /**
       * Matches the current selection against the array of formats and returns a new array with matching formats.
       *
       * @method matchAll
       * @param {Array} names Name of format to match.
       * @param {Object} vars Optional list of variables to replace before checking it.
       * @return {Array} Array with matched formats.
       */
      function matchAll(names, vars) {
        var startElement, matchedFormatNames = [],
          checkedMap = {};

        // Check start of selection for formats
        startElement = selection.getStart();
        dom.getParent(startElement, function (node) {
          var i, name;

          for (i = 0; i < names.length; i++) {
            name = names[i];

            if (!checkedMap[name] && matchNode(node, name, vars)) {
              checkedMap[name] = true;
              matchedFormatNames.push(name);
            }
          }
        }, dom.getRoot());

        return matchedFormatNames;
      }

      /**
       * Returns true/false if the specified format can be applied to the current selection or not. It will currently only check the state for selector formats, it returns true on all other format types.
       *
       * @method canApply
       * @param {String} name Name of format to check.
       * @return {boolean} true/false if the specified format can be applied to the current selection/node.
       */
      function canApply(name) {
        var formatList = get(name),
          startNode, parents, i, x, selector;

        if (formatList) {
          startNode = selection.getStart();
          parents = getParents(startNode);

          for (x = formatList.length - 1; x >= 0; x--) {
            selector = formatList[x].selector;

            // Format is not selector based then always return TRUE
            // Is it has a defaultBlock then it's likely it can be applied for example align on a non block element line
            if (!selector || formatList[x].defaultBlock) {
              return TRUE;
            }

            for (i = parents.length - 1; i >= 0; i--) {
              if (dom.is(parents[i], selector)) {
                return TRUE;
              }
            }
          }
        }

        return FALSE;
      }

      /**
       * Executes the specified callback when the current selection matches the formats or not.
       *
       * @method formatChanged
       * @param {String} formats Comma separated list of formats to check for.
       * @param {function} callback Callback with state and args when the format is changed/toggled on/off.
       * @param {Boolean} similar True/false state if the match should handle similar or exact formats.
       */
      function formatChanged(formats, callback, similar) {
        var currentFormats;

        // Setup format node change logic
        if (!formatChangeData) {
          formatChangeData = {};
          currentFormats = {};

          ed.onNodeChange.addToTop(function (ed, cm, node) {
            var parents = getParents(node),
              matchedFormats = {};

            // Ignore bogus nodes like the <a> tag created by moveStart()
            parents = tinymce.grep(parents, function (node) {
              return node.nodeType == 1 && !node.getAttribute('data-mce-bogus');
            });

            // Check for new formats
            each(formatChangeData, function (callbacks, format) {
              each(parents, function (node) {
                if (matchNode(node, format, {}, callbacks.similar)) {
                  if (!currentFormats[format]) {
                    // Execute callbacks
                    each(callbacks, function (callback) {
                      callback(true, {
                        node: node,
                        format: format,
                        parents: parents
                      });
                    });

                    currentFormats[format] = callbacks;
                  }

                  matchedFormats[format] = callbacks;
                  return false;
                }

                if (matchesUnInheritedFormatSelector(node, format)) {
                  return false;
                }
              });
            });

            // Check if current formats still match
            each(currentFormats, function (callbacks, format) {
              if (!matchedFormats[format]) {
                delete currentFormats[format];

                each(callbacks, function (callback) {
                  callback(false, {
                    node: node,
                    format: format,
                    parents: parents
                  });
                });
              }
            });
          });
        }

        // Add format listeners
        each(formats.split(','), function (format) {
          if (!formatChangeData[format]) {
            formatChangeData[format] = [];
            formatChangeData[format].similar = similar;
          }

          formatChangeData[format].push(callback);
        });

        return this;
      }

      // Expose to public
      tinymce.extend(this, {
        get: get,
        register: register,
        unregister: unregister,
        apply: apply,
        remove: remove,
        toggle: toggle,
        match: match,
        matchAll: matchAll,
        matchNode: matchNode,
        canApply: canApply,
        formatChanged: formatChanged
      });

      // Initialize
      defaultFormats();
      addKeyboardShortcuts();

      // Private functions

      /**
       * Checks if the specified nodes name matches the format inline/block or selector.
       *
       * @private
       * @param {Node} node Node to match against the specified format.
       * @param {Object} format Format object o match with.
       * @return {boolean} true/false if the format matches.
       */
      function matchName(node, format) {
        // Check for inline match
        if (isEq(node, format.inline)) {
          return TRUE;
        }

        // Check for block match
        if (isEq(node, format.block)) {
          return TRUE;
        }

        // Check for selector match
        if (format.selector) {
          return node.nodeType == 1 && dom.is(node, format.selector);
        }
      }

      /**
       * Compares two string/nodes regardless of their case.
       *
       * @private
       * @param {String/Node} Node or string to compare.
       * @param {String/Node} Node or string to compare.
       * @return {boolean} True/false if they match.
       */
      function isEq(str1, str2) {
        str1 = str1 || '';
        str2 = str2 || '';

        str1 = '' + (str1.nodeName || str1);
        str2 = '' + (str2.nodeName || str2);

        return str1.toLowerCase() == str2.toLowerCase();
      }

      function isElementNode(node) {
        return node.nodeType == 1 && !isBookmarkNode(node) && !isWhiteSpaceNode(node) && !isCaretNode(node) && !isBogusBr(node);
      }

      /**
       * Returns the style by name on the specified node. This method modifies the style
       * contents to make it more easy to match. This will resolve a few browser issues.
       *
       * @private
       * @param {Node} node to get style from.
       * @param {String} name Style name to get.
       * @return {String} Style item value.
       */
      function getStyle(node, name) {
        return normalizeStyleValue(dom.getStyle(node, name), name);
      }
      /**
       * Normalize style value by name. This method modifies the style contents
       * to make it more easy to match. This will resolve a few browser issues.
       *
       * @private
       * @param {Node} node to get style from.
       * @param {String} name Style name to get.
       * @return {String} Style item value.
       */
      function normalizeStyleValue(value, name) {
        // Force the format to hex
        if (name == 'color' || name == 'backgroundColor') {
          value = dom.toHex(value);
        }

        // Opera will return bold as 700
        if (name == 'fontWeight' && value == 700) {
          value = 'bold';
        }

        // Normalize fontFamily so "'Font name', Font" becomes: "Font name,Font"
        if (name == 'fontFamily') {
          value = value.replace(/[\'\"]/g, '').replace(/,\s+/g, ',');
        }

        return '' + value;
      }

      /**
       * Replaces variables in the value. The variable format is %var.
       *
       * @private
       * @param {String} value Value to replace variables in.
       * @param {Object} vars Name/value array with variables to replace.
       * @return {String} New value with replaced variables.
       */
      function replaceVars(value, vars) {
        if (typeof (value) != "string") {
          value = value(vars);
        } else if (vars) {
          value = value.replace(/%(\w+)/g, function (str, name) {
            return vars[name] || str;
          });
        }

        return value;
      }

      function isWhiteSpaceNode(node) {
        return node && node.nodeType === 3 && /^([\t \r\n]+|)$/.test(node.nodeValue);
      }

      function wrap(node, name, attrs) {
        var wrapper = dom.create(name, attrs);

        node.parentNode.insertBefore(wrapper, node);
        wrapper.appendChild(node);

        return wrapper;
      }

      /**
       * Expands the specified range like object to depending on format.
       *
       * For example on block formats it will move the start/end position
       * to the beginning of the current block.
       *
       * @private
       * @param {Object} rng Range like object.
       * @param {Array} formats Array with formats to expand by.
       * @return {Object} Expanded range like object.
       */
      function expandRng(rng, format, remove) {
        var lastIdx, leaf, endPoint,
          startContainer = rng.startContainer,
          startOffset = rng.startOffset,
          endContainer = rng.endContainer,
          endOffset = rng.endOffset;

        // This function walks up the tree if there is no siblings before/after the node
        function findParentContainer(start) {
          var container, parent, sibling, siblingName, root;

          container = parent = start ? startContainer : endContainer;
          siblingName = start ? 'previousSibling' : 'nextSibling';
          root = dom.getRoot();

          // If it's a text node and the offset is inside the text
          if (container.nodeType == 3 && !isWhiteSpaceNode(container)) {
            if (start ? startOffset > 0 : endOffset < container.nodeValue.length) {
              return container;
            }
          }

          /*eslint no-constant-condition:0 */
          while (true) {
            // Stop expanding on block elements
            if (!format[0].block_expand && isBlock(parent)) {
              return parent;
            }

            // Walk left/right
            for (sibling = parent[siblingName]; sibling; sibling = sibling[siblingName]) {
              if (!isBookmarkNode(sibling) && !isWhiteSpaceNode(sibling) && !isBogusBr(sibling) && !isCaretNode(sibling)) {
                return parent;
              }
            }

            // Check if we can move up are we at root level or body level
            if (parent == root || parent.parentNode == root) {
              container = parent;
              break;
            }

            parent = parent.parentNode;
          }

          return container;
        }

        // This function walks down the tree to find the leaf at the selection.
        // The offset is also returned as if node initially a leaf, the offset may be in the middle of the text node.
        function findLeaf(node, offset) {
          if (offset === undef) {
            offset = node.nodeType === 3 ? node.length : node.childNodes.length;
          }
          while (node && node.hasChildNodes()) {
            node = node.childNodes[offset];
            if (node) {
              offset = node.nodeType === 3 ? node.length : node.childNodes.length;
            }
          }
          return {
            node: node,
            offset: offset
          };
        }

        // If index based start position then resolve it
        if (startContainer.nodeType == 1 && startContainer.hasChildNodes()) {
          lastIdx = startContainer.childNodes.length - 1;
          startContainer = startContainer.childNodes[startOffset > lastIdx ? lastIdx : startOffset];

          if (startContainer && startContainer.nodeType == 3) {
            startOffset = 0;
          }
        }

        // If index based end position then resolve it
        if (endContainer.nodeType == 1 && endContainer.hasChildNodes()) {
          lastIdx = endContainer.childNodes.length - 1;
          endContainer = endContainer.childNodes[endOffset > lastIdx ? lastIdx : endOffset - 1];

          if (endContainer && endContainer.nodeType == 3) {
            endOffset = endContainer.nodeValue.length;
          }
        }

        // Expands the node to the closes contentEditable false element if it exists
        function findParentContentEditable(node) {
          var parent = node;

          while (parent) {
            if (parent.nodeType === 1 && getContentEditable(parent)) {
              return getContentEditable(parent) === "false" ? parent : node;
            }

            parent = parent.parentNode;
          }

          return node;
        }

        function findWordEndPoint(container, offset, start) {
          var walker, node, pos, lastTextNode;

          function findSpace(node, offset) {
            var pos, pos2, str = node.nodeValue;

            if (typeof (offset) == "undefined") {
              offset = start ? str.length : 0;
            }

            if (start) {
              pos = str.lastIndexOf(' ', offset);
              pos2 = str.lastIndexOf('\u00a0', offset);
              pos = pos > pos2 ? pos : pos2;

              // Include the space on remove to avoid tag soup
              if (pos !== -1 && !remove) {
                pos++;
              }
            } else {
              pos = str.indexOf(' ', offset);
              pos2 = str.indexOf('\u00a0', offset);
              pos = pos !== -1 && (pos2 === -1 || pos < pos2) ? pos : pos2;
            }

            return pos;
          }

          if (container.nodeType === 3) {
            pos = findSpace(container, offset);

            if (pos !== -1) {
              return {
                container: container,
                offset: pos
              };
            }

            lastTextNode = container;
          }

          // Walk the nodes inside the block
          walker = new TreeWalker(container, dom.getParent(container, isBlock) || ed.getBody());
          while ((node = walker[start ? 'prev' : 'next']())) {
            if (node.nodeType === 3) {
              lastTextNode = node;
              pos = findSpace(node);

              if (pos !== -1) {
                return {
                  container: node,
                  offset: pos
                };
              }
            } else if (isBlock(node)) {
              break;
            }
          }

          if (lastTextNode) {
            if (start) {
              offset = 0;
            } else {
              offset = lastTextNode.length;
            }

            return {
              container: lastTextNode,
              offset: offset
            };
          }
        }

        function findSelectorEndPoint(container, sibling_name) {
          var parents, i, y, curFormat;

          if (container.nodeType == 3 && container.nodeValue.length === 0 && container[sibling_name]) {
            container = container[sibling_name];
          }

          parents = getParents(container);
          for (i = 0; i < parents.length; i++) {
            for (y = 0; y < format.length; y++) {
              curFormat = format[y];

              // If collapsed state is set then skip formats that doesn't match that
              if ("collapsed" in curFormat && curFormat.collapsed !== rng.collapsed) {
                continue;
              }

              if (dom.is(parents[i], curFormat.selector)) {
                return parents[i];
              }
            }
          }

          return container;
        }

        function findBlockEndPoint(container, sibling_name) {
          var node, root = dom.getRoot();

          // Expand to block of similar type
          if (!format[0].wrapper) {
            node = dom.getParent(container, format[0].block, root);
          }

          // Expand to first wrappable block element or any block element
          if (!node) {
            node = dom.getParent(container.nodeType == 3 ? container.parentNode : container, function (node) {
              // Fixes #6183 where it would expand to editable parent element in inline mode
              return node != root && isTextBlock(node);
            });
          }

          // Exclude inner lists from wrapping
          if (node && format[0].wrapper) {
            node = getParents(node, 'ul,ol,dl').reverse()[0] || node;
          }

          // Didn't find a block element look for first/last wrappable element
          if (!node) {
            node = container;

            while (node[sibling_name] && !isBlock(node[sibling_name])) {
              node = node[sibling_name];

              // Break on BR but include it will be removed later on
              // we can't remove it now since we need to check if it can be wrapped
              if (isEq(node, 'br')) {
                break;
              }
            }
          }

          return node || container;
        }

        // Expand to closest contentEditable element
        startContainer = findParentContentEditable(startContainer);
        endContainer = findParentContentEditable(endContainer);

        // Exclude bookmark nodes if possible
        if (isBookmarkNode(startContainer.parentNode) || isBookmarkNode(startContainer)) {
          startContainer = isBookmarkNode(startContainer) ? startContainer : startContainer.parentNode;
          startContainer = startContainer.nextSibling || startContainer;

          if (startContainer.nodeType == 3) {
            startOffset = 0;
          }
        }

        if (isBookmarkNode(endContainer.parentNode) || isBookmarkNode(endContainer)) {
          endContainer = isBookmarkNode(endContainer) ? endContainer : endContainer.parentNode;
          endContainer = endContainer.previousSibling || endContainer;

          if (endContainer.nodeType == 3) {
            endOffset = endContainer.length;
          }
        }

        if (format[0].inline) {
          if (rng.collapsed) {
            // Expand left to closest word boundery
            endPoint = findWordEndPoint(startContainer, startOffset, true);
            if (endPoint) {
              startContainer = endPoint.container;
              startOffset = endPoint.offset;
            }

            // Expand right to closest word boundery
            endPoint = findWordEndPoint(endContainer, endOffset);
            if (endPoint) {
              endContainer = endPoint.container;
              endOffset = endPoint.offset;
            }
          }

          // Avoid applying formatting to a trailing space.
          leaf = findLeaf(endContainer, endOffset);
          if (leaf.node) {
            while (leaf.node && leaf.offset === 0 && leaf.node.previousSibling) {
              leaf = findLeaf(leaf.node.previousSibling);
            }

            if (leaf.node && leaf.offset > 0 && leaf.node.nodeType === 3 &&
              leaf.node.nodeValue.charAt(leaf.offset - 1) === ' ') {

              if (leaf.offset > 1) {
                endContainer = leaf.node;
                endContainer.splitText(leaf.offset - 1);
              }
            }
          }
        }

        // Move start/end point up the tree if the leaves are sharp and if we are in different containers
        // Example * becomes !: !<p><b><i>*text</i><i>text*</i></b></p>!
        // This will reduce the number of wrapper elements that needs to be created
        // Move start point up the tree
        if (format[0].inline || format[0].block_expand) {
          if (!format[0].inline || (startContainer.nodeType != 3 || startOffset === 0)) {
            if (!isBlock(startContainer)) {
              startContainer = findParentContainer(true);
            }
          }

          if (!format[0].inline || (endContainer.nodeType != 3 || endOffset === endContainer.nodeValue.length)) {
            if (!isBlock(endContainer)) {
              endContainer = findParentContainer();
            }
          }
        }

        // Expand start/end container to matching selector
        if (format[0].selector && format[0].expand !== FALSE && !format[0].inline) {
          // Find new startContainer/endContainer if there is better one
          startContainer = findSelectorEndPoint(startContainer, 'previousSibling');
          endContainer = findSelectorEndPoint(endContainer, 'nextSibling');
        }

        // Expand start/end container to matching block element or text node
        if (format[0].block || format[0].selector) {
          // Find new startContainer/endContainer if there is better one
          startContainer = findBlockEndPoint(startContainer, 'previousSibling');
          endContainer = findBlockEndPoint(endContainer, 'nextSibling');

          // Non block element then try to expand up the leaf
          if (format[0].block) {
            if (!isBlock(startContainer)) {
              startContainer = findParentContainer(true);
            }

            if (!isBlock(endContainer)) {
              endContainer = findParentContainer();
            }
          }
        }

        // Setup index for startContainer
        if (startContainer.nodeType == 1) {
          startOffset = nodeIndex(startContainer);
          startContainer = startContainer.parentNode;
        }

        // Setup index for endContainer
        if (endContainer.nodeType == 1) {
          endOffset = nodeIndex(endContainer) + 1;
          endContainer = endContainer.parentNode;
        }

        // Return new range like object
        return {
          startContainer: startContainer,
          startOffset: startOffset,
          endContainer: endContainer,
          endOffset: endOffset
        };
      }

      function isColorFormatAndAnchor(node, format) {
        return format.links && node.tagName == 'A';
      }

      /**
       * Removes the specified format for the specified node. It will also remove the node if it doesn't have
       * any attributes if the format specifies it to do so.
       *
       * @private
       * @param {Object} format Format object with items to remove from node.
       * @param {Object} vars Name/value object with variables to apply to format.
       * @param {Node} node Node to remove the format styles on.
       * @param {Node} compare_node Optional compare node, if specified the styles will be compared to that node.
       * @return {Boolean} True/false if the node was removed or not.
       */
      function removeFormat(format, vars, node, compare_node) {
        var i, attrs, stylesModified;

        // Check if node matches format
        if (!matchName(node, format) && !isColorFormatAndAnchor(node, format)) {
          return FALSE;
        }

        if (format.onremove) {
          format.onremove(node, format, vars, node);
        }

        // Should we compare with format attribs and styles
        if (format.remove != 'all') {
          // Remove styles
          each(format.styles, function (value, name) {
            value = normalizeStyleValue(replaceVars(value, vars), name);

            // Indexed array
            if (typeof (name) === 'number') {
              name = value;
              compare_node = 0;
            }

            if (format.remove_similar || (!compare_node || isEq(getStyle(compare_node, name), value))) {
              dom.setStyle(node, name, '');
            }

            stylesModified = 1;
          });

          // Remove style attribute if it's empty
          if (stylesModified && dom.getAttrib(node, 'style') === '') {
            node.removeAttribute('style');
            node.removeAttribute('data-mce-style');
          }

          // Remove attributes
          each(format.attributes, function (value, name) {
            var valueOut;

            value = replaceVars(value, vars);

            // Indexed array
            if (typeof (name) === 'number') {
              name = value;
              compare_node = 0;
            }

            if (!compare_node || isEq(dom.getAttrib(compare_node, name), value)) {
              // Keep internal classes
              if (name == 'class') {
                value = dom.getAttrib(node, name);
                if (value) {
                  // Build new class value where everything is removed except the internal prefixed classes
                  valueOut = '';
                  each(value.split(/\s+/), function (cls) {
                    if (/mce\w+/.test(cls)) {
                      valueOut += (valueOut ? ' ' : '') + cls;
                    }
                  });

                  // We got some internal classes left
                  if (valueOut) {
                    dom.setAttrib(node, name, valueOut);
                    return;
                  }
                }
              }

              // IE6 has a bug where the attribute doesn't get removed correctly
              if (name == "class") {
                node.removeAttribute('className');
              }

              // Remove mce prefixed attributes
              if (MCE_ATTR_RE.test(name)) {
                node.removeAttribute('data-mce-' + name);
              }

              node.removeAttribute(name);
            }
          });

          // Remove classes
          each(format.classes, function (value) {
            value = replaceVars(value, vars);

            if (!compare_node || dom.hasClass(compare_node, value)) {
              dom.removeClass(node, value);
            }
          });

          // Check for non internal attributes
          attrs = dom.getAttribs(node);
          for (i = 0; i < attrs.length; i++) {
            var attrName = attrs[i].nodeName;
            if (attrName.indexOf('_') !== 0 && attrName.indexOf('data-') !== 0) {
              return FALSE;
            }
          }
        }

        // Remove the inline child if it's empty for example <b> or <span>
        if (format.remove != 'none') {
          removeNode(node, format);
          return TRUE;
        }
      }

      /**
       * Removes the node and wrap it's children in paragraphs before doing so or
       * appends BR elements to the beginning/end of the block element if forcedRootBlocks is disabled.
       *
       * If the div in the node below gets removed:
       *  text<div>text</div>text
       *
       * Output becomes:
       *  text<div><br />text<br /></div>text
       *
       * So when the div is removed the result is:
       *  text<br />text<br />text
       *
       * @private
       * @param {Node} node Node to remove + apply BR/P elements to.
       * @param {Object} format Format rule.
       * @return {Node} Input node.
       */
      function removeNode(node, format) {
        var parentNode = node.parentNode,
          rootBlockElm;

        function find(node, next, inc) {
          node = getNonWhiteSpaceSibling(node, next, inc);

          return !node || (node.nodeName == 'BR' || isBlock(node));
        }

        if (format.block) {
          if (!forcedRootBlock) {
            // Append BR elements if needed before we remove the block
            if (isBlock(node) && !isBlock(parentNode)) {
              if (!find(node, FALSE) && !find(node.firstChild, TRUE, 1)) {
                node.insertBefore(dom.create('br'), node.firstChild);
              }

              if (!find(node, TRUE) && !find(node.lastChild, FALSE, 1)) {
                node.appendChild(dom.create('br'));
              }
            }
          } else {
            // Wrap the block in a forcedRootBlock if we are at the root of document
            if (parentNode == dom.getRoot()) {
              if (!format.list_block || !isEq(node, format.list_block)) {
                each(tinymce.grep(node.childNodes), function (node) {
                  if (isValidChild(forcedRootBlock, node.nodeName.toLowerCase())) {
                    if (!rootBlockElm) {
                      rootBlockElm = wrap(node, forcedRootBlock);
                      dom.setAttribs(rootBlockElm, ed.settings.forced_root_block_attrs);
                    } else {
                      rootBlockElm.appendChild(node);
                    }
                  } else {
                    rootBlockElm = 0;
                  }
                });
              }
            }
          }
        }

        // Never remove nodes that isn't the specified inline element if a selector is specified too
        if (format.selector && format.inline && !isEq(format.inline, node)) {
          return;
        }

        dom.remove(node, 1);
      }

      /**
       * Returns the next/previous non whitespace node.
       *
       * @private
       * @param {Node} node Node to start at.
       * @param {boolean} next (Optional) Include next or previous node defaults to previous.
       * @param {boolean} inc (Optional) Include the current node in checking. Defaults to false.
       * @return {Node} Next or previous node or undefined if it wasn't found.
       */
      function getNonWhiteSpaceSibling(node, next, inc) {
        if (node) {
          next = next ? 'nextSibling' : 'previousSibling';

          for (node = inc ? node : node[next]; node; node = node[next]) {
            if (node.nodeType == 1 || !isWhiteSpaceNode(node)) {
              return node;
            }
          }
        }
      }

      /**
       * Checks if the specified node is a bookmark node or not.
       *
       * @param {Node} node Node to check if it's a bookmark node or not.
       * @return {Boolean} true/false if the node is a bookmark node.
       */
      function isBookmarkNode(node) {
        return node && node.nodeType == 1 && node.getAttribute('data-mce-type') == 'bookmark';
      }

      /**
       * Merges the next/previous sibling element if they match.
       *
       * @private
       * @param {Node} prev Previous node to compare/merge.
       * @param {Node} next Next node to compare/merge.
       * @return {Node} Next node if we didn't merge and prev node if we did.
       */
      function mergeSiblings(prev, next) {
        var sibling, tmpSibling;

        /**
         * Compares two nodes and checks if it's attributes and styles matches.
         * This doesn't compare classes as items since their order is significant.
         *
         * @private
         * @param {Node} node1 First node to compare with.
         * @param {Node} node2 Second node to compare with.
         * @return {boolean} True/false if the nodes are the same or not.
         */
        function compareElements(node1, node2) {
          // Not the same name
          if (node1.nodeName != node2.nodeName) {
            return FALSE;
          }

          /**
           * Returns all the nodes attributes excluding internal ones, styles and classes.
           *
           * @private
           * @param {Node} node Node to get attributes from.
           * @return {Object} Name/value object with attributes and attribute values.
           */
          function getAttribs(node) {
            var attribs = {};

            each(dom.getAttribs(node), function (attr) {
              var name = attr.nodeName.toLowerCase();

              // Don't compare internal attributes or style
              if (name.indexOf('_') !== 0 && name !== 'style') {
                attribs[name] = dom.getAttrib(node, name);
              }
            });

            return attribs;
          }

          /**
           * Compares two objects checks if it's key + value exists in the other one.
           *
           * @private
           * @param {Object} obj1 First object to compare.
           * @param {Object} obj2 Second object to compare.
           * @return {boolean} True/false if the objects matches or not.
           */
          function compareObjects(obj1, obj2) {
            var value, name;

            for (name in obj1) {
              // Obj1 has item obj2 doesn't have
              // eslint-disable-next-line no-prototype-builtins
              if (obj1.hasOwnProperty(name)) {
                value = obj2[name];

                // Obj2 doesn't have obj1 item
                if (value === undef) {
                  return FALSE;
                }

                // Obj2 item has a different value
                if (obj1[name] != value) {
                  return FALSE;
                }

                // Delete similar value
                delete obj2[name];
              }
            }

            // Check if obj 2 has something obj 1 doesn't have
            for (name in obj2) {
              // Obj2 has item obj1 doesn't have
              // eslint-disable-next-line no-prototype-builtins
              if (obj2.hasOwnProperty(name)) {
                return FALSE;
              }
            }

            return TRUE;
          }

          // Attribs are not the same
          if (!compareObjects(getAttribs(node1), getAttribs(node2))) {
            return FALSE;
          }

          // Styles are not the same
          if (!compareObjects(dom.parseStyle(dom.getAttrib(node1, 'style')), dom.parseStyle(dom.getAttrib(node2, 'style')))) {
            return FALSE;
          }

          return TRUE;
        }

        function findElementSibling(node, sibling_name) {
          for (sibling = node; sibling; sibling = sibling[sibling_name]) {
            if (sibling.nodeType == 3 && sibling.nodeValue.length !== 0) {
              return node;
            }

            if (sibling.nodeType == 1 && !isBookmarkNode(sibling)) {
              return sibling;
            }
          }

          return node;
        }

        // Check if next/prev exists and that they are elements
        if (prev && next) {
          // If previous sibling is empty then jump over it
          prev = findElementSibling(prev, 'previousSibling');
          next = findElementSibling(next, 'nextSibling');

          // Compare next and previous nodes
          if (compareElements(prev, next)) {
            // Append nodes between
            for (sibling = prev.nextSibling; sibling && sibling != next;) {
              tmpSibling = sibling;
              sibling = sibling.nextSibling;
              prev.appendChild(tmpSibling);
            }

            // Remove next node
            dom.remove(next);

            // Move children into prev node
            each(tinymce.grep(next.childNodes), function (node) {
              prev.appendChild(node);
            });

            return prev;
          }
        }

        return next;
      }

      function getContainer(rng, start) {
        var container, offset, lastIdx;

        container = rng[start ? 'startContainer' : 'endContainer'];
        offset = rng[start ? 'startOffset' : 'endOffset'];

        if (container.nodeType == 1) {
          lastIdx = container.childNodes.length - 1;

          if (!start && offset) {
            offset--;
          }

          container = container.childNodes[offset > lastIdx ? lastIdx : offset];
        }

        // If start text node is excluded then walk to the next node
        if (container.nodeType === 3 && start && offset >= container.nodeValue.length) {
          container = new TreeWalker(container, ed.getBody()).next() || container;
        }

        // If end text node is excluded then walk to the previous node
        if (container.nodeType === 3 && !start && offset === 0) {
          container = new TreeWalker(container, ed.getBody()).prev() || container;
        }

        return container;
      }

      function performCaretAction(type, name, vars, similar) {
        var caretContainerId = '_mce_caret',
          debug = ed.settings.caret_debug;

        // Creates a caret container bogus element
        function createCaretContainer(fill) {
          var caretContainer = dom.create('span', {
            id: caretContainerId,
            'data-mce-bogus': true,
            style: debug ? 'color:red' : ''
          });

          if (fill) {
            caretContainer.appendChild(ed.getDoc().createTextNode(INVISIBLE_CHAR));
          }

          return caretContainer;
        }

        function isCaretContainerEmpty(node, nodes) {
          while (node) {
            if ((node.nodeType === 3 && node.nodeValue !== INVISIBLE_CHAR) || node.childNodes.length > 1) {
              return false;
            }

            // Collect nodes
            if (nodes && node.nodeType === 1) {
              nodes.push(node);
            }

            node = node.firstChild;
          }

          return true;
        }

        // Returns any parent caret container element
        function getParentCaretContainer(node) {
          while (node) {
            if (node.id === caretContainerId) {
              return node;
            }

            node = node.parentNode;
          }
        }

        // Finds the first text node in the specified node
        function findFirstTextNode(node) {
          var walker;

          if (node) {
            walker = new TreeWalker(node, node);

            for (node = walker.current(); node; node = walker.next()) {
              if (node.nodeType === 3) {
                return node;
              }
            }
          }
        }

        // Removes the caret container for the specified node or all on the current document
        function removeCaretContainer(node, move_caret) {
          var child, rng;

          if (!node) {
            node = getParentCaretContainer(selection.getStart());

            if (!node) {
              while ((node = dom.get(caretContainerId))) {
                removeCaretContainer(node, false);
              }
            }
          } else {
            rng = selection.getRng(true);

            if (isCaretContainerEmpty(node)) {
              if (move_caret !== false) {
                rng.setStartBefore(node);
                rng.setEndBefore(node);
              }

              dom.remove(node);
            } else {
              child = findFirstTextNode(node);

              if (child.nodeValue.charAt(0) === INVISIBLE_CHAR) {
                child.deleteData(0, 1);

                // Fix for bug #6976
                if (rng.startContainer == child && rng.startOffset > 0) {
                  rng.setStart(child, rng.startOffset - 1);
                }

                if (rng.endContainer == child && rng.endOffset > 0) {
                  rng.setEnd(child, rng.endOffset - 1);
                }
              }

              dom.remove(node, 1);
            }

            selection.setRng(rng);
          }
        }

        // Applies formatting to the caret postion
        function applyCaretFormat() {
          var rng, caretContainer, textNode, offset, bookmark, container, text;

          rng = selection.getRng(true);
          offset = rng.startOffset;
          container = rng.startContainer;
          text = container.nodeValue;

          caretContainer = getParentCaretContainer(selection.getStart());
          if (caretContainer) {
            textNode = findFirstTextNode(caretContainer);
          }

          // Expand to word is caret is in the middle of a text node and the char before/after is a alpha numeric character
          if (text && offset > 0 && offset < text.length && /\w/.test(text.charAt(offset)) && /\w/.test(text.charAt(offset - 1))) {
            // Get bookmark of caret position
            bookmark = selection.getBookmark();

            // Collapse bookmark range (WebKit)
            rng.collapse(true);

            // Expand the range to the closest word and split it at those points
            rng = expandRng(rng, get(name));
            rng = rangeUtils.split(rng);

            // Apply the format to the range
            apply(name, vars, rng);

            // Move selection back to caret position
            selection.moveToBookmark(bookmark);
          } else {
            if (!caretContainer || textNode.nodeValue !== INVISIBLE_CHAR) {
              caretContainer = createCaretContainer(true);
              textNode = caretContainer.firstChild;

              rng.insertNode(caretContainer);
              offset = 1;

              apply(name, vars, caretContainer);
            } else {
              apply(name, vars, caretContainer);
            }

            // Move selection to text node
            selection.setCursorLocation(textNode, offset);
          }
        }

        function removeCaretFormat() {
          var rng = selection.getRng(true),
            container, offset, bookmark,
            hasContentAfter, node, formatNode, parents = [],
            i, caretContainer;

          container = rng.startContainer;
          offset = rng.startOffset;
          node = container;

          if (container.nodeType == 3) {
            if (offset != container.nodeValue.length) {
              hasContentAfter = true;
            }

            node = node.parentNode;
          }

          while (node) {
            if (matchNode(node, name, vars, similar)) {
              formatNode = node;
              break;
            }

            if (node.nextSibling) {
              hasContentAfter = true;
            }

            parents.push(node);
            node = node.parentNode;
          }

          // Node doesn't have the specified format
          if (!formatNode) {
            return;
          }

          // Is there contents after the caret then remove the format on the element
          if (hasContentAfter) {
            // Get bookmark of caret position
            bookmark = selection.getBookmark();

            // Collapse bookmark range (WebKit)
            rng.collapse(true);

            // Expand the range to the closest word and split it at those points
            rng = expandRng(rng, get(name), true);
            rng = rangeUtils.split(rng);

            // Remove the format from the range
            remove(name, vars, rng);

            // Move selection back to caret position
            selection.moveToBookmark(bookmark);
          } else {
            caretContainer = createCaretContainer();

            node = caretContainer;
            for (i = parents.length - 1; i >= 0; i--) {
              node.appendChild(dom.clone(parents[i], false));
              node = node.firstChild;
            }

            // Insert invisible character into inner most format element
            node.appendChild(dom.doc.createTextNode(INVISIBLE_CHAR));
            node = node.firstChild;

            var block = dom.getParent(formatNode, isTextBlock);

            if (block && dom.isEmpty(block)) {
              // Replace formatNode with caretContainer when removing format from empty block like <p><b>|</b></p>
              formatNode.parentNode.replaceChild(caretContainer, formatNode);
            } else {
              // Insert caret container after the formated node
              dom.insertAfter(caretContainer, formatNode);
            }

            // Move selection to text node
            selection.setCursorLocation(node, 1);

            // If the formatNode is empty, we can remove it safely.
            if (dom.isEmpty(formatNode)) {
              dom.remove(formatNode);
            }
          }
        }

        // Checks if the parent caret container node isn't empty if that is the case it
        // will remove the bogus state on all children that isn't empty
        function unmarkBogusCaretParents() {
          var caretContainer;

          caretContainer = getParentCaretContainer(selection.getStart());
          if (caretContainer && !dom.isEmpty(caretContainer)) {
            tinymce.walk(caretContainer, function (node) {
              if (node.nodeType == 1 && node.id !== caretContainerId && !dom.isEmpty(node)) {
                dom.setAttrib(node, 'data-mce-bogus', null);
              }
            }, 'childNodes');
          }
        }

        // Only bind the caret events once
        if (!ed._hasCaretEvents) {
          // Mark current caret container elements as bogus when getting the contents so we don't end up with empty elements
          ed.onBeforeGetContent.addToTop(function () {
            var nodes = [],
              i;
            if (isCaretContainerEmpty(getParentCaretContainer(selection.getStart()), nodes)) {
              // Mark children
              i = nodes.length;
              while (i--) {
                dom.setAttrib(nodes[i], 'data-mce-bogus', '1');
              }
            }
          });

          // Remove caret container on mouse up and on key up
          tinymce.each('onMouseUp onKeyUp'.split(' '), function (name) {
            ed[name].addToTop(function () {
              removeCaretContainer();
              unmarkBogusCaretParents();
            });
          });

          // Remove caret container on keydown and it's a backspace, enter or left/right arrow keys
          ed.onKeyDown.addToTop(function (ed, e) {
            var keyCode = e.keyCode;

            // Remove caret container on keydown and it's a backspace, enter or left/right arrow keys
            // Backspace key needs to check if the range is collapsed due to bug #6780
            if ((keyCode == 8 && selection.isCollapsed()) || keyCode == 37 || keyCode == 39) {
              removeCaretContainer(getParentCaretContainer(selection.getStart()));
            }

            unmarkBogusCaretParents();
          });

          // Remove bogus state if they got filled by contents using editor.selection.setContent
          ed.onSetContent.add(function (ed, e) {
            if (e.selection) {
              unmarkBogusCaretParents();
            }
          });

          ed._hasCaretEvents = true;
        }

        // Do apply or remove caret format
        if (type == "apply") {
          applyCaretFormat();
        } else {
          removeCaretFormat();
        }
      }

      /**
       * Moves the start to the first suitable text node.
       */
      function moveStart(rng) {
        var container = rng.startContainer,
          offset = rng.startOffset,
          isAtEndOfText,
          walker, node, nodes;

        if (rng.startContainer == rng.endContainer) {
          if (isInlineBlock(rng.startContainer.childNodes[rng.startOffset])) {
            return;
          }
        }

        // Convert text node into index if possible
        if (container.nodeType == 3 && offset >= container.nodeValue.length) {
          // Get the parent container location and walk from there
          offset = nodeIndex(container);
          container = container.parentNode;
          isAtEndOfText = true;
        }

        // Move startContainer/startOffset in to a suitable node
        if (container.nodeType == 1) {
          nodes = container.childNodes;
          container = nodes[Math.min(offset, nodes.length - 1)];
          walker = new TreeWalker(container, dom.getParent(container, dom.isBlock));

          // If offset is at end of the parent node walk to the next one
          if (offset > nodes.length - 1 || isAtEndOfText) {
            walker.next();
          }

          for (node = walker.current(); node; node = walker.next()) {
            if (node.nodeType == 3 && !isWhiteSpaceNode(node)) {
              // Set selection
              rng.setStart(node, 0);
              selection.setRng(rng);
              return;
            }
          }
        }
      }
    };
  })(tinymce);

  /**
   * LegacyInput.js
   *
   * Copyright, Moxiecode Systems AB
   * Released under LGPL License.
   *
   * License: http://www.tinymce.com/license - Inactive
   * Licence: GNU/LGPL 2.1 or later - http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
   * Contributing: http://www.tinymce.com/contributing - Inactive
   */

  tinymce.onAddEditor.add(function (tinymce, ed) {
    var filters, fontSizes, dom, settings = ed.settings;

    function replaceWithSpan(node, styles) {
      tinymce.each(styles, function (value, name) {
        if (value) {
          dom.setStyle(node, name, value);
        }
      });

      dom.rename(node, 'span');
    }

    function convert(editor, params) {
      dom = editor.dom;

      if (settings.convert_fonts_to_spans) {
        tinymce.each(dom.select('font,u,strike', params.node), function (node) {
          filters[node.nodeName.toLowerCase()](ed.dom, node);
        });
      }
    }

    if (settings.inline_styles) {
      fontSizes = tinymce.explode(settings.font_size_legacy_values);

      filters = {
        font: function (dom, node) {
          replaceWithSpan(node, {
            backgroundColor: node.style.backgroundColor,
            color: node.color,
            fontFamily: node.face,
            fontSize: fontSizes[parseInt(node.size, 10) - 1]
          });
        },

        u: function (dom, node) {
          replaceWithSpan(node, {
            textDecoration: 'underline'
          });
        },

        strike: function (dom, node) {
          replaceWithSpan(node, {
            textDecoration: 'line-through'
          });
        }
      };

      ed.onPreProcess.add(convert);
      ed.onSetContent.add(convert);
    }
  });

  /**
   * EnterKey.js
   *
   * Copyright, Moxiecode Systems AB
   * Released under LGPL License.
   *
   * License: http://www.tinymce.com/license - Inactive
   * Licence: GNU/LGPL 2.1 or later - http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
   * Contributing: http://www.tinymce.com/contributing - Inactive
   */

  (function (tinymce) {
    var TreeWalker = tinymce.dom.TreeWalker,
      RangeUtils = tinymce.dom.RangeUtils,
      NodeType = tinymce.dom.NodeType;

    /**
       * Contains logic for handling the enter key to split/generate block elements.
       */
    tinymce.EnterKey = function (editor) {
      var dom = editor.dom,
        selection = editor.selection,
        settings = editor.settings,
        undoManager = editor.undoManager,
        schema = editor.schema;
      var nonEmptyElementsMap = schema.getNonEmptyElements(),
        moveCaretBeforeOnEnterElementsMap = schema.getMoveCaretBeforeOnEnterElements();

      var isIE = tinymce.isIE && tinymce.isIE < 11;

      editor.onNewBlock = new tinymce.util.Dispatcher();

      function handleEnterKey(evt) {
        var rng = selection.getRng(true),
          tmpRng, editableRoot, container, offset, parentBlock, documentMode, shiftKey,
          newBlock, fragment, containerBlock, parentBlockName, containerBlockName, newBlockName, isAfterLastNodeInContainer;

        // Returns true if the block can be split into two blocks or not
        function canSplitBlock(node) {
          return node &&
            dom.isBlock(node) &&
            !/^(TD|TH|CAPTION|FORM)$/.test(node.nodeName) &&
            !/^(fixed|absolute)/i.test(node.style.position) &&
            dom.getContentEditable(node) !== "true" &&
            // prevent splitting of internal
            !node.hasAttribute('data-mce-type');
        }

        function isTableCell(node) {
          return node && /^(TD|TH|CAPTION)$/.test(node.nodeName);
        }

        function isBogus(node) {
          return !!node && node.nodeType === 1 && node.hasAttribute('data-mce-bogus');
        }

        function trimBogusBr(elm) {
          var brs = elm.getElementsByTagName('br');
          var lastBr = brs[brs.length - 1];
          if (isBogus(lastBr)) {
            lastBr.parentNode.removeChild(lastBr);
          }
        }

        function isCaretContainerBlock(node) {
          if (!!node && node.nodeType === 3) {
            node = node.parentNode;
          }

          return (!!node && node.nodeType === 1) && node.hasAttribute('data-mce-caret');
        }

        function showCaretContainerBlock(caretContainer) {
          if (caretContainer && caretContainer.hasAttribute('data-mce-caret')) {
            trimBogusBr(caretContainer);
            caretContainer.removeAttribute('data-mce-caret');
            caretContainer.removeAttribute('data-mce-bogus');
            caretContainer.removeAttribute('style');
            caretContainer.removeAttribute('_moz_abspos');
            return caretContainer;
          }

          return null;
        }

        // Renders empty block on IE
        function renderBlockOnIE(block) {
          var oldRng;

          if (dom.isBlock(block)) {
            oldRng = selection.getRng();
            block.appendChild(dom.create('span', null, '\u00a0'));
            selection.select(block);
            block.lastChild.outerHTML = '';
            selection.setRng(oldRng);
          }
        }

        // Remove the first empty inline element of the block so this: <p><b><em></em></b>x</p> becomes this: <p>x</p>
        function trimInlineElementsOnLeftSideOfBlock(block) {
          var node = block,
            firstChilds = [],
            i;

          if (!node) {
            return;
          }

          // Find inner most first child ex: <p><i><b>*</b></i></p>
          while ((node = node.firstChild)) {
            if (dom.isBlock(node)) {
              return;
            }

            if (node.nodeType == 1 && !nonEmptyElementsMap[node.nodeName.toLowerCase()]) {
              firstChilds.push(node);
            }
          }

          i = firstChilds.length;
          while (i--) {
            node = firstChilds[i];
            if (!node.hasChildNodes() || (node.firstChild == node.lastChild && node.firstChild.nodeValue === '')) {
              dom.remove(node);
            } else {
              // Remove <a> </a> see #5381
              if (node.nodeName == "A" && (node.innerText || node.textContent) === ' ') {
                dom.remove(node);
              }
            }
          }
        }

        // Moves the caret to a suitable position within the root for example in the first non
        // pure whitespace text node or before an image
        function moveToCaretPosition(root) {
          var walker, node, rng, lastNode = root,
            tempElm;

          function firstNonWhiteSpaceNodeSibling(node) {
            while (node) {
              if (node.nodeType == 1 || (node.nodeType == 3 && node.data && /[\r\n\s]/.test(node.data))) {
                return node;
              }

              node = node.nextSibling;
            }
          }

          if (!root) {
            return;
          }

          // Old IE versions doesn't properly render blocks with br elements in them
          // For example <p><br></p> wont be rendered correctly in a contentEditable area
          // until you remove the br producing <p></p>
          if (isIE && parentBlock && parentBlock.firstChild) {
            if (parentBlock.firstChild == parentBlock.lastChild && parentBlock.firstChild.tagName == 'BR') {
              dom.remove(parentBlock.firstChild);
            }
          }

          if (/^(LI|DT|DD)$/.test(root.nodeName)) {
            var firstChild = firstNonWhiteSpaceNodeSibling(root.firstChild);

            if (firstChild && /^(UL|OL|DL)$/.test(firstChild.nodeName)) {
              root.insertBefore(dom.doc.createTextNode('\u00a0'), root.firstChild);
            }
          }

          rng = dom.createRng();

          // Normalize whitespace to remove empty text nodes. Fix for: #6904
          // Gecko will be able to place the caret in empty text nodes but it won't render propery
          // Older IE versions will sometimes crash so for now ignore all IE versions
          if (!isIE) {
            root.normalize();
          }

          if (root.hasChildNodes()) {
            walker = new TreeWalker(root, root);

            while ((node = walker.current())) {
              if (node.nodeType == 3) {
                rng.setStart(node, 0);
                rng.setEnd(node, 0);
                break;
              }

              if (moveCaretBeforeOnEnterElementsMap[node.nodeName.toLowerCase()]) {
                rng.setStartBefore(node);
                rng.setEndBefore(node);
                break;
              }

              lastNode = node;
              node = walker.next();
            }

            if (!node) {
              rng.setStart(lastNode, 0);
              rng.setEnd(lastNode, 0);
            }
          } else {
            if (root.nodeName == 'BR') {
              if (root.nextSibling && dom.isBlock(root.nextSibling)) {
                // Trick on older IE versions to render the caret before the BR between two lists
                if (!documentMode || documentMode < 9) {
                  tempElm = dom.create('br');
                  root.parentNode.insertBefore(tempElm, root);
                }

                rng.setStartBefore(root);
                rng.setEndBefore(root);
              } else {
                rng.setStartAfter(root);
                rng.setEndAfter(root);
              }
            } else {
              rng.setStart(root, 0);
              rng.setEnd(root, 0);
            }
          }

          selection.setRng(rng);

          // Remove tempElm created for old IE:s
          dom.remove(tempElm);
          selection.scrollIntoView(root);
        }

        function setForcedBlockAttrs(node) {
          var forcedRootBlockName = settings.forced_root_block;

          if (forcedRootBlockName && forcedRootBlockName.toLowerCase() === node.tagName.toLowerCase()) {
            dom.setAttribs(node, settings.forced_root_block_attrs);
          }
        }

        function emptyBlock(elm) {
          // BR is needed in empty blocks on non IE browsers
          elm.innerHTML = !isIE ? '<br data-mce-bogus="1">' : '';
        }

        // Creates a new block element by cloning the current one or creating a new one if the name is specified
        // This function will also copy any text formatting from the parent block and add it to the new one
        function createNewBlock(name) {
          var node = container,
            block, clonedNode, caretNode, textInlineElements = schema.getTextInlineElements();

          if (name || parentBlockName == "TABLE") {
            block = dom.create(name || newBlockName);
            setForcedBlockAttrs(block);
          } else {
            block = settings.enterkey_keep_attributes ? parentBlock.cloneNode(false) : dom.create(parentBlock.nodeName);
          }

          caretNode = block;

          // Clone any parent styles
          if (settings.enterkey_keep_styles === true) {
            do {
              if (textInlineElements[node.nodeName]) {
                // Never clone a caret containers
                if (node.id == '_mce_caret') {
                  continue;
                }

                clonedNode = node.cloneNode(false);
                dom.setAttrib(clonedNode, 'id', ''); // Remove ID since it needs to be document unique

                if (block.hasChildNodes()) {
                  clonedNode.appendChild(block.firstChild);
                  block.appendChild(clonedNode);
                } else {
                  caretNode = clonedNode;
                  block.appendChild(clonedNode);
                }
              }
            } while ((node = node.parentNode) && node != editableRoot);
          }

          // BR is needed in empty blocks on non IE browsers
          if (!isIE) {
            caretNode.innerHTML = '<br data-mce-bogus="1">';
          }

          return block;
        }

        // Returns true/false if the caret is at the start/end of the parent block element
        function isCaretAtStartOrEndOfBlock(start) {
          var walker, node, name;

          // Caret is in the middle of a text node like "a|b"
          if (container.nodeType == 3 && (start ? offset > 0 : offset < container.nodeValue.length)) {
            return false;
          }

          // If after the last element in block node edge case for #5091
          if (container.parentNode == parentBlock && isAfterLastNodeInContainer && !start) {
            return true;
          }

          // If the caret is before the first element in parentBlock
          if (start && container.nodeType == 1 && container == parentBlock.firstChild) {
            return true;
          }

          // Caret can be before/after a table
          if (container.nodeName === "TABLE" || (container.previousSibling && container.previousSibling.nodeName == "TABLE")) {
            return (isAfterLastNodeInContainer && !start) || (!isAfterLastNodeInContainer && start);
          }

          // Caret can be before/after a contenteditable|false
          if (NodeType.isContentEditableFalse(container) || (container.previousSibling && NodeType.isContentEditableFalse(container.previousSibling))) {
            return (isAfterLastNodeInContainer && !start) || (!isAfterLastNodeInContainer && start);
          }

          // Walk the DOM and look for text nodes or non empty elements
          walker = new TreeWalker(container, parentBlock);

          // If caret is in beginning or end of a text block then jump to the next/previous node
          if (container.nodeType == 3) {
            if (start && offset === 0) {
              walker.prev();
            } else if (!start && offset == container.nodeValue.length) {
              walker.next();
            }
          }

          while ((node = walker.current())) {
            if (node.nodeType === 1) {
              // Ignore bogus elements
              if (!node.getAttribute('data-mce-bogus')) {
                // Keep empty elements like <img /> <input /> but not trailing br:s like <p>text|<br></p>
                name = node.nodeName.toLowerCase();
                if (nonEmptyElementsMap[name] && name !== 'br') {
                  return false;
                }
              }
            } else if (node.nodeType === 3 && !/^[ \t\r\n]*$/.test(node.nodeValue)) {
              return false;
            }

            if (start) {
              walker.prev();
            } else {
              walker.next();
            }
          }

          return true;
        }

        // Wraps any text nodes or inline elements in the specified forced root block name
        function wrapSelfAndSiblingsInDefaultBlock(container, offset) {
          var newBlock, parentBlock, startNode, node, next, rootBlockName, blockName = newBlockName || 'P';

          // Not in a block element or in a table cell or caption
          parentBlock = dom.getParent(container, dom.isBlock);

          if (!parentBlock || !canSplitBlock(parentBlock)) {
            parentBlock = parentBlock || editableRoot;

            // check if parentBlock is root, ie: <body> or fake root
            if (parentBlock == editableRoot || isTableCell(parentBlock)) {
              rootBlockName = parentBlock.nodeName.toLowerCase();
            } else {
              rootBlockName = parentBlock.parentNode.nodeName.toLowerCase();
            }

            if (!parentBlock.hasChildNodes()) {
              newBlock = dom.create(blockName);
              setForcedBlockAttrs(newBlock);
              parentBlock.appendChild(newBlock);
              rng.setStart(newBlock, 0);
              rng.setEnd(newBlock, 0);
              return newBlock;
            }

            // Find parent that is the first child of parentBlock
            node = container;

            while (node && node.parentNode != parentBlock) {
              node = node.parentNode;
            }

            // Loop left to find start node start wrapping at
            while (node && !dom.isBlock(node)) {
              startNode = node;
              node = node.previousSibling;
            }

            if (startNode && schema.isValidChild(rootBlockName, blockName.toLowerCase())) {
              newBlock = dom.create(blockName);
              setForcedBlockAttrs(newBlock);
              startNode.parentNode.insertBefore(newBlock, startNode);

              // Start wrapping until we hit a block
              node = startNode;
              while (node && !dom.isBlock(node)) {
                next = node.nextSibling;
                newBlock.appendChild(node);
                node = next;
              }

              // Restore range to it's past location
              rng.setStart(container, offset);
              rng.setEnd(container, offset);
            }
          }

          return container;
        }

        // Inserts a block or br before/after or in the middle of a split list of the LI is empty
        function handleEmptyListItem() {
          function isFirstOrLastLi(first) {
            var node = containerBlock[first ? 'firstChild' : 'lastChild'];

            // Find first/last element since there might be whitespace there
            while (node) {
              if (node.nodeType == 1) {
                break;
              }

              node = node[first ? 'nextSibling' : 'previousSibling'];
            }

            return node === parentBlock;
          }

          function getContainerBlock() {
            var containerBlockParent = containerBlock.parentNode;

            if (/^(LI|DT|DD)$/.test(containerBlockParent.nodeName)) {
              return containerBlockParent;
            }

            return containerBlock;
          }

          if (containerBlock == editor.getBody()) {
            return;
          }

          // Check if we are in an nested list
          var containerBlockParentName = containerBlock.parentNode.nodeName;
          if (/^(OL|UL|LI)$/.test(containerBlockParentName)) {
            newBlockName = 'LI';
          }

          newBlock = newBlockName ? createNewBlock(newBlockName) : dom.create('BR');

          if (isFirstOrLastLi(true) && isFirstOrLastLi()) {
            if (containerBlockParentName == 'LI') {
              // Nested list is inside a LI
              dom.insertAfter(newBlock, getContainerBlock());
            } else {
              // Is first and last list item then replace the OL/UL with a text block
              dom.replace(newBlock, containerBlock);
            }
          } else if (isFirstOrLastLi(true)) {
            if (containerBlockParentName == 'LI') {
              // List nested in an LI then move the list to a new sibling LI
              dom.insertAfter(newBlock, getContainerBlock());
              newBlock.appendChild(dom.doc.createTextNode(' ')); // Needed for IE so the caret can be placed
              newBlock.appendChild(containerBlock);
            } else {
              // First LI in list then remove LI and add text block before list
              containerBlock.parentNode.insertBefore(newBlock, containerBlock);
            }
          } else if (isFirstOrLastLi()) {
            // Last LI in list then remove LI and add text block after list
            dom.insertAfter(newBlock, getContainerBlock());
            renderBlockOnIE(newBlock);
          } else {
            // Middle LI in list the split the list and insert a text block in the middle
            // Extract after fragment and insert it after the current block
            containerBlock = getContainerBlock();
            tmpRng = rng.cloneRange();
            tmpRng.setStartAfter(parentBlock);
            tmpRng.setEndAfter(containerBlock);
            fragment = tmpRng.extractContents();

            if (newBlockName == 'LI' && fragment.firstChild.nodeName == 'LI') {
              newBlock = fragment.firstChild;
              dom.insertAfter(fragment, containerBlock);
            } else {
              dom.insertAfter(fragment, containerBlock);
              dom.insertAfter(newBlock, containerBlock);
            }
          }

          dom.remove(parentBlock);
          moveToCaretPosition(newBlock);
          undoManager.add();
        }

        // Inserts a BR element if the forced_root_block option is set to false or empty string
        function insertBr() {
          editor.execCommand("InsertLineBreak", false, evt);
        }

        // Trims any linebreaks at the beginning of node user for example when pressing enter in a PRE element
        function trimLeadingLineBreaks(node) {
          do {
            if (node.nodeType === 3) {
              node.nodeValue = node.nodeValue.replace(/^[\r\n]+/, '');
            }

            node = node.firstChild;
          } while (node);
        }

        function getEditableRoot(node) {
          var root = dom.getRoot(),
            parent, editableRoot;

          // Get all parents until we hit a non editable parent or the root
          parent = node;

          while (parent && parent !== root && dom.getContentEditable(parent) !== "false") {

            if (dom.getContentEditable(parent) === "true") {
              editableRoot = parent;
            }

            parent = parent.parentNode;
          }

          return parent !== root ? editableRoot : root;
        }

        // Adds a BR at the end of blocks that only contains an IMG or INPUT since
        // these might be floated and then they won't expand the block
        function addBrToBlockIfNeeded(block) {
          var lastChild;

          // IE will render the blocks correctly other browsers needs a BR
          if (!isIE) {
            block.normalize(); // Remove empty text nodes that got left behind by the extract

            // Check if the block is empty or contains a floated last child
            lastChild = block.lastChild;
            if (!lastChild || (/^(left|right)$/gi.test(dom.getStyle(lastChild, 'float', true)))) {
              dom.add(block, 'br');
            }
          }
        }

        function insertNewBlockAfter() {
          // If the caret is at the end of a header we produce a P tag after it similar to Word unless we are in a hgroup
          if (/^(H[1-6]|PRE|FIGURE)$/.test(parentBlockName) && containerBlockName != 'HGROUP') {
            newBlock = createNewBlock(newBlockName);
          } else {
            newBlock = createNewBlock();
          }

          // Split the current container block element if enter is pressed inside an empty inner block element
          if (settings.end_container_on_empty_block && canSplitBlock(containerBlock) && dom.isEmpty(parentBlock)) {
            // Split container block for example a BLOCKQUOTE at the current blockParent location for example a P
            newBlock = dom.split(containerBlock, parentBlock);
          } else {
            dom.insertAfter(newBlock, parentBlock);
          }

          moveToCaretPosition(newBlock);
        }

        rng = selection.getRng(true);

        // Event is blocked by some other handler for example the lists plugin
        if (evt.isDefaultPrevented()) {
          return;
        }

        // Delete any selected contents
        if (!rng.collapsed) {
          editor.execCommand('Delete');
          return;
        }

        // Setup range items and newBlockName
        new RangeUtils(dom).normalize(rng);
        container = rng.startContainer;
        offset = rng.startOffset;
        newBlockName = settings.forced_root_block || 'p';

        // reset if force_block_newlines is false (linebreak on enter)
        if (settings.force_block_newlines === false) {
          newBlockName = '';
        }

        newBlockName = newBlockName ? newBlockName.toUpperCase() : '';
        documentMode = dom.doc.documentMode;
        shiftKey = evt.shiftKey;

        // Resolve node index
        if (container.nodeType == 1 && container.hasChildNodes()) {
          isAfterLastNodeInContainer = offset > container.childNodes.length - 1;

          container = container.childNodes[Math.min(offset, container.childNodes.length - 1)] || container;

          if (isAfterLastNodeInContainer && container.nodeType == 3) {
            offset = container.nodeValue.length;
          } else {
            offset = 0;
          }
        }

        // Get editable root node, normally the body element but sometimes a div or span
        editableRoot = getEditableRoot(container);

        // If there is no editable root then enter is done inside a contentEditable false element
        if (!editableRoot) {
          return;
        }

        undoManager.beforeChange();

        // If editable root isn't block nor the root of the editor
        /*if (!dom.isBlock(editableRoot) && editableRoot != dom.getRoot()) {
                  if (!newBlockName || shiftKey) {
                      insertBr();
                  }

                  return;
              }*/

        // Wrap the current node and it's sibling in a default block if it's needed.
        // for example this <td>text|<b>text2</b></td> will become this <td><p>text|<b>text2</p></b></td>
        // This won't happen if root blocks are disabled or the shiftKey is pressed
        if ((newBlockName && !shiftKey) || (!newBlockName && shiftKey)) {
          container = wrapSelfAndSiblingsInDefaultBlock(container, offset);
        }

        // Find parent block and setup empty block paddings
        parentBlock = dom.getParent(container, dom.isBlock);

        containerBlock = parentBlock ? dom.getParent(parentBlock.parentNode, dom.isBlock) : null;

        // Setup block names
        parentBlockName = parentBlock ? parentBlock.nodeName.toUpperCase() : ''; // IE < 9 & HTML5
        containerBlockName = containerBlock ? containerBlock.nodeName.toUpperCase() : ''; // IE < 9 & HTML5

        // Enter inside block contained within a LI then split or insert before/after LI
        if (containerBlockName == 'LI' && !evt.ctrlKey) {
          parentBlock = containerBlock;
          parentBlockName = containerBlockName;
        }

        // Handle enter in list item
        if (/^(LI|DT|DD)$/.test(parentBlockName)) {
          if (!newBlockName && shiftKey) {
            insertBr();
            return;
          }

          // Handle enter inside an empty list item
          if (dom.isEmpty(parentBlock)) {
            handleEmptyListItem();
            return;
          }
        }

        // Don't split PRE tags but insert a BR instead easier when writing code samples etc
        if (parentBlockName == 'PRE' && settings.br_in_pre !== false) {
          if (!shiftKey) {
            insertBr();
            return;
          }
        } else {
          // If no root block is configured then insert a BR by default or if the shiftKey is pressed
          if ((!newBlockName && !shiftKey && parentBlockName != 'LI') || (newBlockName && shiftKey)) {
            insertBr();
            return;
          }
        }

        // If parent block is root then never insert new blocks
        if (newBlockName && parentBlock === editor.getBody()) {
          return;
        }

        // Default block name if it's not configured
        newBlockName = newBlockName || 'P';

        // Insert new block before/after the parent block depending on caret location
        if (isCaretContainerBlock(parentBlock)) {
          newBlock = showCaretContainerBlock(parentBlock);
          if (dom.isEmpty(parentBlock)) {
            emptyBlock(parentBlock);
          }
          moveToCaretPosition(newBlock);
        } else if (isCaretAtStartOrEndOfBlock()) {
          insertNewBlockAfter();
        } else if (isCaretAtStartOrEndOfBlock(true)) {
          // Insert new block before
          newBlock = parentBlock.parentNode.insertBefore(createNewBlock(), parentBlock);
          renderBlockOnIE(newBlock);
          moveToCaretPosition(newBlock);
        } else {
          // Extract after fragment and insert it after the current block
          tmpRng = rng.cloneRange();
          tmpRng.setEndAfter(parentBlock);
          fragment = tmpRng.extractContents();
          trimLeadingLineBreaks(fragment);
          newBlock = fragment.firstChild;

          dom.insertAfter(fragment, parentBlock);
          trimInlineElementsOnLeftSideOfBlock(newBlock);
          addBrToBlockIfNeeded(parentBlock);

          if (dom.isEmpty(parentBlock)) {
            emptyBlock(parentBlock);
          }

          // New block might become empty if it's <p><b>a |</b></p>
          // need to check for newBlock as it can be undefined in some instances (enter in paragraph converted from text in figcaption...)
          if (!newBlock || dom.isEmpty(newBlock)) {
            dom.remove(newBlock);
            insertNewBlockAfter();
          } else {
            moveToCaretPosition(newBlock);
          }

          newBlock.normalize();
        }

        dom.setAttrib(newBlock, 'id', ''); // Remove ID since it needs to be document unique

        // Allow custom handling of new blocks
        editor.onNewBlock.dispatch(editor, newBlock);

        undoManager.add();
      }

      editor.onKeyDown.add(function (ed, evt) {
        if (evt.keyCode == 13) {
          if (handleEnterKey(evt) !== false) {
            evt.preventDefault();
          }
        }
      });
    };
  })(tinymce);

  /**
   * DragDropOverrides.js
   *
   * Released under LGPL License.
   * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
   *
   * License: http://www.tinymce.com/license - Inactive
   * Licence: GNU/LGPL 2.1 or later - http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
   * Contributing: http://www.tinymce.com/contributing - Inactive
   */

  /**
   * This module contains logic overriding the drag/drop logic of the editor.
   *
   * @private
   * @class tinymce.DragDropOverrides
   */
  (function (tinymce) {

    var NodeType = tinymce.dom.NodeType;
    var Fun = tinymce.util.Fun, Arr = tinymce.util.Arr, Delay = tinymce.util.Delay, MousePosition = tinymce.dom.MousePosition;
    var isContentEditableFalse = NodeType.isContentEditableFalse,
      isContentEditableTrue = NodeType.isContentEditableTrue;

    var isDraggable = function (rootElm, elm) {
      return isContentEditableFalse(elm) && elm !== rootElm;
    };

    var isValidDropTarget = function (editor, targetElement, dragElement) {
      if (targetElement === dragElement || editor.dom.isChildOf(targetElement, dragElement)) {
        return false;
      }

      if (isContentEditableFalse(targetElement)) {
        return false;
      }

      return true;
    };

    var cloneElement = function (elm) {
      var cloneElm = elm.cloneNode(true);
      cloneElm.removeAttribute('data-mce-selected');
      return cloneElm;
    };

    var createGhost = function (editor, elm, width, height) {
      var clonedElm = elm.cloneNode(true);

      editor.dom.setStyles(clonedElm, { width: width, height: height });
      editor.dom.setAttrib(clonedElm, 'data-mce-selected', null);

      var ghostElm = editor.dom.create('div', {
        'class': 'mce-drag-container',
        'data-mce-bogus': 'all',
        unselectable: 'on',
        contenteditable: 'false'
      });

      editor.dom.setStyles(ghostElm, {
        position: 'absolute',
        opacity: 0.5,
        overflow: 'hidden',
        border: 0,
        padding: 0,
        margin: 0,
        width: width,
        height: height
      });

      editor.dom.setStyles(clonedElm, {
        margin: 0,
        boxSizing: 'border-box'
      });

      ghostElm.appendChild(clonedElm);

      return ghostElm;
    };

    var appendGhostToBody = function (ghostElm, bodyElm) {
      if (ghostElm.parentNode !== bodyElm) {
        bodyElm.appendChild(ghostElm);
      }
    };

    var moveGhost = function (ghostElm, position, width, height, maxX, maxY) {
      var overflowX = 0, overflowY = 0;

      ghostElm.style.left = position.pageX + 'px';
      ghostElm.style.top = position.pageY + 'px';

      if (position.pageX + width > maxX) {
        overflowX = (position.pageX + width) - maxX;
      }

      if (position.pageY + height > maxY) {
        overflowY = (position.pageY + height) - maxY;
      }

      ghostElm.style.width = (width - overflowX) + 'px';
      ghostElm.style.height = (height - overflowY) + 'px';
    };

    var removeElement = function (elm) {
      if (elm && elm.parentNode) {
        elm.parentNode.removeChild(elm);
      }
    };

    var isLeftMouseButtonPressed = function (e) {
      return e.button === 0;
    };

    var hasDraggableElement = function (state) {
      return state.element;
    };

    var applyRelPos = function (state, position) {
      return {
        pageX: position.pageX - state.relX,
        pageY: position.pageY + 5
      };
    };

    var start = function (state, editor) {
      return function (e) {
        if (isLeftMouseButtonPressed(e)) {
          var ceElm = Arr.find(editor.dom.getParents(e.target), Fun.or(isContentEditableFalse, isContentEditableTrue));

          if (isDraggable(editor.getBody(), ceElm)) {
            var elmPos = editor.dom.getPos(ceElm);
            var bodyElm = editor.getBody();
            var docElm = editor.getDoc().documentElement;

            state.element = ceElm;
            state.screenX = e.screenX;
            state.screenY = e.screenY;
            state.maxX = (editor.inline ? bodyElm.scrollWidth : docElm.offsetWidth) - 2;
            state.maxY = (editor.inline ? bodyElm.scrollHeight : docElm.offsetHeight) - 2;
            state.relX = e.pageX - elmPos.x;
            state.relY = e.pageY - elmPos.y;
            state.width = ceElm.offsetWidth;
            state.height = ceElm.offsetHeight;
            state.ghost = createGhost(editor, ceElm, state.width, state.height);
          }
        }
      };
    };

    var move = function (state, editor) {
      // Reduces laggy drag behavior on Gecko
      var throttledPlaceCaretAt = Delay.throttle(function (clientX, clientY) {
        editor._selectionOverrides.hideFakeCaret();
        editor.selection.placeCaretAt(clientX, clientY);
      }, 0);

      return function (e) {
        var movement = Math.max(Math.abs(e.screenX - state.screenX), Math.abs(e.screenY - state.screenY));

        if (hasDraggableElement(state) && !state.dragging && movement > 10) {
          var args = editor.dom.fire(editor.getBody(), 'dragstart', { target: state.element });

          if (args.preventDefault(e)) {
            return;
          }

          state.dragging = true;
          editor.focus();
        }

        if (state.dragging) {        
          var targetPos = applyRelPos(state, MousePosition.calc(editor, e));

          appendGhostToBody(state.ghost, editor.getBody());
          moveGhost(state.ghost, targetPos, state.width, state.height, state.maxX, state.maxY);

          throttledPlaceCaretAt(e.clientX, e.clientY);
        }
      };
    };

    // Returns the raw element instead of the fake cE=false element
    var getRawTarget = function (selection) {
      var rng = selection.getSel().getRangeAt(0);
      var startContainer = rng.startContainer;
      return startContainer.nodeType === 3 ? startContainer.parentNode : startContainer;
    };

    var drop = function (state, editor) {
      return function (e) {
        if (state.dragging) {
          if (isValidDropTarget(editor, getRawTarget(editor.selection), state.element)) {
            var targetClone = cloneElement(state.element);

            var evt = editor.dom.fire(editor.getBody(), 'drop', {
              targetClone: targetClone,
              clientX: e.clientX,
              clientY: e.clientY
            });

            if (!evt.isDefaultPrevented(e)) {
              targetClone = evt.args.targetClone;

              editor.undoManager.add();

              removeElement(state.element);
              editor.insertContent(editor.dom.getOuterHTML(targetClone));
              editor._selectionOverrides.hideFakeCaret();
            }
          }
        }

        removeDragState(state);
      };
    };

    var stop = function (state, editor) {
      return function () {
        removeDragState(state);
        if (state.dragging) {
          editor.dom.fire(editor.getBody(), 'dragend');
        }
      };
    };

    var removeDragState = function (state) {
      state.dragging = false;
      state.element = null;
      removeElement(state.ghost);
    };

    var bindFakeDragEvents = function (editor) {
      var state = {}, pageDom, dragStartHandler, dragHandler, dropHandler, dragEndHandler, rootDocument;

      pageDom = tinymce.DOM;
      rootDocument = document;
      dragStartHandler = start(state, editor);
      dragHandler = move(state, editor);
      dropHandler = drop(state, editor);
      dragEndHandler = stop(state, editor);

     editor.dom.bind(editor.getBody(), 'mousedown', dragStartHandler);
     editor.dom.bind(editor.getBody(), 'mousemove', dragHandler);
     editor.dom.bind(editor.getBody(), 'mouseup', dropHandler);

      pageDom.bind(rootDocument, 'mousemove', dragHandler);
      pageDom.bind(rootDocument, 'mouseup', dragEndHandler);

     editor.dom.bind(editor.getBody(), 'remove', function () {
        pageDom.unbind(rootDocument, 'mousemove', dragHandler);
        pageDom.unbind(rootDocument, 'mouseup', dragEndHandler);
      });
    };

    var blockIeDrop = function (editor) {
     editor.dom.bind(editor.getBody(), 'drop', function (e) {
        // FF doesn't pass out clientX/clientY for drop since this is for IE we just use null instead
        var realTarget = typeof e.clientX !== 'undefined' ? editor.getDoc().elementFromPoint(e.clientX, e.clientY) : null;

        if (isContentEditableFalse(realTarget) || isContentEditableFalse(editor.dom.getContentEditableParent(realTarget))) {
          e.preventDefault();
        }
      });
    };

    tinymce.DragDropOverrides = {
        init : function (editor) {
          bindFakeDragEvents(editor);
          blockIeDrop(editor);
        }
    };
  })(tinymce);

  /**
   * SelectionOverrides.js
   *
   * Released under LGPL License.
   * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
   *
   * License: http://www.tinymce.com/license - Inactive
   * Licence: GNU/LGPL 2.1 or later - http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
   * Contributing: http://www.tinymce.com/contributing - Inactive
   */

  /**
   * This module contains logic overriding the selection with keyboard/mouse
   * around contentEditable=false regions.
   *
   * @example
   * // Disable the default cE=false selection
   * tinymce.activeEditor.on('ShowCaret BeforeObjectSelected', function(e) {
   *     e.preventDefault();
   * });
   *
   * @private
   * @class tinymce.SelectionOverrides
   */
  (function (tinymce) {

    var CaretWalker = tinymce.caret.CaretWalker, CaretPosition = tinymce.caret.CaretPosition, CaretContainer = tinymce.caret.CaretContainer, CaretUtils = tinymce.caret.CaretUtils,
      CaretContainerRemove = tinymce.caret.CaretContainerRemove, FakeCaret = tinymce.caret.FakeCaret, LineWalker = tinymce.caret.LineWalker, LineUtils = tinymce.caret.LineUtils;

    var NodeType = tinymce.dom.NodeType, RangeUtils = tinymce.dom.RangeUtils;
    var VK = tinymce.VK, Fun = tinymce.util.Fun, Arr = tinymce.util.Arr;

    var Dispatcher = tinymce.util.Dispatcher, DragDropOverrides = tinymce.DragDropOverrides;

    var curry = Fun.curry,
      isContentEditableTrue = NodeType.isContentEditableTrue,
      isContentEditableFalse = NodeType.isContentEditableFalse,
      isElement = NodeType.isElement,
      isAfterContentEditableFalse = CaretUtils.isAfterContentEditableFalse,
      isBeforeContentEditableFalse = CaretUtils.isBeforeContentEditableFalse,
      getSelectedNode = RangeUtils.getSelectedNode;

    function getVisualCaretPosition(walkFn, caretPosition) {
      while ((caretPosition = walkFn(caretPosition))) {
        if (caretPosition.isVisible()) {
          return caretPosition;
        }
      }

      return caretPosition;
    }

    function setEditorTimeout(editor, callback, time) {
      return setTimeout(function () {
        if (!editor.removed) {
          callback();
        }
      }, time);
    }

    tinymce.SelectionOverrides = function (editor) {
      var rootNode = editor.getBody(),
        caretWalker = new CaretWalker(rootNode);
      var getNextVisualCaretPosition = curry(getVisualCaretPosition, caretWalker.next);
      var getPrevVisualCaretPosition = curry(getVisualCaretPosition, caretWalker.prev),
        fakeCaret = new FakeCaret(editor.getBody(), isBlock),
        realSelectionId = 'sel-' + editor.dom.uniqueId(),
        selectedContentEditableNode;

      editor.onShowCaret = new Dispatcher();
      editor.onBeforeObjectSelected = new Dispatcher();
      editor.onObjectSelected = new Dispatcher();
      editor.onContentEditableSelect = new Dispatcher();

      function isFakeSelectionElement(elm) {
        return editor.dom.hasClass(elm, 'mce-offscreen-selection');
      }

      function getRealSelectionElement() {
        var container = editor.dom.get(realSelectionId);
        return container ? container.getElementsByTagName('*')[0] : container;
      }

      function isBlock(node) {
        return editor.dom.isBlock(node);
      }

      function setRange(range) {
        if (range) {
          editor.selection.setRng(range);
        }
      }

      function getRange() {
        return editor.selection.getRng();
      }

      function scrollIntoView(node, alignToTop) {
        editor.selection.scrollIntoView(node, alignToTop);
      }

      function showCaret(direction, node, before) {
        var evt = {
          target: node,
          direction: direction,
          before: before
        };

        editor.onShowCaret.dispatch(editor, evt);

        if (!evt.target) {
          return null;
        }

        scrollIntoView(node, direction === -1);

        return fakeCaret.show(before, node);
      }

      function selectNode(node) {
        var evt = {
          target: node
        };

        editor.onBeforeObjectSelected.dispatch(editor, evt);

        if (!evt.target) {
          return null;
        }

        return getNodeRange(node);
      }

      function getNodeRange(node) {
        var rng = node.ownerDocument.createRange();

        rng.selectNode(node);

        return rng;
      }

      function isMoveInsideSameBlock(fromCaretPosition, toCaretPosition) {
        var inSameBlock = CaretUtils.isInSameBlock(fromCaretPosition, toCaretPosition);

        // Handle bogus BR <p>abc|<br></p>
        if (!inSameBlock && NodeType.isBr(fromCaretPosition.getNode())) {
          return true;
        }

        return inSameBlock;
      }

      function getNormalizedRangeEndPoint(direction, range) {
        range = CaretUtils.normalizeRange(direction, rootNode, range);

        if (direction == -1) {
          return CaretPosition.fromRangeStart(range);
        }

        return CaretPosition.fromRangeEnd(range);
      }

      function isRangeInCaretContainerBlock(range) {
        return CaretContainer.isCaretContainerBlock(range.startContainer);
      }

      function moveToCeFalseHorizontally(direction, getNextPosFn, isBeforeContentEditableFalseFn, range) {
        var node, caretPosition, peekCaretPosition, rangeIsInContainerBlock;

        if (!range.collapsed) {
          node = getSelectedNode(range);
          if (isContentEditableFalse(node)) {
            return showCaret(direction, node, direction == -1);
          }
        }

        rangeIsInContainerBlock = isRangeInCaretContainerBlock(range);
        caretPosition = getNormalizedRangeEndPoint(direction, range);

        if (isBeforeContentEditableFalseFn(caretPosition)) {
          return selectNode(caretPosition.getNode(direction == -1));
        }

        caretPosition = getNextPosFn(caretPosition);
        if (!caretPosition) {
          if (rangeIsInContainerBlock) {
            return range;
          }

          return null;
        }

        if (isBeforeContentEditableFalseFn(caretPosition)) {
          return showCaret(direction, caretPosition.getNode(direction == -1), direction == 1);
        }

        // Peek ahead for handling of ab|c<span cE=false> -> abc|<span cE=false>
        peekCaretPosition = getNextPosFn(caretPosition);
        if (isBeforeContentEditableFalseFn(peekCaretPosition)) {
          if (isMoveInsideSameBlock(caretPosition, peekCaretPosition)) {
            return showCaret(direction, peekCaretPosition.getNode(direction == -1), direction == 1);
          }
        }

        if (rangeIsInContainerBlock) {
          return renderRangeCaret(caretPosition.toRange());
        }

        return null;
      }

      function moveToCeFalseVertically(direction, walkerFn, range) {
        var caretPosition, linePositions, nextLinePositions,
          closestNextLineRect, caretClientRect, clientX,
          dist1, dist2, contentEditableFalseNode;

        contentEditableFalseNode = getSelectedNode(range);
        caretPosition = getNormalizedRangeEndPoint(direction, range);
        linePositions = walkerFn(rootNode, LineWalker.isAboveLine(1), caretPosition);
        nextLinePositions = Arr.filter(linePositions, LineWalker.isLine(1));
        caretClientRect = Arr.last(caretPosition.getClientRects());

        if (isBeforeContentEditableFalse(caretPosition)) {
          contentEditableFalseNode = caretPosition.getNode();
        }

        if (isAfterContentEditableFalse(caretPosition)) {
          contentEditableFalseNode = caretPosition.getNode(true);
        }

        if (!caretClientRect) {
          return null;
        }

        clientX = caretClientRect.left;

        closestNextLineRect = LineUtils.findClosestClientRect(nextLinePositions, clientX);
        if (closestNextLineRect) {
          if (isContentEditableFalse(closestNextLineRect.node)) {
            dist1 = Math.abs(clientX - closestNextLineRect.left);
            dist2 = Math.abs(clientX - closestNextLineRect.right);

            return showCaret(direction, closestNextLineRect.node, dist1 < dist2);
          }
        }

        if (contentEditableFalseNode) {
          var caretPositions = LineWalker.positionsUntil(direction, rootNode, LineWalker.isAboveLine(1), contentEditableFalseNode);

          closestNextLineRect = LineUtils.findClosestClientRect(Arr.filter(caretPositions, LineWalker.isLine(1)), clientX);
          if (closestNextLineRect) {
            return renderRangeCaret(closestNextLineRect.position.toRange());
          }

          closestNextLineRect = Arr.last(Arr.filter(caretPositions, LineWalker.isLine(0)));
          if (closestNextLineRect) {
            return renderRangeCaret(closestNextLineRect.position.toRange());
          }
        }
      }

      function exitPreBlock(direction, range) {
        var pre, caretPos, newBlock;

        function createTextBlock() {
          var textBlock = editor.dom.create(editor.settings.forced_root_block);

          textBlock.innerHTML = '<br data-mce-bogus="1">';

          return textBlock;
        }

        if (range.collapsed && editor.settings.forced_root_block) {
          pre = editor.dom.getParent(range.startContainer, 'PRE');
          if (!pre) {
            return;
          }

          if (direction == 1) {
            caretPos = getNextVisualCaretPosition(CaretPosition.fromRangeStart(range));
          } else {
            caretPos = getPrevVisualCaretPosition(CaretPosition.fromRangeStart(range));
          }

          if (!caretPos) {
            newBlock = createTextBlock();

            if (direction == 1) {
              editor.dom.insertAfter(newBlock, pre);
            } else {
              editor.dom.insertBefore(newBlock, pre);
            }

            editor.selection.select(newBlock, true);
            editor.selection.collapse();
          }
        }
      }

      function moveH(direction, getNextPosFn, isBeforeContentEditableFalseFn, range) {
        var newRange;

        newRange = moveToCeFalseHorizontally(direction, getNextPosFn, isBeforeContentEditableFalseFn, range);
        if (newRange) {
          return newRange;
        }

        newRange = exitPreBlock(direction, range);
        if (newRange) {
          return newRange;
        }

        return null;
      }

      function moveV(direction, walkerFn, range) {
        var newRange;

        newRange = moveToCeFalseVertically(direction, walkerFn, range);
        if (newRange) {
          return newRange;
        }

        newRange = exitPreBlock(direction, range);
        if (newRange) {
          return newRange;
        }

        return null;
      }

      function getBlockCaretContainer() {
        return editor.dom.select('*[data-mce-caret]')[0];
      }

      function showBlockCaretContainer(blockCaretContainer) {
        if (blockCaretContainer.hasAttribute('data-mce-caret')) {
          CaretContainer.showCaretContainerBlock(blockCaretContainer);
          setRange(getRange()); // Removes control rect on IE
          scrollIntoView(blockCaretContainer[0]);
        }
      }

      function renderCaretAtRange(range) {
        var caretPosition, ceRoot;

        range = CaretUtils.normalizeRange(1, rootNode, range);
        caretPosition = CaretPosition.fromRangeStart(range);

        if (isContentEditableFalse(caretPosition.getNode())) {
          return showCaret(1, caretPosition.getNode(), !caretPosition.isAtEnd());
        }

        if (isContentEditableFalse(caretPosition.getNode(true))) {
          return showCaret(1, caretPosition.getNode(true), false);
        }

        // TODO: Should render caret before/after depending on where you click on the page forces after now
        ceRoot = editor.dom.getParent(caretPosition.getNode(), Fun.or(isContentEditableFalse, isContentEditableTrue));

        if (isContentEditableFalse(ceRoot)) {
          return showCaret(1, ceRoot, false);
        }

        return null;
      }

      function renderRangeCaret(range) {
        var caretRange;

        if (!range || !range.collapsed) {
          return range;
        }

        caretRange = renderCaretAtRange(range);
        if (caretRange) {
          return caretRange;
        }

        return range;
      }

      function deleteContentEditableNode(node) {
        var nextCaretPosition, prevCaretPosition, prevCeFalseElm, nextElement;

        if (!isContentEditableFalse(node)) {
          return null;
        }

        if (isContentEditableFalse(node.previousSibling)) {
          prevCeFalseElm = node.previousSibling;
        }

        prevCaretPosition = getPrevVisualCaretPosition(CaretPosition.before(node));

        if (!prevCaretPosition) {
          nextCaretPosition = getNextVisualCaretPosition(CaretPosition.after(node));
        }

        if (nextCaretPosition && isElement(nextCaretPosition.getNode())) {
          nextElement = nextCaretPosition.getNode();
        }

        CaretContainerRemove.remove(node.previousSibling);
        CaretContainerRemove.remove(node.nextSibling);
        editor.dom.remove(node);

        if (editor.dom.isEmpty(editor.getBody())) {
          editor.setContent('');
          editor.focus();
          return;
        }

        if (prevCeFalseElm) {
          return CaretPosition.after(prevCeFalseElm).toRange();
        }

        if (nextElement) {
          return CaretPosition.before(nextElement).toRange();
        }

        if (prevCaretPosition) {
          return prevCaretPosition.toRange();
        }

        if (nextCaretPosition) {
          return nextCaretPosition.toRange();
        }

        return null;
      }

      function isTextBlock(node) {
        var textBlocks = editor.schema.getTextBlockElements();
        return node.nodeName in textBlocks;
      }

      function isEmpty(elm) {
        return editor.dom.isEmpty(elm);
      }

      function mergeTextBlocks(direction, fromCaretPosition, toCaretPosition) {
        var dom = editor.dom,
          fromBlock, toBlock, node, ceTarget;

        fromBlock = dom.getParent(fromCaretPosition.getNode(), dom.isBlock);
        toBlock = dom.getParent(toCaretPosition.getNode(), dom.isBlock);

        if (direction === -1) {
          ceTarget = toCaretPosition.getNode(true);
          if (isAfterContentEditableFalse(toCaretPosition) && isBlock(ceTarget)) {
            if (isTextBlock(fromBlock)) {
              if (isEmpty(fromBlock)) {
                dom.remove(fromBlock);
              }

              return CaretPosition.after(ceTarget).toRange();
            }

            return deleteContentEditableNode(toCaretPosition.getNode(true));
          }
        } else {
          ceTarget = fromCaretPosition.getNode();
          if (isBeforeContentEditableFalse(fromCaretPosition) && isBlock(ceTarget)) {
            if (isTextBlock(toBlock)) {
              if (isEmpty(toBlock)) {
                dom.remove(toBlock);
              }

              return CaretPosition.before(ceTarget).toRange();
            }

            return deleteContentEditableNode(fromCaretPosition.getNode());
          }
        }

        // Verify that both blocks are text blocks
        if (fromBlock === toBlock || !isTextBlock(fromBlock) || !isTextBlock(toBlock)) {
          return null;
        }

        while ((node = fromBlock.firstChild)) {
          toBlock.appendChild(node);
        }

        editor.dom.remove(fromBlock);

        return toCaretPosition.toRange();
      }

      function backspaceDelete(direction, beforeFn, afterFn, range) {
        var node, caretPosition, peekCaretPosition, newCaretPosition;

        if (!range.collapsed) {
          node = getSelectedNode(range);
          if (isContentEditableFalse(node)) {
            return renderRangeCaret(deleteContentEditableNode(node));
          } else {
            return null;
          }
        }

        caretPosition = getNormalizedRangeEndPoint(direction, range);

        if (afterFn(caretPosition) && CaretContainer.isCaretContainerBlock(range.startContainer)) {
          newCaretPosition = direction == -1 ? caretWalker.prev(caretPosition) : caretWalker.next(caretPosition);
          return newCaretPosition ? renderRangeCaret(newCaretPosition.toRange()) : range;
        }

        if (beforeFn(caretPosition)) {
          return renderRangeCaret(deleteContentEditableNode(caretPosition.getNode(direction == -1)));
        }

        peekCaretPosition = direction == -1 ? caretWalker.prev(caretPosition) : caretWalker.next(caretPosition);

        if (beforeFn(peekCaretPosition)) {
          if (direction === -1) {
            return mergeTextBlocks(direction, caretPosition, peekCaretPosition);
          }

          return mergeTextBlocks(direction, peekCaretPosition, caretPosition);
        }
      }

      function registerEvents() {
        var right = curry(moveH, 1, getNextVisualCaretPosition, isBeforeContentEditableFalse);
        var left = curry(moveH, -1, getPrevVisualCaretPosition, isAfterContentEditableFalse);
        var deleteForward = curry(backspaceDelete, 1, isBeforeContentEditableFalse, isAfterContentEditableFalse);
        var backspace = curry(backspaceDelete, -1, isAfterContentEditableFalse, isBeforeContentEditableFalse);
        var up = curry(moveV, -1, LineWalker.upUntil);
        var down = curry(moveV, 1, LineWalker.downUntil);

        function override(evt, moveFn) {
          if (evt.isDefaultPrevented() === false) {
            var range = moveFn(getRange());
            if (range) {
              evt.preventDefault();
              setRange(range);
            }
          }
        }

        function getContentEditableRoot(node) {
          var root = editor.getBody();

          while (node && node != root) {
            if (isContentEditableTrue(node) || isContentEditableFalse(node)) {
              return node;
            }

            node = node.parentNode;
          }

          return null;
        }

        /*function isXYWithinRange(clientX, clientY, range) {
          if (range.collapsed) {
            return false;
          }

          return Arr.reduce(range.getClientRects(), function (state, rect) {
            return state || ClientRect.containsXY(rect, clientX, clientY);
          }, false);
        }*/

        // Some browsers (Chrome) lets you place the caret after a cE=false
        // Make sure we render the caret container in this case
        editor.onMouseUp.add(function () {
          var range = getRange();

          if (range.collapsed) {
            setRange(renderCaretAtRange(range));
          }
        });

        editor.onClick.add(function (editor, e) {
          var contentEditableRoot;

          contentEditableRoot = getContentEditableRoot(e.target);

          if (contentEditableRoot) {
            // Prevent clicks on links in a cE=false element
            if (isContentEditableFalse(contentEditableRoot)) {
              e.preventDefault();
              editor.focus();
            }

            // Removes fake selection if a cE=true is clicked within a cE=false like the toc title
            if (isContentEditableTrue(contentEditableRoot)) {
              if (editor.dom.isChildOf(contentEditableRoot, editor.selection.getNode())) {
                removeContentEditableSelection();
              }
            }
          }
        });

        editor.onNewBlock.add(function () {
          removeContentEditableSelection();
          hideFakeCaret();
        });

        editor.onBlur.add(function () {
          removeContentEditableSelection();
          hideFakeCaret();
        });

        function handleTouchSelect(editor) {
          var moved = false;

          editor.dom.bind(editor.getBody(), 'touchstart', function () {
            moved = false;
          });

          editor.dom.bind(editor.getBody(), 'touchmove', function () {
            moved = true;
          });

          editor.dom.bind(editor.getBody(), 'touchend', function (e) {
            var contentEditableRoot = getContentEditableRoot(e.target);

            if (contentEditableRoot) {
              if (isContentEditableFalse(contentEditableRoot)) {
                if (!moved) {
                  e.preventDefault();
                  setContentEditableSelection(selectNode(contentEditableRoot));
                }
              }

              // fire fake event
              editor.onContentEditableSelect.dispatch(editor, e);
            }
          });
        }

        var hasNormalCaretPosition = function (elm) {
          var caretWalker = new CaretWalker(elm);

          if (!elm.firstChild) {
            return false;
          }

          var startPos = CaretPosition.before(elm.firstChild);
          var newPos = caretWalker.next(startPos);

          return newPos && !isBeforeContentEditableFalse(newPos) && !isAfterContentEditableFalse(newPos);
        };

        var isInSameBlock = function (node1, node2) {
          var block1 = editor.dom.getParent(node1, editor.dom.isBlock);
          var block2 = editor.dom.getParent(node2, editor.dom.isBlock);
          return block1 === block2;
        };

        var isContentKey = function (e) {
          if (e.keyCode >= 112 && e.keyCode <= 123) {
            return false;
          }

          return true;
        };

        // Checks if the target node is in a block and if that block has a caret position better than the
        // suggested caretNode this is to prevent the caret from being sucked in towards a cE=false block if
        // they are adjacent on the vertical axis
        var hasBetterMouseTarget = function (targetNode, caretNode) {
          var targetBlock = editor.dom.getParent(targetNode, editor.dom.isBlock);
          var caretBlock = editor.dom.getParent(caretNode, editor.dom.isBlock);

          return targetBlock && !isInSameBlock(targetBlock, caretBlock) && hasNormalCaretPosition(targetBlock);
        };

        handleTouchSelect(editor);

        /*function isXYWithinRange(clientX, clientY, range) {
          if (range.collapsed) {
            return false;
          }

          return Arr.reduce(range.getClientRects(), function (state, rect) {
            return state || CaretUtils.containsXY(rect, clientX, clientY);
          }, false);
        }*/

        editor.onMouseDown.add(function (editor, e) {
          var contentEditableRoot;

          contentEditableRoot = getContentEditableRoot(e.target);

          if (contentEditableRoot) {
            if (isContentEditableFalse(contentEditableRoot)) {
              e.preventDefault();
              setContentEditableSelection(selectNode(contentEditableRoot));
            } else {
              /*if (!isXYWithinRange(e.clientX, e.clientY, editor.selection.getRng())) {
                editor.selection.placeCaretAt(e.clientX, e.clientY);
              }*/

              if (!editor.selection.isCollapsed()) {
                editor.selection.placeCaretAt(e.clientX, e.clientY);
              }
            }

            // fire fake event
            editor.onContentEditableSelect.dispatch(editor, e);
          } else {
            // Remove needs to be called here since the mousedown might alter the selection without calling selection.setRng
            // and therefore not fire the AfterSetSelectionRange event.
            removeContentEditableSelection();
            hideFakeCaret();

            var caretInfo = LineUtils.closestCaret(rootNode, e.clientX, e.clientY);

            if (caretInfo) {
              if (!hasBetterMouseTarget(e.target, caretInfo.node)) {
                e.preventDefault();
                editor.getBody().focus();
                setRange(showCaret(1, caretInfo.node, caretInfo.before));
              }
            }
          }
        });

        editor.onKeyDown.add(function (editor, e) {
          if (VK.modifierPressed(e)) {
            return;
          }

          switch (e.keyCode) {
            case VK.RIGHT:
              override(e, right);
              break;

            case VK.DOWN:
              override(e, down);
              break;

            case VK.LEFT:
              override(e, left);
              break;

            case VK.UP:
              override(e, up);
              break;

            case VK.DELETE:
              override(e, deleteForward);
              break;

            case VK.BACKSPACE:
              override(e, backspace);
              break;

            default:
              if (isContentEditableFalse(editor.selection.getNode()) && isContentKey(e)) {
                e.preventDefault();
              }
              break;
          }
        });

        function paddEmptyContentEditableArea() {
          var br, ceRoot = getContentEditableRoot(editor.selection.getNode());

          if (isContentEditableTrue(ceRoot) && isBlock(ceRoot) && editor.dom.isEmpty(ceRoot)) {
            br = editor.dom.create('br', {
              "data-mce-bogus": "1"
            });

            editor.dom.empty(ceRoot);
            editor.dom.add(ceRoot, br);

            editor.selection.setRng(CaretPosition.before(br).toRange());
          }
        }

        function handleBlockContainer(e) {
          var blockCaretContainer = getBlockCaretContainer();

          if (!blockCaretContainer) {
            return;
          }

          if (e.type == 'compositionstart') {
            e.preventDefault();
            e.stopPropagation();
            showBlockCaretContainer(blockCaretContainer);
            return;
          }

          if (CaretContainer.hasContent(blockCaretContainer)) {
            showBlockCaretContainer(blockCaretContainer);
          }
        }

        function handleEmptyBackspaceDelete(e) {
          var prevent;

          switch (e.keyCode) {
            case VK.DELETE:
              prevent = paddEmptyContentEditableArea();
              break;

            case VK.BACKSPACE:
              prevent = paddEmptyContentEditableArea();
              break;
          }

          if (prevent) {
            e.preventDefault();
          }
        }

        // Must be added to "top" since undoManager needs to be executed after
        editor.dom.bind(editor.getBody(), 'keyup compositionstart', function (e) {
          handleBlockContainer(e);
          handleEmptyBackspaceDelete(e);
        }, true);

        editor.onCut.add(function () {
          var node = editor.selection.getNode();

          if (isContentEditableFalse(node)) {
            setEditorTimeout(editor, function () {
              setRange(renderRangeCaret(deleteContentEditableNode(node)));
            });
          }
        });

        editor.selection.onGetSelectionRange.add(function (sel, e) {
          var rng = e.range;

          if (selectedContentEditableNode) {
            if (!selectedContentEditableNode.parentNode) {
              selectedContentEditableNode = null;
              return;
            }

            rng = rng.cloneRange();
            rng.selectNode(selectedContentEditableNode);
            e.range = rng;
          }
        });

        editor.selection.onSetSelectionRange.add(function (sel, e) {
          var rng;


          rng = setContentEditableSelection(e.range);

          if (rng) {
            e.range = rng;
          }
        });

        editor.selection.onAfterSetSelectionRange.add(function (sel, e) {
          var rng = e.range;

          if (!isRangeInCaretContainer(rng)) {
            hideFakeCaret();
          }

          if (rng.startContainer.parentNode == rootNode) {
            return;
          }

          if (!isFakeSelectionElement(rng.startContainer.parentNode)) {
            removeContentEditableSelection();
          }
        });

        editor.dom.bind(editor.getBody(), 'focus', function () {
          // Make sure we have a proper fake caret on focus
          setEditorTimeout(editor, function () {
            editor.selection.setRng(renderRangeCaret(editor.selection.getRng()));
          }, 0);
        });

        editor.onCopy.add(function (editor, e) {
          var clipboardData = e.clipboardData;

          // Make sure we get proper html/text for the fake cE=false selection
          if (!e.isDefaultPrevented() && clipboardData) {

            var realSelectionElement = getRealSelectionElement();

            if (realSelectionElement) {
              e.preventDefault();
              clipboardData.clearData();
              clipboardData.setData('text/html', realSelectionElement.outerHTML);
              clipboardData.setData('text/plain', realSelectionElement.outerText);
            }
          }
        });

        DragDropOverrides.init(editor);
      }

      function isWithinCaretContainer(node) {
        return (
          CaretContainer.isCaretContainer(node) ||
          CaretContainer.startsWithCaretContainer(node) ||
          CaretContainer.endsWithCaretContainer(node)
        );
      }

      function isRangeInCaretContainer(rng) {
        return isWithinCaretContainer(rng.startContainer) || isWithinCaretContainer(rng.endContainer);
      }

      function setContentEditableSelection(range) {
        var node,
          dom = editor.dom,
          $realSelectionContainer, sel,
          startContainer, startOffset, endOffset, caretPosition, targetClone;

        if (!range) {
          return null;
        }

        if (range.collapsed) {
          if (!isRangeInCaretContainer(range)) {
            caretPosition = getNormalizedRangeEndPoint(1, range);

            if (isContentEditableFalse(caretPosition.getNode())) {
              //return showCaret(1, caretPosition.getNode(), !caretPosition.isAtEnd());
              return showCaret(1, caretPosition.getNode(), false);
            }

            if (isContentEditableFalse(caretPosition.getNode(true))) {
              return showCaret(1, caretPosition.getNode(true), false);
            }
          }

          return null;
        }

        startContainer = range.startContainer;
        startOffset = range.startOffset;
        endOffset = range.endOffset;

        // Normalizes <span cE=false>[</span>] to [<span cE=false></span>]
        if (startContainer.nodeType == 3 && startOffset == 0 && isContentEditableFalse(startContainer.parentNode)) {
          startContainer = startContainer.parentNode;
          startOffset = dom.nodeIndex(startContainer);
          startContainer = startContainer.parentNode;
        }

        if (startContainer.nodeType != 1) {
          return null;
        }

        if (endOffset == startOffset + 1) {
          node = startContainer.childNodes[startOffset];
        }

        if (!isContentEditableFalse(node)) {
          return null;
        }

        targetClone = node.cloneNode(true);

        var evt = {
          node: node,
          target: targetClone
        };

        editor.onObjectSelected.dispatch(editor, evt);

        if (!evt.isDefaultPrevented === false) {
          return null;
        }

        $realSelectionContainer = dom.get(realSelectionId);

        if (!$realSelectionContainer) {
          $realSelectionContainer = dom.create('div', { 'data-mce-bogus': 'all', 'class': 'mce-offscreen-selection', 'id': realSelectionId });
          dom.add(editor.getBody(), $realSelectionContainer);
        }

        range = dom.createRng();

        //dom.empty($realSelectionContainer);
        $realSelectionContainer.innerHTML = '';

        $realSelectionContainer.appendChild(document.createTextNode('\u00a0'));
        $realSelectionContainer.appendChild(targetClone);
        $realSelectionContainer.appendChild(document.createTextNode('\u00a0'));

        range.setStart($realSelectionContainer.firstChild, 1);
        range.setEnd($realSelectionContainer.lastChild, 0);

        dom.setStyle($realSelectionContainer, 'top', dom.getPos(node, editor.getBody()).y);

        $realSelectionContainer.focus();
        sel = editor.selection.getSel();
        sel.removeAllRanges();
        sel.addRange(range);

        dom.setAttrib(dom.select('*[data-mce-selected]'), 'data-mce-selected', null);

        node.setAttribute('data-mce-selected', 1);
        selectedContentEditableNode = node;
        hideFakeCaret();

        return range;
      }

      function removeContentEditableSelection() {
        if (selectedContentEditableNode) {
          selectedContentEditableNode.removeAttribute('data-mce-selected');

          editor.dom.remove(realSelectionId);

          selectedContentEditableNode = null;
        }
      }

      function destroy() {
        var dom = editor.dom,
          $realSelectionContainer;
        
        fakeCaret.destroy();
        selectedContentEditableNode = null;

        $realSelectionContainer = dom.get(realSelectionId);

        if ($realSelectionContainer) {
          dom.remove($realSelectionContainer);
        }
      }

      function hideFakeCaret() {
        fakeCaret.hide();
      }

      registerEvents();

      return {
        showBlockCaretContainer: showBlockCaretContainer,
        hideFakeCaret: hideFakeCaret,
        destroy: destroy
      };
    };

  })(tinymce);

  /**
   * @package   	JCE
   * @copyright 	Copyright (c) 2009-2024 Ryan Demmer. All rights reserved.
   * @license   	GNU/GPL 2 or later - http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
   * JCE is free software. This version may have been modified pursuant
   * to the GNU General Public License, and as distributed it includes or
   * is derivative of works licensed under the GNU General Public License or
   * other free or open source software licenses.
   */

  /*global tinymce:true */

  (function () {
    var Entities = tinymce.html.Entities, each = tinymce.each,
      extend = tinymce.extend,
      DomParser = tinymce.html.DomParser,
      HtmlSerializer = tinymce.html.Serializer,
      Dispatcher = tinymce.util.Dispatcher,
      DOM = tinymce.DOM;

    function validateContent(ed, content) {
      var args = {
        "no_events": true,
        "format": "raw"
      };

      // create new settings object
      var settings = {};

      // extend with editor settings
      extend(settings, ed.settings);

      // set content    
      args.content = content;

      if (ed.settings.validate) {
        // trigger cleanup etc in editor
        args.format = "html";

        // set a load flag so code is processed as code blocks
        args.load = true;

        // onBeforeGetContent
        ed.onBeforeGetContent.dispatch(ed, args);

        // allow all tags
        settings.verify_html = false;

        // no root blocks
        settings.forced_root_block = false;

        // must validate
        settings.validate = true;

        // create dom parser
        var parser = new DomParser(settings, ed.schema);

        // create html serializer
        var serializer = new HtmlSerializer(settings, ed.schema);

        // clean content
        args.content = serializer.serialize(parser.parse(args.content), args);

        args.get = true;

        // onPostProcess
        ed.onPostProcess.dispatch(ed, args);

        // pass content
        content = args.content;
      }

      return content;
    }

    tinymce.PluginManager.add('core', function (ed, url) {
      // command store
      var store;

      // media update event
      ed.onUpdateMedia = new Dispatcher();
      ed.onWfEditorSave = new Dispatcher();

      // is the editor in SPPageBuilder
      function isSpPageBuilder() {
        var pb = DOM.get('sp-inline-popover');

        return pb && DOM.isChildOf(ed.getElement(), pb) || false;
      }

      var contentLoaded = false, elm = ed.getElement();

      function isEmpty() {
        if (elm.nodeName === 'TEXTAREA') {
          return elm.value == '';
        } else {
          return elm.innerHTML == '';
        }
      }

      function insertContent(value) {
        value = Entities.decode(value);

        if (value) {
          if (elm.nodeName === 'TEXTAREA') {
            elm.value = value;
          } else {
            elm.innerHTML = value;
          }
        }

        return true;
      }

      function isFakeRoot(node) {
        return node && node.nodeType == 1 && node.hasAttribute('data-mce-root');
      }

      var startup_content_html = ed.settings.startup_content_html || '';

      ed.onBeforeRenderUI.add(function () {
        // load content on first startup
        if (startup_content_html && elm) {
          if (!contentLoaded && isEmpty()) {
            contentLoaded = true;
            return insertContent(startup_content_html);
          }
        }
      });

      var quoteMap = {
        en: {
          '\u0022': '&ldquo;{$selection}&rdquo;',
          '\u0027': '&lsquo;{$selection}&rsquo;'
        },

        de: {
          '\u0022': '&bdquo;{$selection}&ldquo;',
          '\u0027': '&sbquo;{$selection}&rsquo;'
        }
      };

      // special quotes shortcute
      ed.onKeyUp.add(function (ed, e) {
        // eslint-disable-next-line dot-notation
        var map = quoteMap[ed.settings.language] || quoteMap['en'];

        if ((e.key == '\u0022' || e.key == '\u0027') && e.shiftKey && e.ctrlKey) {
          var value = map[e.key];

          ed.undoManager.add();
          ed.execCommand('mceReplaceContent', false, value);
        }
      });

      ed.onExecCommand.add(function (ed, cmd, ui, val, args) {
        if (cmd == 'Undo' || cmd == 'Redo' || cmd == 'mceReApply' || cmd == 'mceRepaint') {
          return;
        }

        store = { cmd: cmd, ui: ui, value: val, args: args };
      });

      ed.addShortcut('ctrl+alt+z', '', 'mceReApply');

      ed.addCommand('mceReApply', function () {
        if (!store || !store.cmd) {
          return;
        }

        return ed.execCommand(store.cmd, store.ui, store.value, store.args);
      });

      function fakeRootBlock() {
        ed.settings.editable_root = 'rootblock';

        ed.onPreInit.addToTop(function () {
          var selection = ed.selection, dom = ed.dom;

          // set dom root element for getRoot method
          dom.settings.root_element = ed.settings.editable_root;

          ed.schema.addValidElements('#mce:root[id|data-mce-root]');

          // add children from body element
          ed.schema.children['mce:root'] = ed.schema.children.body;
          // set "mce:root" as a valid child of body
          ed.schema.children.body['mce:root'] = {};

          // remove fake root when serializing
          ed.serializer.addAttributeFilter('data-mce-root', function (nodes) {
            var i = nodes.length;

            while (i--) {
              nodes[i].unwrap();
            }
          });

          // remove <br data-mce-bogus="1">
          ed.serializer.addAttributeFilter('data-mce-bogus', function (nodes) {
            var i = nodes.length;

            while (i--) {
              nodes[i].remove();
            }
          });

          // wrap content in fake root
          ed.onBeforeSetContent.add(function (editor, o) {
            if (!o.content) {
              o.content = '<br data-mce-bogus="1">';
            }

            o.content = '<mce:root id="' + ed.settings.editable_root + '" data-mce-root="1">' + o.content + '</mce:root>';
          });

          function isEmptyRoot(node) {
            return /^(&nbsp;|&#160;|\s|\u00a0|)$/.test(node.innerHTML);
          }

          // reset selection to fake root
          ed.onSetContent.addToTop(function (ed, o) {
            var root = dom.get(ed.settings.editable_root), rng;

            if (root) {

              if (isEmptyRoot(root)) {
                root.innerHTML = '<br data-mce-bogus="1">';
              }

              // Move the caret to the end of the marker
              rng = dom.createRng();
              rng.setStart(root, 0);
              rng.setEnd(root, 0);
              selection.setRng(rng);
            }
          });

          // clear non-breaking space
          ed.onSaveContent.add(function (ed, o) {
            if (o.content === '&nbsp;') {
              o.content = '';
            }
          });

          // UndoManager gets content without event processing, so extract manually
          ed.undoManager.onBeforeAdd.add(function (um, level) {
            var container = ed.dom.create('div', {}, level.content);

            if (isFakeRoot(container.firstChild)) {
              level.content = container.firstChild.innerHTML;
            }

          });
        });
      }

      ed.onPreInit.add(function () {
        ed.onUpdateMedia.add(function (ed, o) {

          if (!o.before || !o.after) {
            return;
          }

          function updateSrcSet(elm, o) {
            // srcset
            var srcset = elm.getAttribute('srcset');

            if (srcset) {
              var sets = srcset.split(',');

              for (var i = 0; i < sets.length; i++) {
                var values = sets[i].trim().split(' ');

                if (o.before == values[0]) {
                  values[0] = o.after;
                }

                sets[i] = values.join(' ');
              }

              elm.setAttribute('srcset', sets.join(','));
            }
          }

          each(ed.dom.select('img,poster'), function (elm) {
            var src = elm.getAttribute('src');

            if (src && src.indexOf('?') !== -1) {
              src = src.substring(0, src.indexOf('?'));
            }

            if (src == o.before) {
              var after = o.after;
              var stamp = '?' + new Date().getTime();

              if (src.indexOf('?') !== -1 && after.indexOf('?') === -1) {
                after += stamp;
              }

              ed.dom.setAttribs(elm, { 'src': after, 'data-mce-src': o.after });
            }

            if (elm.getAttribute('srcset')) {
              updateSrcSet(elm, o);
            }
          });

          each(ed.dom.select('a[href]'), function (elm) {
            var href = ed.dom.getAttrib(elm, 'href');

            if (href == o.before) {
              ed.dom.setAttribs(elm, { 'href': o.after, 'data-mce-href': o.after });
            }
          });
        });

        ed.onWfEditorSave.add(function (ed, o) {
          o.content = validateContent(ed, o.content);
        });

        if (isSpPageBuilder()) {
          // run cleanup on sppagebuilder code
          ed.onGetContent.addToTop(function (ed, o) {
            // double-check for sppagebuilder
            if (ed.id.indexOf('sppbeditor-') == -1) {
              return;
            }

            // only for "raw" format
            if (o.format != "raw") {
              return;
            }

            var args = tinymce.extend(o, { format: 'html' });
            o.content = ed.serializer.serialize(ed.getBody(), args);
          });
        }
      });

      if (ed.settings.forced_root_block == false && ed.settings.editable_root != false) {
        fakeRootBlock();
      }
    });
  })();

  /**
   * @package    JCE
   * @copyright    Copyright (c) 2009-2024 Ryan Demmer. All rights reserved.
   * @license    GNU/GPL 2 or later - http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
   * JCE is free software. This version may have been modified pursuant
   * to the GNU General Public License, and as distributed it includes or
   * is derivative of works licensed under the GNU General Public License or
   * other free or open source software licenses.
   */

  /*global tinymce:true */

  (function () {
    tinymce.PluginManager.add('help', function (ed, url) {
      ed.addCommand('mceHelp', function () {
        ed.windowManager.open({
          title: ed.getLang('dlg.help', 'Help'),
          url: ed.getParam('site_url') + 'index.php?option=com_jce&task=plugin.display&plugin=help&lang=' + ed.getParam('language') + '&section=editor&category=editor&article=about',
          size: 'mce-modal-landscape-full'
        });
      });

      // Register buttons
      ed.addButton('help', {
        title: 'dlg.help',
        cmd: 'mceHelp'
      });
    });
  })();

  /**
   * @package   	JCE
   * @copyright 	Copyright (c) 2009-2024 Ryan Demmer. All rights reserved.
   * @copyright   Copyright 2009, Moxiecode Systems AB
   * @copyright   Copyright (c) 1999-2015 Ephox Corp. All rights reserved
   * @license   	GNU/LGPL 2.1 or later - http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
   * JCE is free software. This version may have been modified pursuant
   * to the GNU General Public License, and as distributed it includes or
   * is derivative of works licensed under the GNU General Public License or
   * other free or open source software licenses.
   */

  /*global tinymce:true */

  (function () {
    var AutoLinkPattern = /^(https?:\/\/|ssh:\/\/|ftp:\/\/|file:\/|www\.|(?:mailto:)?[A-Z0-9._%+\-]+@)(.+)$/i;

    tinymce.PluginManager.add('autolink', function (ed, url) {
      if (!ed.getParam('autolink_url', true) && !ed.getParam('autolink_email', true)) {
        return;
      }

      if (ed.settings.autolink_pattern) {
        AutoLinkPattern = ed.settings.autolink_pattern;
      }

      ed.onAutoLink = new tinymce.util.Dispatcher(this);

      // Add a key down handler
      ed.onKeyDown.addToTop(function (ed, e) {
        if (e.keyCode == 13) {
          return handleEnter(ed);
        }
      });

      // Internet Explorer has built-in automatic linking for most cases
      if (tinymce.isIE) {
        return;
      }

      ed.onKeyPress.add(function (ed, e) {
        if (e.which == 41) {
          return handleEclipse(ed);
        }
      });

      // Add a key up handler
      ed.onKeyUp.add(function (ed, e) {
        if (e.keyCode == 32) {
          return handleSpacebar(ed);
        }
      });

      function handleEclipse(ed) {
        parseCurrentLine(ed, -1, '(');
      }

      function handleSpacebar(ed) {
        parseCurrentLine(ed, 0, '');
      }

      function handleEnter(ed) {
        parseCurrentLine(ed, -1, '');
      }

      function parseCurrentLine(editor, endOffset, delimiter) {
        var rng, end, start, endContainer, bookmark, text, matches, prev, len, rngText;

        function scopeIndex(container, index) {
          if (index < 0) {
            index = 0;
          }

          if (container.nodeType == 3) {
            var len = container.data.length;

            if (index > len) {
              index = len;
            }
          }

          return index;
        }

        function setStart(container, offset) {
          if (container.nodeType != 1 || container.hasChildNodes()) {
            rng.setStart(container, scopeIndex(container, offset));
          } else {
            rng.setStartBefore(container);
          }
        }

        function setEnd(container, offset) {
          if (container.nodeType != 1 || container.hasChildNodes()) {
            rng.setEnd(container, scopeIndex(container, offset));
          } else {
            rng.setEndAfter(container);
          }
        }

        // Never create a link when we are inside a link
        if (editor.selection.getNode().tagName == 'A') {
          return;
        }

        // We need at least five characters to form a URL,
        // hence, at minimum, five characters from the beginning of the line.
        rng = editor.selection.getRng(true).cloneRange();
        if (rng.startOffset < 5) {
          // During testing, the caret is placed between two text nodes.
          // The previous text node contains the URL.
          prev = rng.endContainer.previousSibling;
          if (!prev) {
            if (!rng.endContainer.firstChild || !rng.endContainer.firstChild.nextSibling) {
              return;
            }

            prev = rng.endContainer.firstChild.nextSibling;
          }

          len = prev.length;
          setStart(prev, len);
          setEnd(prev, len);

          if (rng.endOffset < 5) {
            return;
          }

          end = rng.endOffset;
          endContainer = prev;
        } else {
          endContainer = rng.endContainer;

          // Get a text node
          if (endContainer.nodeType != 3 && endContainer.firstChild) {
            while (endContainer.nodeType != 3 && endContainer.firstChild) {
              endContainer = endContainer.firstChild;
            }

            // Move range to text node
            if (endContainer.nodeType == 3) {
              setStart(endContainer, 0);
              setEnd(endContainer, endContainer.nodeValue.length);
            }
          }

          if (rng.endOffset == 1) {
            end = 2;
          } else {
            end = rng.endOffset - 1 - endOffset;
          }
        }

        start = end;

        do {
          // Move the selection one character backwards.
          setStart(endContainer, end >= 2 ? end - 2 : 0);
          setEnd(endContainer, end >= 1 ? end - 1 : 0);
          end -= 1;
          rngText = rng.toString();

          // Loop until one of the following is found: a blank space, &nbsp;, delimiter, (end-2) >= 0
        } while (rngText != ' ' && rngText !== '' && rngText.charCodeAt(0) != 160 && (end - 2) >= 0 && rngText != delimiter);

        if (rng.toString() == delimiter || rng.toString().charCodeAt(0) == 160) {
          setStart(endContainer, end);
          setEnd(endContainer, start);
          end += 1;
        } else if (rng.startOffset === 0) {
          setStart(endContainer, 0);
          setEnd(endContainer, start);
        } else {
          setStart(endContainer, end);
          setEnd(endContainer, start);
        }

        // Exclude last . from word like "www.site.com."
        text = rng.toString();
        if (text.charAt(text.length - 1) == '.') {
          setEnd(endContainer, start - 1);
        }

        text = rng.toString();
        matches = text.match(AutoLinkPattern);

        if (matches) {
          if (matches[1] == 'www.') {
            matches[1] = 'https://www.';
          } else if (/@$/.test(matches[1]) && !/^mailto:/.test(matches[1])) {
            matches[1] = 'mailto:' + matches[1];
          }

          if (matches[1].indexOf('http') !== -1) {
            if (!editor.getParam('autolink_url', true)) {
              return;
            }
          }

          if (matches[1].indexOf('mailto:') !== -1) {
            if (!editor.getParam('autolink_email', true)) {
              return;
            }
          }

          bookmark = editor.selection.getBookmark();

          editor.selection.setRng(rng);
          editor.execCommand('createlink', false, matches[1] + matches[2]);

          var node = editor.selection.getNode();

          if (editor.settings.default_link_target) {
            editor.dom.setAttrib(node, 'target', editor.settings.default_link_target);
          }

          editor.onAutoLink.dispatch(editor, { node: node });

          editor.selection.moveToBookmark(bookmark);
          editor.nodeChanged();
        }
      }
    });
  })();

  /**
   * @package   	JCE
   * @copyright 	Copyright (c) 2009-2024 Ryan Demmer. All rights reserved.
   * @license   	GNU/GPL 2 or later - http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
   * JCE is free software. This version may have been modified pursuant
   * to the GNU General Public License, and as distributed it includes or
   * is derivative of works licensed under the GNU General Public License or
   * other free or open source software licenses.
   */

  /*global tinymce:true */

  (function () {
    var each = tinymce.each,
      Node = tinymce.html.Node;

    function split(str, delim) {
      return str.split(',');
    }

    // list of HTML tags
    var tags = [
      'a', 'abbr', 'acronym', 'address', 'applet', 'area', 'article', 'aside', 'audio', 'b', 'base', 'basefont', 'bdi', 'bdo', 'bgsound', 'big', 'blink', 'blockquote', 'body', 'br', 'button', 'canvas', 'caption', 'center', 'cite', 'code', 'col', 'colgroup', 'command', 'content', 'data', 'datalist', 'dd', 'del', 'details', 'dfn', 'dialog', 'dir', 'div', 'dl', 'dt', 'element', 'em', 'embed', 'fieldset', 'figcaption', 'figure', 'font', 'footer', 'form', 'frame', 'frameset', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'i', 'iframe', 'image', 'img', 'input', 'ins', 'isindex', 'kbd', 'keygen', 'label', 'legend', 'li', 'link', 'listing', 'main', 'map', 'mark', 'marquee', 'menu', 'menuitem', 'meta', 'meter', 'multicol', 'nav', 'nobr', 'noembed', 'noframes', 'noscript', 'object', 'ol', 'optgroup', 'option', 'output', 'p', 'param', 'picture', 'plaintext', 'pre', 'progress', 'q', 'rp', 'rt', 'rtc', 'ruby', 's', 'samp', 'script', 'section', 'select', 'shadow', 'slot', 'small', 'source', 'spacer', 'span', 'strike', 'strong', 'style', 'sub', 'summary', 'sup', 'table', 'tbody', 'td', 'template', 'textarea', 'tfoot', 'th', 'thead', 'time', 'title', 'tr', 'track', 'tt', 'u', 'ul', 'var', 'video', 'wbr', 'xmp'
    ];

    var fontIconRe = /<([a-z0-9]+)([^>]+)class="([^"]*)(glyph|uk-)?(fa|icon)-([\w-]+)([^"]*)"([^>]*)><\/\1>/gi;
    var paddedRx = /<(p|h1|h2|h3|h4|h5|h6|pre|div|address|caption)\b([^>]+)>(&nbsp;|\u00a0)<\/\1>/gi;

    tinymce.PluginManager.add('cleanup', function (ed, url) {
      // set validate value to verify_html value
      if (ed.settings.verify_html === false) {
        ed.settings.validate = false;
      }

      ed.onPreInit.add(function () {
        // Remove bogus elements
        ed.serializer.addAttributeFilter('data-mce-caret', function (nodes, name, args) {
          var i = nodes.length;

          while (i--) {
            nodes[i].remove();
          }
        });

        // cleanup data-mce-bogus tags
        if (ed.settings.remove_trailing_brs === false) {
          // Remove bogus elements
          ed.serializer.addAttributeFilter('data-mce-bogus', function (nodes, name, args) {
            var i = nodes.length, node, textNode;

            while (i--) {
              node = nodes[i];

              if (node.name !== 'br') {
                continue;
              }

              if (!node.prev && !node.next) {
                textNode = new Node('#text', 3);
                textNode.value = '\u00a0';
                node.replace(textNode);
              } else {
                node.remove();
              }
            }
          });
        }

        // cleanup tmp attributes
        ed.serializer.addAttributeFilter('data-mce-tmp', function (nodes, name) {
          var i = nodes.length,
            node;

          while (i--) {
            node = nodes[i];
            node.attr('data-mce-tmp', null);
          }
        });

        // cleanup tmp attributes
        ed.parser.addAttributeFilter('data-mce-tmp', function (nodes, name) {
          var i = nodes.length,
            node;

          while (i--) {
            node = nodes[i];
            node.attr('data-mce-tmp', null);
          }
        });

        function removeEventAttributes() {
          // remove all event attributes
          each(ed.schema.elements, function (elm) {
            // no attributes on this element
            if (!elm.attributesOrder || elm.attributesOrder.length === 0) {
              return true;
            }

            each(elm.attributes, function (obj, name) {
              if (name.indexOf('on') === 0) {
                delete elm.attributes[name];
                elm.attributesOrder.splice(tinymce.inArray(elm, elm.attributesOrder, name), 1);
              }
            });
          });
        }

        if (ed.settings.verify_html !== false) {
          if (!ed.settings.allow_event_attributes) {
            removeEventAttributes();
          }

          // add support for "bootstrap" icons
          var elements = ed.schema.elements;

          // allow empty elements. There really is no need to remove them...
          each(split('ol ul sub sup blockquote font table tbody tr strong b'), function (name) {
            if (elements[name]) {
              elements[name].removeEmpty = false;
            }
          });

          if (!ed.getParam('pad_empty_tags', true)) {
            each(elements, function (v, k) {
              if (v.paddEmpty) {
                v.paddEmpty = false;
              }
            });
          }

          if (!ed.getParam('table_pad_empty_cells', true)) {
            elements.th.paddEmpty = false;
            elements.td.paddEmpty = false;
          }

          each(elements, function (v, k) {
            // skip internal elements
            if (k.indexOf('mce:') == 0) {
              return true;
            }

            // custom element
            if (tinymce.inArray(tags, k) === -1) {
              ed.schema.addCustomElements(k);
            }
          });
        }

        // only if "Cleanup HTML" enabled
        if (ed.settings.verify_html !== false) {
          // Invalid Attribute Values cleanup
          var invalidAttribValue = ed.getParam('invalid_attribute_values', '');

          if (invalidAttribValue) {
            /**
                         * adapted from https://github.com/tinymce/tinymce/blob/master/src/core/src/main/js/ui/Selector.js
                         * Copyright (c) 1999-2017 Ephox Corp. All rights reserved
                         */
            function attrFilter(value, expr, check) {
              return !expr ? !!check :
                expr === "=" ? value === check :
                  expr === "*=" ? value.indexOf(check) >= 0 :
                    expr === "~=" ? (" " + value + " ").indexOf(" " + check + " ") >= 0 :
                      expr === "!=" ? value != check :
                        expr === "^=" ? value.indexOf(check) === 0 :
                          expr === "$=" ? value.substr(value.length - check.length) === check :
                            false;
            }

            function replaceAttributeValue(nodes, name, expr, check) {
              var i = nodes.length,
                node;

              while (i--) {
                node = nodes[i];

                var value = node.attr(name);

                if (!value) {
                  continue;
                }

                // remove attribute if it matches expression
                if (!expr || attrFilter(value, expr, check)) {
                  node.attr(name, null);
                  // remove temp attribute
                  if (name === 'src' || name === 'href' || name === 'style') {
                    node.attr('data-mce-' + name, null);
                  }

                  // remove <a> nodes without attributes
                  if (node.name === "a" && !node.attributes.length) {
                    node.unwrap();
                  }
                }
              }
            }

            each(tinymce.explode(invalidAttribValue), function (item) {
              var matches = /([a-z0-9\*]+)\[([a-z0-9-]+)([\^\$\!~\*]?=)?["']?([^"']+)?["']?\]/i.exec(item);

              if (matches && matches.length == 5) {
                var tag = matches[1],
                  attrib = matches[2],
                  expr = matches[3],
                  value = matches[4];

                // remove the entire attribute
                if (attrib && !expr && !value) {
                  expr = '';
                }

                if (typeof expr !== "undefined") {
                  // all tags
                  if (tag == '*') {
                    ed.parser.addAttributeFilter(attrib, function (nodes, name) {
                      replaceAttributeValue(nodes, name, expr, value);
                    });
                    ed.serializer.addAttributeFilter(attrib, function (nodes, name) {
                      replaceAttributeValue(nodes, name, expr, value);
                    });
                    // specific tag
                  } else {
                    ed.parser.addNodeFilter(tag, function (nodes, name) {
                      replaceAttributeValue(nodes, attrib, expr, value);
                    });
                    ed.serializer.addNodeFilter(tag, function (nodes, name) {
                      replaceAttributeValue(nodes, attrib, expr, value);
                    });
                  }
                }
              }
            });
          }
        }

        ed.serializer.addNodeFilter(ed.settings.invalid_elements, function (nodes, name) {
          var i = nodes.length,
            node;

          if (ed.schema.isValidChild('body', name)) {
            while (i--) {
              node = nodes[i];
              node.remove();
            }
          }
        });

        ed.parser.addNodeFilter(ed.settings.invalid_elements, function (nodes, name) {
          var i = nodes.length,
            node;

          if (ed.schema.isValidChild('body', name)) {
            while (i--) {
              node = nodes[i];

              // don't remove system spans
              if (name === 'span' && node.attr('data-mce-type')) {
                continue;
              }

              node.unwrap();
            }
          }
        });

        // try and keep empty a tags that are not anchors, process bootstrap icons
        ed.parser.addNodeFilter('a,i,span,li', function (nodes, name) {
          var i = nodes.length,
            node, cls;

          while (i--) {
            node = nodes[i], cls = (node.attr('class') || name === "li");
            // padd it with a space if its empty and has a class, eg: <i class="icon-ok"></i>
            if (cls && !node.firstChild) {
              node.attr('data-mce-empty', '1');
              node.append(new Node('#text', '3')).value = '\u00a0';
            }
          }
        });

        // cleanup padded "bootstrap" tags
        ed.serializer.addAttributeFilter('data-mce-empty', function (nodes, name) {
          var i = nodes.length,
            node, fc;

          while (i--) {
            node = nodes[i], fc = node.firstChild;
            node.attr('data-mce-empty', null);

            if (fc && (fc.value === '\u00a0' || fc.value === '&nbsp;')) {
              fc.remove();
            }
          }
        });

        // disable onclick etc.
        ed.parser.addAttributeFilter('onclick,ondblclick,onmousedown,onmouseup', function (nodes, name) {
          var i = nodes.length,
            node;

          while (i--) {
            node = nodes[i];

            node.attr('data-mce-' + name, node.attr(name));
            node.attr(name, 'return false;');
          }
        });

        ed.serializer.addAttributeFilter('data-mce-onclick,data-mce-ondblclick,data-mce-onmousedown,data-mce-onmouseup', function (nodes, name) {
          var i = nodes.length,
            node, k;

          while (i--) {
            node = nodes[i], k = name.replace('data-mce-', '');

            node.attr(k, node.attr(name));
            node.attr(name, null);
          }
        });

        ed.serializer.addNodeFilter('br', function (nodes, name) {
          var i = nodes.length,
            node;

          if (i) {
            while (i--) {
              node = nodes[i];

              // parent node is body
              if (node.parent && node.parent.name === "body" && !node.prev) {
                node.remove();
              }
            }
          }
        });

        // remove br in Gecko
        ed.parser.addNodeFilter('br', function (nodes, name) {
          var i = nodes.length,
            node;

          if (i) {
            while (i--) {
              node = nodes[i];

              // parent node is body
              if (node.parent && node.parent.name === "body" && !node.prev) {
                node.remove();
              }
            }
          }
        });
      });

      // run cleanup with default settings
      if (ed.settings.verify_html === false) {
        ed.addCommand('mceCleanup', function () {
          var s = ed.settings,
            se = ed.selection,
            bm;
          bm = se.getBookmark();

          var content = ed.getContent({
            cleanup: true
          });

          // set verify to true
          s.verify_html = true;

          // create new schema
          var schema = new tinymce.html.Schema(s);

          // clean content
          content = new tinymce.html.Serializer({
            validate: true
          }, schema).serialize(new tinymce.html.DomParser({
            validate: true,
            allow_event_attributes: !!ed.settings.allow_event_attributes
          }, schema).parse(content));

          ed.setContent(content, {
            cleanup: true
          });

          se.moveToBookmark(bm);
        });
      }

      // Cleanup callback
      ed.onBeforeSetContent.add(function (ed, o) {
        // remove br tag added by Firefox
        o.content = o.content.replace(/^<br>/, '');

        // Geshi
        o.content = convertFromGeshi(o.content);

        // only if "Cleanup HTML" enabled
        if (ed.settings.validate) {
          // remove attributes
          if (ed.getParam('invalid_attributes')) {
            var s = ed.getParam('invalid_attributes', '');

            o.content = o.content.replace(new RegExp('<([^>]+)(' + s.replace(/,/g, '|') + ')="([^"]+)"([^>]*)>', 'gi'), function () {
              // get tag an attributes (if any) from arguments array, eg: match, p1,p2...pn, offset, string
              var args = arguments, tag = args[1], attribs = args[args.length - 3] || '';
              return '<' + tag + attribs + '>';
            });
          }
        }

        // pad bootstrap icons
        o.content = o.content.replace(fontIconRe, '<$1$2class="$3$4$5-$6$7"$8 data-mce-empty="1">&nbsp;</$1>');

        // padd some empty tags
        o.content = o.content.replace(/<(a|i|span)\b([^>]+)><\/\1>/gi, '<$1$2 data-mce-empty="1">&nbsp;</$1>');

        // padd list elements
        o.content = o.content.replace(/<li><\/li>/, '<li data-mce-empty="1">&nbsp;</li>');
      });

      // Cleanup callback
      ed.onPostProcess.add(function (ed, o) {
        if (o.set) {
          // Geshi
          o.content = convertFromGeshi(o.content);
        }
        if (o.get) {
          // Geshi
          o.content = convertToGeshi(o.content);

          // Remove empty jcemediabox / jceutilities anchors
          o.content = o.content.replace(/<a([^>]*)class="jce(box|popup|lightbox|tooltip|_tooltip)"([^>]*)><\/a>/gi, '');
          // Remove span elements with jcemediabox / jceutilities classes
          o.content = o.content.replace(/<span class="jce(box|popup|lightbox|tooltip|_tooltip)">(.*?)<\/span>/gi, '$2');
          // legacy mce stuff
          o.content = o.content.replace(/_mce_(src|href|style|coords|shape)="([^"]+)"\s*?/gi, '');

          if (ed.settings.validate === false) {
            // fix body content
            o.content = o.content.replace(/<body([^>]*)>([\s\S]*)<\/body>/, '$2');

            if (!ed.getParam('remove_tag_padding')) {
              // pad empty elements
              o.content = o.content.replace(/<(p|h1|h2|h3|h4|h5|h6|th|td|pre|div|address|caption)\b([^>]*)><\/\1>/gi, '<$1$2>&nbsp;</$1>');
            }
          }

          if (!ed.getParam('table_pad_empty_cells', true)) {
            o.content = o.content.replace(/<(th|td)([^>]*)>(&nbsp;|\u00a0)<\/\1>/gi, '<$1$2></$1>');
          }

          // clean empty tags
          o.content = o.content.replace(/<(a|i|span)([^>]+)>(&nbsp;|\u00a0)<\/\1>/gi, function (match, tag, attribs) {
            // remove data-mce-empty attribute
            attribs = attribs.replace('data-mce-empty="1"', '');
            // return empty tag
            return '<' + tag + ' ' + tinymce.trim(attribs) + '></' + tag + '>';
          });

          // clean empty list tags
          o.content = o.content.replace(/<li data-mce-empty="1">(&nbsp;|\u00a0)<\/li>/gi, '<li></li>');

          // remove padding on div (legacy)
          if (ed.getParam('remove_div_padding')) {
            o.content = o.content.replace(/<div([^>]*)>(&nbsp;|\u00a0)<\/div>/g, '<div$1></div>');
          }

          // remove padding on everything
          if (ed.getParam('pad_empty_tags', true) === false) {
            o.content = o.content.replace(paddedRx, '<$1$2></$1>');
          }

          // convert multiple consecutive non-breaking spaces
          if (ed.getParam('keep_nbsp', true) && ed.settings.entity_encoding === "raw") {
            o.content = o.content.replace(/\u00a0/g, '&nbsp;');
          }

          // fix boolean custom attributes
          o.content = o.content.replace(/(uk|v|ng|data)-([\w-]+)=""(\s|>)/gi, '$1-$2$3');

          // Remove empty contents
          if (ed.settings.padd_empty_editor) {
            o.content = o.content.replace(/^(<div>(&nbsp;|&#160;|\s|\u00a0|)<\/div>[\r\n]*|<br(\s*\/)?>[\r\n]*)$/, '');
          }

          // fix self-closing hr tags for pagebreak
          o.content = o.content.replace(/<hr(.*)class="system-pagebreak"(.*?)\/?>/gi, '<hr$1class="system-pagebreak"$2/>');
          // fix self-closing hr tags for readmore
          o.content = o.content.replace(/<hr id="system-readmore"(.*?)>/gi, '<hr id="system-readmore" />');
        }
      });

      ed.onSaveContent.add(function (ed, o) {
        // Convert entities to characters
        if (ed.getParam('cleanup_pluginmode')) {

          var entities = {
            '&#39;': "'",
            '&amp;': '&',
            '&quot;': '"',
            '&apos;': "'"
          };

          o.content = o.content.replace(/&(#39|apos|amp|quot);/gi, function (a) {
            return entities[a];
          });
        }
      });

      // Register buttons
      ed.addButton('cleanup', {
        title: 'advanced.cleanup_desc',
        cmd: 'mceCleanup'
      });

      function convertFromGeshi(h) {
        h = h.replace(/<pre xml:lang="([^"]+)"([^>]*)>(.*?)<\/pre>/g, function (a, b, c, d) {
          var attr = '';

          if (c && /\w/.test(c)) {
            attr = c.split(' ').join(' data-geshi-');
          }

          return '<pre data-geshi-lang="' + b + '"' + attr + '>' + d + '</pre>';
        });

        return h;
      }

      function convertToGeshi(h) {
        h = h.replace(/<pre([^>]+)data-geshi-lang="([^"]+)"([^>]*)>(.*?)<\/pre>/g, function (a, b, c, d, e) {
          var s = b + d;
          s = s.replace(/data-geshi-/gi, '').replace(/\s+/g, ' ').replace(/\s$/, '');

          return '<pre xml:lang="' + c + '"' + s + '>' + e + '</pre>';
        });

        return h;
      }
    });
  })();

  /**
   * @package   	JCE
   * @copyright 	Copyright (c) 2009-2024 Ryan Demmer. All rights reserved.
   * @license   	GNU/LGPL 2.1 or later - http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
   * JCE is free software. This version may have been modified pursuant
   * to the GNU General Public License, and as distributed it includes or
   * is derivative of works licensed under the GNU General Public License or
   * other free or open source software licenses.
   */

  /*global tinymce:true */

  (function () {
    var each = tinymce.each,
      Node = tinymce.html.Node,
      VK = tinymce.VK,
      DomParser = tinymce.html.DomParser,
      Serializer = tinymce.html.Serializer,
      SaxParser = tinymce.html.SaxParser;

    function createTextNode(value, raw) {
      var text = new Node('#text', 3);
      text.raw = raw !== false ? true : false;
      text.value = value;

      return text;
    }

    function isOnlyChild(node) {
      var parent = node.parent,
        child = parent.firstChild,
        count = 0;

      if (child) {
        do {
          if (child.type === 1) {
            // Ignore bogus elements
            if (child.attributes.map['data-mce-type'] || child.attributes.map['data-mce-bogus']) {
              continue;
            }

            if (child === node) {
              continue;
            }

            count++;
          }

          // Keep comments
          if (child.type === 8) {
            count++;
          }

          // Keep non whitespace text nodes
          if ((child.type === 3 && !/^[ \t\r\n]*$/.test(child.value))) {
            count++;
          }
        } while ((child = child.next));
      }

      return count === 0;
    }

    tinymce.PluginManager.add('code', function (ed, url) {

      var blockElements = [], inlineElements = [],
        htmlSchema = new tinymce.html.Schema({
          schema: 'mixed',
          invalid_elements: ed.settings.invalid_elements
        }),
        xmlSchema = new tinymce.html.Schema({
          verify_html: false
        });

      // should code blocks be used?
      var code_blocks = ed.settings.code_use_blocks !== false;

      // allow script URLS, eg: href="javascript:;"
      if (ed.settings.code_allow_script) {
        ed.settings.allow_script_urls = true;
      }

      ed.addCommand('InsertShortCode', function (ui, html) {
        if (ed.settings.code_protect_shortcode) {
          html = processShortcode(html, 'pre');

          if (tinymce.is(html)) {
            ed.execCommand('mceReplaceContent', false, html);
          }
        }

        return false;
      });

      function processOnInsert(value, node) {
        if (/\{.+\}/gi.test(value) && ed.settings.code_protect_shortcode) {
          var tagName;

          // an empty block container, so insert as <pre>
          /*if (node && ed.dom.isEmpty(node)) {
            tagName = 'pre';
          }*/

          value = processShortcode(value, tagName);
        }

        if (ed.settings.code_allow_custom_xml) {
          value = processXML(value);
        }

        // script / style
        if (/<(\?|script|style)/.test(value)) {
          // process script and style tags
          value = value.replace(/<(script|style)([^>]*?)>([\s\S]*?)<\/\1>/gi, function (match, type) {
            if (!ed.getParam('code_allow_' + type)) {
              return '';
            }

            match = match.replace(/<br[^>]*?>/gi, '\n');

            return createCodePre(match, type);
          });

          value = processPhp(value);
        }

        return value;
      }

      /**
       * Detect and process shortcode in an html string
       * @param {String} html
       * @param {String} tagName
       */
      function processShortcode(html, tagName) {
        // quick check to see if we should proceed
        if (html.indexOf('{') === -1) {
          return html;
        }

        // skip stuff like {1} etc.
        if (html.charAt(0) == '{' && html.length < 3) {
          return html;
        }

        // process as sourcerer
        if (html.indexOf('{/source}') != -1) {
          html = processSourcerer(html);
        }

        // default to inline span if the tagName is not set. This will be converted to pre by the DomParser if required
        tagName = tagName || 'span';

        // shortcode blocks eg: {article}\nhtml{/article} or inline or single line shortcode, eg: {youtube}https://www.youtube.com/watch?v=xxDv_RTdLQo{/youtube}
        return html.replace(/(?:(<(code|pre|samp|span)[^>]*(data-mce-type="code")?>)?)(?:\{)([\w-]+)(.*?)(?:\/?\})(?:([\s\S]+?)\{\/\4\})?/g, function (match) {
          // already wrapped in a tag
          if (match.charAt(0) === '<') {
            return match;
          }

          return createShortcodePre(match, tagName);
        });
      }

      function processSourcerer(html) {
        // quick check to see if we should proceed
        if (html.indexOf('{/source}') === -1) {
          return html;
        }

        // shortcode blocks eg: {source}html{/source}
        return html.replace(/(?:(<(code|pre|samp|span)[^>]*(data-mce-type="code")?>|")?)\{source(.*?)\}([\s\S]+?)\{\/source\}/g, function (match) {
          // already wrapped in a tag
          if (match.charAt(0) === '<' || match.charAt(0) === '"') {
            return match;
          }

          match = ed.dom.decode(match);

          return '<pre data-mce-code="shortcode" data-mce-label="sourcerer">' + ed.dom.encode(match) + '</pre>';
        });
      }

      function processPhp(content) {
        // Remove PHP if not enabled
        if (!ed.settings.code_allow_php) {
          return content.replace(/<\?(php)?([\s\S]*?)\?>/gi, '');
        }

        // PHP code within an attribute
        content = content.replace(/\="([^"]+?)"/g, function (a, b) {
          b = b.replace(/<\?(php)?(.+?)\?>/gi, function (x, y, z) {
            return '__php_start__' + ed.dom.encode(z) + '__php_end__';
          });

          return '="' + b + '"';
        });

        // PHP code within a textarea
        if (/<textarea/.test(content)) {
          content = content.replace(/<textarea([^>]*)>([\s\S]*?)<\/textarea>/gi, function (a, b, c) {
            c = c.replace(/<\?(php)?(.+?)\?>/gi, function (x, y, z) {
              return '__php_start__' + ed.dom.encode(z) + '__php_end__';
            });
            return '<textarea' + b + '>' + c + '</textarea>';
          });
        }

        // PHP code within an element
        content = content.replace(/<([^>]+)<\?(php)?(.+?)\?>([^>]*?)>/gi, function (a, b, c, d, e) {
          if (b.charAt(b.length) !== ' ') {
            b += ' ';
          }
          return '<' + b + 'data-mce-php="' + d + '" ' + e + '>';
        });

        // PHP code other
        content = content.replace(/<\?(php)?([\s\S]+?)\?>/gi, function (match) {
          // replace newlines with <br /> so they are preserved inside the span
          match = match.replace(/\n/g, '<br />');

          // create code span
          return createCodePre(match, 'php', 'span');
        });

        return content;
      }

      /**
       * Check whether a tag is a defined invalid element
       * @param {String} name
       */
      function isInvalidElement(name) {
        var invalid_elements = ed.settings.invalid_elements.split(',');
        return tinymce.inArray(invalid_elements, name) !== -1;
      }

      /**
       * Check if a tag is an XML element - not part of the HMTL Schema, but is also not a defined invalid element
       * @param {String} name
       */
      function isXmlElement(name) {
        return !htmlSchema.isValid(name) && !isInvalidElement(name);
      }

      /**
       * Validate xml code using a custom SaxParser. This will remove event attributes ir required, and validate nested html using the editor schema.
       * @param {String} xml
       */
      function validateXml(xml) {
        var html = [];

        // check that the element or attribute is not invalid
        function isValid(tag, attr) {
          // is an xml tag and is not an invalid_element
          if (isXmlElement(tag)) {
            return true;
          }

          return ed.schema.isValid(tag, attr);
        }

        new SaxParser({
          start: function (name, attrs, empty) {
            if (!isValid(name)) {
              return;
            }

            html.push('<', name);

            var attr;

            if (attrs) {
              for (var i = 0, len = attrs.length; i < len; i++) {
                attr = attrs[i];

                if (!isValid(name, attr.name)) {
                  continue;
                }

                // skip event attributes
                if (ed.settings.allow_event_attributes !== true) {
                  if (attr.name.indexOf('on') === 0) {
                    continue;
                  }
                }

                html.push(' ', attr.name, '="', ed.dom.encode('' + attr.value, true), '"');
              }
            }

            if (!empty) {
              html[html.length] = '>';
            } else {
              html[html.length] = ' />';
            }
          },

          text: function (value) {
            if (value.length > 0) {
              html[html.length] = value;
            }
          },

          end: function (name) {
            if (!isValid(name)) {
              return;
            }

            html.push('</', name, '>');
          },

          cdata: function (text) {
            html.push('<![CDATA[', text, ']]>');
          },

          comment: function (text) {
            html.push('<!--', text, '-->');
          }
        }, xmlSchema).parse(xml);

        return html.join('');
      }

      /**
       * Detect and process xml tags
       * @param {String} content
       */
      function processXML(content) {
        return content.replace(/<([a-z0-9\-_\:\.]+)(?:[^>]*?)\/?>((?:[\s\S]*?)<\/\1>)?/gi, function (match, tag) {
          // check if svg is allowed
          if (tag === 'svg' && ed.settings.code_allow_svg_in_xml === false) {
            return match;
          }

          // check if mathml is allowed
          if (tag === 'math' && ed.settings.code_allow_mathml_in_xml === false) {
            return match;
          }

          // check if the tags is part of the generic HTML schema, return if true
          if (!isXmlElement(tag)) {
            return match;
          }

          // validate xml by default to remove event attributes and invalid nested html
          if (ed.settings.code_validate_xml !== false) {
            match = validateXml(match);
          }

          return createCodePre(match, 'xml');
        });
      }

      /**
       * Create a shortcode pre. This differs from the code pre as it is still contenteditable
       * @param {String} data
       * @param {String} tag
       */
      function createShortcodePre(data, tag) {
        // decode data before re-encoding
        data = ed.dom.decode(data);

        // replace newlines with linebreaks
        data = data.replace(/[\n\r]/gi, '<br />');

        return ed.dom.createHTML(tag || 'pre', {
          'data-mce-code': 'shortcode',
          'data-mce-type': 'shortcode'
        }, ed.dom.encode(data));
      }

      /**
       * Create a code pre. This pre is not contenteditable by the editor, and plaintext-only
       * @param {String} data
       * @param {String} type
       * @param {String} tag
       */
      function createCodePre(data, type, tag) {
        // "protect" code if we are not using code blocks
        if (!code_blocks) {
          // convert linebreaks to newlines
          data = data.replace(/<br[^>]*?>/gi, '\n');

          // create placeholder span
          return ed.dom.createHTML('img', {
            src: 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7',
            'data-mce-resize': 'false',
            'data-mce-code': type || 'script',
            'data-mce-type': 'placeholder',
            'data-mce-value': escape(data)
          });
        }

        return ed.dom.createHTML(tag || 'pre', {
          'data-mce-code': type || 'script'
        }, ed.dom.encode(data));
      }

      function handleEnterInPre(ed, node, before) {
        var parents = ed.dom.getParents(node, blockElements.join(','));

        // set defualt content and get the element to use
        var newBlockName = ed.settings.forced_root_block || 'p';

        // reset if force_block_newlines is false (linebreak on enter)
        if (ed.settings.force_block_newlines === false) {
          newBlockName = 'br';
        }

        // get the first block in the collection
        var block = parents.shift();

        // skip if it is the body
        if (block === ed.getBody()) {
          return;
        }

        // create element
        var elm = ed.dom.create(newBlockName, {}, '\u00a0');

        // insert after parent element
        if (before) {
          block.parentNode.insertBefore(elm, block);
        } else {
          ed.dom.insertAfter(elm, block);
        }

        var rng = ed.selection.getRng();

        rng.setStart(elm, 0);
        rng.setEnd(elm, 0);

        ed.selection.setRng(rng);
        ed.selection.scrollIntoView(elm);
      }

      ed.onKeyDown.add(function (ed, e) {
        var node;

        if (e.keyCode == VK.ENTER) {
          node = ed.selection.getNode();

          // override enter key behaviour in shortcode pre blocks
          if (node.nodeName === 'PRE' && node.getAttribute('data-mce-code') === 'shortcode') {
            if (!e.shiftKey) {
              ed.execCommand("InsertLineBreak", false, e);
              e.preventDefault();
            }

            return;
          }

          if (node.nodeName === 'SPAN' && node.getAttribute('data-mce-code')) {
            handleEnterInPre(ed, node);
            e.preventDefault();
          }
        }

        if (e.keyCode == VK.UP && e.altKey) {
          node = ed.selection.getNode();

          if (node.nodeName == 'PRE') {
            handleEnterInPre(ed, node, true);
            e.preventDefault();
          }
        }

        // Check for tab but not ctrl/cmd+tab since it switches browser tabs
        if (e.keyCode == 9 && !VK.metaKeyPressed(e)) {
          node = ed.selection.getNode();

          if (node.nodeName === 'PRE' && node.getAttribute('data-mce-code')) {
            ed.selection.setContent('\t', {
              no_events: true
            });
            e.preventDefault();
          }
        }

        if (e.keyCode === VK.BACKSPACE || e.keyCode === VK.DELETE) {
          node = ed.selection.getNode();

          if (node.nodeName === 'SPAN' && node.getAttribute('data-mce-code') && node.getAttribute('data-mce-type') === 'placeholder') {
            ed.undoManager.add();

            ed.dom.remove(node);
            e.preventDefault();
          }
        }
      });

      ed.onPreInit.add(function () {
        function isCodePlaceholder(node) {
          return node.nodeName === 'SPAN' && node.getAttribute('data-mce-code') && node.getAttribute('data-mce-type') == 'placeholder';
        }

        ed.dom.bind(ed.getDoc(), 'keyup click', function (e) {
          var node = e.target,
            sel = ed.selection.getNode();

          ed.dom.removeClass(ed.dom.select('.mce-item-selected'), 'mce-item-selected');

          // edge case where forced_root_block:false
          if (node === ed.getBody() && isCodePlaceholder(sel)) {
            if (sel.parentNode === node && !sel.nextSibling) {
              ed.dom.insertAfter(ed.dom.create('br', {
                'data-mce-bogus': 1
              }), sel);
            }

            return;
          }

          if (isCodePlaceholder(node)) {
            e.preventDefault();
            e.stopImmediatePropagation();

            ed.selection.select(node);

            // add a slight delay before adding selected class to avoid it being removed by the keyup event
            window.setTimeout(function () {
              ed.dom.addClass(node, 'mce-item-selected');
            }, 10);

            e.preventDefault();
          }
        });

        var ctrl = ed.controlManager.get('formatselect');

        if (ctrl) {
          each(['script', 'style', 'php', 'shortcode', 'xml'], function (key) {
            // control element title
            var title = ed.getLang('code.' + key, key);

            if (key === 'shortcode' && ed.settings.code_protect_shortcode) {
              ctrl.add(title, key, {
                class: 'mce-code-' + key
              });

              ed.formatter.register('shortcode', {
                block: 'pre',
                attributes: {
                  'data-mce-code': 'shortcode'
                }
              });

              return true;
            }

            // map settings value to simplified key
            if (key === 'xml') {
              ed.settings.code_allow_xml = !!ed.settings.code_allow_custom_xml;
            }

            if (ed.getParam('code_allow_' + key) && code_blocks) {
              ctrl.add(title, key, {
                class: 'mce-code-' + key
              });

              ed.formatter.register(key, {
                block: 'pre',
                attributes: {
                  'data-mce-code': key
                },
                onformat: function (elm, fmt, vars) {
                  // replace linebreaks with newlines
                  each(ed.dom.select('br', elm), function (br) {
                    ed.dom.replace(ed.dom.doc.createTextNode('\n'), br);
                  });
                }
              });
            }
          });
        }

        // store block elements from schema map
        each(ed.schema.getBlockElements(), function (block, blockName) {
          blockElements.push(blockName);
        });

        each(ed.schema.getTextInlineElements(), function (inline, name) {
          inlineElements.push(name);
        });

        if (ed.settings.code_protect_shortcode) {
          ed.textpattern.addPattern({
            start: '{',
            end: '}',
            cmd: 'InsertShortCode',
            remove: true
          });

          ed.textpattern.addPattern({
            start: ' {',
            end: '}',
            format: 'inline-shortcode',
            remove: false
          });
        }

        ed.formatter.register('inline-shortcode', {
          inline: 'span',
          attributes: {
            'data-mce-code': 'shortcode'
          }
        });

        // remove paragraph parent of a pre block
        ed.onSetContent.add(function (ed, o) {
          each(ed.dom.select('pre[data-mce-code]', ed.getBody()), function (elm) {
            var p = ed.dom.getParent(elm, 'p');

            if (p && p.childNodes.length === 1) {
              ed.dom.remove(p, 1);
            }
          });
        });

        // Convert script elements to span placeholder
        ed.parser.addNodeFilter('script,style', function (nodes) {
          var i = nodes.length,
            node;

          while (i--) {
            var node = nodes[i];

            // remove any code spans that are added to json-like syntax in code blocks
            if (node.firstChild) {
              node.firstChild.value = node.firstChild.value.replace(/<span([^>]+)>([\s\S]+?)<\/span>/gi, function (match, attr, content) {
                if (attr.indexOf('data-mce-code') === -1) {
                  return match;
                }

                return ed.dom.decode(content);
              });
            }

            if (!code_blocks) {
              var value = '';

              if (node.firstChild) {
                value = tinymce.trim(node.firstChild.value);
              }

              var placeholder = Node.create('img', {
                src: 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7',
                'data-mce-code': node.name,
                'data-mce-type': 'placeholder',
                'data-mce-resize': 'false',
                title: ed.dom.encode(value)
              });

              // eslint-disable-next-line no-loop-func
              each(node.attributes, function (attr) {
                placeholder.attr('data-mce-p-' + attr.name, attr.value);
              });

              if (value) {
                placeholder.attr('data-mce-value', escape(value));

                //var text = createTextNode('<!--mce:protected ' + escape(value) + '-->')
                //placeholder.append(text);
              }

              node.replace(placeholder);

              continue;
            }

            // serialize to string
            value = new Serializer({
              validate: false
            }).serialize(node);

            // trim
            value = tinymce.trim(value);

            var pre = new Node('pre', 1);

            pre.attr({
              'data-mce-code': node.name
            });

            var text = createTextNode(value, false);
            pre.append(text);

            node.replace(pre);
          }
        });

        ed.parser.addAttributeFilter('data-mce-code', function (nodes, name) {
          var i = nodes.length,
            node, parent;

          function isBody(parent) {
            return parent.name === 'body';
          }

          function isValidCode(type) {
            return type === 'shortcode' || type === 'php';
          }

          function isBlockNode(node) {
            return tinymce.inArray(blockElements, node.name) != -1;
          }

          function isInlineTextNode(node) {
            return tinymce.inArray(inlineElements, node.name) != -1;
          }

          function isInlineNode(node) {
            if (node.name != 'span') {
              return false;
            }

            if (node.next && (node.next.type == '#text' || !isBlockNode(node.next))) {
              return true;
            }

            if (node.prev && (node.prev.type == '#text' || !isBlockNode(node.prev))) {
              return true;
            }

            if (node.parent && !isBlockNode(node.parent)) {
              return true;
            }

            return false;
          }

          while (i--) {
            node = nodes[i], parent = node.parent;

            // don't process placeholders
            if (node.attr('data-mce-type') == 'placeholder') {
              continue;
            }

            if (!isValidCode(node.attr(name))) {
              continue;
            }

            var value = node.firstChild.value;

            // replace linebreaks with newlines
            if (value) {
              node.firstChild.value = value.replace(/<br[\s\/]*>/g, '\n');
            }

            if (parent) {
              // don't process shortcode in code blocks
              if (parent.attr(name)) {
                node.unwrap();
                continue;
              }

              // rename shortcode blocks to <pre>
              if (isBody(parent) || isOnlyChild(node) || !isInlineNode(node)) {
                node.name = 'pre';

                // reset if node parent is inline and not a block node, eg: <strong>{var}</strong>
                if (node.parent && isInlineTextNode(node.parent)) {
                  node.name = 'span';
                }
              }

              // add whitespace after the span so a cursor can be set
              if (node.name == 'span' && node === parent.lastChild) {
                var nbsp = createTextNode('\u00a0');
                parent.append(nbsp);
              }
            }
          }
        });

        ed.serializer.addAttributeFilter('data-mce-code', function (nodes, name) {
          var i = nodes.length,
            node, child;

          function isXmlNode(node) {
            return !/(shortcode|php)/.test(node.attr('data-mce-code'));
          }

          while (i--) {
            var root_block = false;

            node = nodes[i];

            // get the code block type, eg: script, shortcode, style, php
            var type = node.attr(name);

            if (node.name === 'img') {
              var elm = new Node(type, 1);

              for (var key in node.attributes.map) {
                var val = node.attributes.map[key];

                if (key.indexOf('data-mce-p-') !== -1) {
                  key = key.substr(11);
                } else {
                  val = null;
                }

                elm.attr(key, val);
              }

              var value = node.attr('data-mce-value');

              if (value) {
                var text = createTextNode(unescape(value));

                // only use text node if shortcode or php
                if (type == 'php' || type == 'shortcode') {
                  elm = text;
                } else {
                  elm.append(text);
                }
              }

              node.replace(elm);

              continue;
            }

            // pre node is empty, remove
            if (node.isEmpty()) {
              node.remove();
            }

            // skip xml
            if (type === 'xml') {
              continue;
            }

            // set the root block type for script and style tags so the parser does the work wrapping free text
            if (type === 'script' || type === 'style') {
              root_block = type;
            }

            var child = node.firstChild,
              newNode = node.clone(true),
              text = '';

            if (child) {
              do {
                if (isXmlNode(node)) {
                  var value = child.name == 'br' ? '\n' : child.value;

                  if (value) {
                    text += value;
                  }
                }
              } while ((child = child.next));
            }

            if (text) {
              newNode.empty();

              var parser = new DomParser({
                validate: false
              });

              // validate attributes of script and style tags
              if (type === 'script' || type === 'style') {
                parser.addNodeFilter(type, function (items, name) {
                  var n = items.length;

                  while (n--) {
                    var item = items[n];

                    // eslint-disable-next-line no-loop-func
                    each(item.attributes, function (attr) {
                      if (!attr) {
                        return true;
                      }

                      // allow data-* attributes
                      if (attr.name.indexOf('data-') === 0 && attr.name.indexOf('data-mce-') === -1) {
                        return true;
                      }

                      if (ed.schema.isValid(name, attr.name) === false) {
                        item.attr(attr.name, null);
                      }
                    });
                  }
                });
              }

              // parse text and process
              var fragment = parser.parse(text, {
                forced_root_block: root_block
              });
              // append fragment to <pre> clone
              newNode.append(fragment);
            }

            node.replace(newNode);

            if (type === 'shortcode' && newNode.name === 'pre') {
              // append newline to the end of shortcode blocks
              var newline = createTextNode('\n');
              newNode.append(newline);

              // unwrap to text as further processing is not needed
              newNode.unwrap();
            }
          }
        });

        ed.onPaste.addToTop(function (ed, e) {
          var clipboardData = e.clipboardData || window.clipboardData || null;

          if (!clipboardData) {
            return;
          }

          var text = clipboardData.getData('text/plain') || clipboardData.getData('Text') || clipboardData.getData('text') || '';
          var value = '';

          // trim text
          text = tinymce.trim(text);

          if (text) {
            var node = ed.selection.getNode();

            // don't process into PRE tags
            if (node && node.nodeName === 'PRE') {
              return;
            }

            value = processOnInsert(text);

            // update with processed text
            if (value !== text) {
              e.preventDefault();
              ed.execCommand('mceInsertContent', false, value);
            }
          }
        });

        /*ed.onNodeChange.add(function (ed, cm, node) {
          var toolbar = DOM.get(ed.id + '_toolbar');
          
          if (node && node.hasAttribute('data-mce-code')) {
            if (toolbar) {
              DOM.addClass(toolbar, 'mceDisabled');
            }
          } else {
            DOM.removeClass(toolbar, 'mceDisabled');
          }
        });*/

        ed.onContextMenu.addToTop(function (ed, e) {
          var node = ed.selection.getNode();

          if (node && node.hasAttribute('data-mce-code')) {
            return false;
          }
        });
      });

      ed.onInit.add(function () {
        // Display "script" instead of "pre" in element path
        if (ed.theme && ed.theme.onResolveName) {
          ed.theme.onResolveName.add(function (theme, o) {
            var node = o.node;

            if (node.getAttribute('data-mce-code')) {
              o.name = node.getAttribute('data-mce-code');
            }
          });
        }
      });

      ed.onBeforeSetContent.addToTop(function (ed, o) {
        if (ed.settings.code_protect_shortcode) {
          if (o.content.indexOf('data-mce-code="shortcode"') === -1) {
            o.content = processShortcode(o.content);
          }
        }

        if (ed.settings.code_allow_custom_xml) {
          // only process content on "load"
          if (o.content && o.load) {
            o.content = processXML(o.content);
          }
        }

        // test for PHP, Script or Style
        if (/<(\?|script|style)/.test(o.content)) {
          // Remove javascript if not enabled
          if (!ed.settings.code_allow_script) {
            o.content = o.content.replace(/<script[^>]*>([\s\S]*?)<\/script>/gi, '');
          }

          if (!ed.settings.code_allow_style) {
            o.content = o.content.replace(/<style[^>]*>([\s\S]*?)<\/style>/gi, '');
          }

          o.content = processPhp(o.content);
        }
      });

      ed.onPostProcess.add(function (ed, o) {
        if (o.get) {
          // Process converted php
          if (/(data-mce-php|__php_start__)/.test(o.content)) {
            // attribute value
            o.content = o.content.replace(/({source})?__php_start__(.*?)__php_end__/g, function (match, pre, code) {
              return (pre || '') + '<?php' + ed.dom.decode(code) + '?>';
            });

            // textarea
            o.content = o.content.replace(/<textarea([^>]*)>([\s\S]*?)<\/textarea>/gi, function (a, b, c) {
              if (/&lt;\?php/.test(c)) {
                c = ed.dom.decode(c);
              }
              return '<textarea' + b + '>' + c + '</textarea>';
            });

            // as attribute
            o.content = o.content.replace(/data-mce-php="([^"]+?)"/g, function (a, b) {
              return '<?php' + ed.dom.decode(b) + '?>';
            });
          }

          // shortcode content will be encoded as text, so decode
          if (ed.settings.code_protect_shortcode) {

            o.content = o.content.replace(/\{([\s\S]+?)\}/gi, function (match, content) {
              return '{' + ed.dom.decode(content) + '}';
            });

            // sourcerer with encoded content
            o.content = o.content.replace(/\{source([^\}]*?)\}([\s\S]+?)\{\/source\}/gi, function (match, start, content) {
              return '{source' + start + '}' + ed.dom.decode(content) + '{/source}';
            });

            // other shotcode tags
            o.content = o.content.replace(/\{([\w-]+)(.*?)\}([\s\S]+)\{\/\1\}/gi, function (match, start, attr, content) {
              return '{' + start + attr + '}' + ed.dom.decode(content) + '{/' + start + '}';
            });
          }

          // decode code snippets
          o.content = o.content.replace(/<(pre|span)([^>]+?)>([\s\S]*?)<\/\1>/gi, function (match, tag, attr, content) {
            // not the droids etc.
            if (attr.indexOf('data-mce-code') === -1) {
              return match;
            }

            // trim content
            content = tinymce.trim(content);

            // get element from match
            var node = ed.dom.create('div', {}, match), elm = node.firstChild, type = elm.getAttribute('data-mce-code');

            // replace linebreaks with newline in some blocks
            if (type != 'script') {
              content = content.replace(/<br[^>]*?>/gi, '\n');
            }

            // decode content
            content = ed.dom.decode(content);

            // remove and replace <?php?> tags
            if (type == 'php') {
              content = content.replace(/<\?(php)?/gi, '').replace(/\?>/g, '');
              content = '<?php\n' + tinymce.trim(content) + '\n?>';
            }

            return content;
          });

          // decode protected code
          o.content = o.content.replace(/<!--mce:protected ([\s\S]+?)-->/gi, function (match, content) {
            return unescape(content);
          });
        }
      });
    });
  })();

  /**
   * @package   	JCE
   * @copyright 	Copyright (c) 2009-2024 Ryan Demmer. All rights reserved.
   * @license   	GNU/GPL 2 or later - http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
   * JCE is free software. This version may have been modified pursuant
   * to the GNU General Public License, and as distributed it includes or
   * is derivative of works licensed under the GNU General Public License or
   * other free or open source software licenses.
   */
  (function () {
      var each = tinymce.each;

      // Register plugin
      tinymce.PluginManager.add('effects', function (ed, url) {
          function cleanEventAttribute(val) {
              if (!val) {
                  return '';
              }

              return val.replace(/^\s*this.src\s*=\s*\'([^\']+)\';?\s*$/, '$1').replace(/^\s*|\s*$/g, '');
          }

          ed.onPreInit.add(function () {
              ed.onBeforeSetContent.add(function (ed, o) {

                  if (o.content.indexOf('onmouseover=') === -1) {
                      return;
                  }

                  var div = ed.dom.create('div', {}, o.content);

                  each(ed.dom.select('img[onmouseover]', div), function (node) {
                      var mouseover = node.getAttribute('onmouseover'), mouseout = node.getAttribute('onmouseout');

                      if (!mouseover || mouseover.indexOf('this.src') !== 0) {
                          return true;
                      }

                      mouseover = cleanEventAttribute(mouseover);

                      // remove attribute
                      node.removeAttribute('onmouseover');

                      // if cleaned value is blank, move on
                      if (!mouseover) {
                          return true;
                      }

                      node.setAttribute('data-mouseover', mouseover);

                      if (mouseout && mouseout.indexOf('this.src') === 0) {

                          mouseout = cleanEventAttribute(mouseout);

                          // remove attribute
                          node.removeAttribute('onmouseout');

                          if (!mouseout) {
                              return;
                          }

                          node.setAttribute('data-mouseout', mouseout);
                      }
                  });

                  o.content = div.innerHTML;
              });

              // update event effects
              ed.parser.addAttributeFilter('onmouseover', function (nodes) {
                  var i = nodes.length;

                  while (i--) {
                      var node = nodes[i];

                      if (node.name !== 'img') {
                          continue;
                      }

                      var mouseover = node.attr('onmouseover'), mouseout = node.attr('onmouseout');

                      if (!mouseover || mouseover.indexOf('this.src') !== 0) {
                          continue;
                      }

                      mouseover = cleanEventAttribute(mouseover);

                      node.attr('data-mouseover', mouseover);
                      node.attr('onmouseover', null);

                      if (mouseout && mouseout.indexOf('this.src') === 0) {
                          mouseout = cleanEventAttribute(mouseout);

                          node.attr('data-mouseout', mouseout);
                          node.attr('onmouseout', null);
                      }
                  }
              });

              ed.serializer.addAttributeFilter('data-mouseover', function (nodes) {
                  var i = nodes.length;

                  while (i--) {
                      var node = nodes[i];

                      if (node.name !== 'img') {
                          continue;
                      }

                      var mouseover = node.attr('data-mouseover'), mouseout = node.attr('data-mouseout');

                      mouseover = cleanEventAttribute(mouseover);

                      node.attr('data-mouseover', null);
                      node.attr('data-mouseout', null);

                      if (!mouseover) {
                          continue;
                      }

                      node.attr('onmouseover', "this.src='" + mouseover + "';");

                      mouseout = cleanEventAttribute(mouseout);

                      if (mouseout) {
                          node.attr('onmouseout', "this.src='" + mouseout + "';");
                      }
                  }
              });

              // update events when content is inserted
              /*ed.selection.onSetContent.add(function () {
                  bindMouseoverEvent(ed);
              });*/

              // update events when content is set
              ed.onSetContent.add(function () {
                  bindMouseoverEvent(ed);
              });

              ed.onUpdateMedia.add(function (ed, o) {
                  bindMouseoverEvent(ed);
                  
                  if (!o.before || !o.after) {
                      return;
                  }

                  each(ed.dom.select('img[data-mouseover]'), function (elm) {
                      var mouseover = elm.getAttribute('data-mouseover'), mouseout = elm.getAttribute('data-mouseout');

                      if (!mouseover) {
                          return true;
                      }

                      if (mouseover == o.before) {
                          elm.setAttribute('data-mouseover', o.after);
                      }

                      if (mouseout == o.before) {
                          elm.setAttribute('data-mouseout', o.after);
                      }
                  });
              });
          });

          function bindMouseoverEvent(ed) {
              each(ed.dom.select('img'), function (elm) {
                  var src = elm.getAttribute('src'), mouseover = elm.getAttribute('data-mouseover'), mouseout = elm.getAttribute('data-mouseout');

                  elm.onmouseover = elm.onmouseout = null;

                  if (!src || !mouseover || !mouseout) {
                      return true;
                  }

                  elm.onmouseover = function () {
                      elm.setAttribute('src', elm.getAttribute('data-mouseover'));
                  };

                  elm.onmouseout = function () {
                      elm.setAttribute('src', elm.getAttribute('data-mouseout') || src);
                  };
              });
          }
      });
  })();

  /**
   * @package   	JCE
   * @copyright 	Copyright (c) 2009-2024 Ryan Demmer. All rights reserved.
   * @license   	GNU/GPL 2 or later - http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
   * JCE is free software. This version may have been modified pursuant
   * to the GNU General Public License, and as distributed it includes or
   * is derivative of works licensed under the GNU General Public License or
   * other free or open source software licenses.
   */

  /*global tinymce:true */

  (function () {
    var VK = tinymce.VK,
      each = tinymce.each;
    var blocks = [];

    tinymce.PluginManager.add('format', function (ed, url) {

      // Register buttons
      ed.addButton('italic', {
        title: 'advanced.italic_desc',
        onclick: function (e) {
          e.preventDefault();

          // restore focus
          ed.focus();

          e.shiftKey ? ed.formatter.toggle('italic-i') : ed.formatter.toggle('italic');

          ed.undoManager.add();
        }
      });

      ed.addShortcut('meta+shift+i', 'italic.desc', function () {
        ed.formatter.apply('italic-i');
      });

      function addSoftHyphenShortcut() {
        ed.addCommand('mceSoftHyphen', function () {
          ed.execCommand('mceInsertContent', false, (ed.plugins.visualchars && ed.plugins.visualchars.state) ? '<span data-mce-bogus="1" class="mce-item-hidden mce-item-shy">&shy;</span>' : '&shy;');
        });

        var keyCode = 189;

        // Firefox seems to use a different keyCode, - instead of _
        if (tinymce.isGecko) {
          keyCode = 173;
        }

        ed.addShortcut('ctrl+shift+' + keyCode, 'softhyphen.desc', 'mceSoftHyphen');

      }

      // add shoft hyphen keyboard shortcut
      addSoftHyphenShortcut();

      ed.onPreInit.add(function (ed) {
        each(ed.schema.getBlockElements(), function (v, k) {
          if (/\W/.test(k)) {
            return true;
          }

          blocks.push(k.toLowerCase());
        });

        // Register default block formats
        ed.formatter.register('aside', {
          block: 'aside',
          remove: 'all',
          wrapper: true
        });

        // paragraph
        ed.formatter.register('p', {
          block: 'p',
          remove: 'all'
        });

        // div
        ed.formatter.register('div', {
          block: 'div',
          onmatch: ed.settings.forced_root_block ? function () {
            return false;
          } : false
        });

        // div container
        ed.formatter.register('div_container', {
          block: 'div',
          wrapper: true,
          onmatch: ed.settings.forced_root_block ? function () {
            return false;
          } : false
        });

        // span
        ed.formatter.register('span', {
          inline: 'span',
          remove: 'all',
          onmatch: function () {
            return false;
          }
        });

        // section
        ed.formatter.register('section', {
          block: 'section',
          remove: 'all',
          wrapper: true,
          merge_siblings: false
        });

        // article
        ed.formatter.register('article', {
          block: 'article',
          remove: 'all',
          wrapper: true,
          merge_siblings: false
        });

        // footer
        ed.formatter.register('footer', {
          block: 'footer',
          remove: 'all',
          wrapper: true,
          merge_siblings: false
        });

        // header
        ed.formatter.register('header', {
          block: 'header',
          remove: 'all',
          wrapper: true,
          merge_siblings: false
        });

        // nav
        ed.formatter.register('nav', {
          block: 'nav',
          remove: 'all',
          wrapper: true,
          merge_siblings: false
        });

        // code
        ed.formatter.register('code', {
          inline: 'code',
          remove: 'all'
        });

        // samp
        ed.formatter.register('samp', {
          inline: 'samp',
          remove: 'all'
        });

        // blockquote - remove wrapper?
        ed.formatter.register('blockquote', {
          block: 'blockquote',
          wrapper: 1,
          remove: 'all',
          merge_siblings: false
        });

        // Italic - <i>
        ed.formatter.register('italic-i', {
          inline: 'i',
          remove: 'all'
        });

        var custom_css = ed.getParam('custom_css', '');

        // load custom css if any
        if (custom_css) {
          var doc = ed.getDoc(), head = doc.getElementsByTagName('head')[0];

          var style = ed.dom.create('style', { type: 'text/css', id: 'mceCustomStyles' });

          var values = [];

          each(custom_css.split(';'), function (value) {
            values.push('.mceContentBody ' + value);
          });

          style.appendChild(doc.createTextNode(values.join(';')));

          head.appendChild(style);
        }

      });

      // update with HMTL5 tags
      ed.settings.removeformat = [{
        selector: 'b,strong,em,i,font,u,strike,sub,sup,dfn,code,samp,kbd,var,cite,mark,q,footer',
        remove: 'all',
        split: true,
        expand: false,
        block_expand: true,
        deep: true
      }];

      ed.onKeyDown.add(function (ed, e) {

        // select parent element with SHIFT + UP
        /*if (e.keyCode == VK.UP && e.shiftKey) {
          var p, n = ed.selection.getNode();

          // Find parent element just before the document body
          p = ed.dom.getParents(n, blocks.join(','));

          // get the first block in the collection
          var block = p[p.length - 1];

          if (block === ed.getBody() || block === n) {
            return;
          }

          // prevent default action
          e.preventDefault();

          ed.selection.select(block);
        }*/

        if ((e.keyCode === VK.ENTER || e.keyCode === VK.UP || e.keyCode === VK.DOWN) && e.altKey) {
          // clear blocks
          clearBlocks(e);
        }
      });

      ed.onKeyUp.addToTop(function (ed, e) {
        if (e.keyCode === VK.ENTER) {
          var n = ed.selection.getNode();
          if (n.nodeName === 'DIV' && ed.settings.force_block_newlines) {
            // remove all attributes
            if (ed.settings.keep_styles === false) {
              ed.dom.removeAllAttribs(n);
            }
            ed.formatter.apply('p');
          }
        }
      });

      // Format Block fix
      ed.onBeforeExecCommand.add(function (ed, cmd, ui, v, o) {
        var se = ed.selection,
          n = se.getNode(),
          p;

        switch (cmd) {
          case 'FormatBlock':
            // remove format
            if (!v) {
              o.terminate = true;

              if (n === ed.getBody()) {
                return;
              }

              ed.undoManager.add();

              p = ed.dom.getParent(n, blocks.join(',')) || '';

              if (p) {
                var name = p.nodeName.toLowerCase();

                if (ed.formatter.get(name)) {
                  ed.formatter.remove(name);
                }
              }

              var cm = ed.controlManager.get('formatselect');

              if (cm) {
                cm.select(p);
              }
            }

            // Definition List
            if (v === 'dl') {
              ed.execCommand('InsertDefinitionList');
              o.terminate = true;
            }

            // Definition List - DT or DD
            if (v === 'dt' || v === 'dd') {
              // not yet in a Definition List
              if (n && !ed.dom.getParent(n, 'dl')) {
                ed.execCommand('InsertDefinitionList');
              }

              // rename DT to DD
              if (v === 'dt' && n.nodeName === 'DD') {
                ed.dom.rename(n, 'DT');
              }

              // rename DD to DT
              if (v === 'dd' && n.nodeName === 'DT') {
                ed.dom.rename(n, 'DD');
              }

              o.terminate = true;
            }

            break;
          case 'RemoveFormat':
            if (!v && !ed.dom.isBlock(n)) {
              cm = ed.controlManager.get('styleselect');
              // get select Styles value if any
              if (cm && cm.selectedValue) {
                // remove style
                ed.execCommand('mceToggleFormat', false, cm.selectedValue);
              }
            }

            break;
        }
      });

      ed.onExecCommand.add(function (ed, cmd, ui, v, o) {
        var se = ed.selection,
          n = se.getNode();
        // remove empty Definition List
        switch (cmd) {
          case 'mceToggleFormat':
            if (v === "dt" || v === "dd") {
              if (n.nodeName === "DL" && ed.dom.select('dt,dd', n).length === 0) {
                ed.formatter.remove('dl');
              }
            }
            break;
        }
      });

      function clearBlocks(e) {
        var p, n = ed.selection.getNode();

        // set defualt content and get the element to use
        var tag = ed.getParam('forced_root_block', 'p');

        if (!tag) {
          tag = ed.getParam('force_block_newlines') ? 'p' : 'br';
        }

        // Find parent element just before the document body
        p = ed.dom.getParents(n, blocks.join(','));

        // inside a table
        if (ed.dom.getParent(n, 'td,th')) {
          p = ed.dom.getParents(n, 'td,th,tr,tfoot,thead,table');
        }

        if (p && p.length > 1) {
          // prevent default action
          e.preventDefault();

          // get the first block in the collection
          var block = p[p.length - 1];

          // skip if it is the body
          if (block === ed.getBody()) {
            return;
          }

          // create element
          var el = ed.dom.create(tag, {}, '\u00a0');

          if (e.keyCode === VK.ENTER || e.keyCode === VK.DOWN) {
            // insert after parent element
            ed.dom.insertAfter(el, block);
          } else {
            // insert after parent element
            ed.dom.insertBefore(el, block);
          }

          // select and collapse
          ed.selection.select(el);
          ed.selection.collapse(1);
        }

        // execute normal enter/up behaviour
      }
    });

  })();

  /**
   * @package   	JCE
   * @copyright 	Copyright (c) 2009-2024 Ryan Demmer. All rights reserved.
   * @copyright   Copyright 2009, Moxiecode Systems AB
   * @copyright   Copyright (c) 1999-2015 Ephox Corp. All rights reserved
   * @license   	GNU/LGPL 2.1 or later - http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
   * JCE is free software. This version may have been modified pursuant
   * to the GNU General Public License, and as distributed it includes or
   * is derivative of works licensed under the GNU General Public License or
   * other free or open source software licenses.
   */
  /*global tinymce:true */

  (function () {
    var each = tinymce.each,
      DOM = tinymce.DOM, PreviewCss = tinymce.util.PreviewCss;

    /* Make a css url absolute
       * @param u URL string
       * @param p URL of the css file
       */
    function toAbsolute(u, p) {
      return u.replace(/url\(["']?(.+?)["']?\)/gi, function (a, b) {

        if (b.indexOf('://') < 0) {
          return 'url("' + p + b + '")';
        }

        return a;
      });
    }

    function isEditorContentCss(url) {
      return /\/(tinymce|plugins\/jce)\//.match(url) !== -1 && url.indexOf('content.css') !== -1;
    }

    function cleanSelectorText(selectorText) {
      // Parse simple element.class1, .class1
      var selector = /^(?:([a-z0-9\-_]+))?(\.[a-z0-9_\-\.]+)$/i.exec(selectorText);

      // no match
      if (!selector) {
        return '';
      }

      var elementName = selector[1];

      if (elementName !== "body") {
        return selector[2].substr(1).split('.').join(' ');
      }

      return '';
    }

    var rgba = {}, luma = {};

    /*no-bitwise:0;no-cond-assign:0*/

    function getRGBA(val) {
      if (!rgba[val]) {
        var r = 0, b = 0, g = 0, a = 1, values, match;

        if (val.indexOf('#') !== -1) {
          val = val.substr(1);

          // fff -> ffffff
          if (val.length === 3) {
            val += val;
          }

          r = parseInt(val.substring(0, 2), 16);
          g = parseInt(val.substring(2, 4), 16);
          b = parseInt(val.substring(4, 6), 16);

          if (val.length > 6) {
            a = parseInt(val.substring(6, 8), 16);
            a = +(a / 255).toFixed(2);
          }

        } else {
          // remove spaces
          val = val.replace(/\s/g, '');

          var match = /^(?:rgb|rgba)\(([^\)]*)\)$/.exec(val);

          if (match) {
            values = match[1].split(',').map(function (x, i) {
              return parseFloat(x);
            });
          }

          if (values) {
            r = values[0];
            g = values[1];
            b = values[2];

            if (values.length === 4) {
              a = values[3] || 1;
            }
          }
        }

        rgba[val] = { r: r, g: g, b: b, a: a };
      }

      return rgba[val];
    }

    // https://github.com/bgrins/TinyColor/blob/master/tinycolor.js#L75
    function getLuminance(val) {
      if (!luma[val]) {
        var col = getRGBA(val);

        // opacity is set
        /*if (col.a < 1 && color2) {
                  var col2 = getRGBA(color2);

                  col = {
                      r: ((col2.r - col.r) * col.a) + col.r,
                      g: ((col2.g - col.g) * col.a) + col.g,
                      b: ((col2.b - col.b) * col.a) + col.b
                  };
              }*/

        var RsRGB, GsRGB, BsRGB, R, G, B;

        RsRGB = col.r / 255;
        GsRGB = col.g / 255;
        BsRGB = col.b / 255;

        if (RsRGB <= 0.03928) {
          R = RsRGB / 12.92;
        } else {
          R = Math.pow(((RsRGB + 0.055) / 1.055), 2.4);
        }
        if (GsRGB <= 0.03928) {
          G = GsRGB / 12.92;
        } else {
          G = Math.pow(((GsRGB + 0.055) / 1.055), 2.4);
        }
        if (BsRGB <= 0.03928) {
          B = BsRGB / 12.92;
        } else {
          B = Math.pow(((BsRGB + 0.055) / 1.055), 2.4);
        }

        luma[val] = (0.2126 * R) + (0.7152 * G) + (0.0722 * B);

        //luma[val] = 0.2126 * col.r + 0.7152 * col.g + 0.0722 * col.b; // per ITU-R BT.709
      }

      return luma[val];
    }

    // https://github.com/bgrins/TinyColor/blob/master/tinycolor.js#L726
    function isReadable(color1, color2, wcag2, limit) {
      var l1 = getLuminance(color1);
      var l2 = getLuminance(color2);

      var lvl = (Math.max(l1, l2) + 0.05) / (Math.min(l1, l2) + 0.05);

      wcag2 = wcag2 || 4.5;
      limit = limit || 21;

      return lvl >= parseFloat(wcag2) && lvl < parseFloat(limit); // AA
    }

    tinymce.PluginManager.add('importcss', function (ed, url) {
      var self = this;

      // create an event to use externally
      ed.onImportCSS = new tinymce.util.Dispatcher();

      ed.onImportCSS.add(function () {
        if (tinymce.is(ed.settings.importcss_classes)) {
          return;
        }

        self.get();
      });

      // attempt to import when the editor is initialised
      ed.onInit.add(function () {
        ed.onImportCSS.dispatch();

        // check for high contrast if not already set in a parameter
        if (ed.settings.content_style_reset === 'auto' && !ed.dom.hasClass(ed.getBody(), 'mceContentReset')) {
          setHighContrastMode();
        }

        setGuideLinesColor();
      });

      ed.onFocus.add(function (ed) {
        if (ed._hasGuidelines) {
          return;
        }

        setGuideLinesColor();
      });


      function setHighContrastMode() {

        var bodybg = ed.dom.getStyle(ed.getBody(), 'background-color', true), color = ed.dom.getStyle(ed.getBody(), 'color', true);

        if (!bodybg || !color) {
          return;
        }

        var hex = ed.dom.toHex(bodybg);

        // if the colours match, may be an error in stylesheet loading
        if (hex == ed.dom.toHex(color) && hex === '#000000') {
          return;
        }

        if (!isReadable(color, bodybg, 3.0)) {
          ed.dom.addClass(ed.getBody(), 'mceContentReset');
        }
      }

      function setGuideLinesColor() {

        var gray = [
          '#000000',
          '#080808',
          '#101010',
          '#181818',
          '#202020',
          '#282828',
          '#303030',
          '#383838',
          '#404040',
          '#484848',
          '#505050',
          '#585858',
          '#606060',
          '#686868',
          '#696969',
          '#707070',
          '#787878',
          '#808080',
          '#888888',
          '#909090',
          '#989898',
          '#a0a0a0',
          '#a8a8a8',
          '#a9a9a9',
          '#b0b0b0',
          '#b8b8b8',
          '#bebebe',
          '#c0c0c0',
          '#c8c8c8',
          '#d0d0d0',
          '#d3d3d3',
          '#d8d8d8',
          '#dcdcdc',
          '#e0e0e0',
          '#e8e8e8',
          '#f0f0f0',
          '#f5f5f5',
          '#f8f8f8',
          '#ffffff'
        ];

        var blue = [
          '#0d47a1',
          '#1565c0',
          '#1976d2',
          '#1e88e5',
          '#2196f3',
          '#42a5f5',
          '#64b5f6',
          '#90caf9',
          '#bbdefb',
          '#e3f2fd'
        ];

        var guidelines = '#787878', visualchars = '#a8a8a8', control = '#1e88e5', controlbg = '#b4d7ff', placeholder = '#efefef', bodybg = ed.dom.getStyle(ed.getBody(), 'background-color', true), color = ed.dom.getStyle(ed.getBody(), 'color', true);

        if (!bodybg) {
          return;
        }

        ed._hasGuidelines = true;

        // guidelines
        for (var i = 0; i < gray.length; i++) {
          if (isReadable(gray[i], bodybg, 4.5, 5.0)) {

            if (ed.dom.toHex(color) === ed.dom.toHex(gray[i])) {
              continue;
            }

            guidelines = gray[i];

            break;
          }
        }

        // control element selection
        for (var i = 0; i < blue.length; i++) {
          if (isReadable(blue[i], bodybg, 4.5, 5.0)) {
            control = blue[i];
            break;
          }
        }

        if (guidelines || control) {
          var css = ':root{';

          if (guidelines) {
            css += '--mce-guidelines: ' + guidelines + ';';
            css += '--mce-visualchars: ' + visualchars + ';';
          }

          {
            css += '--mce-placeholder: ' + placeholder + ';';
          }

          if (control) {
            css += '--mce-control-selection: ' + control + ';';
            css += '--mce-control-selection-bg: ' + controlbg + ';';
          }

          css += '}';

          ed.dom.addStyle(css);
        }
      }

      this.get = function () {
        var self = this,
          doc = ed.getDoc(), href = '',
          rules = [],
          fonts = false;

        var fontface = [], filtered = {}, classes = [];

        function isAllowedStylesheet(href) {
          var styleselect = ed.getParam('styleselect_stylesheets');

          if (!styleselect) {
            return true;
          }

          if (typeof filtered[href] !== 'undefined') {
            return filtered[href];
          }

          filtered[href] = (href.indexOf(styleselect) !== -1);

          return filtered[href];
        }

        var bodyRx = ed.settings.body_class ? new RegExp('.(' + (ed.settings.body_class.split(' ').join('|')) + ')') : false;

        function isBodyClass(value) {
          if (!bodyRx) {
            return false;
          }

          return bodyRx.test(value);
        }

        function isValidStyle(value) {
          return /\.[\w\-\:]+$/.test(value);
        }

        function parseCSS(stylesheet) {
          // IE style imports
          each(stylesheet.imports, function (r) {
            if (r.href.indexOf('://fonts.googleapis.com') > 0) {
              var v = '@import url(' + r.href + ');';

              if (self.fontface.indexOf(v) === -1) {
                self.fontface.unshift(v);
              }

              return;
            }

            parseCSS(r);
          });

          try {
            rules = stylesheet.cssRules || stylesheet.rules;
            href = stylesheet.href;

            if (!href) {
              return;
            }

            if (isEditorContentCss(href)) {
              return;
            }

            // get stylesheet href
            href = href.substr(0, href.lastIndexOf('/') + 1);

            ed.hasStyleSheets = true;
          } catch (e) {
            // Firefox fails on rules to remote domain for example:
            // @import url(//fonts.googleapis.com/css?family=Pathway+Gothic+One);
          }

          each(rules, function (r) {
            // Real type or fake it on IE
            switch (r.type || 1) {
              // Rule
              case 1:
                if (!isAllowedStylesheet(stylesheet.href)) {
                  return true;
                }

                if (r.selectorText) {
                  each(r.selectorText.split(','), function (v) {
                    v = v.trim();

                    // internal styles
                    if (/\.mce[-A-Za-z0-9]/.test(v)) {
                      return;
                    }

                    // wf-* styles
                    if (/\.wf[e]?-/.test(v)) {
                      return;
                    }

                    // custom body classes
                    if (isBodyClass(v)) {
                      return;
                    }

                    if (!isValidStyle(v)) {
                      return;
                    }

                    classes.push(v);
                  });
                }

                break;

              // Import
              case 3:
                if (r.href.indexOf('//fonts.googleapis.com') > 0) {
                  var v = '@import url(' + r.href + ');';

                  if (fontface.indexOf(v) === -1) {
                    fontface.unshift(v);
                  }
                }

                // only local imports
                if (r.href.indexOf('//') === -1) {
                  parseCSS(r.styleSheet);
                }
                break;
              // font-face
              case 5:
                // check for text and skip popular font icons
                if (r.cssText && /(fontawesome|glyphicons|icomoon)/i.test(r.cssText) === false) {
                  var v = toAbsolute(r.cssText, href);

                  if (fontface.indexOf(v) === -1) {
                    fontface.push(v);
                  }
                }
                break;
            }
          });
        }

        // parse stylesheets
        if (!classes.length) {
          try {
            each(doc.styleSheets, function (styleSheet) {
              parseCSS(styleSheet);
            });
          } catch (ex) {
            // error
          }
        }

        // add font-face rules
        if (!fontface.length && !fonts) {
          try {
            // get document head
            var head = DOM.doc.getElementsByTagName('head')[0];
            // create style element
            var style = DOM.create('style', {
              type: 'text/css'
            });

            var css = self.fontface.join("\n");

            if (style.styleSheet) {
              var setCss = function () {
                try {
                  style.styleSheet.cssText = css;
                } catch (e) {
                  // error
                }
              };
              if (style.styleSheet.disabled) {
                setTimeout(setCss, 10);
              } else {
                setCss();
              }
            } else {
              style.appendChild(DOM.doc.createTextNode(css));
            }

            // add to head
            head.appendChild(style);

            // set fonts flag so we only do this once
            fonts = true;

          } catch (e) {
            // error
          }
        }

        // sort and expose if classes have been set
        if (classes.length) {
          // remove duplicates
          classes = classes.filter(function (val, ind, arr) {
            return arr.indexOf(val) === ind;
          });

          // sort alphabetically
          if (ed.getParam('styleselect_sort', 1)) {
            classes.sort();
          }

          ed.settings.importcss_classes = tinymce.map(classes, function (val) {
            var cls = cleanSelectorText(val);

            var style = PreviewCss.getCssText(ed, { classes: cls.split(' ') });

            return { 'selector': val, 'class': cls, 'style': style };
          });

          PreviewCss.reset();

          return ed.settings.importcss_classes;
        }
      };
    });
  })();

  /**
   * @package   	JCE
   * @copyright 	Copyright (c) 2009-2024 Ryan Demmer. All rights reserved.
   * @license   	GNU/GPL 2 or later - http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
   * JCE is free software. This version may have been modified pursuant
   * to the GNU General Public License, and as distributed it includes or
   * is derivative of works licensed under the GNU General Public License or
   * other free or open source software licenses.
   */

  /*global tinymce:true */

  (function () {
    tinymce.PluginManager.add('colorpicker', function (ed, url) {
      // Register commands
      ed.addCommand('mceColorPicker', function (ui, v) {
        ed.windowManager.open({
          url: ed.getParam('site_url') + 'index.php?option=com_jce&task=plugin.display&plugin=colorpicker',
          width: 365,
          height: 320,
          close_previous: false
        }, {
          input_color: v.color,
          func: v.func
        });
      });
    });
  })();

  /**
   * @package   	JCE
   * @copyright 	Copyright (c) 2009-2024 Ryan Demmer. All rights reserved.
   * @copyright   Copyright 2009, Moxiecode Systems AB
   * @copyright   Copyright (c) 1999-2015 Ephox Corp. All rights reserved
   * @license   	GNU/LGPL 2.1 or later - http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
   * JCE is free software. This version may have been modified pursuant
   * to the GNU General Public License, and as distributed it includes or
   * is derivative of works licensed under the GNU General Public License or
   * other free or open source software licenses.
   */

  /*global tinymce:true */

  (function () {
    var each = tinymce.each,
      JSON = tinymce.util.JSON,
      RangeUtils = tinymce.dom.RangeUtils,
      Uuid = tinymce.util.Uuid,
      Env = tinymce.util.Env;

    // Register plugin
    tinymce.PluginManager.add('upload', function (ed, url) {
      var plugins = [], files = [];

      function cancel() {
        // Block browser default drag over
        ed.dom.bind(ed.getBody(), 'dragover', function (e) {
          var dataTransfer = e.dataTransfer;

          // cancel dropped files
          if (dataTransfer && dataTransfer.files && dataTransfer.files.length) {
            e.preventDefault();
          }
        });

        ed.dom.bind(ed.getBody(), 'drop', function (e) {
          var dataTransfer = e.dataTransfer;

          // cancel dropped files
          if (dataTransfer && dataTransfer.files && dataTransfer.files.length) {
            e.preventDefault();
          }
        });
      }

      ed.onPreInit.add(function () {
        // get list of supported plugins
        each(ed.plugins, function (plg, name) {
          if (tinymce.is(plg.getUploadConfig, 'function')) {

            var data = plg.getUploadConfig();

            if (data.inline && data.filetypes) {
              plugins.push(plg);
            }
          }
        });

        // Cleanup callback
        ed.onBeforeSetContent.add(function (ed, o) {
          o.content = o.content.replace(/<\/media>/g, '&nbsp;</media>');
        });

        // Cleanup callback
        ed.onPostProcess.add(function (ed, o) {
          o.content = o.content.replace(/(&nbsp;|\u00a0)<\/media>/g, '</media>');
        });

        ed.schema.addValidElements('+media[type|width|height|class|style|title|*]');

        // Remove bogus elements
        ed.serializer.addAttributeFilter('data-mce-marker', function (nodes, name, args) {
          var i = nodes.length;

          while (i--) {
            nodes[i].remove();
          }
        });

        function isMediaPlaceholder(node) {
          if (node.name === 'media') {
            return true;
          }

          if (node.name === 'img') {
            if (node.attr('data-mce-upload-marker')) {
              return true;
            }

            var cls = node.attr('class');

            if (cls && cls.indexOf('upload-placeholder') != -1) {
              return true;
            }
          }

          return false;
        }

        // find and convert upload markers
        ed.parser.addNodeFilter('img,media', function (nodes) {
          var i = nodes.length,
            node;

          while (i--) {
            node = nodes[i];

            if (isMediaPlaceholder(node)) {

              // no plugins to upload, remove node
              if (plugins.length == 0) {
                node.remove();
              } else {
                createUploadMarker(node);
              }
            }
          }
        });

        // remove upload markers
        ed.serializer.addNodeFilter('img', function (nodes) {
          var i = nodes.length,
            node, cls;

          while (i--) {
            node = nodes[i], cls = node.attr('class');

            if (cls && /mce-item-upload-marker/.test(cls)) {
              // remove marker classes
              cls = cls.replace(/(?:^|\s)(mce-item-)(?!)(upload|upload-marker|upload-placeholder)(?!\S)/g, '');
              // set class and src
              node.attr({
                'data-mce-src': '',
                'src': '',
                'class': tinymce.trim(cls)
              });

              // rename
              node.name = 'media';
              node.shortEnded = false;
              // remove alt if set
              node.attr('alt', null);
              // remove maarker attribute
              node.attr('data-mce-upload-marker', null);
            }
          }
        });

        function bindUploadEvents(ed) {
          each(ed.dom.select('.mce-item-upload-marker', ed.getBody()), function (n) {
            if (plugins.length == 0) {
              ed.dom.remove(n);
            } else {
              bindUploadMarkerEvents(n);
            }
          });
        }

        // update events when content is set
        ed.onSetContent.add(function () {
          bindUploadEvents(ed);
        });

        // update events when fullscreen is activated
        if (ed.onFullScreen) {
          ed.onFullScreen.add(function (editor) {
            bindUploadEvents(editor);
          });
        }
      });

      ed.onInit.add(function () {
        // no supported plugins
        if (plugins.length == 0) {
          cancel();
          return;
        }

        // Display "a#name" instead of "img" in element path
        if (ed.theme && ed.theme.onResolveName) {
          ed.theme.onResolveName.add(function (theme, o) {
            var n = o.node;

            if (n && n.nodeName === 'IMG' && /mce-item-upload/.test(n.className)) {
              o.name = 'placeholder';
            }
          });
        }

        function cancelEvent(e) {
          e.preventDefault();
          e.stopPropagation();
        }

        ed.dom.bind(ed.getBody(), 'dragover', function (e) {
          e.dataTransfer.dropEffect = tinymce.VK.metaKeyPressed(e) ? "copy" : "move";
        });

        // Attach drop handler and grab files
        ed.dom.bind(ed.getBody(), 'drop', function (e) {
          var dataTransfer = e.dataTransfer, rng;

          // Add dropped files
          if (dataTransfer && dataTransfer.files && dataTransfer.files.length) {
            each(dataTransfer.files, function (file) {
              if (!rng) {
                rng = RangeUtils.getCaretRangeFromPoint(e.clientX, e.clientY, ed.getDoc());

                if (rng) {
                  ed.selection.setRng(rng);
                }
              }

              addFile(file);
            });

            cancelEvent(e);
          }

          // upload...
          if (files.length) {
            each(files, function (file) {
              uploadFile(file);
            });
          }
          // stop Firefox opening the image in a new window if the drop target is itself (drag cancelled)
          if (tinymce.isGecko && e.target.nodeName == 'IMG') {
            cancelEvent(e);
          }
        });
      });

      var noop = function () { };

      function uploadHandler(file, success, failure, progress) {
        var xhr, formData;

        success = success || noop;
        failure = failure || noop;
        progress = progress || noop;

        var args = {
          method: 'upload',
          id: Uuid.uuid('wf_'),
          inline: 1,
          name: file.filename
        };

        var url = file.upload_url;

        // add query
        url += '&' + ed.settings.query;

        xhr = new XMLHttpRequest();
        xhr.open('POST', url);

        xhr.upload.onprogress = function (e) {
          progress(e.loaded / e.total * 100);
        };

        xhr.onerror = function () {
          failure("Image upload failed due to a XHR Transport error. Code: " + xhr.status);
        };

        xhr.onload = function () {
          var json;

          if (xhr.status < 200 || xhr.status >= 300) {
            failure("HTTP Error: " + xhr.status);
            return;
          }

          json = JSON.parse(xhr.responseText);

          if (!json) {
            failure('Invalid JSON response!');
          }

          if (json.error || !json.result) {
            failure(json.error.message || 'Invalid JSON response!');
            return;
          }

          success(json.result);
        };

        formData = new FormData();

        // Add params
        each(args, function (value, name) {
          formData.append(name, value);
        });

        formData.append('file', file, file.name);

        xhr.send(formData);
      }

      function addFile(file) {
        // check for extension in file name, eg. image.php.jpg
        if (/\.(php([0-9]*)|phtml|pl|py|jsp|asp|htm|html|shtml|sh|cgi)\./i.test(file.name)) {

          ed.windowManager.alert({
            text: ed.getLang('upload.file_extension_error', 'File type not supported'),
            title: ed.getLang('upload.error', 'Upload Error')
          });

          return false;
        }

        // get first url for the file type
        each(plugins, function (plg) {
          if (!file.upload_url) {
            var url = plg.getUploadURL(file);

            if (url) {
              file.upload_url = url;
              file.uploader = plg;

              return false;
            }
          }
        });

        if (file.upload_url) {
          if (tinymce.is(file.uploader.getUploadConfig, 'function')) {
            // check file type and size
            var config = file.uploader.getUploadConfig();

            var name = file.target_name || file.name;

            // remove some common characters
            file.filename = name.replace(/[\+\\\/\?\#%&<>"\'=\[\]\{\},;@\^\(\)£€$~]/g, '');

            if (!new RegExp('\.(' + config.filetypes.join('|') + ')$', 'i').test(file.name)) {

              ed.windowManager.alert({
                text: ed.getLang('upload.file_extension_error', 'File type not supported'),
                title: ed.getLang('upload.error', 'Upload Error')
              });

              return false;
            }

            if (file.size) {
              var max = parseInt(config.max_size, 10) || 1024;

              if (file.size > max * 1024) {

                ed.windowManager.alert({
                  text: ed.getLang('upload.file_size_error', 'File size exceeds maximum allowed size'),
                  title: ed.getLang('upload.error', 'Upload Error')
                });

                return false;
              }
            }
          }

          if (!file.marker && ed.settings.upload_use_placeholder !== false) {

            var uid = Uuid.uuid('wf-tmp-');

            ed.execCommand('mceInsertContent', false, '<span data-mce-marker="1" id="' + uid + '">\uFEFF</span>', {
              skip_undo: 1
            });

            var n = ed.dom.get(uid), w, h;

            // get approximate size of image from file size
            if (/image\/(gif|png|jpeg|jpg)/.test(file.type) && file.size) {
              w = h = Math.round(Math.sqrt(file.size));

              // set minimum value of 100
              w = Math.max(300, w);
              h = Math.max(300, h);

              ed.dom.setStyles(n, {
                width: w,
                height: h
              });

              ed.dom.addClass(n, 'mce-item-upload');
            } else {
              ed.setProgressState(true);
            }

            file.marker = n;
          }

          // add files to queue
          files.push(file);

          return true;
        } else {

          ed.windowManager.alert({
            text: ed.getLang('upload.file_extension_error', 'File type not supported'),
            title: ed.getLang('upload.error', 'Upload Error')
          });

          return false;
        }
      }

      /**
       * Create an upload marker on selected nodes
       * @param {*} node 
       */
      function createUploadMarker(node) {
        var src = node.attr('src') || '',
          style = {},
          styles, cls = [];

        // get alt from src if not base64 encoded
        if (!node.attr('alt') && !/data:image/.test(src)) {
          var alt = src.substring(src.length, src.lastIndexOf('/') + 1);
          // set alt
          node.attr('alt', alt);
        }

        if (node.attr('style')) {
          style = ed.dom.styles.parse(node.attr('style'));
        }

        // convert hspace
        if (node.attr('hspace')) {
          style['margin-left'] = style['margin-right'] = node.attr('hspace');
        }

        // convert vspace
        if (node.attr('vspace')) {
          style['margin-top'] = style['margin-bottom'] = node.attr('vspace');
        }

        // convert align
        if (node.attr('align')) {
          style["float"] = node.attr('align');
        }

        if (node.attr('class')) {
          cls = node.attr('class').replace(/\s*upload-placeholder\s*/, '').split(' ');
        }

        // add marker classes
        cls.push('mce-item-upload');
        cls.push('mce-item-upload-marker');

        if (node.name === 'media') {
          node.name = 'img';
          node.shortEnded = true;
        }

        // set attribs
        node.attr({
          'src': Env.transparentSrc,
          'class': tinymce.trim(cls.join(' '))
        });

        var tmp = ed.dom.create('span', {
          'style': style
        });

        // add styles if any
        var styles = ed.dom.getAttrib(tmp, 'style');

        if (styles) {
          node.attr({
            'style': styles,
            'data-mce-style': styles
          });
        }
      }

      /**
       * Find and replace the marker with the uploaded file, using attributes from the uploader
       * @param {*} file 
       * @param {*} data 
       * @returns 
       */
      function selectAndInsert(file, data) {
        var marker = file.marker, uploader = file.uploader;

        // select marker
        ed.selection.select(marker);

        var elm = uploader.insertUploadedFile(data);

        if (elm) {
          // is an element node
          if (typeof elm === 'object' && elm.nodeType) {
            // transfer width and height from marker
            if (ed.dom.hasClass(marker, 'mce-item-upload-marker')) {
              var styles = ed.dom.getAttrib(marker, 'data-mce-style');

              var w = marker.width || 0;
              var h = marker.height || 0;

              // transfer styles
              if (styles) {
                // parse to object
                styles = ed.dom.styles.parse(styles);

                if (styles.width) {
                  w = styles.width;

                  delete styles.width;
                }

                if (styles.height) {
                  h = styles.height;

                  delete styles.height;
                }

                // set styles
                ed.dom.setStyles(elm, styles);
              }

              // pass through width and height
              if (w) {
                ed.dom.setAttrib(elm, 'width', w);
              }

              if (h) {
                if (w) {
                  h = '';
                }

                ed.dom.setAttrib(elm, 'height', h);
              }
            }

            ed.undoManager.add();

            // replace marker with new element
            ed.dom.replace(elm, marker);
          }

          ed.nodeChanged();

          return true;
        }
      }

      /*
       * Bind events to upload marker and create upload input
       * @param marker Marker / Placeholder element
       */
      function bindUploadMarkerEvents(marker) {
        var dom = tinymce.DOM;

        function removeUpload() {
          dom.setStyles('wf_upload_button', {
            'top': '',
            'left': '',
            'display': 'none',
            'zIndex': ''
          });
        }

        // remove upload on nodechange
        ed.onNodeChange.add(removeUpload);

        // remove on window scroll
        ed.dom.bind(ed.getWin(), 'scroll', removeUpload);

        var input = dom.get('wf_upload_input'), btn = dom.get('wf_upload_button');

        // create input
        if (!btn) {
          btn = dom.add(dom.doc.body, 'div', {
            'id': 'wf_upload_button',
            'class': 'btn',
            'role': 'button',
            'title': ed.getLang('upload.button_description', 'Click to upload a file')
          }, '<label for="wf_upload_input"><span class="icon-upload"></span>&nbsp;' + ed.getLang('upload.label', 'Upload') + '</label>');

          // create upload input
          input = dom.add(btn, 'input', {
            'type': 'file',
            'id': 'wf_upload_input'
          });
        }

        // add upload on mouseover
        ed.dom.bind(marker, 'mouseover', function (e) {

          if (ed.dom.getAttrib(marker, 'data-mce-selected')) {
            return;
          }

          var vp = ed.dom.getViewPort(ed.getWin());
          var p1 = dom.getRect(ed.getContentAreaContainer());
          var p2 = ed.dom.getRect(marker);

          if (vp.y > p2.y + p2.h / 2 - 25) {
            return;
          }

          if (vp.y < (p2.y + p2.h / 2 + 25) - p1.h) {
            return;
          }

          var x = Math.max(p2.x - vp.x, 0) + p1.x;
          var y = Math.max(p2.y - vp.y, 0) + p1.y - Math.max(vp.y - p2.y, 0);

          var zIndex = ed.id == 'mce_fullscreen' ? dom.get('mce_fullscreen_container').style.zIndex : 0;

          dom.setStyles('wf_upload_button', {
            'top': y + p2.h / 2 - 16,
            'left': x + p2.w / 2 - 50,
            'display': 'block',
            'zIndex': zIndex + 1
          });

          dom.setStyles('wf_select_button', {
            'top': y + p2.h / 2 - 16,
            'left': x + p2.w / 2 - 50,
            'display': 'block',
            'zIndex': zIndex + 1
          });

          // bind onchange event to input to trigger upload
          input.onchange = function () {
            if (input.files) {
              var file = input.files[0];

              if (file) {
                file.marker = marker;

                if (addFile(file)) {
                  // add width and height as styles if set
                  each(['width', 'height'], function (key) {
                    ed.dom.setStyle(marker, key, ed.dom.getAttrib(marker, key));
                  });

                  // rename to "span" to support css:after
                  file.marker = ed.dom.rename(marker, 'span');

                  uploadFile(file);
                  removeUpload();
                }
              }
            }
          };
        });

        // remove upload on mouseout
        ed.dom.bind(marker, 'mouseout', function (e) {
          // don't remove if over upload input
          if (!e.relatedTarget && e.clientY > 0) {
            return;
          }

          removeUpload();
        });
      }

      function removeFile(file) {
        // remove from list
        for (var i = 0; i < files.length; i++) {
          if (files[i] === file) {
            files.splice(i, 1);
          }
        }

        files.splice(tinymce.inArray(files, file), 1);
      }

      function uploadFile(file) {

        uploadHandler(file, function (response) {

          var files = response.files || [], item = files.length ? files[0] : {};

          if (file.uploader) {

            var obj = tinymce.extend({
              type: file.type,
              name: file.name
            }, item);

            selectAndInsert(file, obj);
          }

          removeFile(file);

          if (file.marker) {
            ed.dom.remove(file.marker);
          }

          ed.setProgressState(false);

        }, function (message) {

          ed.windowManager.alert({
            text: message,
            title: ed.getLang('upload.error', 'Upload Error')
          });

          removeFile(file);

          if (file.marker) {
            ed.dom.remove(file.marker);
          }

          ed.setProgressState(false);

        }, function (value) {
          if (file.marker) {
            ed.dom.setAttrib(file.marker, 'data-progress', value);
          }
        });
      }

      this.plugins = plugins;
      this.upload = uploadHandler;
    });
  })();

  /**
   * @package   	JCE
   * @copyright 	Copyright (c) 2009-2024 Ryan Demmer. All rights reserved.
   * @license   	GNU/GPL 2 or later - http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
   * JCE is free software. This version may have been modified pursuant
   * to the GNU General Public License, and as distributed it includes or
   * is derivative of works licensed under the GNU General Public License or
   * other free or open source software licenses.
   */

  /*global tinymce:true */

  (function () {
    var VK = tinymce.VK,
      Node = tinymce.html.Node,
      each = tinymce.each;
    var blocks = [];

    tinymce.PluginManager.add('figure', function (ed, url) {
      ed.onPreInit.add(function (ed) {
        ed.parser.addNodeFilter('figure', function (nodes, name) {
          var i = nodes.length,
            node;

          while (i--) {
            node = nodes[i];

            if (node.getAll('figcaption').length === 0) {
              var figcaption = new Node('figcaption', 1);
              figcaption.attr('data-mce-empty', ed.getLang('figcaption.default', 'Write a caption...'));
              figcaption.attr('contenteditable', true);

              node.append(figcaption);
            }

            node.attr('data-mce-image', '1');
            node.attr('contenteditable', 'false');

            each(node.getAll('img'), function (img) {
              img.attr('data-mce-contenteditable', 'true');
            });

            if (ed.settings.figure_data_attribute !== false) {
              node.attr('data-wf-figure', '1');
            }
          }
        });

        ed.parser.addNodeFilter('figcaption', function (nodes, name) {
          var i = nodes.length,
            node;

          while (i--) {
            node = nodes[i];
            // Add identifying attribute to create dummy text
            if (!node.firstChild) {
              node.attr('data-mce-empty', ed.getLang('figcaption.default', 'Write a caption...'));
            }
            // make editable
            node.attr('contenteditable', 'true');
          }
        });

        ed.serializer.addNodeFilter('figure', function (nodes, name) {
          var i = nodes.length,
            node;

          while (i--) {
            node = nodes[i];
            node.attr('contenteditable', null);

            each(node.getAll('img'), function (img) {
              img.attr('data-mce-contenteditable', null);
            });
          }
        });

        ed.serializer.addNodeFilter('figcaption', function (nodes, name) {
          var i = nodes.length,
            node;

          while (i--) {
            node = nodes[i];
            // remove empty figcaption
            if (!node.firstChild) {
              node.remove();
            } else {
              node.attr('contenteditable', null);
            }
          }
        });

        ed.serializer.addAttributeFilter('data-mce-image', function (nodes, name) {
          var i = nodes.length,
            node;

          while (i--) {
            node = nodes[i];
            node.attr(name, null);
          }
        });

        each(ed.schema.getBlockElements(), function (v, k) {
          if (/\W/.test(k)) {
            return true;
          }

          blocks.push(k.toLowerCase());
        });

        ed.formatter.register('figure', {
          block: 'figure',
          remove: 'all',
          ceFalseOverride: true,
          deep: false,
          onformat: function (elm, fmt, vars, node) {
            vars = vars || {};

            if (ed.dom.select('img,video,iframe', elm)) {
              ed.dom.setAttribs(elm, {
                'data-mce-image': 1,
                'contenteditable': false
              });

              // set fake contenteditable for img element
              ed.dom.setAttrib(ed.dom.select('img', elm), 'data-mce-contenteditable', 'true');

              ed.dom.add(elm, 'figcaption', {
                'data-mce-empty': ed.getLang('figcaption.default', 'Write a caption...'),
                'contenteditable': true
              }, vars.caption || '');

              if (ed.settings.figure_data_attribute !== false) {
                ed.dom.setAttribs(elm, {
                  'data-wf-figure': '1'
                });
              }
            }
          },
          onremove: function (node) {
            ed.dom.remove(ed.dom.select('figcaption', node));
            ed.dom.remove(ed.dom.getParent('figure', node), 1);
          }
        });

        ed.onBeforeExecCommand.add(function (ed, cmd, ui, v, o) {
          var se = ed.selection,
            n = se.getNode();

          switch (cmd) {
            case 'JustifyRight':
            case 'JustifyLeft':
            case 'JustifyCenter':
              if (n && ed.dom.is(n, 'img,span[data-mce-object]')) {
                var parent = ed.dom.getParent(n, 'FIGURE');

                if (parent) {
                  se.select(parent);
                  ed.execCommand(cmd, false);
                  o.terminate = true;
                }
              }
              break;
          }
        });

        ed.onClick.add(function (ed, e) {
          if (e.target.nodeName === 'IMG' && VK.metaKeyPressed(e)) {
            var figure = ed.dom.getParent(e.target, 'figure');

            if (figure) {
              ed.selection.select(figure);
              ed.nodeChanged();
            }
          }
        });

        ed.onNodeChange.add(function (ed, cm, n) {
          if (n.nodeName !== 'FIGURE') {
            ed.dom.removeAttrib(ed.dom.select('figure'), 'data-mce-selected');
          }
        });

        function setClipboardData(ed, e) {
          var clipboardData = e.clipboardData;

          if (!clipboardData) {
            return;
          }

          // get selected node
          var node = ed.dom.getParent(ed.selection.getNode(), 'figure');

          if (!node) {
            return;
          }

          ed.selection.select(node);

          var content = ed.selection.getContent({
            contextual: true
          });

          var data = {
            html: content,
            text: content.toString()
          };

          clipboardData.clearData();
          clipboardData.setData('text/html', data.html);
          clipboardData.setData('text/plain', data.text);

          if (e.type == 'cut') {
            ed.dom.remove(node);
          }
        }

        // update clipboardData 
        ed.onCopy.add(setClipboardData);
        ed.onCut.add(setClipboardData);

        ed.onKeyDown.add(function (ed, e) {
          var isDelete, rng, container, offset, collapsed;

          isDelete = e.keyCode == VK.DELETE;

          if (!e.isDefaultPrevented() && (isDelete || e.keyCode == VK.BACKSPACE) && !VK.modifierPressed(e)) {
            rng = ed.selection.getRng();
            container = rng.startContainer;
            offset = rng.startOffset;
            collapsed = rng.collapsed;

            container = ed.dom.getParent(container, 'FIGURE');

            // remove figure and children if the img is selected
            if (container) {
              var node = ed.selection.getNode();

              if (node.nodeName === 'IMG') {
                ed.dom.remove(container);
                ed.nodeChanged();
                e.preventDefault();
                return;
              }

              // override delete only if the figcaption is empty, so it is not itself removed
              if (node.nodeName == 'FIGCAPTION' && (!node.nodeValue || node.nodeValue.length === 0) && node.childNodes.length === 0) {
                e.preventDefault();
              }

              if (node.nodeType === 3 && (!collapsed && !offset)) {
                var figcaption = ed.dom.getParent(node, 'FIGCAPTION');

                if (figcaption) {
                  while (figcaption.firstChild) {
                    figcaption.removeChild(figcaption.firstChild);
                  }

                  e.preventDefault();
                }
              }
            }
          }
        });
      });

    });
  })();

  /**
   * @package   	JCE
   * @copyright 	Copyright (c) 2009-2024 Ryan Demmer. All rights reserved.
   * @copyright   Copyright 2009, Moxiecode Systems AB
   * @copyright   Copyright (c) 1999-2015 Ephox Corp. All rights reserved
   * @license   	GNU/LGPL 2.1 or later - http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
   * JCE is free software. This version may have been modified pursuant
   * to the GNU General Public License, and as distributed it includes or
   * is derivative of works licensed under the GNU General Public License or
   * other free or open source software licenses.
   */

  /*global tinymce:true */

  (function () {
    var DOM = tinymce.DOM;

    tinymce.PluginManager.add('noneditable', function (editor) {
      var nonEditableRegExps, contentEditableAttrName = 'contenteditable';

      var editClass = tinymce.trim(editor.getParam("noneditable_editable_class", "mceEditable"));
      var nonEditClass = tinymce.trim(editor.getParam("noneditable_noneditable_class", "mceNonEditable"));

      function hasClass(checkClassName) {
        return function (node) {
          return (" " + node.attr("class") + " ").indexOf(checkClassName) !== -1;
        };
      }

      function isNonEditable(node) {
        if (node.attr) {
          return node.hasClass(nonEditClass);
        }

        return DOM.hasClass(node, nonEditClass);
      }

      function isEditable(node) {
        if (node.attr) {
          return node.hasClass(editClass);
        }

        return DOM.hasClass(node, editClass);
      }

      function convertRegExpsToNonEditable(e) {
        var i = nonEditableRegExps.length, content = e.content, cls = tinymce.trim(nonEditClass);

        function replaceMatchWithSpan(match) {
          var args = arguments, index = args[args.length - 2];
          var prevChar = index > 0 ? content.charAt(index - 1) : '';

          // Is value inside an attribute then don't replace
          if (prevChar === '"') {
            return match;
          }

          // Is value inside a contentEditable="false" tag
          if (prevChar === '>') {
            var findStartTagIndex = content.lastIndexOf('<', index);
            if (findStartTagIndex !== -1) {
              var tagHtml = content.substring(findStartTagIndex, index);
              if (tagHtml.indexOf('contenteditable="false"') !== -1) {
                return match;
              }
            }
          }

          return (
            '<span class="' + cls + '" data-mce-content="' + editor.dom.encode(args[0]) + '">' +
            editor.dom.encode(typeof args[1] === "string" ? args[1] : args[0]) + '</span>'
          );
        }

        // Don't replace the variables when raw is used for example on undo/redo
        if (e.format == "raw") {
          return;
        }

        while (i--) {
          content = content.replace(nonEditableRegExps[i], replaceMatchWithSpan);
        }

        e.content = content;
      }

      var hasEditClass = hasClass(editClass);
      var hasNonEditClass = hasClass(nonEditClass);

      nonEditableRegExps = editor.getParam("noneditable_regexp");

      if (nonEditableRegExps && !nonEditableRegExps.length) {
        nonEditableRegExps = [nonEditableRegExps];
      }

      editor.onPreInit.add(function () {
        editor.formatter.register('noneditable', {
          block: 'div',
          wrapper: true,
          onformat: function (elm, fmt, vars) {
            tinymce.each(vars, function (value, key) {
              editor.dom.setAttrib(elm, key, value);
            });
          }
        });

        if (nonEditableRegExps) {
          editor.onBeforeSetContent.add(function (ed, e) {
            convertRegExpsToNonEditable(e);
          });
        }

        editor.parser.addAttributeFilter('class', function (nodes) {
          var i = nodes.length, node;

          while (i--) {
            node = nodes[i];

            if (hasEditClass(node)) {
              node.attr(contentEditableAttrName, "true");
            } else if (hasNonEditClass(node)) {
              node.attr(contentEditableAttrName, "false");
            }
          }
        });

        editor.serializer.addAttributeFilter(contentEditableAttrName, function (nodes) {
          var i = nodes.length, node;

          while (i--) {
            node = nodes[i];
            if (!hasEditClass(node) && !hasNonEditClass(node)) {
              continue;
            }

            if (nonEditableRegExps && node.attr('data-mce-content')) {
              node.name = "#text";
              node.type = 3;
              node.raw = true;
              node.value = node.attr('data-mce-content');
            } else {
              node.attr(contentEditableAttrName, null);
            }
          }
        });
      });

      /*editor.onInit.add(function () {
        // disable all controls if a non-editable is selected
        editor.onNodeChange.add(function (ed, cm, n, collapsed) {
          var state = !collapsed && isNonEditable(n);

          tinymce.each(cm.controls, function (c) {
            if (c && c.isRendered()) {
              c.setDisabled(state);
            }
          });
        });
      });*/

      this.isEditable = isEditable;
      this.isNonEditable = isNonEditable;
    });
  })();

  /*global tinymce:true */
  /**
   * @package   	JCE
   * @copyright 	Copyright (c) 2009-2024 Ryan Demmer. All rights reserved.
   * @license   	GNU/LGPL 2.1 or later - http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
   * JCE is free software. This version may have been modified pursuant
   * to the GNU General Public License, and as distributed it includes or
   * is derivative of works licensed under the GNU General Public License or
   * other free or open source software licenses.
   */
  (function () {
    var DOM = tinymce.DOM;

    tinymce.PluginManager.add('branding', function (ed, url) {

      // turn off branding
      if (ed.settings.branding === false) {
        return;
      }

      ed.onPostRender.add(function () {
        var container = ed.getContentAreaContainer();
        DOM.insertAfter(DOM.create('div', { 'class': 'mceBranding' }, 'Powered by JCE Core. <span id="mceBrandingMessage"></span><a href="https://www.joomlacontenteditor.net/buy" target="_blank" title="Get JCE Pro">JCE Pro</a>'), container);
      });

      ed.onNodeChange.add(function (ed, cm, n, co) {
        var container = ed.getContentAreaContainer(), msg = 'Get more features with ';

        if (n.nodeName === "IMG") {
          msg = 'Image resizing, thumbnails and editing in ';
        }

        if (ed.dom.is(n, '.mce-item-media')) {
          msg = 'Upload and manage audio and video with ';
        }

        DOM.setHTML(DOM.get('mceBrandingMessage', container), msg);
      });
    });
  })();

  /**
   * @package   	JCE
   * @copyright 	Copyright (c) 2009-2024 Ryan Demmer. All rights reserved.
   * @copyright   Copyright 2009, Moxiecode Systems AB
   * @copyright   Copyright (c) 1999-2015 Ephox Corp. All rights reserved
   * @license   	GNU/LGPL 2.1 or later - http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
   * JCE is free software. This version may have been modified pursuant
   * to the GNU General Public License, and as distributed it includes or
   * is derivative of works licensed under the GNU General Public License or
   * other free or open source software licenses.
   */

  /*global tinymce:true */

  (function () {
      var each = tinymce.each, BlobCache = tinymce.file.BlobCache, Conversions = tinymce.file.Conversions, Uuid = tinymce.util.Uuid, DOM = tinymce.DOM;

      var count = 0;

      var uniqueId = function (prefix) {
          return ('blobid') + (count++);
      };

      function isSupportedImage(value) {
          return /\.(jpg|jpeg|png|gif|webp|avif)$/.test(value);
      }

      function getImageExtension(value) {
          if (isSupportedImage(value)) {
              return value.substring(value.length, value.lastIndexOf('.') + 1);
          }

          return '';
      }

      function uploadHandler(settings, blobInfo, success, failure, progress) {
          var xhr, formData;

          xhr = new XMLHttpRequest();
          xhr.open('POST', settings.url);

          xhr.upload.onprogress = function (e) {
              progress(e.loaded / e.total * 100);
          };

          xhr.onerror = function () {
              failure("Image upload failed due to a XHR Transport error. Code: " + xhr.status);
          };

          xhr.onload = function () {
              var json;

              if (xhr.status < 200 || xhr.status >= 300) {
                  failure("HTTP Error: " + xhr.status);
                  return;
              }

              json = JSON.parse(xhr.responseText);

              if (!json || json.error) {
                  failure(json.error.message || 'Invalid JSON response!');
                  return;
              }

              if (!json.result || !json.result.files) {
                  failure(json.error.message || 'Invalid JSON response!');
                  return;
              }

              success(json.result.files[0]);
          };

          formData = new FormData();
          formData.append('file', blobInfo.blob(), blobInfo.filename());

          // Add multipart params
          each(settings, function (value, name) {
              if (name == 'url' || name == 'multipart') {
                  return true;
              }

              formData.append(name, value);
          });

          xhr.send(formData);
      }

      function imageToBlobInfo(blobCache, img, resolve, reject) {
          var base64, blobInfo;

          if (img.src.indexOf('blob:') === 0) {
              blobInfo = blobCache.getByUri(img.src);

              if (blobInfo) {
                  resolve({
                      image: img,
                      blobInfo: blobInfo
                  });
              } else {
                  Conversions.uriToBlob(img.src).then(function (blob) {
                      Conversions.blobToDataUri(blob).then(function (dataUri) {
                          base64 = Conversions.parseDataUri(dataUri).data;
                          blobInfo = blobCache.create(uniqueId(), blob, base64);
                          blobCache.add(blobInfo);

                          resolve({
                              image: img,
                              blobInfo: blobInfo
                          });
                      });
                  }, function (err) {
                      reject(err);
                  });
              }

              return;
          }

          base64 = Conversions.parseDataUri(img.src).data;
          blobInfo = blobCache.findFirst(function (cachedBlobInfo) {
              return cachedBlobInfo.base64() === base64;
          });

          if (blobInfo) {
              resolve({
                  image: img,
                  blobInfo: blobInfo
              });
          } else {
              Conversions.uriToBlob(img.src).then(function (blob) {
                  blobInfo = blobCache.create(uniqueId(), blob, base64);
                  blobCache.add(blobInfo);

                  resolve({
                      image: img,
                      blobInfo: blobInfo
                  });
              }, function (err) {
                  reject(err);
              });
          }
      }

      tinymce.PluginManager.add('blobupload', function (ed, url) {
          var uploaders = [];

          ed.onPreInit.add(function () {
              // get list of supported plugins
              each(ed.plugins, function (plg, name) {
                  if (tinymce.is(plg.getUploadConfig, 'function')) {

                      var data = plg.getUploadConfig();

                      if (data.inline && data.filetypes) {
                          uploaders.push(plg);
                      }
                  }
              });
          });

          function findMarker(marker) {
              var found;

              each(ed.dom.select('img[src]'), function (image) {
                  if (image.src == marker.src) {
                      found = image;

                      return false;
                  }
              });

              return found;
          }

          function removeMarker(marker) {
              each(ed.dom.select('img[src]'), function (image) {
                  if (image.src == marker.src) {
                      ed.selection.select(image);
                      ed.execCommand('mceRemoveNode');

                      var node = ed.selection.getNode();

                      // restore bogus break
                      if (node.nodeName == 'P' && ed.dom.isEmpty(node)) {
                          ed.dom.add(node, 'br', { 'data-mce-bogus': 1 });
                      }
                  }
              });
          }

          function processImages(images) {
              var cachedPromises = {};

              var promises = tinymce.map(images, function (img) {
                  var newPromise;

                  if (cachedPromises[img.src]) {
                      // Since the cached promise will return the cached image
                      // We need to wrap it and resolve with the actual image
                      return new Promise(function (resolve) {
                          cachedPromises[img.src].then(function (imageInfo) {
                              if (typeof imageInfo === 'string') { // error apparently
                                  return imageInfo;
                              }
                              resolve({
                                  image: img,
                                  blobInfo: imageInfo.blobInfo
                              });
                          });
                      });
                  }

                  newPromise = new Promise(function (resolve, reject) {
                      imageToBlobInfo(BlobCache, img, resolve, reject);
                  }).then(function (result) {
                      delete cachedPromises[result.image.src];
                      return result;
                  })['catch'](function (error) {
                      delete cachedPromises[img.src];
                      return error;
                  });

                  cachedPromises[img.src] = newPromise;

                  return newPromise;
              });

              return Promise.all(promises);
          }

          ed.onInit.add(function () {
              ed.onPasteBeforeInsert.add(function (ed, o) {
                  var transparentSrc = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7';

                  var node = ed.dom.create('div', 0, o.content), images = tinymce.grep(ed.dom.select('img[src]', node), function (img) {
                      var src = img.getAttribute('src');

                      if (img.hasAttribute('data-mce-bogus')) {
                          return false;
                      }

                      if (img.hasAttribute('data-mce-placeholder')) {
                          return false;
                      }

                      if (img.hasAttribute('data-mce-upload-marker')) {
                          return false;
                      }

                      if (!src || src == transparentSrc) {
                          return false;
                      }

                      if (src.indexOf('blob:') === 0) {
                          return true;
                      }

                      if (src.indexOf('data:') === 0) {
                          return true;
                      }

                      return false;
                  });

                  if (images.length) {
                      var promises = [];

                      processImages(images).then(function (result) {
                          each(result, function (item) {
                              if (typeof item == 'string') {
                                  return;
                              }

                              ed.selection.select(findMarker(item.image));
                              ed.selection.scrollIntoView();

                              promises.push(uploadPastedImage(item.image, item.blobInfo));
                          });
                      });

                      Promise.all(promises).then();
                  }
              });
          });

          function uploadPastedImage(marker, blobInfo) {
              return new Promise(function (resolve, reject) {
                  // no suitable uploaders, remove blob
                  if (!uploaders.length) {
                      removeMarker(marker);

                      return resolve();
                  }

                  var html = '' +
                      '<div class="mceForm">' +
                      '<p>' + ed.getLang('upload.name_description', 'Please supply a name for this file') + '</p>' +
                      '<div class="mceModalRow">' +
                      '   <label for="' + ed.id + '_blob_input">' + ed.getLang('dlg.name', 'Name') + '</label>' +
                      '   <div class="mceModalControl mceModalControlAppend">' +
                      '       <input type="text" id="' + ed.id + '_blob_input" autofocus />' +
                      '       <select id="' + ed.id + '_blob_mimetype">' +
                      '           <option value="jpeg">jpeg</option>' +
                      '           <option value="png">png</option>' +
                      '       </select>' +
                      '   </div>' +
                      '</div>' +
                      '<div class="mceModalRow">' +
                      '   <label for="' + ed.id + '_blob_input">' + ed.getLang('dlg.quality', 'Quality') + '</label>' +
                      '   <div class="mceModalControl">' +
                      '       <select id="' + ed.id + '_blob_quality" class="mce-flex-25">' +
                      '           <option value="100">100</option>' +
                      '           <option value="90">90</option>' +
                      '           <option value="80">80</option>' +
                      '           <option value="70">70</option>' +
                      '           <option value="60">60</option>' +
                      '           <option value="50">50</option>' +
                      '           <option value="40">40</option>' +
                      '           <option value="30">30</option>' +
                      '           <option value="20">20</option>' +
                      '           <option value="10">10</option>' +
                      '       </select>' +
                      '       <span role="presentation">%</span>' +
                      '   </div>' +
                      '</div>' +
                      '</div>';

                  var win = ed.windowManager.open({
                      title: ed.getLang('dlg.name', 'Name'),
                      content: html,
                      size: 'mce-modal-landscape-small',
                      buttons: [
                          {
                              title: ed.getLang('cancel', 'Cancel'),
                              id: 'cancel'
                          },
                          {
                              title: ed.getLang('submit', 'Submit'),
                              id: 'submit',
                              onclick: function (e) {
                                  var filename = DOM.getValue(ed.id + '_blob_input');

                                  if (!filename) {
                                      removeMarker(marker);
                                      return resolve();
                                  }

                                  // remove some common characters
                                  filename = filename.replace(/[\+\\\/\?\#%&<>"\'=\[\]\{\},;@\^\(\)£€$~]/g, '');

                                  // check for extension in file name, eg. image.php.jpg
                                  if (/\.(php([0-9]*)|phtml|pl|py|jsp|asp|htm|html|shtml|sh|cgi)\b/i.test(filename)) {
                                      ed.windowManager.alert({
                                          text: ed.getLang('upload.file_extension_error', 'File type not supported'),
                                          title: ed.getLang('upload.error', 'Upload Error')
                                      });

                                      removeMarker(marker);
                                      return resolve();
                                  }

                                  var url, uploader;

                                  each(uploaders, function (instance) {
                                      if (!url) {
                                          url = instance.getUploadURL({ name: blobInfo.filename() });

                                          if (url) {
                                              uploader = instance;
                                              return false;
                                          }
                                      }
                                  });

                                  if (!url) {
                                      removeMarker(marker);
                                      return resolve();
                                  }

                                  var ext = getImageExtension(blobInfo.filename()) || 'jpeg';

                                  var quality = DOM.getValue(ed.id + '_blob_quality') || 100;
                                  var mimetype = DOM.getValue(ed.id + '_blob_mimetype') || ext;

                                  var props = {
                                      method: 'upload',
                                      id: Uuid.uuid('wf_'),
                                      inline: 1,
                                      name: filename,
                                      url: url + '&' + ed.settings.query,
                                      mimetype: 'image/' + mimetype,
                                      quality: quality
                                  };

                                  var images = tinymce.grep(ed.dom.select('img[src]'), function (image) {
                                      return image.src == marker.src;
                                  });

                                  ed.setProgressState(true);

                                  uploadHandler(props, blobInfo, function (data) {
                                      data.marker = images[0];

                                      var elm = uploader.insertUploadedFile(data);

                                      if (elm) {
                                          ed.undoManager.add();
                                          // replace marker with new element
                                          ed.dom.replace(elm, images[0]);
                                          // select new image
                                          ed.selection.select(elm);
                                      }

                                      ed.setProgressState(false);

                                      win.close();

                                      return resolve();

                                  }, function (error) {

                                      ed.windowManager.alert({
                                          text: error,
                                          title: ed.getLang('upload.error', 'Upload Error')
                                      });

                                      ed.setProgressState(false);

                                      return resolve();
                                  }, function () { });
                              },
                              classes: 'primary'
                          }
                      ],
                      open: function () {
                          //DOM.select('input + span', this.elm)[0].innerText = '.' + getImageExtension(blobInfo.filename());

                          window.setTimeout(function () {
                              DOM.get(ed.id + '_blob_input').focus();
                          }, 10);
                      },
                      close: function () {
                          removeMarker(marker);
                          return resolve();
                      }
                  });
              });
          }
      });
  })();

})();

/**
 * @package   	JCE
 * @copyright 	Copyright (c) 2009-2024 Ryan Demmer. All rights reserved.
 * @license   	GNU/GPL 2 or later - http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
 * JCE is free software. This version may have been modified pursuant
 * to the GNU General Public License, and as distributed it includes or
 * is derivative of works licensed under the GNU General Public License or
 * other free or open source software licenses.
 */

/* global jQuery, WFEditor */

/**
 * Widget Factory Editor
 */
(function () {
    var svgToggleIcon = '<svg version="1.1" xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 448 448"><title></title><g id="wf-toggle-icon" stroke="none" stroke-width="1"></g><path d="M280 64.132v59.482c15.84 6.914 30.406 16.803 42.995 29.391 26.443 26.442 41.005 61.6 41.005 98.995s-14.563 72.552-41.005 98.995c-26.442 26.442-61.599 41.005-98.995 41.005s-72.552-14.563-98.995-41.005c-26.442-26.442-41.005-61.6-41.005-98.995s14.563-72.552 41.005-98.995c12.589-12.589 27.155-22.478 42.995-29.392v-59.481c-80.959 24.097-140 99.082-140 187.868 0 108.248 87.753 196 196 196s196-87.752 196-196c0-88.786-59.041-163.77-140-187.868zM196 0h56v224h-56z"></path></svg>';

    var each = tinymce.each,
        extend = tinymce.extend,
        DOM = tinymce.DOM,
        Event = tinymce.dom.Event,
        Dispatcher = tinymce.util.Dispatcher;

    /**
     * Check if an element is hidden
     * @param {string|node} el Element id or node
     * 
     * @returns {boolean} True if the element is hidden
     */
    function isHidden(el) {
        if (typeof el === "string") {
            el = document.getElementById(el);
        }

        return el && el.style.display === "none";
    }

    /**
     * Create the refocus bookmark id
     * @param {tinymce.Editor} ed 
     * @returns 
     */
    function getRefocusBookmarkId(ed) {
        var prefix = 'wf-bookmark-{path}{query}-{id}-';
        prefix = prefix.replace(/\{path\}/g, document.location.pathname);
        prefix = prefix.replace(/\{query\}/g, document.location.search);
        prefix = prefix.replace(/\{id\}/g, ed.id);

        // replace some characters and remove multiple _ characters
        prefix = prefix.replace(/\W/g, '_').replace(/_+/g, '_').replace(/^_+|_+$/g, '');

        return prefix;
    }

    /**
     * Get the refocus bookmark
     * @param {tinymce.Editor} ed 
     * @returns {string} The bookmark
     */
    function getRefocusBookmark(ed) {
        var bookmarkStore = sessionStorage.getItem('wf_refocus_bookmark'), bookmarkData = {}, bookmark = 0;

        if (bookmarkStore) {
            try {
                bookmarkData = JSON.parse(bookmarkStore);
            } catch (e) {
                // error
            }
        }

        var bookmarkId = getRefocusBookmarkId(ed);

        bookmark = bookmarkData[bookmarkId] || 0;

        if (bookmark) {
            sessionStorage.removeItem('wf_refocus_bookmark');

            // convert to int
            bookmark = parseInt(bookmark);
        }

        return bookmark;
    }

    /**
     * Set the refocus bookmark
     * @param {tinymce.Editor} ed
     * @param {string} bookmark
     */
    function setRefocusBookmark(ed, bookmark) {
        if (!bookmark) {
            return;
        }
        
        var bookmarkData = {}, bookmarkId = getRefocusBookmarkId(ed);

        bookmarkData[bookmarkId] = bookmark;

        sessionStorage.setItem('wf_refocus_bookmark', JSON.stringify(bookmarkData));
    }

    /**
     * Build a query string from an object
     * @param {object} params 
     * @param {string} prefix 
     * 
     * @returns The query string
     */
    function http_build_query(params, prefix) {
        const queryStringParts = [];

        for (const key in params) {
            if (params.hasOwnProperty(key)) {
                const value = params[key];
                const fullKey = prefix ? `${prefix}[${key}]` : key;

                if (typeof value === 'object' && value !== null) {
                    // Recursive call for nested objects
                    queryStringParts.push(http_build_query(value, fullKey));
                } else {
                    queryStringParts.push(encodeURIComponent(fullKey) + '=' + encodeURIComponent(value));
                }
            }
        }

        return queryStringParts.join('&');
    }

    /**
     * Get the script options from Joomla's options
     * @param {string} key 
     * 
     * @returns Editor Options object
     */
    function getScriptOptions(key) {
        // Balbooa Gridbox compatibility - for some reason it resets the Joomla object...
        if (!Joomla.optionsStorage) {
            Joomla.optionsStorage = {};

            const scripts = document.querySelectorAll('script.joomla-script-options.new');

            if (!scripts) {
                throw new Error('No Joomla options found');
            }

            scripts.forEach(element => {
                const text = element.text || element.textContent;

                try {
                    const data = JSON.parse(text);

                    if (data) {
                        Joomla.optionsStorage = data;
                    }
                } catch (e) { }
            });
        }

        // Get the editor settings from Joomla's options
        var settings = Joomla.getOptions ? Joomla.getOptions('plg_editor_jce', {}) : (Joomla.optionsStorage.plg_editor_jce || {});

        // Check if settings or settings.editor is not defined. Might be a legacy scriptDeclaration init
        if (!settings || !settings[key]) {
            return null;
        }

        settings = settings[key];

        // If settings.editor is an array, use the first element
        if (Array.isArray(settings)) {
            settings = settings[0];
        }

        return settings;
    }

    var PlatformEditor = {
        register: function (editor) {
            var instance = {
                getValue: function () {
                    return WfEditor.getContent(editor.id);
                },
                setValue: function (value) {
                    WfEditor.setContent(editor.id, value);
                },
                getSelection: function () {
                    return WfEditor.getSelection(editor.id, { format: 'text' });
                },
                replaceSelection: function (value) {
                    return WfEditor.insert(editor.id, value);
                },
                // Required by Joomla's API for Mail Component Integration
                disable: function (disabled) {
                    return editor.setMode(disabled ? 'readonly' : 'design');
                },
                // Some extra instance dependent
                id: editor.id,
                instance: editor,
                onSave: function () {
                }
            };

            // Joomla 5+ Registration is done via the decorator
            if (typeof JceDecorator !== "undefined") {
                return true;
            }

            if (Joomla.editors) {
                Joomla.editors.instances[editor.id] = instance;
            }
        },
        unregister: function (editor) {
            var elm = editor.getElement();

            // Joomla 5+
            if (typeof JceDecorator !== "undefined") {
                var instance = JoomlaEditor.get(elm.id);

                if (instance && instance instanceof JceDecorator) {
                    return JoomlaEditor.unregister(instance);
                }

                return true;
            }

            if (Joomla.editors) {
                delete Joomla.editors.instances[elm.id];
            }
        }
    };

    var WfEditor = {
        // empty settings object
        settings: null,

        // empty bookmark object
        bookmark: null,

        options: {},

        getSite: function (base) {
            var site, host;
            // get url from browser
            var u = document.location.href;
            // if bas is a full url
            if (base.indexOf('http') !== -1) {
                // get the host part of the url eg: www.mysite.com
                host = base.substr(base.indexOf('://') + 3);
                // get the
                site = host.substr(host.indexOf('/'));
            } else {
                site = u.substr(0, u.indexOf(base) + base.length);
            }

            if (u.indexOf('/administrator/') !== -1) {
                site = site + 'administrator/';
            }

            return site;
        },

        /**
         * Initialise WfEditor
         * @param {Object} settings TinyMCE Settings
         * 
         * @returns {void}
         */
        init: function (settings) {
            settings = settings || getScriptOptions('editor');

            if (!settings) {
                throw new Error('Unable to initialize editor. No settings found');
            }

            var base = settings.base_url;
            var site = this.getSite(base);

            // fix https in base url
            if (/https:\/\//.test(document.location.href)) {
                base = base.replace(/http:/, 'https:');
            }

            // set preinit object to prevent tinymce from generating baseURL
            window.tinyMCEPreInit = {};

            // serialize query
            settings.query = http_build_query(settings.query);

            // set baseURL, suffix and query string
            extend(tinymce, {
                baseURL: base + 'media/com_jce/editor/tinymce',
                suffix: '',
                query: settings.query
            });

            var indent = 'p,h1,h2,h3,h4,h5,h6,blockquote,div,title,style,pre,script,td,ul,li,area,table,thead,tfoot,tbody,tr,section,article,hgroup,aside,figure,object,video,audio';

            // create settings object if not already created...
            this.settings = this.settings || extend({
                document_base_url: base,
                site_url: site,
                schema: 'mixed',
                convert_urls: true,
                relative_urls: true,
                mode: 'textareas',
                entity_encoding: 'raw',
                editor_selector: 'wf-editor',
                editor_deselector: 'wf-no-editor',
                entity_encoding: 'raw',
                urlconverter_callback: 'WFEditor.convertURL',
                popup_css: false,
                add_form_submit_trigger: false,
                submit_patch: false,
                theme: 'none',
                skin_directionality: 'ltr',
                invalid_elements: 'applet,iframe,object,embed,script,style,body,bgsound,base,basefont,frame,frameset,head,html,id,ilayer,layer,link,meta,name,title,xml',
                plugins: '',
                external_plugins: {},
                whitespace_elements: 'pre,script,style,textarea,code',
                allow_conditional_comments: true,
                allow_event_attributes: false,
                fix_list_elements: true,
                indent_before: indent,
                indent_after: indent,
                update_styles: true,
                constrain_menus: false,
                compress: {
                    css: false,
                    javascript: false
                },
                language_load: false
            }, settings);

            if (this.settings) {
                try {
                    var s = this.settings;

                    if (s.compress.css) {
                        extend(this.settings, {
                            content_css: false,
                            editor_css: false
                        });
                    }

                    // mark javascript files loaded
                    this.markLoaded();

                    WFEditor.load();
                } catch (e) {
                    // error
                    console.debug(e);
                }
            }
        },

        markLoaded: function () {
            var s = this.settings,
                each = tinymce.each;

            var suffix = s.suffix || '';

            function load(u) {
                tinymce.ScriptLoader.markDone(tinyMCE.baseURL + '/' + u);
            }

            if (s.compress.javascript == 1) {
                each(s.external_plugins, function (url, name) {
                    load(url);
                });

                // Add plugins with languages
                each(s.plugins.split(','), function (n) {
                    if (n) {
                        load('plugins/' + n + '/plugin' + suffix + '.js');
                    }
                });
            }

            // mark core plugins loaded
            each(['core', 'help', 'autolink', 'cleanup', 'code', 'format', 'importcss', 'colorpicker', 'upload', 'blobupload', 'figure', 'ui', 'noneditable', 'branding'], function (n) {
                load('plugins/' + n + '/plugin' + suffix + '.js');
            });
        },

        setBookmark: function (ed) {
            function isHidden(ed) {
                return ed.isHidden() || DOM.getStyle(ed.id + '_ifr', 'visibility') == 'hidden';
            }

            function isEditor(el) {
                return DOM.getParent(el, 'div.mceEditor, div.mceSplitButtonMenu, div.mceListBoxMenu, div.mceDropDown');
            }

            Event.add(document.body, 'mousedown', function (e) {
                var el = e.target;

                if (isEditor(el)) {
                    return;
                }

                if (!isHidden(ed) && ed.selection) {
                    var n = ed.selection.getNode();

                    if (DOM.getParent(n, 'body#tinymce')) {
                        ed.lastSelectionBookmark = ed.selection.getBookmark(1);
                    }
                }
            });
        },

        load: function () {
            var self = this,
                loaded;

            // pass settings to tinymce. This is required for when the editor is initialized after the page is loaded using tinymce.execCommand('mceAddEditor', false, id);
            tinymce.settings = this.settings;

            // setup editor before init
            tinyMCE.onAddEditor.add(function (mgr, ed) {
                var el = ed.getElement();

                if (ed.settings.theme !== "advanced") {
                    return;
                }

                // access after editor is created - required in case of script order change
                if (window.Joomla) {
                    // update editor settings object with joomla_xtd_buttons options
                    if (Joomla.getOptions) {
                        var options = getScriptOptions('joomla_xtd_buttons');

                        if (options) {
                            // update settings
                            ed.settings = extend(ed.settings, {
                                'joomla_xtd_buttons': options
                            });
                        }
                    }

                    // register editor
                    PlatformEditor.register(ed);
                }

                // load packer css
                if (self.settings.compress.css) {
                    ed.onPreInit.add(function () {
                        ed.dom.loadCSS(self.settings.site_url + 'index.php?option=com_jce&task=editor.pack&type=css&slot=content');
                    });
                }

                // create toggle
                self.createToggle(el);

                // create bookmark
                self.setBookmark(ed);

                ed.onPreInit.add(function () {
                    // create tabs before render
                    self.createTabs(ed);
                });

                // form submit trigger
                ed.onInit.add(function () {
                    ed.onSubmit.addToTop(function () {
                        if (ed.initialized && ed.getElement()) {
                            ed.isNotDirty = 1;
                            self.getContent(ed.id);
                        }
                    });

                    if (ed.settings.refocus) {
                        window.setTimeout(function () {
                            var bookmark = getRefocusBookmark(ed);

                            if (bookmark) {
                                self.setActiveLine(ed, bookmark);
                            }
                        }, 100);
                    }
                });

                // Form submit patch
                ed.onBeforeRenderUI.add(function () {
                    var n = ed.getElement().form;

                    if (!n || n._mceOldSubmit) {
                        return;
                    }

                    if (!n.submit.nodeType && !n.submit.length) {
                        ed.formElement = n;
                        n._mceOldSubmit = n.submit;
                        n.submit = function () {
                            // Save all instances
                            tinymce.each(tinymce.editors, function (e) {
                                if (e.initialized && e.getElement()) {
                                    e.isNotDirty = 1;
                                    self.getContent(e.id);
                                }
                            });

                            return ed.formElement._mceOldSubmit(ed.formElement);
                        };

                        n = null;
                    }
                });

                ed.onPostRender.add(function () {
                    // get stored state
                    var el = ed.getElement(), state = self.getEditorState(el);

                    // get toggle option
                    var toggle = tinymce.is(ed.settings.toggle) ? parseInt(ed.settings.toggle, 10) : 0;

                    // only disable editor if you can switch it back on
                    if (!state && toggle) {
                        ed.hide();

                        if (ed.plugins.source) {
                            ed.plugins.source.hide();
                        }

                        if (ed.plugins.preview) {
                            ed.plugins.preview.hide();
                        }
                    }
                });

                ed.onWfEditorChange = new Dispatcher();

                ed.onWfEditorChange.add(function (ed, o) {
                    if (tinymce.is(o.content)) {
                        ed.setContent(o.content, o);
                        ed.onChange.dispatch();
                    }
                });

                ed.onSaveContent.add(function () {
                    if (ed !== tinymce.activeEditor) {
                        return;
                    }

                    var bookmark = self.getActiveLine(ed);
                    setRefocusBookmark(ed, bookmark);
                });

                // remove tabs etc. when editor is removed
                ed.onRemove.add(function () {
                    var container = DOM.getParent(ed.getElement(), 'div.wf-editor-container');

                    if (container) {
                        var nodes = tinymce.grep(DOM.select('div', container), function (node) {
                            if (node === ed.getElement() || node === ed.getContainer()) {
                                return false;
                            }

                            return true;
                        });

                        // remove found nodes
                        DOM.remove(nodes);

                        // remove parent container, leaving remaining nodes for tinymce to deal with
                        DOM.remove(container, 1);
                    }
                });
            });

            function _load() {
                if (!loaded) {
                    // set loaded flag
                    loaded = true;
                    // create editor
                    return self.preinit();
                }
            }

            // load editor when page fully loaded
            Event.bind(window, 'load', function () {
                _load();

                self.initSubformEvents();
            });

            Event.bind(window, 'ready', function () {
                window.setTimeout(function () {
                    _load();
                }, 1000);
            });
        },

        initSubformEvents: function () {
            var self = this, settings = this.settings;

            function removeEditor(el) {
                var ed = tinymce.EditorManager.get(el.id);

                if (ed) {
                    ed.remove();
                    ed.destroy(true);

                    PlatformEditor.unregister(ed);
                }
            }

            function createEditor(el) {
                var ed = tinymce.EditorManager.get(el.id);

                // editor does not exist
                if (!ed) {
                    self.createInstance(el);

                    // create new tinymce editor instance
                    ed = new tinymce.Editor(el.id, settings);
                }

                // render
                ed.render();
            }

            function rebuildEditor(row) {
                // find textarea elements with an id within the container
                var elements = DOM.select('.wf-editor-container > textarea[id]', row);

                each(elements, function (el) {
                    removeEditor(el);
                    createEditor(el);
                });
            }

            if (window.jQuery) {
                jQuery('div.subform-repeatable').on('subform-row-add', function (event, row) {
                    var elements = DOM.select('.wf-editor', row);

                    each(elements, function (el) {
                        createEditor(el);
                    });
                }).on('subform-row-remove', function (event, row) {
                    var elements = DOM.select('.wf-editor', row);

                    each(elements, function (el) {
                        removeEditor(el);
                    });
                });

                // re-build editors on reinit event
                jQuery(document).on('editor-reinit', function (e, row) {
                    rebuildEditor(row);
                });

                // re-build editors when a subform is sorted
                jQuery(document).on('sortstop', function (e, ui) {
                    if (ui.item[0]) {
                        rebuildEditor(ui.item[0]);
                    }
                });
            }

            Event.add(document, 'subform-row-add', function (e, row) {
                var row = e.detail ? e.detail.row : null;

                if (!row) {
                    return;
                }

                var elements = DOM.select('.wf-editor', row);

                each(elements, function (el) {
                    createEditor(el);
                });
            });

            // Joomla 4 custom elements subform
            Event.add(document, 'subform-row-remove', function (e) {
                var row = e.detail ? e.detail.row : null;

                if (!row) {
                    return;
                }

                var elements = DOM.select('.wf-editor', row);

                each(elements, function (el) {
                    removeEditor(el);
                });
            });

            Event.add(document, 'sortstop', function (e) {
                var row = e.detail ? e.detail.row : null;

                if (!row) {
                    return;
                }

                if (row) {
                    rebuildEditor(row);
                }
            });

            // use dragend to try and guess when sortable is finished
            Event.add(DOM.select('joomla-field-subform.subform-repeatable'), 'dragend', function (e) {
                rebuildEditor(e.target);
            });
        },

        isEditorActive: function (elm) {
            return DOM.hasClass(elm, 'wf-no-editor') == false;
        },

        canToggle: function () {
            var settings = this.settings;

            return tinymce.is(settings.toggle) ? parseInt(settings.toggle, 10) : 0;
        },

        getEditorState: function (el) {
            // get stored state
            var s = this.settings, state;

            if (s.use_state_cookies !== false) {
                state = tinymce.util.Storage.get('wf_editor_state_' + el.id);
            }

            // not defined
            if (state === null || typeof state === "undefined") {
                state = tinymce.is(s.toggle_state) ? s.toggle_state : 1;
            }

            // cast to integer
            state = parseInt(state, 10);

            return state;
        },

        /**
         * Create each textarea instance
         */
        createInstance: function (el) {
            var self = this,
                s = this.settings;

            // get element from id
            if (typeof el === "string") {
                el = DOM.get(el);
            }

            // element not found...?
            if (!el) {
                return;
            }

            // set textarea dimensions if required
            if (s.width) {
                DOM.setStyle(el, 'width', s.width);
            }

            if (s.height) {
                DOM.setStyle(el, 'height', s.height);
            }

            // get stored state
            var state = this.getEditorState(el);

            if (self.canToggle()) {
                self.createToggle(el);

                // get header (previously created by createToggle or elsewhere) 
                var header = DOM.getPrev(el, '.wf-editor-header');

                // only disable editor if you can switch it back on
                if (!state) {
                    DOM.addClass(el, 'wf-no-editor');

                    DOM.hide(DOM.select('.wf-editor-tabs', header));
                    DOM.addClass(el.parentNode, 'wf-editor-toggle-off');

                    return false;
                }
            }

            return true;
        },

        /**
         * Create the editor using existing settings
         * @param {Mixed} elements Optional elements to create the editor from
         */
        create: function (elements) {
            // must be an array
            if (typeof elements === "string") {
                // find existing editors and remove
                var ed = tinymce.get(elements);

                if (ed) {
                    tinymce.remove(ed);
                }

                elements = [elements];
            }

            return this.preinit(elements);
        },

        /**
         * Preinit before initialising tinymce
         */
        preinit: function (elements) {
            var self = this,
                settings = this.settings;

            function createId(elm) {
                var id = elm.id;

                // Use element id, or unique name or generate a unique id
                if (!id) {
                    id = elm.name;

                    if (id && !DOM.get(id)) {
                        id = elm.name;
                    } else {
                        // Generate unique name
                        id = DOM.uniqueId();
                    }

                    elm.setAttribute('id', id);
                }

                return id;
            }

            try {
                // if elements is empty, use default selector
                elements = elements || DOM.select('.wf-editor');

                each(elements, function (elm) {
                    elm = DOM.get(elm);

                    if (!elm) {
                        return true;
                    }

                    var editorId = createId(elm);

                    // editor already exists...
                    if (tinymce.get(editorId)) {
                        return true;
                    }

                    // show the textarea
                    DOM.show(elm);

                    // create toggle etc. and return state (on/off)
                    if (settings.theme == "advanced") {
                        self.createInstance(elm);
                    }

                    // create editor
                    var editor = new tinymce.Editor(editorId, settings, tinymce.EditorManager);
                    editor.render();
                });
            } catch (e) {
                // error
                console.debug(e);
            }
        },

        toggleEditor: function (el) {
            var ed = tinymce.get(el.id);

            // turn it on
            if (!ed) {
                // add loader
                DOM.addClass(el.parentNode, 'mce-loading');

                DOM.removeClass(el, 'wf-no-editor');
                DOM.removeClass(el.parentNode, 'wf-editor-toggle-off');

                // store state
                if (this.settings.use_state_cookies !== false) {
                    tinymce.util.Storage.set('wf_editor_state_' + el.id, 1);
                }

                // switch editor on
                tinymce.execCommand('mceToggleEditor', false, el.id);

                // remove loader
                setTimeout(function () {
                    DOM.removeClass(el.parentNode, 'mce-loading');
                }, 1000);
            } else {
                if (DOM.hasClass(el, 'wf-no-editor')) {
                    DOM.removeClass(el, 'wf-no-editor');

                    DOM.setStyle(DOM.select('.wf-editor-tabs', el.parentNode), 'display', '');
                    DOM.removeClass(el.parentNode, 'wf-editor-toggle-off');

                    // store state
                    if (this.settings.use_state_cookies !== false) {
                        tinymce.util.Storage.set('wf_editor_state_' + el.id, 1);
                    }

                    var activeTab;

                    if (this.settings.use_state_cookies !== false) {
                        activeTab = sessionStorage.getItem('wf-editor-tabs-' + ed.id);
                    }

                    if (!activeTab) {
                        activeTab || ed.settings.active_tab || 'wf-editor-wysiwyg';
                    }

                    // hide textarea
                    DOM.hide(ed.getElement());

                    switch (activeTab) {
                        default:
                        case 'wf-editor-wysiwyg':
                            ed.show();
                            break;
                        case 'wf-editor-source':
                            ed.plugins.source.toggle();
                            break;
                        case 'wf-editor-preview':
                            ed.plugins.preview.toggle();
                            break;
                    }
                } else {
                    DOM.addClass(el, 'wf-no-editor');

                    DOM.hide(DOM.select('.wf-editor-tabs', el.parentNode));
                    DOM.addClass(el.parentNode, 'wf-editor-toggle-off');

                    var height;

                    if (this.settings.use_state_cookies !== false) {
                        height = sessionStorage.getItem('wf-editor-container-height');
                    }

                    // set textarea height
                    if (height && !ed.getParam('fullscreen_enabled')) {
                        DOM.setStyle(ed.getElement(), 'height', height);
                    }

                    // store state
                    if (this.settings.use_state_cookies !== false) {
                        tinymce.util.Storage.set('wf_editor_state_' + el.id, 0);
                    }

                    // hide editor (and trigger save)
                    ed.hide();

                    // pass content to textarea
                    this.getContent(ed.id);

                    // hide source
                    if (ed.plugins.source) {
                        ed.plugins.source.hide();
                    }

                    // hide preview
                    if (ed.plugins.preview) {
                        ed.plugins.preview.hide();
                    }

                    DOM.setStyle(ed.getElement(), 'display', '');
                }
            }
        },

        getActiveTab: function (ed) {
            var parent = ed.getElement().parentNode, activeTab = parent.querySelector('.wf-editor-tabs > button.active');

            // no active tabs, default to wysiwyg
            if (!activeTab) {
                return 'wysiwyg';
            }

            var ctrl = activeTab.getAttribute('aria-controls');

            // default to wysiwyg
            if (!ctrl) {
                return 'wysiwyg';
            }

            // get tab name from aria value
            ctrl = ctrl.substring(10);

            return ctrl;
        },

        // Get a reference to the current editor
        getEditor: function (el) {
            var ed, win = window;

            // tinymce is in the parent window
            if (!win.tinymce && window.parent.tinymce) {
                win = window.parent;
            }

            if (el) {
                if (typeof el === 'string') {
                    el = document.getElementById(el);
                }

                // use element passed in
                if (el && el.id) {
                    ed = win.tinymce.get(el.id);
                }
            }

            // get active editor
            if (!ed) {
                ed = win.tinymce.activeEditor;
            }

            // no editor?
            if (!ed || !ed.getElement()) {
                return false;
            }

            // editor hidden?
            if (DOM.hasClass(ed.getElement(), 'wf-no-editor')) {
                return false;
            }

            var tab = this.getActiveTab(ed);

            if (tab == 'wysiwyg') {
                return ed;
            }

            if (tab == 'source') {
                return ed.plugins.source;
            }

            return false;
        },

        loadContent: function (ed) {
            var el = ed.getElement();

            // editor is hidden
            if (isHidden(ed.id + '_parent')) {
                if (ed.plugins.source) {
                    var code = ed.plugins.source.getContent();

                    if (code !== null) {
                        if (!/TEXTAREA|INPUT/i.test(el.nodeName)) {
                            el.innerHTML = code;
                        } else {
                            el.value = code;
                        }

                        ed.load();
                    }
                }
            }
        },

        createToggle: function (el) {
            var self = this,
                s = this.settings;

            // get header, creating it if it doesn't exist (K2, WidgetKit etc.)
            var header = DOM.getPrev(el, '.wf-editor-header') || this.createHeader(el);

            if (!self.canToggle()) {
                return;
            }

            if (DOM.select('button.wf-editor-toggle', header).length === 0) {
                // create toggle button
                var btn = DOM.add(header, 'button', {
                    'class': 'wf-editor-toggle btn btn-link',
                    'tabindex': '-1'
                }, '' + svgToggleIcon + (s.toggle_label || ""));

                Event.add(btn, 'click', function (e) {
                    e.preventDefault();
                    self.toggleEditor(el);
                });
            }
        },

        setActiveLine: function (ed, pos, fromCharacterIndex) {
            var blocks = [], node;

            // convert to int
            pos = parseInt(pos);

            if (!pos || pos < 0) {
                return;
            }

            function getElementNodeAtCharacterIndexPosition(position) {
                // Create a TreeWalker to traverse through all text nodes
                let walker = document.createTreeWalker(ed.getDoc(), NodeFilter.SHOW_TEXT, null, false);

                let currentPos = 0;

                // Loop through the text nodes to find the node at the given position
                while (walker.nextNode()) {
                    let node = walker.currentNode;
                    let nodeLength = node.length;

                    // Check if the current position is within this node
                    if (currentPos + nodeLength >= position) {
                        // Return the parent node of the text node (the element that contains it)
                        return node.parentNode;  // This is the parent element containing the text node
                    }

                    // Update the current position
                    currentPos += nodeLength;
                }

                // If no element is found (position out of bounds), return null
                return null;
            }

            if (fromCharacterIndex) {
                node = getElementNodeAtCharacterIndexPosition(pos);
            } else {
                each(ed.schema.getBlockElements(), function (value, name) {
                    if (/\W/.test(name)) {
                        return true;
                    }

                    blocks.push(name.toLowerCase());
                });

                // get number of lines
                var nodes = ed.dom.select(blocks.join(',')), node = nodes[pos] || null;
            }

            if (node) {
                ed.focus();

                var len = node.childNodes.length;

                ed.selection.setCursorLocation(node, len);
                ed.selection.scrollIntoView(node);
            }
        },

        getActiveLine: function (ed) {
            var blocks = [], line = 0;

            tinymce.each(ed.schema.getBlockElements(), function (value, name) {
                if (/\W/.test(name)) {
                    return true;
                }

                blocks.push(name.toLowerCase());
            });

            // get number of lines
            var node = ed.selection.getNode(), nodes = ed.dom.select(blocks.join(','));

            if (!node) {
                return line;
            }

            if (node.nodeType !== 1 || node.getAttribute('data-mce-type') === "bookmark") {
                node = node.parentNode;
            }

            for (var i = 0, len = nodes.length; i < len; i++) {
                if (nodes[i] === node) {
                    line = i;
                    break;
                }
            }

            return line;
        },

        toggleTab: function (ed, tab) {
            var self = this;

            // get textarea element
            var el = ed.getElement();

            // set loader
            DOM.addClass(el.parentNode, 'mce-loading');

            // store sizes before hiding editor
            if (!isHidden(ed.id + '_parent')) {

                if (!DOM.hasClass(el.parentNode, 'mce-fullscreen')) {
                    ed.settings.container_height = ed.getContainer().offsetHeight;

                    // store in session
                    if (this.settings.use_state_cookies !== false) {
                        sessionStorage.setItem('wf-editor-container-height', ed.settings.container_height);
                    }

                    ed.settings.container_width = ed.getContainer().offsetWidth;

                    // store in session
                    if (this.settings.use_state_cookies !== false) {
                        sessionStorage.setItem('wf-editor-container-width', ed.settings.container_width);
                    }

                    // store interface height
                    function getInterfaceHeight() {
                        var h = 0,
                            ca = ed.getContentAreaContainer(),
                            p = ca.parentNode;

                        tinymce.each(p.childNodes, function (n) {
                            if (n === ca) {
                                return;
                            }

                            h += n.offsetHeight;
                        });

                        return h;
                    }

                    ed.settings.interface_height = getInterfaceHeight();
                    // store in session
                    if (this.settings.use_state_cookies !== false) {
                        sessionStorage.setItem('wf-editor-interface-height', ed.settings.interface_height);
                    }
                }
            }

            // source code
            if (tab === "wf-editor-source") {

                // hide editor
                ed.hide();

                // hide textarea
                DOM.hide(el);

                // hide preview
                if (ed.plugins.preview) {
                    ed.plugins.preview.hide();
                }

                // toggle source code
                return ed.plugins.source.toggle();
            }

            // preview
            if (tab === "wf-editor-preview") {
                // pass content to textarea and load
                self.loadContent(ed);

                ed.hide();
                // hide textarea
                DOM.hide(el);

                // hide source
                if (ed.plugins.source) {
                    ed.plugins.source.hide();
                }

                ed.onToggleTab.dispatch(ed, tab);

                // toggle preview
                return ed.plugins.preview.toggle();
            }

            // pass content to textarea and load
            self.loadContent(ed);

            if (ed.plugins.source) {
                var pos = ed.plugins.source.getCursorPos();

                if (pos) {
                    ed.activeLine = pos;
                }

                ed.plugins.source.hide();
            }

            if (ed.plugins.preview) {
                ed.plugins.preview.hide();
            }

            // resize iframe
            DOM.setStyle(ed.id + '_ifr', 'max-width', DOM.getStyle(el.parentNode, 'max-width'));

            ed.show();

            // update cursor location on the active editor
            if (ed.activeLine) {
                window.setTimeout(function () {
                    self.setActiveLine(ed, ed.activeLine, true);
                }, 100);
            }

            DOM.removeClass(el.parentNode, 'mce-loading');
        },

        createHeader: function (element) {
            var container = DOM.create('div', {
                'class': 'editor wf-editor-container'
            }, '<div class="wf-editor-header"></div>');

            // add container before textarea
            element.parentNode.insertBefore(container, element);

            // add element to container
            DOM.add(container, element);

            // set header
            var header = container.firstChild;

            return header;
        },

        createTabs: function (ed) {
            var self = this,
                settings = this.settings, el = ed.getElement();

            // get header, creating it if it doesn't exist (K2, WidgetKit etc.)
            var header = DOM.getPrev(el, '.wf-editor-header') || this.createHeader(el);

            // we need at least one of these to show tabs
            if (!ed.plugins.source && !ed.plugins.preview) {
                return false;
            }

            // tabs exist, exit...
            if (DOM.select('.wf-editor-tabs', header).length) {
                return;
            }

            // create tab event
            ed.onToggleTab = new tinymce.util.Dispatcher(ed);

            var tablist = DOM.add(header, 'div', { 'role': 'tablist', 'class': 'wf-editor-tabs nav nav-tabs' });

            var activeTab;

            if (settings.use_state_cookies !== false) {
                activeTab = sessionStorage.getItem('wf-editor-tabs-' + ed.id);
            }

            if (!activeTab) {
                activeTab = ed.settings.active_tab || 'wf-editor-wysiwyg';
            }

            // set for plugins
            ed.settings.active_tab = activeTab;

            function makeTabActive(tab) {
                // deactivate all
                DOM.removeClass(DOM.select('button', tablist), 'active');
                DOM.setAttrib(DOM.select('button', tablist), 'aria-expanded', 'false');

                DOM.addClass(tab, 'active');
                DOM.setAttrib(tab, 'aria-expanded', 'true');
            }

            // Editor tab
            var editorTab = DOM.add(tablist, 'button', { 'type': 'button', 'class': 'nav-item', 'aria-controls': 'wf-editor-wysiwyg' }, ed.getLang('tab.wysiwyg', 'Editor'));

            // default to editor tab
            makeTabActive(editorTab);

            // Source tab
            if (ed.plugins.source) {
                var sourceTab = DOM.add(tablist, 'button', { 'type': 'button', 'class': 'nav-item', 'aria-controls': 'wf-editor-source' }, ed.getLang('tab.code', 'Code'));

                if (activeTab === "wf-editor-source") {
                    makeTabActive(sourceTab);
                }
            }

            // Preview tab
            if (ed.plugins.preview) {
                var previewTab = DOM.add(tablist, 'button', { 'type': 'button', 'class': 'nav-item', 'aria-controls': 'wf-editor-preview' }, ed.getLang('tab.preview', 'Preview'));

                if (activeTab === "wf-editor-preview") {
                    makeTabActive(previewTab);
                }
            }

            // Add tab click events
            Event.add(tablist, 'click', function (e) {
                e.preventDefault();

                var item = DOM.getParent(e.target, 'button');

                if (!item) {
                    return;
                }

                if (DOM.hasClass(item, 'active')) {
                    return;
                }

                makeTabActive(item);

                // get the action from tab button
                var action = DOM.getAttrib(item, 'aria-controls');

                // store current tab in a cookie
                if (settings.use_state_cookies !== false) {
                    sessionStorage.setItem('wf-editor-tabs-' + ed.id, action);
                }

                self.toggleTab(ed, action);
            });

            var state = this.getEditorState(el), toggle = tinymce.is(settings.toggle) ? parseInt(settings.toggle, 10) : 0;

            if (!state && toggle) {
                DOM.hide(DOM.select('.wf-editor-tabs', el.parentNode));
            }
        },

        textareaResize: function (el) {
            var header = DOM.getPrev(el, '.wf-editor-header'),
                container = header.parentNode;

            Event.add(el, 'mousedown', function (e) {
                // Register envent handlers
                var mm = Event.add(el, 'mousemove', function (e) {
                    container.style.maxWidth = el.offsetWidth + 'px';
                });

                var mu = Event.add(el, 'mouseup', function (e) {
                    Event.remove(el, 'mousemove', mm);
                    Event.remove(el, 'mouseup', mu);
                    container.style.maxWidth = el.offsetWidth + 'px';
                });
            });
        },

        wrapText: function (el, s) {
            if (s) {
                el.setAttribute("wrap", "soft");
            } else {
                el.removeAttribute("wrap");
            }
        },

        /**
         * Set the editor content
         * @param {String} id The editor id
         * @param {String} html The html content to set
         * 
         * @returns {void}
         */
        setContent: function (id, html) {
            var ed = this.getEditor(id);

            if (ed) {
                ed.setContent(html);
            } else {
                var elm = document.getElementById(id);

                if (elm) {
                    elm.value = html;
                }
            }
        },

        /**
         * Get the editor content
         * @param {String} id The editor id
         * 
         * @returns {String} The editor content
         */
        getContent: function (id) {
            var ed = this.getEditor(id);

            // could happen, does happen...
            if (!ed) {
                return '';
            }

            // return textarea content
            var elm = document.getElementById(id), state = this.isEditorActive(elm);

            // pass content from editor
            if (ed && state) {
                return ed.save();
            }

            if (elm) {
                return elm.value;
            }

            return '';
        },

        /**
         * Get the current editor selection
         * @param {string} id Editor id
         * @param {object} args Additional arguments
         * 
         * @returns Editor selection content
         */
        getSelection: function (id, args) {
            var ed = this.getEditor(id);

            // pass content to textarea and return
            if (ed && ed.getSelection) {
                return ed.getSelection(args || {});
            }

            // return textarea content
            return document.getSelection().toString();
        },

        /**
         * Insert content into the editor. This function is provided for editor-xtd buttons and includes methods for inserting into textareas
         * @param {String} el The editor id
         * @param {String} v The text to insert
         * 
         * @returns {Boolean} True if successful
         */
        insert: function (el, v) {
            // get an editor object
            var ed = this.getEditor(el);

            // insert into textarea if editor not loaded or is hidden
            if (!ed) {
                if (typeof el === "string") {
                    el = document.getElementById(el);
                }

                if (el && !isHidden(el)) {
                    this.insertIntoTextarea(el, v);
                }

                return true;
            }

            // editor found, insert
            if (ed) {
                // tinymce
                if (ed.execCommand) {
                    // textarea visible
                    if (!isHidden(ed.getElement())) {
                        this.insertIntoTextarea(ed.getElement(), v);

                        return true;
                    }

                    if (ed.lastSelectionBookmark) {
                        ed.selection.moveToBookmark(ed.lastSelectionBookmark);
                    }

                    ed.execCommand('mceInsertContent', false, v);
                    return true;
                }

                // code editor
                ed.insertContent(v);

                return true;
            }

            return false;
        },

        /**
         * Insert content into a textarea
         * @param {node} el The textarea element 
         * @param {string} v The text to insert 
         * 
         * @returns {void}
         */
        insertIntoTextarea: function (el, v) {
            el.focus();
            // IE
            if (document.selection) {
                var rng = document.selection.createRange();
                rng.text = v;
                // Mozilla / Netscape
            } else {
                el.setRangeText(v, el.selectionStart, el.selectionEnd, "end");
            }
        },

        /**
         * Convert URLs to relative or absolute based on editor settings
         * Replacement for tinymce.Editor.convertURL
         * @param {string} url URL to convert.
         * @param {string|node} elm Tag name or HTML DOM element depending on HTML or DOM insert.
         * @param {boolean} save Always true
         * @param {string} name The attribute name that is being set.
         * 
         * @returns {string} The converted URL.
         */
        convertURL: function (url, elm, save, name) {
            if (!url) {
                return url;
            }

            var ed = tinymce.EditorManager.activeEditor;

            // no editor?
            if (!ed) {
                return url;
            }

            var settings = ed.settings,
                base = settings.document_base_url;

            // Don't convert link href since thats the CSS files that gets loaded into the editor also skip local file URLs
            if (!settings.convert_urls || (elm && elm.nodeName === 'LINK') || url.indexOf('file:') === 0) {
                return url;
            }

            if (url === base || url === base.substring(0, base.length - 1) || url.charAt(0) === '/') {
                return url;
            }

            // mixed urls allows absolute and relative urls based on user input
            if (!settings.mixed_urls) {

                // Convert to relative
                if (settings.relative_urls) {

                    // only if absolute
                    if (url.indexOf(base) === 0) {
                        return ed.documentBaseURI.toRelative(url);
                    }

                    return url;
                }

                // Convert to absolute
                url = ed.documentBaseURI.toAbsolute(url, settings.remove_script_host);
            }

            if (settings.protocol_relative) {
                url = url.replace(/(http|https|ftp|ftps):\/\//, '//');
            }

            return url;
        },

        indent: function (h) {
            // simple indentation
            h = h.replace(/\n+/g, '\n');

            return tinymce.trim(h);
        }
    };

    // this is a bit of a hack for Hikashop, which relies on the removed addScriptDeclaration method to initialize the JCE Editor, but calls the setupEditors method for Tinymce
    var HikashopFix = function () {
        Joomla.JoomlaTinyMCE = {
            setupEditors: function (form) {
                if (!DOM.get(form)) {
                    return;
                }

                var elms = DOM.select('.wf-editor', form);

                if (!elms.length) {
                    return;
                }

                WfEditor.init();
            }
        };
    };

    document.addEventListener('DOMContentLoaded', function handler() {
        // Initialize the editor
        WfEditor.init();

        // Remove the DOMContentLoaded event listener
        this.removeEventListener('DOMContentLoaded', handler);

        HikashopFix();
    });

    window.WfEditor = window.WFEditor = WfEditor;
})();
/**
 * Joomla! IeCursor Fix function override
 */

// eslint-disable-next-line no-unused-vars
function IeCursorFix() {
    return true;
}

// eslint-disable-next-line no-unused-vars
function jInsertEditorText(text, editor) {
    try {
        // eslint-disable-next-line no-undef
        WfEditor.insert(editor, text);
    } catch (e) {
        // error
    }
}